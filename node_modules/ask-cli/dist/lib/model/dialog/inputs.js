"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.partitionAcdlResponses = exports.SpecialCommand = exports.isCommandOfType = exports.isQuitCommand = exports.isQuitCommandInput = exports.isCommand = exports.inputToCommand = void 0;
const inputToCommand = (input) => {
    const [enm] = Object.entries(SpecialCommand).find(([, value]) => value === input.toLowerCase()) || [undefined];
    return enm ? SpecialCommand[enm] : SpecialCommand.UNKNOWN;
};
exports.inputToCommand = inputToCommand;
const isCommand = (input) => {
    return "command" in input;
};
exports.isCommand = isCommand;
const isQuitCommandInput = (cmd) => {
    return (0, exports.isCommand)(cmd) && (0, exports.isQuitCommand)(cmd.command);
};
exports.isQuitCommandInput = isQuitCommandInput;
const isQuitCommand = (cmd) => {
    return (0, exports.isCommandOfType)(cmd, [SpecialCommand.QUIT]);
};
exports.isQuitCommand = isQuitCommand;
const isCommandOfType = (cmd, types) => {
    return types.includes(cmd);
};
exports.isCommandOfType = isCommandOfType;
/**
 * Command values should be lower cased.
 * Command evaluation will be case agnostic.
 */
var SpecialCommand;
(function (SpecialCommand) {
    SpecialCommand["QUIT"] = ".quit";
    SpecialCommand["SAVE"] = ".save";
    SpecialCommand["VARS"] = ".vars";
    SpecialCommand["END_TURN"] = ".endturn";
    SpecialCommand["UNKNOWN"] = "UNKNOWN";
})(SpecialCommand = exports.SpecialCommand || (exports.SpecialCommand = {}));
const partitionAcdlResponses = (acdlLines, responses) => {
    // Partition the ACDL lines with each partition ending with response()
    const partitionedAcdlLines = acdlLines.responses
        .reduce((acc, resp) => {
        const [head = [], ...rest] = acc;
        // Add a new partition to the start when the response ends with response()
        return [
            ...(resp.acdl.match(/.*response\(.+\).*/g) ? [[]] : []),
            // Add the current response to the first partition
            [...head, resp],
            ...rest,
        ];
    }, [])
        // New partitions are at the end of the list, reverse to get the right order
        .reverse();
    return {
        // Match a response with the partitioned acdlLines.
        // Its possible for the acdlLine partitions or the responses to be longer.
        groups: [...Array(Math.max(partitionedAcdlLines.length, responses.length)).keys()].map((i) => ({
            responseLine: responses.length > i ? responses[i] : undefined,
            acdlLines: partitionedAcdlLines.length > i ? partitionedAcdlLines[i] : undefined,
        })),
        before: acdlLines.beforeResponse,
    };
};
exports.partitionAcdlResponses = partitionAcdlResponses;
