"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCommand = exports.MODELING_STACK_AC_DESCRIPTION = exports.MODELING_STACK_AC = exports.MODELING_STACK_IM_DESCRIPTION = exports.MODELING_STACK_IM = exports.CODE_LANGUAGE_JAVA = exports.CODE_LANGUAGE_PYTHON = exports.CODE_LANGUAGE_NODEJS = void 0;
const abstract_command_1 = require("../abstract-command");
const option_model_json_1 = __importDefault(require("../option-model.json"));
const hosted_skill_controller_1 = __importDefault(require("../../controllers/hosted-skill-controller"));
const manifest_1 = __importDefault(require("../../model/manifest"));
const resources_config_1 = __importDefault(require("../../model/resources-config"));
const constants_1 = require("../../utils/constants");
const profile_helper_1 = __importDefault(require("../../utils/profile-helper"));
const messenger_1 = __importDefault(require("../../view/messenger"));
const helper = __importStar(require("./helper"));
const hostedHelper = __importStar(require("./hosted-skill-helper"));
const wizardHelper = __importStar(require("./wizard-helper"));
exports.CODE_LANGUAGE_NODEJS = "NodeJS";
exports.CODE_LANGUAGE_PYTHON = "Python";
exports.CODE_LANGUAGE_JAVA = "Java";
exports.MODELING_STACK_IM = "Interaction Model";
exports.MODELING_STACK_IM_DESCRIPTION = "The Interaction Model stack enables you to define the user interactions with a combination of utterances, intents, and slots.";
exports.MODELING_STACK_AC = "Alexa Conversations";
exports.MODELING_STACK_AC_DESCRIPTION = "Alexa Conversations (AC) uses deep learning to manage the dialog flow. User utterances, APL, and APLA documents train the skill model to create natural, human-like Alexa voice experiences.";
class NewCommand extends abstract_command_1.AbstractCommand {
    name() {
        return "new";
    }
    description() {
        return "create a new skill project from Alexa skill templates";
    }
    requiredOptions() {
        return [];
    }
    optionalOptions() {
        return ["templateUrl", "templateBranch", "profile", "debug"];
    }
    async handle(cmd) {
        let profile, vendorId;
        try {
            profile = profile_helper_1.default.runtimeProfile(cmd.profile);
            vendorId = profile_helper_1.default.resolveVendorId(profile);
        }
        catch (err) {
            messenger_1.default.getInstance().error(err);
            throw err;
        }
        // 0. collect user input and then create a skill(hosted skill or non hosted skill)
        messenger_1.default.getInstance().info("Please follow the wizard to start your Alexa skill project ->");
        return new Promise((resolve, reject) => {
            wizardHelper.collectUserCreationProjectInfo(cmd, (initErr, userInput) => {
                if (initErr) {
                    messenger_1.default.getInstance().error(initErr);
                    return reject(initErr);
                }
                if (!userInput) {
                    return resolve();
                }
                if (userInput.deploymentType === constants_1.DEPLOYER_TYPE.HOSTED.NAME) {
                    createHostedSkill(cmd, profile, vendorId, userInput)
                        .then(resolve)
                        .catch((hostedErr) => {
                        messenger_1.default.getInstance().error(hostedErr);
                        return reject(hostedErr);
                    });
                }
                else {
                    createNonHostedSkill(cmd, profile, cmd.debug, userInput)
                        .then(resolve)
                        .catch((nonHostedErr) => {
                        messenger_1.default.getInstance().error(nonHostedErr);
                        return reject(nonHostedErr);
                    });
                }
            });
        });
    }
}
exports.default = NewCommand;
function createHostedSkill(cmd, profile, vendorId, userInput) {
    return new Promise((resolve, reject) => {
        const hostedSkillController = new hosted_skill_controller_1.default({ profile, doDebug: cmd.debug });
        hostedHelper.validateUserQualification(vendorId, hostedSkillController, (validateErr) => {
            if (validateErr) {
                return reject(validateErr);
            }
            hostedHelper.createHostedSkill(hostedSkillController, userInput, vendorId, (createErr, skillId) => {
                if (createErr) {
                    return reject(createErr);
                }
                messenger_1.default.getInstance().info(`Hosted skill provisioning finished. Skill-Id: ${skillId}`);
                messenger_1.default.getInstance().info(`Please follow the instructions at ${constants_1.GIT_USAGE_HOSTED_SKILL_DOCUMENTATION}` +
                    ' to learn more about the usage of "git" for Hosted skill.');
                resources_config_1.default.getInstance().write();
                resolve();
            });
        });
    });
}
function createNonHostedSkill(cmd, profile, doDebug, userInput) {
    return new Promise((resolve, reject) => {
        // 1.download skill project templates
        helper.downloadTemplateFromGit(userInput, doDebug, (projectErr, projectFolderPath) => {
            if (projectErr) {
                return reject(projectErr);
            }
            messenger_1.default.getInstance().info(`Project for skill "${userInput.skillName}" is successfully created at ${projectFolderPath}\n`);
            if (userInput.deploymentType === constants_1.DEPLOYER_TYPE.SELF_HOSTED.NAME) {
                // nothing more to do for self hosted skills
                resolve();
            }
            try {
                // 2.load involving M(Model) component (ResourcesConfig & Manifest) from the downloaded skill project with 'default' profile
                helper.loadSkillProjectModel(projectFolderPath, "default");
                // 3.remove git record and update skill name
                helper.updateSkillProjectWithUserSettings(userInput.skillName, projectFolderPath, profile);
            }
            catch (projErr) {
                return reject(projErr);
            }
            // 4.bootstrap the skill project with deploy delegate if needed
            helper.initializeDeployDelegate(userInput.deploymentType, projectFolderPath, profile, cmd.debug, (deployDelegateErr, deployerType) => {
                if (deployDelegateErr) {
                    return reject(deployDelegateErr);
                }
                messenger_1.default.getInstance().info(deployerType ? `Project initialized with deploy delegate "${deployerType}" successfully.` : "Project initialized successfully.");
                resources_config_1.default.getInstance().write();
                manifest_1.default.getInstance().write();
                resolve();
            });
        });
    });
}
exports.createCommand = new NewCommand(option_model_json_1.default).createCommand();
