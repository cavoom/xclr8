"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModelingStackType = exports.getDeploymentType = exports.confirmUsingUnofficialTemplate = exports.getTargetTemplateName = exports.selectSkillCodeLanguage = exports.getSkillDefaultRegion = exports.getSkillLocale = exports.getSkillName = void 0;
const ramda_1 = require("ramda");
const chalk_1 = require("chalk");
const path_1 = __importDefault(require("path"));
const inquirer_1 = __importDefault(require("inquirer"));
const constants_1 = require("../../utils/constants");
const string_utils_1 = require("../../utils/string-utils");
const _1 = require(".");
/**
 * Prompts the user to type a skill name and defaults to the name of the repo in the URL argument if provided.
 *
 * @param {string} url A url of the skill sample repository, used to determine the default skill name
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function getSkillName(url, callback) {
    const defaultName = url ? path_1.default.basename(url, path_1.default.extname(url)) : constants_1.HOSTED_SKILL.DEFAULT_SKILL_NAME;
    inquirer_1.default
        .prompt([
        {
            message: "Please type in your skill name: ",
            type: "input",
            default: defaultName,
            name: "skillName",
            validate: (input) => {
                if (!(0, string_utils_1.isNonBlankString)(input)) {
                    return "Skill name can't be empty.";
                }
                return true;
            },
        },
    ])
        .then((answer) => {
        callback(null, answer.skillName.trim());
    })
        .catch((error) => {
        callback(error);
    });
}
exports.getSkillName = getSkillName;
/**
 * Prompts for the default locale to use for the skill
 * i.e.  en-US, de-DE, fr-FR...
 *
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function getSkillLocale(callback) {
    inquirer_1.default
        .prompt([
        {
            message: "Choose the default locale for your skill: ",
            type: "list",
            choices: constants_1.HOSTED_SKILL.LOCALES,
            name: "locale",
            pageSize: 5,
        },
    ])
        .then((answer) => {
        callback(null, answer.locale);
    })
        .catch((error) => {
        callback(error);
    });
}
exports.getSkillLocale = getSkillLocale;
/**
 * Prompts the user to select the default AWS Region to deploy the skill resources to
 * ie. us-east-1
 *
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function getSkillDefaultRegion(callback) {
    inquirer_1.default
        .prompt([
        {
            message: "Choose the default region for your skill: ",
            type: "list",
            choices: Object.keys(constants_1.HOSTED_SKILL.REGIONS),
            name: "region",
        },
    ])
        .then((answer) => {
        callback(null, constants_1.HOSTED_SKILL.REGIONS[answer.region]);
    })
        .catch((error) => {
        callback(error);
    });
}
exports.getSkillDefaultRegion = getSkillDefaultRegion;
/**
 * Prompts the user to select what coding language to use for the sample skill
 * i.e. NodeJs, Python, Java
 *
 * @param {NewSkillCodeLanguage[]} languages to offer as options
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function selectSkillCodeLanguage(languages, callback) {
    inquirer_1.default
        .prompt([
        {
            type: "list",
            message: "Choose the programming language you will use to code your skill: ",
            name: "language",
            choices: languages,
        },
    ])
        .then((answer) => {
        callback(null, answer.language.trim());
    })
        .catch((error) => {
        callback(error);
    });
}
exports.selectSkillCodeLanguage = selectSkillCodeLanguage;
/**
 * Prompts the user to select what Template they want to clone
 *
 * @param {SampleTemplate[]} templateMap the list of templates to select from
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function getTargetTemplateName(templateMap, callback) {
    inquirer_1.default
        .prompt([
        {
            type: "list",
            message: "Choose a template to start with: ",
            name: "templateName",
            choices: templateMap.map((sampleTemplate) => `${String(sampleTemplate.name)}\n  ${(0, chalk_1.gray)(sampleTemplate.desc)}`),
            pageSize: 30,
            filter: (input_1) => input_1.replace(/\n.*/g, ""),
        },
    ])
        .then((answer) => {
        callback(null, templateMap.find((sampletemplate) => sampletemplate.name === answer.templateName));
    })
        .catch((error) => {
        callback(error, undefined);
    });
}
exports.getTargetTemplateName = getTargetTemplateName;
/**
 * Prompts the user to continue [yes or no] cloning the remote repo locally.
 * ie. if the repository is not an official Amazon Alexa Skill sample template
 *
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function confirmUsingUnofficialTemplate(callback) {
    inquirer_1.default
        .prompt([
        {
            message: "Would you like to continue download the skill template? ",
            type: "confirm",
            name: "confirmation",
            default: false,
        },
    ])
        .then((answer) => {
        callback(null, answer.confirmation);
    })
        .catch((error) => {
        callback(error);
    });
}
exports.confirmUsingUnofficialTemplate = confirmUsingUnofficialTemplate;
/**
 * Prompts the user to select a Deployment Type
 * i.e. Lambda vs CloudFormation vs Alexa hosted vs self hosted
 *
 * @param {NewSkillDeployerTypeInfo[]} deployType An array of possible deployment types
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function getDeploymentType(deployType, callback) {
    const deployDelegateChoices = deployType.map((deployer) => `${deployer.OPTION_NAME}\n  ${(0, chalk_1.gray)(deployer.DESCRIPTION)}`);
    inquirer_1.default
        .prompt([
        {
            message: "Choose a method to host your skill's backend resources: ",
            type: "list",
            name: "deployDelegate",
            choices: deployDelegateChoices,
            pageSize: 30,
            filter: (input) => input.replace(/\n.*/g, ""),
        },
    ])
        .then((answer) => {
        const selectedDeployDelegate = (0, ramda_1.find)((0, ramda_1.propEq)("OPTION_NAME", answer.deployDelegate))(deployType);
        callback(null, (0, ramda_1.view)((0, ramda_1.lensPath)(["NAME"]), selectedDeployDelegate));
    })
        .catch((error) => {
        callback(error);
    });
}
exports.getDeploymentType = getDeploymentType;
/**
 * Prompts the user to select the modeling stack type they want the samples to use
 * i.e. Interaction Model vs Alexa Conversations
 *
 * @param {uiCallback} callback function that will be called with the resulting value or error
 */
function getModelingStackType(callback) {
    const modelingStackChoices = [
        `${_1.MODELING_STACK_IM}\n  ${(0, chalk_1.gray)(_1.MODELING_STACK_IM_DESCRIPTION)}`,
        `${_1.MODELING_STACK_AC}\n  ${(0, chalk_1.gray)(_1.MODELING_STACK_AC_DESCRIPTION)}`,
    ];
    inquirer_1.default
        .prompt([
        {
            message: "Choose a modeling stack for your skill: ",
            type: "list",
            name: "modelingStack",
            choices: modelingStackChoices,
            default: _1.MODELING_STACK_IM,
            pageSize: 5,
            filter: (input) => input.replace(/\n.*/g, ""),
        },
    ])
        .then((answer) => {
        callback(null, answer.modelingStack);
    })
        .catch((error) => {
        callback(error);
    });
}
exports.getModelingStackType = getModelingStackType;
