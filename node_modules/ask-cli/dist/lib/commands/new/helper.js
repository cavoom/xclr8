"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bootstrapProject = exports.initializeDeployDelegate = exports.updateSkillProjectWithUserSettings = exports.loadSkillProjectModel = exports.downloadTemplateFromGit = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const git_client_1 = __importDefault(require("../../clients/git-client"));
const skill_infrastructure_controller_1 = __importDefault(require("../../controllers/skill-infrastructure-controller"));
const manifest_1 = __importDefault(require("../../model/manifest"));
const resources_config_1 = __importDefault(require("../../model/resources-config"));
const constants_1 = require("../../utils/constants");
const string_utils_1 = __importDefault(require("../../utils/string-utils"));
/**
 * Download the template from git
 * @param {Object} userInput user input initialization setting
 * @param {uiCallback} callback (error, projectFolderPath)
 */
function downloadTemplateFromGit(userInput, doDebug, callback) {
    var _a, _b;
    const projectFolderPath = path_1.default.join(process.cwd(), userInput.projectFolderName);
    const gitClient = new git_client_1.default(projectFolderPath, { showOutput: !!doDebug, showCommand: !!doDebug });
    const branch = ((_a = userInput.templateInfo) === null || _a === void 0 ? void 0 : _a.templateBranch) || constants_1.TEMPLATES.TEMPLATE_DEFAULT_BRANCH_NAME;
    gitClient.clone((_b = userInput.templateInfo) === null || _b === void 0 ? void 0 : _b.templateUrl, branch, projectFolderPath);
    callback(null, projectFolderPath);
}
exports.downloadTemplateFromGit = downloadTemplateFromGit;
/**
 * Validate if ask-resources config and skill.json exist in the skill package template
 * @param {String} projectPath path for the skill project
 * @param {String} profile ask-cli profile
 */
function loadSkillProjectModel(projectPath, profile) {
    new resources_config_1.default(path_1.default.join(projectPath, constants_1.FILE_PATH.ASK_RESOURCES_JSON_CONFIG));
    const skillMetaSrc = resources_config_1.default.getInstance().getSkillMetaSrc(profile);
    if (!string_utils_1.default.isNonBlankString(skillMetaSrc)) {
        throw new Error('[Error]: Invalid skill project structure. Please set the "src" field in skillMetadata resource.');
    }
    const skillPackageSrc = path_1.default.isAbsolute(skillMetaSrc) ? skillMetaSrc : path_1.default.join(projectPath, skillMetaSrc);
    if (!fs_extra_1.default.existsSync(skillPackageSrc)) {
        throw new Error(`[Error]: Invalid skill package src. Attempt to get the skill package but doesn't exist: ${skillPackageSrc}.`);
    }
    const manifestPath = path_1.default.join(skillPackageSrc, "skill.json");
    if (!fs_extra_1.default.existsSync(manifestPath)) {
        throw new Error(`[Error]: Invalid skill project structure. Please make sure skill.json exists in ${skillPackageSrc}.`);
    }
    new manifest_1.default(manifestPath);
}
exports.loadSkillProjectModel = loadSkillProjectModel;
/**
 * Filter the downloaded skill project by
 * 1.Remove the .git folder to avoid obfuscated git history
 * 2.Update skill name in the skill.json
 * @param {String} skillName the skill name
 * @param {String} projectPath the project file path
 * @param {String} profile ask-cli profile
 */
function updateSkillProjectWithUserSettings(skillName, projectPath, profile) {
    // update skill name
    manifest_1.default.getInstance().setSkillName(skillName);
    // update ask-resources config with profile name
    const defaultProfileObject = resources_config_1.default.getInstance().getProfile("default");
    resources_config_1.default.getInstance().setProfile("default", undefined);
    resources_config_1.default.getInstance().setProfile(profile, defaultProfileObject);
    // remove .git folder
    const hiddenGitFolder = path_1.default.join(projectPath, ".git");
    fs_extra_1.default.removeSync(hiddenGitFolder);
}
exports.updateSkillProjectWithUserSettings = updateSkillProjectWithUserSettings;
/**
 * To initialize Deploy Engine or not by selected deployment type
 * @param {NewSkillDeployerType} deployerType the deployer type from userInput
 * @param {String} infrastructurePath the root path for current deploy delegate's files in skill's project
 * @param {String} profile ask-cli profile
 * @param {Boolean} doDebug
 * @param {uiCallback} callback { error, ddType } return the selected deploy delegate type
 */
function initializeDeployDelegate(deployerType, projectFolderPath, profile, doDebug, callback) {
    // no need to bootstrap if it's self-hosted
    if (!deployerType || deployerType === constants_1.DEPLOYER_TYPE.SELF_HOSTED.NAME) {
        callback(null);
        return;
    }
    // no need to bootstrap as the project is already configured with deployerType
    let ddType = resources_config_1.default.getInstance().getSkillInfraType(profile);
    if (string_utils_1.default.isNonBlankString(ddType) && deployerType === ddType) {
        callback(null, ddType);
        return;
    }
    // bootstrap when deployerType is not set from the template
    const infrastructurePath = path_1.default.join(projectFolderPath, constants_1.FILE_PATH.SKILL_INFRASTRUCTURE.INFRASTRUCTURE);
    bootstrapProject(deployerType, infrastructurePath, profile, doDebug, (bootstrapErr) => {
        if (bootstrapErr) {
            callback(bootstrapErr);
        }
        else {
            ddType = resources_config_1.default.getInstance().getSkillInfraType(profile);
            callback(null, ddType);
        }
    });
}
exports.initializeDeployDelegate = initializeDeployDelegate;
/**
 * Trigger the bootstrap process from the selected deploy delegate
 * @param {NewSkillDeployerType} deployerType the type of the deployer
 * @param {String} infrastructurePath the root path for current deploy delegate's files in skill's project
 * @param {String} profile ask-cli profile
 * @param {Boolean} doDebug
 * @param {Function} callback (error)
 */
function bootstrapProject(deployerType, infrastructurePath, profile, doDebug, callback) {
    // 1.Initiate ask-resources config for skillInfrastructure field
    const ddFolderPath = deployerType.startsWith("@ask-cli/") ? deployerType.replace("@ask-cli/", "") : deployerType;
    const workspacePath = path_1.default.join(infrastructurePath, string_utils_1.default.filterNonAlphanumeric(ddFolderPath));
    fs_extra_1.default.ensureDirSync(workspacePath);
    resources_config_1.default.getInstance().setSkillInfraType(profile, deployerType);
    resources_config_1.default.getInstance().setSkillInfraDeployState(profile, {});
    // 2.Bootstrap skill project with deploy delegate logic
    const skillInfraController = new skill_infrastructure_controller_1.default({ profile, doDebug });
    skillInfraController.bootstrapInfrastructures(workspacePath, (bootstrapErr) => {
        bootstrapErr ? callback(bootstrapErr) : callback(null);
    });
}
exports.bootstrapProject = bootstrapProject;
