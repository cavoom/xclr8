"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionRuleValidatorMap = exports.validateOptionRules = exports.validateOptionString = exports.validateRequiredOption = void 0;
const R = require("ramda");
const fs = require("fs");
const urlUtils = require("../utils/url-utils");
const messenger_1 = __importDefault(require("../view/messenger"));
const path_1 = __importDefault(require("path"));
exports.optionRuleValidatorMap = {
    ENUM: (options, key, ruleModel) => {
        assertNotNullForRuleModel(ruleModel, "values");
        const possibleValues = ruleModel.values;
        if (!possibleValues.includes(options[key])) {
            throw `Value must be in (${possibleValues.join(", ")}).`;
        }
    },
    REGEX(options, key, ruleModel) {
        assertNotNullForRuleModel(ruleModel, "regex");
        const regex = new RegExp(ruleModel.regex);
        if (!regex.test(options[key])) {
            throw `Input value (${options[key]}) doesn't match REGEX rule ${ruleModel.regex}.`;
        }
    },
    FILE_PATH(options, key, ruleModel) {
        var _a;
        try {
            fs.accessSync(options[key], fs.constants.R_OK);
        }
        catch (e) {
            if (e.code === "ENOENT") {
                throw "File does not exist with the given path.";
            }
            else {
                throw "The provided file must have read permission.";
            }
        }
        if (ruleModel && ruleModel.extension) {
            if (!((_a = ruleModel.extension) === null || _a === void 0 ? void 0 : _a.includes(path_1.default.extname(options[key])))) {
                throw `File extension is not of type ${ruleModel.extension}.`;
            }
        }
    },
    NUMBER(options, key) {
        const num = Number(options[key]);
        if (Number.isNaN(num)) {
            throw "Input should be a number.";
        }
    },
    INTEGER(options, key) {
        exports.optionRuleValidatorMap.NUMBER(options, key);
        const num = Number(options[key]);
        if (!Number.isInteger(num)) {
            throw "Input number should be an integer.";
        }
    },
    URL(options, key) {
        if (!urlUtils.isValidUrl(options[key])) {
            throw "Input should be a URL.";
        }
    },
};
function assertNotNullForRuleModel(obj, key) {
    // TODO add unit test after logger integration
    if (!obj || !obj[key]) {
        obj && messenger_1.default.getInstance().fatal(new Error(`Option rule model of type "${obj.type}" requires field "${String(key)}" to be set!`));
        messenger_1.default.getInstance().dispose();
        process.exit(1);
    }
}
/**
 * Validate that option value has been set
 * @param options
 * @param key
 */
function validateRequiredOption(options, key) {
    if (!options[key]) {
        throw "Field is required and must be set.";
    }
}
exports.validateRequiredOption = validateRequiredOption;
/**
 * Validate that option value is valid non-empty string
 * @param options
 * @param key
 */
function validateOptionString(options, key) {
    if (!R.is(String, options[key])) {
        throw "Must be a string.";
    }
    if (R.isEmpty(options[key].trim())) {
        throw "Value must not be empty.";
    }
}
exports.validateOptionString = validateOptionString;
/**
 * Validate option value against specific rules
 * @param options
 * @param key
 * @param rules
 */
function validateOptionRules(options, key, rules) {
    // if no rule is associated with current option key, fallback to no-op
    if (rules && rules.length) {
        for (const rule of rules) {
            const ruleValidator = exports.optionRuleValidatorMap[rule.type];
            // check if there is a validator for given rule type. If not, fallback to no-op
            if (ruleValidator) {
                ruleValidator(options, key, rule);
            }
        }
    }
}
exports.validateOptionRules = validateOptionRules;
