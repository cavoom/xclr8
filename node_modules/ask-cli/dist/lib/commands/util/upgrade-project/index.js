"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCommand = void 0;
const git_client_1 = __importDefault(require("../../../clients/git-client"));
const abstract_command_1 = require("../../abstract-command");
const option_model_json_1 = __importDefault(require("../../option-model.json"));
const messenger_1 = __importDefault(require("../../../view/messenger"));
const profile_helper_1 = __importDefault(require("../../../utils/profile-helper"));
const constants_1 = __importDefault(require("../../../utils/constants"));
const helper_1 = __importDefault(require("./helper"));
const hosted_skill_helper_1 = __importDefault(require("./hosted-skill-helper"));
class UpgradeProjectCommand extends abstract_command_1.AbstractCommand {
    name() {
        return "upgrade-project";
    }
    description() {
        return "upgrade the v1 ask-cli skill project to v2 structure";
    }
    requiredOptions() {
        return [];
    }
    optionalOptions() {
        return ["profile", "debug"];
    }
    async handle(cmd) {
        let profile, upgradeInfo;
        try {
            profile = profile_helper_1.default.runtimeProfile(cmd.profile);
            const { v1Config, isDeployed } = helper_1.default.loadV1ProjConfig(process.cwd(), profile);
            // 0.upgrade if project is un-deployed v1 template
            if (!isDeployed) {
                helper_1.default.attemptUpgradeUndeployedProject(process.cwd(), v1Config, profile);
                messenger_1.default.getInstance().info("Template project migration finished.");
                return;
            }
            // 1.extract upgrade-necessary information and confirm project is upgrade-able
            upgradeInfo = helper_1.default.extractUpgradeInformation(v1Config, profile);
        }
        catch (checkErr) {
            messenger_1.default.getInstance().error(checkErr);
            throw checkErr;
        }
        return new Promise((resolve, reject) => {
            // 2.preview new project structure
            helper_1.default.previewUpgrade(upgradeInfo, (previewErr, previewConfirm) => {
                if (previewErr) {
                    messenger_1.default.getInstance().error(previewErr);
                    return reject(previewErr);
                }
                if (!previewConfirm) {
                    messenger_1.default.getInstance().info("Command upgrade-project aborted.");
                    return resolve();
                }
                // 3.create v2 project based on the upgrade info
                if (upgradeInfo.isHosted) {
                    return _createV2HostedSkillProject(upgradeInfo, profile, cmd.debug)
                        .then(() => {
                        messenger_1.default.getInstance().info("Project migration finished.");
                        return resolve();
                    })
                        .catch((v2Err) => {
                        messenger_1.default.getInstance().error(v2Err);
                        return reject(v2Err);
                    });
                }
                else {
                    _createV2NonHostedSkillProject(upgradeInfo, profile, cmd.debug)
                        .then(() => {
                        messenger_1.default.getInstance().info("Project migration finished.");
                        return resolve();
                    })
                        .catch((v2Err) => {
                        messenger_1.default.getInstance().error(v2Err);
                        return reject(v2Err);
                    });
                }
            });
        });
    }
}
exports.default = UpgradeProjectCommand;
async function _createV2HostedSkillProject(upgradeInfo, profile, doDebug) {
    const rootPath = process.cwd();
    const { skillId, gitRepoUrl } = upgradeInfo;
    const verbosityOptions = {
        showCommand: !!doDebug,
        showOutput: !!doDebug,
    };
    const gitClient = new git_client_1.default(rootPath, verbosityOptions);
    hosted_skill_helper_1.default.checkIfDevBranchClean(gitClient);
    // 1.move v1 skill project content into legacy folder
    helper_1.default.moveOldProjectToLegacyFolder(rootPath);
    // 2.instantiate MVC and ask-resource config
    hosted_skill_helper_1.default.createV2ProjectSkeletonAndLoadModel(rootPath, skillId, profile);
    // 3.import skill metadata
    return new Promise((resolve, reject) => {
        hosted_skill_helper_1.default.downloadSkillPackage(rootPath, skillId, constants_1.default.SKILL.STAGE.DEVELOPMENT, profile, doDebug, (packageErr) => {
            if (packageErr) {
                return reject(packageErr);
            }
            // 4.copy Lambda code to skill code and update deploy state
            try {
                hosted_skill_helper_1.default.handleExistingLambdaCode(rootPath, gitRepoUrl, profile);
            }
            catch (codeErr) {
                return reject(codeErr);
            }
            // 5. config git setting
            hosted_skill_helper_1.default.postUpgradeGitSetup(profile, doDebug, gitClient, gitRepoUrl, skillId, (gitErr) => {
                if (gitErr) {
                    return reject(gitErr);
                }
                resolve();
            });
        });
    });
}
async function _createV2NonHostedSkillProject(upgradeInfo, profile, doDebug) {
    const rootPath = process.cwd();
    const { skillId, lambdaResources } = upgradeInfo;
    // 1.move v1 skill project content into legacy folder
    helper_1.default.moveOldProjectToLegacyFolder(rootPath);
    // 2.instantiate MVC and ask-resource config
    helper_1.default.createV2ProjectSkeletonAndLoadModel(rootPath, skillId, profile);
    // 3.import skill metadata from skillId
    return new Promise((resolve, reject) => {
        helper_1.default.downloadSkillPackage(rootPath, skillId, constants_1.default.SKILL.STAGE.DEVELOPMENT, profile, doDebug, (packageErr) => {
            if (packageErr) {
                return reject(packageErr);
            }
            // 4.copy Lambda code to skill code
            try {
                helper_1.default.handleExistingLambdaCode(rootPath, lambdaResources, profile);
                resolve();
            }
            catch (codeErr) {
                reject(codeErr);
            }
        });
    });
}
exports.createCommand = new UpgradeProjectCommand(option_model_json_1.default).createCommand();
