"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCommand = void 0;
const path_1 = __importDefault(require("path"));
const smapi_client_1 = __importStar(require("../../clients/smapi-client"));
const abstract_command_1 = require("../abstract-command");
const option_model_json_1 = __importDefault(require("../option-model.json"));
const hosted_skill_controller_1 = __importDefault(require("../../controllers/hosted-skill-controller"));
const cli_warn_1 = __importDefault(require("../../exceptions/cli-warn"));
const constants_1 = __importDefault(require("../../utils/constants"));
const profile_helper_1 = __importDefault(require("../../utils/profile-helper"));
const string_utils_1 = __importDefault(require("../../utils/string-utils"));
const json_view_1 = __importDefault(require("../../view/json-view"));
const messenger_1 = __importDefault(require("../../view/messenger"));
const helper_1 = __importDefault(require("./helper"));
const ui_1 = __importDefault(require("./ui"));
class InitCommand extends abstract_command_1.AbstractCommand {
    name() {
        return "init";
    }
    description() {
        return "setup a new or existing Alexa skill project";
    }
    requiredOptions() {
        return [];
    }
    optionalOptions() {
        return ["hosted-skill-id", "profile", "debug"];
    }
    async handle(cmd) {
        let profile;
        try {
            profile = profile_helper_1.default.runtimeProfile(cmd.profile);
        }
        catch (err) {
            messenger_1.default.getInstance().error(err);
            throw err;
        }
        const rootPath = process.cwd();
        if (!cmd.hostedSkillId) {
            await initNonHostedSkill(rootPath, cmd, profile);
        }
        else {
            await initAlexaHostedSkill(rootPath, cmd, profile);
        }
    }
}
exports.default = InitCommand;
async function initAlexaHostedSkill(rootPath, cmd, profile) {
    const smapiClient = new smapi_client_1.default({ profile, doDebug: cmd.debug });
    const hostedSkillController = new hosted_skill_controller_1.default({ profile, doDebug: cmd.debug });
    try {
        const skillName = await _getSkillName(smapiClient, cmd.hostedSkillId);
        const folderName = await _confirmProjectFolderName(skillName);
        const projectPath = path_1.default.join(rootPath, folderName);
        return new Promise((resolve, reject) => {
            hostedSkillController.updateAskSystemScripts((scriptErr) => {
                if (scriptErr) {
                    messenger_1.default.getInstance().error(scriptErr);
                    return reject(scriptErr);
                }
                hostedSkillController.clone(cmd.hostedSkillId, skillName, projectPath, (cloneErr) => {
                    if (cloneErr) {
                        messenger_1.default.getInstance().error(cloneErr);
                        return reject(cloneErr);
                    }
                    hostedSkillController.updateSkillPrePushScript(folderName, (hooksErr) => {
                        if (hooksErr) {
                            messenger_1.default.getInstance().error(hooksErr);
                            return reject(hooksErr);
                        }
                        messenger_1.default.getInstance().info(`\n${skillName} successfully initialized.\n`);
                        return resolve();
                    });
                });
            });
        });
    }
    catch (err) {
        messenger_1.default.getInstance().error(err);
        throw err;
    }
}
async function initNonHostedSkill(rootPath, cmd, profile) {
    return new Promise((resolve, reject) => {
        helper_1.default.preInitCheck(rootPath, profile, (preCheckErr) => {
            if (preCheckErr) {
                if (preCheckErr instanceof cli_warn_1.default) {
                    messenger_1.default.getInstance().warn(preCheckErr.message);
                }
                else {
                    messenger_1.default.getInstance().error(preCheckErr);
                }
                return reject(preCheckErr);
            }
            _collectAskResources()
                .then((userInput) => {
                helper_1.default.previewAndWriteAskResources(rootPath, userInput, profile, (previewErr) => {
                    if (previewErr) {
                        if (previewErr instanceof cli_warn_1.default) {
                            messenger_1.default.getInstance().warn(previewErr.message);
                        }
                        else {
                            messenger_1.default.getInstance().error(previewErr);
                        }
                        return reject(previewErr);
                    }
                    helper_1.default.bootstrapSkillInfra(rootPath, profile, cmd.debug, (postErr) => {
                        if (postErr) {
                            messenger_1.default.getInstance().error(postErr);
                            return reject(postErr);
                        }
                        messenger_1.default.getInstance().info('\nSuccess! Run "ask deploy" to deploy your skill.');
                        resolve();
                    });
                });
            })
                .catch((inputErr) => {
                messenger_1.default.getInstance().error(inputErr);
                return reject(inputErr);
            });
        });
    });
}
/**
 * List of QAs to collect users' ask-resources configurations
 */
async function _collectAskResources() {
    return new Promise((resolve, reject) => {
        helper_1.default.getSkillIdUserInput((skillIdErr, skillId) => {
            if (skillIdErr) {
                return reject(skillIdErr);
            }
            helper_1.default.getSkillMetadataUserInput((metaErr, skillMeta) => {
                if (metaErr) {
                    return reject(metaErr);
                }
                helper_1.default.getSkillCodeUserInput((codeErr, skillCode) => {
                    if (codeErr) {
                        return reject(codeErr);
                    }
                    if (!skillCode) {
                        // return to skip skillInfra setting if skill code is not provided
                        return resolve({ skillId: skillId, skillMeta });
                    }
                    helper_1.default.getSkillInfraUserInput((infraErr, skillInfra) => {
                        if (infraErr) {
                            return reject(infraErr);
                        }
                        resolve({ skillId: skillId, skillMeta, skillCode, skillInfra });
                    });
                });
            });
        });
    });
}
/**
 * To get skill name by calling skill's getManifest api
 * @param {Object} smapiClient SMAPI client to make request
 * @param {string} skillId The skill ID
 * @param {callback} callback { error, response }
 */
async function _getSkillName(smapiClient, skillId) {
    var _a, _b;
    const manifest = await _getSkillManifest(smapiClient, skillId);
    const locales = (_b = (_a = manifest === null || manifest === void 0 ? void 0 : manifest.manifest) === null || _a === void 0 ? void 0 : _a.publishingInformation) === null || _b === void 0 ? void 0 : _b.locales;
    if (!locales) {
        throw "No skill name found.";
    }
    return locales["en-US"] ? locales["en-US"].name : Object.values(locales)[0].name;
}
/**
 * To call getManifest api and return skill manifest
 * @param {Object} smapiClient SMAPI client to make request
 * @param {string} skillId The skill ID
 * @param {callback} callback { error, response }
 */
async function _getSkillManifest(smapiClient, skillId) {
    return new Promise((resolve, reject) => {
        smapiClient.skill.manifest.getManifest(skillId, constants_1.default.SKILL.STAGE.DEVELOPMENT, (err, res) => {
            if (err || !res) {
                return reject(err);
            }
            if ((0, smapi_client_1.isSmapiError)(res)) {
                return reject(json_view_1.default.toString(res.body));
            }
            resolve(res.body);
        });
    });
}
/**
 * To confirm the project folder name with users,
 * the default folder name is generated from the skillName
 * @param {string} skillName The skill name
 * @param {string} callback callback { error, response }
 */
async function _confirmProjectFolderName(skillName) {
    const suggestedProjectName = string_utils_1.default.filterNonAlphanumeric(skillName);
    return new Promise((resolve, reject) => {
        ui_1.default.getProjectFolderName(suggestedProjectName, (getFolderNameErr, folderName) => {
            if (getFolderNameErr) {
                return reject(getFolderNameErr);
            }
            return resolve(folderName);
        });
    });
}
exports.createCommand = new InitCommand(option_model_json_1.default).createCommand();
