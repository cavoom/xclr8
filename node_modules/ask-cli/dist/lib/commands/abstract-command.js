"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCommand = void 0;
const semver_1 = __importDefault(require("semver"));
const httpClient = __importStar(require("../clients/http-client"));
const option_validator_1 = require("./option-validator");
const app_config_1 = __importDefault(require("../model/app-config"));
const constants_1 = __importDefault(require("../utils/constants"));
const messenger_1 = __importDefault(require("../view/messenger"));
const metrics_1 = __importDefault(require("../utils/metrics"));
const package_json_1 = __importDefault(require("../../package.json"));
/**
 * Base class for ASK CLI command that provides option parsing, commander configuration and option validation at runtime.
 */
class AbstractCommand {
    constructor(optionModel) {
        // eslint-disable-next-line global-require
        this._optionModel = optionModel || require("./option-model");
    }
    exit(statusCode) {
        messenger_1.default.getInstance().dispose();
        process.exit(statusCode || 0);
    }
    createCommand() {
        new messenger_1.default({});
        return (commander) => {
            try {
                // register command name and description
                const commanderCopy = commander.command(this.name()).description(this.description());
                // register command options
                this._registerOptions(commanderCopy);
                // register command action
                this._registerAction(commanderCopy);
            }
            catch (err) {
                messenger_1.default.getInstance().fatal(err);
                this.exit(1);
            }
        };
    }
    _registerAction(commander) {
        // the result commander's parse, args, contains a Commander object (args[0]), and an array of unrecognized user inputs (args[1])
        commander.action(async (...args) => {
            const commandInstance = args[0];
            const remaining = args[1];
            // set Messenger debug preferrance
            messenger_1.default.getInstance().doDebug = commandInstance.debug;
            // Start metric client
            metrics_1.default.startAction(commandInstance._name, "");
            const isCredentialHelperCmd = commandInstance._name === "git-credentials-helper";
            // Check if a new CLI version is released
            await this._remindsIfNewVersion(commandInstance.debug, isCredentialHelperCmd || process.env.ASK_SKIP_NEW_VERSION_REMINDER);
            try {
                this._validateOptions(commandInstance);
                /**
                 * Since this code is ran for every command, we'll just be initiating appConfig here (no files created).
                 * Only `ask configure` command should have the eligibility to create the ASK config file (which is handled
                 * in the configure workflow).
                 */
                if (commandInstance._name !== "configure") {
                    new app_config_1.default();
                }
            }
            catch (err) {
                messenger_1.default.getInstance().error(err);
                this.exit(1);
                return;
            }
            // execute handler logic of each command; quit execution
            try {
                await this.handle(commandInstance, remaining);
                metrics_1.default.sendData().then(() => {
                    this.exit(0);
                });
            }
            catch (error) {
                metrics_1.default.sendData(error).then(() => {
                    this.exit(error ? 1 : 0);
                });
            }
        });
    }
    _registerOptions(commander) {
        const requiredOptions = this.requiredOptions();
        if (requiredOptions && requiredOptions.length) {
            for (const optionId of requiredOptions) {
                commander = this._registerOption(commander, optionId, true);
            }
        }
        const optionalOptions = this.optionalOptions();
        if (optionalOptions && optionalOptions.length) {
            for (const optionId of optionalOptions) {
                commander = this._registerOption(commander, optionId, false);
            }
        }
        return commander;
    }
    _registerOption(commander, optionId, required) {
        const optionModel = this._optionModel[optionId];
        // Check if given option name has a model defined. Refer to option-model.json for all available option models
        if (!optionModel) {
            throw new Error(`Unrecognized option ID: ${optionId}`);
        }
        return commander.option(AbstractCommand.buildOptionString(optionModel), `${required ? "[REQUIRED]" : "[OPTIONAL]"} ${optionModel.description}`);
    }
    _validateOptions(cmd) {
        const requiredOptions = this.requiredOptions();
        if (requiredOptions && requiredOptions.length) {
            for (const optionId of requiredOptions) {
                const [name, value] = this._validateOption(cmd, optionId, true);
                if (value !== undefined)
                    metrics_1.default.setOption(name, value);
            }
        }
        const optionalOptions = this.optionalOptions();
        if (optionalOptions && optionalOptions.length) {
            for (const optionId of optionalOptions) {
                const [name, value] = this._validateOption(cmd, optionId, false);
                if (value !== undefined)
                    metrics_1.default.setOption(name, value);
            }
        }
    }
    /**
     * Looks up the option, validates the value, and returns the (name, value) pair if it is valid
     * @param cmd commander instance
     * @param optionId the option to lookup
     * @param required whether the option is required
     * @returns the option name, the option value if option was set
     * @throws error if the option is invalid
     */
    _validateOption(cmd, optionId, required) {
        const optionModel = this._optionModel[optionId];
        const optionKey = AbstractCommand.parseOptionKey(optionModel.name);
        try {
            if (required) {
                (0, option_validator_1.validateRequiredOption)(cmd, optionKey);
            }
            // the value is undefined if the user did not specify this option
            const optionValue = cmd[optionKey];
            if (optionValue) {
                // Validate string value for options that require string input
                if (optionModel.stringInput === "REQUIRED") {
                    (0, option_validator_1.validateOptionString)(cmd, optionKey);
                }
                (0, option_validator_1.validateOptionRules)(cmd, optionKey, optionModel.rule);
            }
            return [optionModel.name, optionValue];
        }
        catch (err) {
            throw `Please provide valid input for option: ${optionModel.name}. ${err}`;
        }
    }
    _remindsIfNewVersion(doDebug, skip) {
        if (skip)
            return Promise.resolve();
        return new Promise((resolve) => {
            httpClient.request({
                url: `${constants_1.default.NPM_REGISTRY_URL_BASE}/${constants_1.default.APPLICATION_NAME}/latest`,
                method: constants_1.default.HTTP_REQUEST.VERB.GET,
            }, "GET_NPM_REGISTRY", doDebug, (err, response) => {
                var _a;
                if (err) {
                    const error = err.statusCode ? `Http Status Code: ${err.statusCode}.` : err;
                    messenger_1.default.getInstance().error(`Failed to get the latest version for ${constants_1.default.APPLICATION_NAME} from NPM registry.\n${error}\n`);
                }
                else {
                    const latestVersion = (_a = response.body) === null || _a === void 0 ? void 0 : _a.version;
                    if (package_json_1.default.version !== latestVersion) {
                        if (semver_1.default.major(package_json_1.default.version) < semver_1.default.major(latestVersion)) {
                            messenger_1.default.getInstance().warn(`\
New MAJOR version (v${latestVersion}) of ${constants_1.default.APPLICATION_NAME} is available now. Current version v${package_json_1.default.version}.
It is recommended to use the latest version. Please update using "npm upgrade -g ${constants_1.default.APPLICATION_NAME}".
\n`);
                        }
                        else if (semver_1.default.major(package_json_1.default.version) === semver_1.default.major(latestVersion) &&
                            semver_1.default.minor(package_json_1.default.version) < semver_1.default.minor(latestVersion)) {
                            messenger_1.default.getInstance().warn(`\
New MINOR version (v${latestVersion}) of ${constants_1.default.APPLICATION_NAME} is available now. Current version v${package_json_1.default.version}.
It is recommended to use the latest version. Please update using "npm upgrade -g ${constants_1.default.APPLICATION_NAME}".
\n`);
                        }
                    }
                }
                resolve();
            });
        });
    }
    /**
     * Build the usage string for an option
     * @param {Object} optionModel
     */
    static buildOptionString(optionModel) {
        const optionStringArray = [];
        if (optionModel.alias) {
            optionStringArray.push(`-${optionModel.alias},`);
        }
        optionStringArray.push(`--${optionModel.name}`);
        if (optionModel.stringInput === "REQUIRED") {
            optionStringArray.push(`<${optionModel.name}>`);
        }
        else if (optionModel.stringInput === "OPTIONAL") {
            optionStringArray.push(`[${optionModel.name}]`);
        }
        return optionStringArray.join(" ");
    }
    /**
     * convert option name to option key
     * Example: skill-id -> skillId
     * @param name
     */
    static parseOptionKey(name) {
        const arr = name.split("-");
        return arr.slice(1).reduce((end, element) => end + element.charAt(0).toUpperCase() + element.slice(1), arr[0]);
    }
}
exports.AbstractCommand = AbstractCommand;
module.exports = {
    AbstractCommand,
};
