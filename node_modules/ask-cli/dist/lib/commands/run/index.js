"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCommand = void 0;
const path_1 = __importDefault(require("path"));
const smapi_client_1 = __importDefault(require("../../clients/smapi-client"));
const abstract_command_1 = require("../abstract-command");
const option_model_json_1 = __importDefault(require("../../commands/option-model.json"));
const authorization_controller_1 = __importDefault(require("../../controllers/authorization-controller"));
const resources_config_1 = __importDefault(require("../../model/resources-config"));
const constants_1 = __importDefault(require("../../utils/constants"));
const profile_helper_1 = __importDefault(require("../../utils/profile-helper"));
const json_view_1 = __importDefault(require("../../view/json-view"));
const string_utils_1 = __importDefault(require("../../utils/string-utils"));
const messenger_1 = __importDefault(require("../../view/messenger"));
const cli_error_1 = __importDefault(require("../../exceptions/cli-error"));
const helper = __importStar(require("./helper"));
class RunCommand extends abstract_command_1.AbstractCommand {
    name() {
        return "run";
    }
    description() {
        return ("Starts a local instance of your project as the skill endpoint." +
            " Automatically re-routes development requests and responses between the Alexa service and your local instance.");
    }
    requiredOptions() {
        return [];
    }
    optionalOptions() {
        return ["debug-port", "wait-for-attach", "watch", "region", "profile", "debug"];
    }
    async handle(cmd) {
        const debugPort = cmd.debugPort || constants_1.default.RUN.DEFAULT_DEBUG_PORT;
        const skillCodeRegion = cmd.region || constants_1.default.ALEXA.REGION.NA;
        const runRegion = cmd.region || constants_1.default.ALEXA.REGION.NA;
        const watch = cmd.watch || false;
        let skillId, profile;
        try {
            profile = profile_helper_1.default.runtimeProfile(cmd.profile);
            new resources_config_1.default(path_1.default.join(process.cwd(), constants_1.default.FILE_PATH.ASK_RESOURCES_JSON_CONFIG));
            skillId = resources_config_1.default.getInstance().getSkillId(profile);
            if (!string_utils_1.default.isNonBlankString(skillId)) {
                throw new cli_error_1.default(`Failed to obtain skill-id for the given profile - ${profile}` + ". Please deploy you skill project first.");
            }
        }
        catch (error) {
            messenger_1.default.getInstance().error(error);
            throw error;
        }
        try {
            const token = await this._getAccessTokenForProfile(profile, cmd.debug);
            const runFlowInstance = await this._getSkillRunFlow(skillId, profile, skillCodeRegion, cmd.waitForAttach, watch, cmd.debug, debugPort, token, runRegion);
            messenger_1.default.getInstance().info("\n*****Once the session is successfully started, " +
                "you can use `ask dialog` to make simulation requests to your local skill code*****\n");
            if (cmd.waitForAttach) {
                messenger_1.default.getInstance().info(`\n*****Debugging session will wait until inspector is attached at port - ${debugPort}*****\n`);
            }
            await runFlowInstance.execCommand();
        }
        catch (tokenErr) {
            messenger_1.default.getInstance().error(tokenErr);
            throw tokenErr;
        }
    }
    _getAccessTokenForProfile(profile, debug) {
        const authorizationController = new authorization_controller_1.default({
            auth_client_type: "LWA",
            doDebug: debug,
        });
        return new Promise((resolve, reject) => {
            authorizationController.tokenRefreshAndRead(profile, (tokenErr, token) => {
                if (tokenErr) {
                    return reject(tokenErr);
                }
                resolve(token);
            });
        });
    }
    _getHostedSkillRuntime(smapiClient, skillId) {
        return new Promise((resolve, reject) => {
            smapiClient.skill.alexaHosted.getAlexaHostedSkillMetadata(skillId, (err, response) => {
                if (err) {
                    return reject(err);
                }
                if (response.statusCode >= 300) {
                    const error = json_view_1.default.toString(response.body);
                    return reject(error);
                }
                try {
                    if (!response.body) {
                        throw new cli_error_1.default("Received an empty response body from getAlexaHostedSkillMetadata");
                    }
                    const { runtime } = response.body.alexaHosted;
                    if (!string_utils_1.default.isNonBlankString(runtime)) {
                        throw new cli_error_1.default(`Unable to determine runtime of the hosted skill - ${skillId}`);
                    }
                    resolve(helper.getNormalisedRuntime(runtime));
                }
                catch (error) {
                    return reject(error);
                }
            });
        });
    }
    async _getSkillRunFlow(skillId, profile, skillCodeRegion, waitForAttach, watch, debug, debugPort, token, runRegion) {
        if (this._filterAlexaHostedSkill(profile)) {
            const smapiClient = new smapi_client_1.default({
                profile,
                doDebug: debug,
            });
            const runtime = await this._getHostedSkillRuntime(smapiClient, skillId);
            return helper.getSkillFlowInstance(runtime, helper.getHostedSkillInvocationInfo(runtime), waitForAttach, debugPort, token, skillId, runRegion, watch);
        }
        else {
            const skillCodeFolderName = helper.getSkillCodeFolderName(profile, skillCodeRegion);
            messenger_1.default.getInstance().info(`Skill code folder name select for the run session: ${skillCodeFolderName}`);
            const userConfig = resources_config_1.default.getInstance().getSkillInfraUserConfig(profile);
            if (!userConfig) {
                throw new cli_error_1.default("Failed to obtain userConfig from project " + `resource file ${constants_1.default.FILE_PATH.ASK_RESOURCES_JSON_CONFIG}`);
            }
            const { runtime, handler } = userConfig;
            if (!runtime) {
                throw new cli_error_1.default(`Failed to obtain runtime from userConfig in project resource file ${constants_1.default.FILE_PATH.ASK_RESOURCES_JSON_CONFIG}`);
            }
            const normalisedRuntime = helper.getNormalisedRuntime(runtime);
            return helper.getSkillFlowInstance(normalisedRuntime, helper.getNonHostedSkillInvocationInfo(normalisedRuntime, handler, skillCodeFolderName), waitForAttach, debugPort, token, skillId, runRegion, watch);
        }
    }
    _filterAlexaHostedSkill(profile) {
        return resources_config_1.default.getInstance().getSkillInfraType(profile) === constants_1.default.DEPLOYER_TYPE.HOSTED.NAME;
    }
}
exports.default = RunCommand;
exports.createCommand = new RunCommand(option_model_json_1.default).createCommand();
