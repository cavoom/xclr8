"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportStatusView = void 0;
const listr_1 = __importDefault(require("listr"));
const events_1 = require("events");
const import_status_view_observable_1 = require("./import-status-view-observable");
const import_status_view_events_1 = require("./import-status-view-events");
const retry_utility_1 = require("../../utils/retry-utility");
const messenger_1 = __importDefault(require("../messenger"));
/**
 * View class used to print the status of an skill import
 */
class ImportStatusView {
    constructor(locales, listr) {
        this.listrTasks = [];
        this.eventMapping = new Map();
        this.skillIdTaskTitle = "Retrieving skill id...";
        this.importIdTaskTitle = "Retrieving import id...";
        // add skill id and import id tasks
        this.addTask(this.skillIdTaskTitle);
        this.addTask(this.importIdTaskTitle);
        // add all locales tasks
        locales.map((taskTitle) => this.addTask(taskTitle, `[${taskTitle}] Import model builder task.`));
        // initialize listr if not injected
        this.listr = listr ? listr : new listr_1.default([], { concurrent: true, exitOnError: true });
        this.listr.add(this.listrTasks);
        messenger_1.default.getInstance().pause();
        this.listr.run().catch((error) => {
            messenger_1.default.getInstance().warn(error === null || error === void 0 ? void 0 : error.message);
        });
    }
    addTask(taskTitle, initialText) {
        const emitter = new events_1.EventEmitter();
        const task = new import_status_view_observable_1.ImportStatusViewObservable(emitter, taskTitle).getObservable();
        this.listrTasks.push({
            title: initialText ? initialText : taskTitle,
            task: task,
        });
        this.eventMapping.set(taskTitle, emitter);
    }
    /**
     * Function used to publish an update to one of the locales/tasks
     * @param {string} taskTitle title of the task. i.e. for a locale import model build task 'en-US'
     * @param {ImportStatusViewEvents} importStatusPollViewEventName Import status view event to emit
     * @param {string} value Optional value to pass along with the event
     */
    publishEvent(taskTitle, importStatusPollViewEventName, value) {
        var _a;
        (_a = this.eventMapping.get(taskTitle)) === null || _a === void 0 ? void 0 : _a.emit(importStatusPollViewEventName, value);
    }
    /**
     * Call this idempotence function once a skill id has been found
     *  this will publish the skill id on the terminal and completes the task
     * @param skillId Alexa skill id
     * @param fromLocalConfigurationFiles set to true, if this skill id was retreived from the local ask-state file. false if it was retrieved from the SMAPI service api calls
     */
    displaySkillId(skillId, fromLocalConfigurationFiles) {
        var _a;
        const eventToPublish = fromLocalConfigurationFiles
            ? import_status_view_events_1.IMPORT_STATUS_FETCHING_SKILL_ID_SUCESS_EVENT
            : import_status_view_events_1.IMPORT_STATUS_FETCHING_NEW_SKILL_ID_SUCESS_EVENT;
        (_a = this.eventMapping.get(this.skillIdTaskTitle)) === null || _a === void 0 ? void 0 : _a.emit(eventToPublish, skillId);
    }
    /**
     * Call this idempotence function with the import id once it has been retrieved from the SMAPI service calls
     *  this will publish the import id on the terminal and completes the task
     * @param importId Alexa skill model build import id
     */
    displayImportId(importId) {
        var _a;
        (_a = this.eventMapping.get(this.importIdTaskTitle)) === null || _a === void 0 ? void 0 : _a.emit(import_status_view_events_1.IMPORT_STATUS_FETCHING_IMPORT_ID_SUCESS_EVENT, importId);
    }
    /**
     * Call this function to stop all tasks from continuing to print/update on the terminal
     */
    stop() {
        this.eventMapping.forEach((emitter) => {
            emitter.emit(import_status_view_events_1.IMPORT_STATUS_CANCEL_TASK_EVENT);
        });
    }
    /**
     * Async function that only returns once all the tasks have been disabled
     * @returns This promise returns once all the tasks have been disabled
     */
    async waitForCompletion() {
        return new Promise((resolve) => {
            const retryEverySecondFor2Hrs = {
                base: 1000,
                factor: 1.0,
                maxRetry: 2 * 60 * 60,
            };
            const retryCall = (loopCallback) => {
                loopCallback(this.isRunning());
            };
            const shouldRetryCondition = (isRunning) => {
                return isRunning === true ? true : false;
            };
            const onRetryCompletion = () => {
                messenger_1.default.getInstance().resume();
                resolve();
            };
            (0, retry_utility_1.retry)(retryEverySecondFor2Hrs, retryCall, shouldRetryCondition, onRetryCompletion);
        });
    }
    isRunning() {
        let isRunning = false;
        this.listrTasks.forEach((task) => {
            if (task.enabled) {
                isRunning = true;
            }
        });
        return isRunning;
    }
}
exports.ImportStatusView = ImportStatusView;
