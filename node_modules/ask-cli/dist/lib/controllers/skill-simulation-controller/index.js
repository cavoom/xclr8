"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkillSimulationController = void 0;
const dialog_save_skill_io_file_1 = __importDefault(require("../../model/dialog-save-skill-io-file"));
const smapi_client_1 = __importStar(require("../../clients/smapi-client"));
const cli_retriable_error_1 = require("../../exceptions/cli-retriable-error");
const cli_error_1 = __importDefault(require("../../exceptions/cli-error"));
const json_view_1 = require("../../view/json-view");
const CONSTANTS = __importStar(require("../../utils/constants"));
class SkillSimulationController {
    /**
     * Constructor for SkillSimulationController
     * @param {Object} configuration { profile, doDebug }
     * @throws {Error} if configuration is invalid for dialog.
     */
    constructor(configuration) {
        if (configuration === undefined) {
            throw "Cannot have an undefined configuration.";
        }
        const { skillId, locale, stage, profile, saveSkillIo, debug, smapiClient } = configuration;
        this.profile = profile;
        this.doDebug = debug;
        this.smapiClient =
            smapiClient ||
                new smapi_client_1.default({
                    profile: this.profile,
                    doDebug: this.doDebug,
                });
        this.skillId = skillId;
        this.locale = locale;
        this.stage = stage;
        this.skillIOInstance = new dialog_save_skill_io_file_1.default(saveSkillIo);
    }
    /**
     * Start skill simulation by calling SMAPI POST skill simulation
     * @param {String} utterance text utterance to simulate against.
     * @param {Boolean} newSession Boolean to specify to FORCE_NEW_SESSION
     */
    async startSkillSimulation(utterance, newSession) {
        this.skillIOInstance.startInvocation({
            utterance,
            newSession,
        });
        try {
            const res = await this.smapiClient.skill.test.simulateSkill(this.skillId, this.stage, utterance, newSession, this.locale);
            if ((0, smapi_client_1.isSmapiError)(res)) {
                throw new cli_retriable_error_1.RetriableServiceError((0, json_view_1.toString)(res.body), res.body);
            }
            return res;
        }
        catch (err) {
            if (err instanceof cli_retriable_error_1.RetriableServiceError) {
                throw err;
            }
            throw new cli_retriable_error_1.RetriableServiceError(err);
        }
    }
    /**
     * Poll for skill simulation results.
     * @todo Implement timeout.
     * @param {String} simulationId simulation ID associated to the current simulation.
     * @param {Function} callback  function to execute upon a response.
     */
    async getSkillSimulationResult(simulationId, pollCount) {
        const retryConfig = {
            factor: CONSTANTS.CONFIGURATION.RETRY.GET_SIMULATE_STATUS.FACTOR,
            maxRetry: CONSTANTS.CONFIGURATION.RETRY.GET_SIMULATE_STATUS.MAX_RETRY,
            base: CONSTANTS.CONFIGURATION.RETRY.GET_SIMULATE_STATUS.MIN_TIME_OUT,
        };
        try {
            const res = await this.smapiClient.skill.test.getSimulation(this.skillId, simulationId, this.stage);
            if ((0, smapi_client_1.isSmapiError)(res)) {
                throw new cli_retriable_error_1.RetriableServiceError((0, json_view_1.toString)(res.body), res.body);
            }
            this.skillIOInstance.endInvocation({
                body: res.body,
            });
            const status = res.body.status;
            if (status === CONSTANTS.SKILL.SIMULATION_STATUS.SUCCESS) {
                return res;
            }
            else if (status === CONSTANTS.SKILL.SIMULATION_STATUS.FAILURE) {
                throw new cli_retriable_error_1.RetriableServiceError(`Failed to simulate skill. Error: ${res.body.result.error.message}`, res.body);
            }
            else {
                if (pollCount && pollCount > retryConfig.maxRetry) {
                    throw new cli_error_1.default(!status
                        ? `Failed to get status for simulation id: ${simulationId}.` + "Please run again using --debug for more details."
                        : "Retry attempt exceeded.");
                }
                else {
                    const retryInterval = retryConfig.base * Math.pow(retryConfig.factor, pollCount ? pollCount : 0);
                    await new Promise((resolve) => setTimeout(resolve, retryInterval));
                    return this.getSkillSimulationResult(simulationId, (pollCount ? pollCount : 0) + 1);
                }
            }
        }
        catch (err) {
            if (err instanceof cli_retriable_error_1.RetriableServiceError) {
                throw err;
            }
            throw new cli_retriable_error_1.RetriableServiceError(err);
        }
    }
}
exports.SkillSimulationController = SkillSimulationController;
