"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionModelGenerator = void 0;
const ask = __importStar(require("./ast"));
const util_1 = require("./util");
const ast_1 = require("./ast");
const interaction_model_merger_1 = require("./interaction-model-merger");
const GENERATOR_NAME = "acdl";
class InteractionModelGeneratorContext {
    constructor(allGeneratedSlotTypes) {
        /**
         * Cache generated slot types across all locales, to avoid regenerating if it was already generated.
         */
        Object.defineProperty(this, "allGeneratedSlotTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Generated slot types.
         */
        Object.defineProperty(this, "generatedSlotTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.allGeneratedSlotTypes = allGeneratedSlotTypes;
        this.generatedSlotTypes = new Map();
    }
    addGeneratedSlotType(generatedSlotType) {
        const name = generatedSlotType.slotType.name;
        this.generatedSlotTypes.set(name, generatedSlotType);
        this.allGeneratedSlotTypes.set(name, generatedSlotType);
        return generatedSlotType;
    }
    getGeneratedSlotType(name) {
        return this.generatedSlotTypes.get(name);
    }
    getGeneratedSlotTypes() {
        return [...this.generatedSlotTypes.values()];
    }
    importGeneratedSlotType(name) {
        const generatedSlotType = this.allGeneratedSlotTypes.get(name);
        if (generatedSlotType === undefined) {
            return undefined;
        }
        this.generatedSlotTypes.set(name, generatedSlotType);
        return generatedSlotType;
    }
    clone() {
        const context = new InteractionModelGeneratorContext(new Map());
        context.allGeneratedSlotTypes = new Map(this.allGeneratedSlotTypes);
        context.generatedSlotTypes = new Map(this.generatedSlotTypes);
        return context;
    }
}
/**
 * Interaction model generator generates interaction model from definitions in ACDL code.
 */
class InteractionModelGenerator {
    /**
     * Gets locales from a `skill` action call.
  
    * ~~~acdl
     * mySkill = skill(
     *   locales = [Locale.en_US, ...],
     *   ...
     * )
     * ~~~
     *
     * @param skill The `skill` action call.
     * @returns The set of locales defined in the `skill` action call.
     */
    findLocales(skill) {
        var _a;
        const locales = skill.getArgumentValueThing("locales");
        const localeItems = (locales === null || locales === void 0 ? void 0 : locales.isList()) && locales.isLiteral() ? (_a = locales.getItems()) !== null && _a !== void 0 ? _a : [] : [];
        return new Set(localeItems
            .map((locale) => { var _a; return (((_a = locale === null || locale === void 0 ? void 0 : locale.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name" && locale.origin.name ? locale.origin.name : undefined); })
            .filter(util_1.isNotUndefined));
    }
    /**
     * Finds intents in the `skill` action call for specified locale.
     * The `intents` value is a list of name references, which can be:
     *
     * - `intent` action call
     * - `variations` action call with name references
     * - name reference to name declaration of any of above
     *
     * Name declarations can have `@locale` annotation that has to match the specified locale.
     *
     * ~~~acdl
     * mySkill = skill(
     *   intents = [...],
     *   ...
     * )
     * ~~~
     *
     * @param skill Skill action call.
     * @param locale The locale for which to find the intents.
     * @returns The intents found in skill action call for specified locale.
     */
    findIntents(skill, locale, checker) {
        var _a, _b, _c;
        const intents = skill.getArgumentValueThing("intents");
        return this.uniqueValues((_c = (_b = (_a = intents === null || intents === void 0 ? void 0 : intents.asList()) === null || _a === void 0 ? void 0 : _a.getListItems()) === null || _b === void 0 ? void 0 : _b.map((item) => this.resolveVariations(item === null || item === void 0 ? void 0 : item.item, locale, checker)).filter(util_1.isNotUndefined)) !== null && _c !== void 0 ? _c : []);
    }
    uniqueValues(array) {
        return [...new Set(array)];
    }
    /**
     * Gets the utterance sample text.
     *
     * @param utterance The value with sample utterance. This can be
     * @returns The text value of the sample utterance.
     */
    getUtteranceText(utterance) {
        if ((utterance === null || utterance === void 0 ? void 0 : utterance.kind) !== "Call") {
            return undefined;
        }
        if (typeof utterance.arguments === "string") {
            return utterance.arguments;
        }
        if (ask.isUtterance(utterance.arguments)) {
            return utterance.arguments.text;
        }
        return undefined;
    }
    /**
     * Gets string value from `Thing` representing a string literal.
     *
     * @param value Thing that potentially represents a string literal.
     * @returns String value of the thing, or `undefined` if it does not represent a string.
     */
    getStringValue(value) {
        var _a, _b;
        return (value === null || value === void 0 ? void 0 : value.isString()) && typeof ((_a = value.apply) === null || _a === void 0 ? void 0 : _a.call.arguments) === "string" ? (_b = value.apply) === null || _b === void 0 ? void 0 : _b.call.arguments : undefined;
    }
    /**
     * Gets string array from `Thing` representing a string array literal.
     *
     * @param value Thing that potentially represents a string array literal.
     * @param defaultValue Default value for items that are not string literals.
     * @returns String array value of the thing, or `undefined` if it does not represent a string array.
     */
    getStringListValue(value, defaultValue) {
        var _a, _b;
        return (_b = (_a = value === null || value === void 0 ? void 0 : value.asList()) === null || _a === void 0 ? void 0 : _a.getItems()) === null || _b === void 0 ? void 0 : _b.map((item) => { var _a; return (_a = this.getStringValue(item)) !== null && _a !== void 0 ? _a : defaultValue; });
    }
    /**
     * Gets fully qualified name of the thing representing a name declaration.
     *
     * @param value Thing.
     * @returns Fully qualified name of the thing.
     */
    getFullyQualifiedName(value) {
        var _a, _b, _c;
        if (!ask.isNameDeclaration((_a = value.apply) === null || _a === void 0 ? void 0 : _a.call.context)) {
            return undefined;
        }
        return (_c = (_b = value.apply) === null || _b === void 0 ? void 0 : _b.call.context.name) === null || _c === void 0 ? void 0 : _c.name;
    }
    /**
     * Generates slot type based on the list-based catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myBuiltinCatalog = builtinCatalog<MySlot>("AMAZON.Actor")
     * ~~~
     *
     * @returns The slot type based on the list-based catalog type.
     */
    generateBuiltinCatalog(catalogValueThing, context) {
        var _a;
        if (!((_a = catalogValueThing === null || catalogValueThing === void 0 ? void 0 : catalogValueThing.apply) === null || _a === void 0 ? void 0 : _a.isBuiltinCatalogAction())) {
            return undefined;
        }
        // for builtin catalog, use its name as slot type name
        const fullyQualifiedName = this.getStringValue(catalogValueThing.apply.getArgumentValueThing("name"));
        if (!fullyQualifiedName) {
            throw new Error("Builtin catalog name cannot be undefined or empty.");
        }
        const name = fullyQualifiedName;
        const existingSlotType = context.getGeneratedSlotType(name);
        if (existingSlotType) {
            if (existingSlotType.fullyQualifiedName !== fullyQualifiedName) {
                throw new Error(`Slot type '${existingSlotType.fullyQualifiedName}' collides with '${fullyQualifiedName}'.`);
            }
            return existingSlotType;
        }
        const importedSlotType = context.importGeneratedSlotType(name);
        if (importedSlotType) {
            return importedSlotType;
        }
        return context.addGeneratedSlotType({
            fullyQualifiedName,
            slotType: { generatedBy: GENERATOR_NAME, name },
        });
    }
    /**
     * Generates slot type based on the list-based catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myListBasedCatalog = listBasedCatalog<MySlot>(
     *   // itemsThing
     *   CatalogItem<MySlot> {
     *     id = "test",
     *     value = "test value",
     *     synonyms = [
     *       "test synonym 1",
     *       "test synonym 2"
     *     ]
     *   }
     * )
     * ~~~
     *
     * @returns The slot type based on the list-based catalog type.
     */
    generateListBasedCatalog(catalogValueThing, context) {
        var _a, _b, _c, _d;
        if (!((_a = catalogValueThing === null || catalogValueThing === void 0 ? void 0 : catalogValueThing.apply) === null || _a === void 0 ? void 0 : _a.isListBasedCatalogAction())) {
            return undefined;
        }
        // for listBasedCatalog, use fully qualified name of the named reference as its name and define values
        const fullyQualifiedName = this.getFullyQualifiedName(catalogValueThing);
        const name = this.getSimpleName(fullyQualifiedName);
        if (!fullyQualifiedName || !name) {
            throw new Error("List-based catalog name cannot be undefined or empty.");
        }
        const existingSlotType = context.getGeneratedSlotType(name);
        if (existingSlotType) {
            if (existingSlotType.fullyQualifiedName !== fullyQualifiedName) {
                throw new Error(`Slot type '${existingSlotType.fullyQualifiedName}' collides with '${fullyQualifiedName}'.`);
            }
            return existingSlotType;
        }
        const importedSlotType = context.importGeneratedSlotType(name);
        if (importedSlotType) {
            return importedSlotType;
        }
        const items = (_d = (_c = (_b = catalogValueThing.apply.getArgumentValueThing("items")) === null || _b === void 0 ? void 0 : _b.asList()) === null || _c === void 0 ? void 0 : _c.getItems()) !== null && _d !== void 0 ? _d : [];
        const valueSet = new Set();
        const idSet = new Set();
        const values = items.map((item) => {
            var _a, _b;
            const id = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("id"));
            const value = (_a = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("value"))) !== null && _a !== void 0 ? _a : "";
            const synonyms = (_b = this.getStringListValue(item === null || item === void 0 ? void 0 : item.getProperty("synonyms"), "")) !== null && _b !== void 0 ? _b : [];
            if (value === "") {
                throw new Error(`Empty string value found in catalog: ${fullyQualifiedName}.`);
            }
            if (valueSet.has(value)) {
                throw new Error(`Duplicate value "${value}" found in catalog: ${fullyQualifiedName}.`);
            }
            if (id && idSet.has(id)) {
                throw new Error(`Duplicate id "${id}" found in catalog: ${fullyQualifiedName}.`);
            }
            valueSet.add(value);
            idSet.add(id);
            return {
                id,
                name: {
                    value,
                    synonyms,
                },
            };
        });
        return context.addGeneratedSlotType({
            fullyQualifiedName,
            slotType: { generatedBy: GENERATOR_NAME, name, values },
        });
    }
    /**
     * Gets annotation applied on the value having the defined name.
     *
     * @param value Value from which the annotation should be extracted.
     * @param name Name of the annotation.
     * @param checker Type checker.
     * @returns Annotation applied on the value.
     */
    getAnnotation(value, name, checker) {
        var _a, _b;
        return (_b = (_a = value === null || value === void 0 ? void 0 : value.annotations) === null || _a === void 0 ? void 0 : _a.filter((annotation) => { var _a, _b; return ((_b = (_a = checker.getApply(annotation.call)) === null || _a === void 0 ? void 0 : _a.decl.name) === null || _b === void 0 ? void 0 : _b.name) === name; })) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Gets argument value from the annotation.
     *
     * @param annotation Annotation from which to get the argument value.
     * @param argumentName Name of the argument to retrieve.
     * @param checker Type checker.
     * @returns Argument value from the annotation.
     */
    getAnnotationArgumentValue(annotation, argumentName, checker) {
        var _a;
        return ask.isCall(annotation === null || annotation === void 0 ? void 0 : annotation.call) ? (_a = checker.getApply(annotation.call)) === null || _a === void 0 ? void 0 : _a.getArgumentValue(argumentName) : undefined;
    }
    /**
     * Gets locales from annotated node.
     *
     * @param node Node for which to get locales.
     * @param checker Type checker.
     * @returns Locales as a simple string array.
     */
    getLocalesFromAnnotatedNode(node, checker) {
        var _a, _b, _c;
        const localeAnnotation = this.getAnnotation(node, ast_1.AlexaConversations.locale, checker);
        const localesValue = this.getAnnotationArgumentValue(localeAnnotation, "locales", checker);
        const result = [];
        if (ask.isCall(localesValue) && ask.isListLiteral(localesValue === null || localesValue === void 0 ? void 0 : localesValue.arguments)) {
            for (const localeItem of localesValue.arguments.items) {
                if ((_a = checker.getType(localeItem.item)) === null || _a === void 0 ? void 0 : _a.isLocale()) {
                    if (ask.isPropRef(localeItem.item)) {
                        if ((_b = localeItem.item.name) === null || _b === void 0 ? void 0 : _b.name) {
                            result.push((_c = localeItem.item.name) === null || _c === void 0 ? void 0 : _c.name);
                        }
                    }
                }
            }
        }
        return result;
    }
    /**
     * Resolves variations to get node for specific locale.
     *
     * @param node Node from which to start resolving the variations.
     * @param locale Locale for which to search the resolved value.
     * @param checker Type checker.
     * @param locales Locales of the node.
     * @returns Node for specific locale.
     */
    resolveVariations(node, locale, checker, locales = new Set()) {
        if (node === undefined) {
            return undefined;
        }
        // if this is a declaration, append locales from the declaration into the context
        if (ask.isNameDeclaration(node)) {
            this.getLocalesFromAnnotatedNode(node, checker).forEach((locale) => locales.add(locale));
            // resolve the name value recursively
            return this.resolveVariations(node.expression, locale, checker, locales);
        }
        if (ask.isNameReference(node) || ask.isPropRef(node)) {
            const nodes = new Set();
            // recursively add name references and name declaration into `nodes`
            const declaration = checker.resolveNameReferenceToDecl(node, nodes);
            for (const node of nodes) {
                if (ask.isNameReference(node) || ask.isPropRef(node) || ask.isNameDeclaration(node)) {
                    this.getLocalesFromAnnotatedNode(node, checker).forEach((locale) => locales.add(locale));
                }
            }
            return this.resolveVariations(declaration, locale, checker, locales);
        }
        if (ask.isCall(node)) {
            const apply = checker.getApply(node);
            if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                const variationsValue = apply.getArgumentValue("variations");
                if (ask.isCall(variationsValue) && ask.isListLiteral(variationsValue.arguments)) {
                    for (const item of variationsValue.arguments.items) {
                        const variationLocales = new Set(locales);
                        const variation = this.resolveVariations(item.item, locale, checker, variationLocales);
                        if (variation) {
                            return variation;
                        }
                    }
                    return undefined;
                }
            }
        }
        // return the node only if the locales are not defined or they match the requested locale
        return !locales.size || locales.has(locale) ? node : undefined;
    }
    /**
     * Determines whether the node is a name declaration that was generated using `interactionModel` generator.
     *
     * @param node Node to evaluate.
     * @param checker Type checker.
     * @returns Indicates whether the node was generated using `interactionModel` generator.
     */
    isGeneratedFromInteractionModel(node, checker) {
        if (ask.isNameDeclaration(node)) {
            const intentValueAnnotation = this.getAnnotation(node, ast_1.AlexaConversations.generated, checker);
            const generatorNameValue = this.getAnnotationArgumentValue(intentValueAnnotation, "generatorName", checker);
            return ask.isCall(generatorNameValue) && generatorNameValue.arguments === "interactionModel";
        }
        return false;
    }
    /**
     * Generates slot type based on the catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myBuiltinCatalog = builtinCatalog<MySlot>("AMAZON.Actor")
     *
     * // catalogAnnotation
     * @catalog(myListBasedCatalog)
     * type MySlot: String {}
     *
     * type MyIntent {
     *   // property
     *   MySlot mySlot
     * }
     * ~~~
     *
     * @returns The intent slots based on the complex type.
     */
    generateCatalog(property, locale, context) {
        var _a, _b, _c;
        // Unwrap the type from optional and list types
        let type = property.type;
        while ((type === null || type === void 0 ? void 0 : type.isOptional()) || (type === null || type === void 0 ? void 0 : type.isList())) {
            if (type === null || type === void 0 ? void 0 : type.isOptional()) {
                type = type === null || type === void 0 ? void 0 : type.getOptionalType();
            }
            else {
                type = type === null || type === void 0 ? void 0 : type.getListItemType();
            }
        }
        if (!type || ((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) !== "TypeDeclaration") {
            return undefined;
        }
        const typeDeclaration = type === null || type === void 0 ? void 0 : type.declaration;
        const { checker } = type;
        const catalogAnnotation = this.getAnnotation(typeDeclaration, ast_1.AlexaConversations.catalog, checker);
        const catalogAnnotationArgumentValue = this.getAnnotationArgumentValue(catalogAnnotation, "catalog", checker);
        const catalogValue = this.resolveVariations(catalogAnnotationArgumentValue, locale, checker);
        const catalogThing = checker.getThing(catalogValue);
        if (this.isGeneratedFromInteractionModel((_b = catalogThing === null || catalogThing === void 0 ? void 0 : catalogThing.apply) === null || _b === void 0 ? void 0 : _b.call.context, checker)) {
            context = context.clone();
        }
        return (_c = this.generateBuiltinCatalog(catalogThing, context)) !== null && _c !== void 0 ? _c : this.generateListBasedCatalog(catalogThing, context);
    }
    /**
     * Generates intent slots based on the complex type.
     *
     * ~~~
     * @catalog(myBuiltinCatalog)
     * type MyBuiltinSlot: String {}
     *
     * @catalog(myListBasedCatalog)
     * type MyListBasedSlot: String {}
     *
     * // intentType
     * type MyIntent {
     *   MyBuiltinSlot myBuiltinSlot
     *   MyListBasedSlot myListBasedSlot
     * }
     * ~~~
     *
     * @returns The intent slots based on the complex type.
     */
    generateSlots(intentType, locale, context) {
        var _a, _b;
        return ((_b = (_a = intentType === null || intentType === void 0 ? void 0 : intentType.properties) === null || _a === void 0 ? void 0 : _a.map((property) => {
            var _a, _b, _c;
            const propertyType = (_b = (_a = property.type) === null || _a === void 0 ? void 0 : _a.getOptionalType()) !== null && _b !== void 0 ? _b : property.type;
            const slotType = (_c = this.generateCatalog(property, locale, context)) === null || _c === void 0 ? void 0 : _c.slotType.name;
            if (!slotType) {
                throw new Error(`The catalog for property "${property.name}" in "${intentType}" for locale "${locale}" could not be found.`);
            }
            const multipleValues = (propertyType === null || propertyType === void 0 ? void 0 : propertyType.isList()) ? { multipleValues: { enabled: true } } : undefined;
            return {
                name: property.name,
                type: slotType,
                ...multipleValues,
            };
        })) !== null && _b !== void 0 ? _b : []);
    }
    /**
     * Creates intents in interaction model from them. Samples from `intent<T>` actions are used for sample utterances,
     * and the type is used to generate slots.
     *
     * ~~~
     * // intent.declaration
     * invocationUtterances =
     *   // intent.apply
     *   intent
     *     // generic argument 0
     *     <MyIntent>
     *     (
     *       // argument: samples
     *       [
     *         "hello world",
     *         "hello {myBuiltinSlot}",
     *         "{myListBasedSlot} world"
     *       ]
     *     )
     * ~~~
     *
     * @returns The intent defined by the `intent` action.
     */
    generateIntent(intent, locale, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!ask.isNameDeclaration((_a = intent === null || intent === void 0 ? void 0 : intent.apply) === null || _a === void 0 ? void 0 : _a.call.context)) {
            return undefined;
        }
        const name = this.getSimpleName((_c = (_b = intent === null || intent === void 0 ? void 0 : intent.apply) === null || _b === void 0 ? void 0 : _b.call.context.name) === null || _c === void 0 ? void 0 : _c.name);
        if (intent === undefined || name === undefined) {
            return undefined;
        }
        if (this.isGeneratedFromInteractionModel((_d = intent.apply) === null || _d === void 0 ? void 0 : _d.call.context, intent.checker)) {
            return undefined;
        }
        const samplesValue = (_f = (_e = intent.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValueThing("samples")) === null || _f === void 0 ? void 0 : _f.origin;
        const samplesItems = ask.isCall(samplesValue) && ask.isListLiteral(samplesValue.arguments) ? samplesValue.arguments.items : [];
        const samples = samplesItems.map((item) => this.getUtteranceText(item.item)).filter(util_1.isNotUndefined);
        const intentType = (_h = (_g = intent.apply) === null || _g === void 0 ? void 0 : _g.getGenericArguments()) === null || _h === void 0 ? void 0 : _h[0];
        const slots = this.generateSlots(intentType, locale, context);
        return { generatedBy: GENERATOR_NAME, name, samples, slots };
    }
    /**
     * Generates interaction model from ACDL constructs. Gets `intents` defined in `skill` action call and creates
     * intents in interaction model from them. Samples from `intent<T>` actions are used for sample utterances, and
     * the type is used to generate slots.
     * Also, `extendCatalog` calls are collected to find slot type definitions for built-in types.
     *
     * // interactionModels/custom/en-US.json
     * {
     *  "languageModel": {
     *   "intents": [
     *    {
     *     "generated": "acdl",
     *     "name": "getTravelTimeIntentEn",
     *     "slots": [
     *      {
     *       "name": "DepartingPlanet",
     *       "type": "planetCatalogEn"
     *      },
     *      ...
     *     ],
     *     "samples": [
     *      "calculate travel time",
     *      ...
     *     ]
     *    }
     *   ],
     *   "types": [
     *    {
     *     "generated": "acdl",
     *     "name": "planetCatalogEn",
     *     "values": [
     *      {
     *       "name": {
     *        "value": "Mercury"
     *       },
     *       ...
     *      }
     *     ]
     *    }
     *   ]
     *  }
     * }
     *
     * @returns Interaction model generated from ACDL constructs.
     */
    generateInteractionModels(skills, extendCatalogActions) {
        const result = new Map();
        // intents are taken from the (single) skill definition (following the similar logic in root dialogs)
        if (skills.length !== 1) {
            return result;
        }
        const skill = skills[0].apply;
        const { checker } = skill;
        const locales = this.findLocales(skill);
        const allGeneratedSlotTypes = new Map();
        // the interaction model is generated for each skill's locale
        locales.forEach((locale) => {
            const context = new InteractionModelGeneratorContext(allGeneratedSlotTypes);
            const interactionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: "",
                        intents: this.findIntents(skill, locale, checker)
                            .map((intent) => this.generateIntent(checker.getThing(intent), locale, context))
                            .filter(util_1.isNotUndefined),
                        types: context
                            .getGeneratedSlotTypes()
                            .map((generatedSlotType) => generatedSlotType.slotType)
                            .filter((slotType) => !slotType.name.startsWith("AMAZON."))
                            .concat(this.generateSlotTypesFromExtendedCatalogs(extendCatalogActions)),
                    },
                },
            };
            result.set(locale, interactionModel);
        });
        return result;
    }
    getSimpleName(fullyQualifiedName) {
        if (!fullyQualifiedName) {
            return undefined;
        }
        const lastDotIndex = fullyQualifiedName.lastIndexOf(".");
        if (lastDotIndex === -1) {
            return fullyQualifiedName;
        }
        return fullyQualifiedName.substring(lastDotIndex + 1);
    }
    generateSlotTypesFromExtendedCatalogs(extendCatalogActions) {
        var _a, _b, _c;
        const result = new Map();
        for (const extendCatalogAction of extendCatalogActions) {
            const catalogValueThing = extendCatalogAction.apply.getArgumentValueThing("catalog");
            if (!((_a = catalogValueThing === null || catalogValueThing === void 0 ? void 0 : catalogValueThing.apply) === null || _a === void 0 ? void 0 : _a.isBuiltinCatalogAction())) {
                throw new Error("The 'extendCatalog' call can extend only builtin catalogs.");
            }
            const fullyQualifiedName = this.getStringValue(catalogValueThing.apply.getArgumentValueThing("name"));
            if (!fullyQualifiedName) {
                throw new Error("Extended catalog name cannot be undefined or empty.");
            }
            const itemsThing = extendCatalogAction.apply.getArgumentValueThing("items");
            let values = [];
            if (itemsThing === null || itemsThing === void 0 ? void 0 : itemsThing.isList()) {
                values =
                    (_c = (_b = itemsThing.getItems()) === null || _b === void 0 ? void 0 : _b.map((item) => {
                        var _a, _b;
                        const id = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("id"));
                        const value = (_a = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("value"))) !== null && _a !== void 0 ? _a : "";
                        const synonyms = (_b = this.getStringListValue(item === null || item === void 0 ? void 0 : item.getProperty("synonyms"), "")) !== null && _b !== void 0 ? _b : [];
                        const x = {
                            id,
                            name: {
                                value,
                                synonyms,
                            },
                        };
                        return x;
                    })) !== null && _c !== void 0 ? _c : [];
                let slotType = { name: fullyQualifiedName, values };
                const existingSlotType = result.get(fullyQualifiedName);
                if (existingSlotType) {
                    slotType = interaction_model_merger_1.SlotTypeMerger.INSTANCE.merge(existingSlotType, slotType);
                }
                result.set(fullyQualifiedName, slotType);
            }
        }
        return [...result.values()];
    }
}
exports.InteractionModelGenerator = InteractionModelGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJhY3Rpb24tbW9kZWwtZ2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVyYWN0aW9uLW1vZGVsLWdlbmVyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUE2QjtBQUM3QixpQ0FBc0M7QUFLdEMsK0JBQXVHO0FBR3ZHLHlFQUEwRDtBQUUxRCxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUM7QUFtQjlCLE1BQU0sZ0NBQWdDO0lBV3BDLFlBQVkscUJBQXFEO1FBVmpFOztXQUVHO1FBQ0g7Ozs7O1dBQThEO1FBRTlEOztXQUVHO1FBQ0g7Ozs7O1dBQTJEO1FBR3pELElBQUksQ0FBQyxxQkFBcUIsR0FBRyxxQkFBcUIsQ0FBQztRQUNuRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQsb0JBQW9CLENBQUMsaUJBQW9DO1FBQ3ZELE1BQU0sSUFBSSxHQUFHLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7UUFDN0MsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNyRCxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3hELE9BQU8saUJBQWlCLENBQUM7SUFDM0IsQ0FBQztJQUVELG9CQUFvQixDQUFDLElBQVk7UUFDL0IsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxxQkFBcUI7UUFDbkIsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVELHVCQUF1QixDQUFDLElBQVk7UUFDbEMsTUFBTSxpQkFB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