"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ActionThing_locales, _DialogThing_locales;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionThing = exports.ListThing = exports.StringThing = exports.NumberThing = exports.BooleanThing = exports.VoidThing = exports.NothingThing = exports.AnyThing = exports.TypeThing = exports.ArgumentsThing = exports.ArgumentThing = exports.DialogThing = exports.ActionThing = exports.FunctionThing = exports.ObjectThing = void 0;
const ask = __importStar(require("./ast"));
const ast_1 = require("./ast");
const type_1 = require("./type");
const visit_1 = require("./visit");
class BaseThing {
    constructor(checker, 
    /**
     * Unique token identifying this Thing.
     */
    token, 
    /**
     * Represents the Type of this Thing.
     */
    type, 
    /**
     * Optional `Apply` instance if this `Thing` is the result of a Call.
     */
    apply, 
    /**
     * The node that this Thing originates from.
     */
    origin, 
    /**
     * The parent of this THing, e.g. `person` in `person.name`.
     */
    parent, 
    /**
     * Location of this Thing in the Source Tree.
     */
    loc = origin === null || origin === void 0 ? void 0 : origin.loc, 
    /**
     * URI of the SourceFile of this Thing.
     */
    uri = origin === null || origin === void 0 ? void 0 : origin.uri) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: token
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "apply", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: apply
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parent
        });
        Object.defineProperty(this, "loc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: loc
        });
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uri
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Thing"
        });
        Object.defineProperty(this, "propertiesIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    get root() {
        if (this.parent === undefined) {
            return this;
        }
        return this.parent.root;
    }
    /**
     * Checks if this Thing is a literal value.
     */
    isLiteral() {
        return this.apply !== undefined && this.apply.isType();
    }
    /**
     * Get a new Thing representing this Thing refined to a more narrow type within a specific context.
     *
     * @returns the more narrowly typed thing.
     */
    cast(type, origin) {
        if (this.isAction()) {
            return new ActionThing(this.checker, this.token, type, this.origin);
        }
        if (this.isDialog()) {
            return new DialogThing(this.checker, this.token, type, this.origin);
        }
        if (type.isArgument()) {
            return new ArgumentThing(this.checker, this.token, type, undefined, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isArguments()) {
            return new ArgumentsThing(this.checker, this.token, type, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isObject()) {
            return new ObjectThing(this.checker, this.token, type, this.apply, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isList()) {
            return new ListThing(this.checker, this.token, type, this.apply, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isPrimitive()) {
            return type.getThing(this.token, origin !== null && origin !== void 0 ? origin : this.origin, this.parent, this.apply);
        }
        return type.getThing(this.token, origin !== null && origin !== void 0 ? origin : this.origin, this.parent, this.apply);
    }
    /**
     * Check if this Thing equals the {@link other} Thing. Equality is determined by the unique {@link Thing.token}
     * given to the Thing.
     *
     * @param other other thing to compare against this Thing.
     * @returns `true` if they are the exact same value, `false` otherwise.
     */
    equals(other) {
        return this.token === (other === null || other === void 0 ? void 0 : other.token);
    }
    /**
     * Helper method to compare if this {@link Thing} complies with some type-narrowing assertion, {@link f};
     * @param f function which narrows the type of this thing.
     * @returns `true` if the condition passes or `false` otherwise.
     */
    is(f) {
        return f(this);
    }
    /**
     * Casts this `Thing` to {@link T} if the condition {@link f} passes, otherwise returns `undefined`.
     *
     * @param f assertion function to apply to this Thing.
     * @returns casts this `Thing` to {@link T} if the condition {@link f} passes, otherwise returns `undefined`.
     */
    as(f) {
        return this.is(f) ? this : undefined;
    }
    /**
     * Checks if this is a {@link NothingThing} instance.
     */
    isNothing() {
        return this instanceof NothingThing;
    }
    /**
     * Checks if this is a {@link VoidThing} instance.
     */
    isVoid() {
        return this instanceof VoidThing;
    }
    /**
     * Checks if this is a {@link ObjectThing} instance.
     */
    isObject() {
        return this instanceof ObjectThing;
    }
    /**
     * Checks if this is a {@link AnyThing} instance.
     */
    isAny() {
        return this instanceof AnyThing;
    }
    /**
     * Checks if this is a {@link Primitive} instance.
     */
    isPrimitive() {
        return this instanceof PrimitiveThing;
    }
    /**
     * @returns a {@link Primitive} instance if this is one, otherwise `undefined`.
     */
    asPrimitive() {
        return this.isPrimitive() ? this : undefined;
    }
    /**
     * @returns a {@link StringThing} instance if this is one, otherwise `undefined`.
     */
    asString() {
        return this.isString() ? this : undefined;
    }
    /**
     * Checks if this is a {@link StringThing instance.
     */
    isString() {
        return this instanceof StringThing;
    }
    /**
     * @returns a {@link NumberThing} instance if this is one, otherwise `undefined`.
     */
    asNumber() {
        return this.isNumber() ? this : undefined;
    }
    isNumber() {
        return this instanceof NumberThing;
    }
    asBoolean() {
        return this.isBoolean() ? this : undefined;
    }
    isBoolean() {
        return this instanceof BooleanThing;
    }
    asList() {
        return this.isList() ? this : undefined;
    }
    isList() {
        return this instanceof ListThing;
    }
    asLiteralList() {
        return this.isList() && this.isLiteral() ? this : undefined;
    }
    isLiteralList() {
        return this.isLiteral() && this.isList();
    }
    isFunction() {
        return this instanceof FunctionThing;
    }
    asFunction() {
        return this.isFunction() ? this : undefined;
    }
    isAction() {
        return this instanceof ActionThing;
    }
    asAction() {
        return this.isAction() ? this : undefined;
    }
    isArgument() {
        return this instanceof ArgumentThing;
    }
    asArgument() {
        return this.isArgument() ? this : undefined;
    }
    isArguments() {
        return this instanceof ArgumentsThing;
    }
    asArguments() {
        return this.isArguments() ? this : undefined;
    }
    isDialog() {
        return this instanceof DialogThing;
    }
    asDialog() {
        return this.isDialog() ? this : undefined;
    }
    isUnion() {
        return this instanceof UnionThing;
    }
    getPropertiesList() {
        var _a;
        return Object.values((_a = this.getProperties()) !== null && _a !== void 0 ? _a : {});
    }
    /**
     * @returns an object where the keys are the names of arguments and the values are {@link Thing} instances
     * representing values within a simulation or abstract values during type checking.
     */
    getProperties() {
        if (this.isLiteral()) {
            const args = this.apply.getArguments();
            if (args !== undefined) {
                return Object.keys(args)
                    .map((propName) => ({
                    [propName]: this.getProperty(propName),
                }))
                    .reduce((a, b) => ({ ...a, ...b }), {});
            }
        }
        return undefined;
    }
    /**
     * If this {@link Thing} is an Object containing properties, or a {@link UnionThing} of many Object Types that
     * contain properties, then return a {@link Thing} representing that property. This interface applies in both the
     * abstract type-checking phase of the compiler as well as during evaluation of a Dialog {@link Flow}.
     *
     * @returns a {@link Thing} value representing the value of a property of "this" {@link Thing}. If this is not
     * an {@link ObjectThing} or the property does not exist, then `undefined` is returned.
     */
    getProperty(name) {
        var _a, _b, _c;
        if (this.propertiesIndex === undefined) {
            this.propertiesIndex = new Map();
        }
        const propertyName = typeof name === "string" ? name : name === null || name === void 0 ? void 0 : name.name;
        if (propertyName === undefined) {
            return undefined;
        }
        const propertyToken = `${this.token}[${propertyName}]`;
        if (this.isObject()) {
            let thing = this.propertiesIndex.get(propertyName);
            if (thing === undefined) {
                if (this.isLiteral()) {
                    thing = this.checker.getThing((_a = this.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue(propertyName), propertyToken);
                }
                else {
                    thing = (_b = this.type
                        .getPropertyType(propertyName)) === null || _b === void 0 ? void 0 : _b.getThing(propertyToken, typeof name === "string" ? undefined !== null && undefined !== void 0 ? undefined : new ask.Name(name) : name, this);
                    this.propertiesIndex.set(propertyName, thing !== null && thing !== void 0 ? thing : null);
                }
            }
            return thing !== null && thing !== void 0 ? thing : undefined;
        }
        if (this.isUnion()) {
            const things = this.things.map((thing) => { var _a; return (_a = thing.getProperty(name)) !== null && _a !== void 0 ? _a : this.checker.void.getThing(propertyToken, undefined); });
            const type = things
                .map((t) => { var _a; return (_a = t === null || t === void 0 ? void 0 : t.type) !== null && _a !== void 0 ? _a : this.checker.nothing; })
                .reduce((a, b) => { var _a; return (_a = a.union(b)) !== null && _a !== void 0 ? _a : this.checker.nothing; }, this.checker.nothing);
            return new UnionThing(this.checker, propertyToken, type, typeof name === "string" ? undefined : name, things);
        }
        if (this.isArgument()) {
            const thing = (_c = this.type.getPropertyType(propertyName)) === null || _c === void 0 ? void 0 : _c.getThing(propertyToken, undefined);
            this.propertiesIndex.set(propertyName, thing !== null && thing !== void 0 ? thing : null);
            return thing;
        }
        return undefined;
    }
    /**
     * If this is a {@link ListThing} or a {@link UnionThing} of many {@link ListThing} types, then return a {@link Thing}
     * representing the item at the specified {@link index} in the list.
     *
     * @param index the index of the item to access in the list. The index can either be a literal number or an abstract {@link NumberThing}
     * @param origin optional override of the node from which this {@link Thing} value originated from.
     * @returns a {@link Thing} representing the item if it exists or `undefined` otherwise.
     */
    getItem(index, origin) {
        var _a, _b, _c;
        const literal = typeof index === "number" ? index : typeof index.literal === "number" ? index.literal : index.token;
        const itemToken = `${this.token}[${literal}]`;
        if (this.isList()) {
            if (typeof literal === "number") {
                const item = this.checker.getThing((_b = (_a = this.apply) === null || _a === void 0 ? void 0 : _a.getListItems()) === null || _b === void 0 ? void 0 : _b[literal], itemToken);
                if (item) {
                    return item;
                }
            }
            return (_c = this.type.getListItemType()) === null || _c === void 0 ? void 0 : _c.getThing(itemToken, origin || (typeof index === "number" ? undefined : index.origin), this);
        }
        if (this.isUnion()) {
            const things = this.things.map((thing) => { var _a; return (_a = thing.getItem(index, origin)) !== null && _a !== void 0 ? _a : this.checker.void.getThing(itemToken, origin); });
            const type = things
                .map((t) => { var _a; return (_a = t === null || t === void 0 ? void 0 : t.type) !== null && _a !== void 0 ? _a : this.checker.nothing; })
                .reduce((a, b) => { var _a; return (_a = a.union(b)) !== null && _a !== void 0 ? _a : this.checker.nothing; }, this.checker.nothing);
            return new UnionThing(this.checker, itemToken, type, typeof index === "number" ? origin : index.origin, things);
        }
        return undefined;
    }
    /**
     * Find all locales this Base Thing support
     * The base thing depends on it's type to calculate locales
     *
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales() {
        return this.type.getLocales();
    }
}
/**
 * Base type of all Things that contain Properties.
 */
class ObjectThing extends BaseThing {
    /**
     * Checks if this is a literal Object or an abstract Object such as one received from an Event during simulation.
     */
    isLiteral() {
        var _a;
        return ((_a = this.apply) === null || _a === void 0 ? void 0 : _a.isType()) === true;
    }
}
exports.ObjectThing = ObjectThing;
/**
 * Represents a Function value within a Dialog Flow simulation.
 *
 * This class encapsulates the Tree and TypeChecker environment that contains this Function and provides
 * a friendly interface over it so that consumers such as {@link evaluateDialogFlow} are insulated from
 * the various mappings between abstract Function signatures and concrete Functions/Action/Dialogs passed
 * around during the simulation.
 */
class FunctionThing extends ObjectThing {
    constructor(checker, token, type, origin, abstractToConcreteArgumentNames) {
        super(checker, token, type, undefined, origin, undefined);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "abstractToConcreteArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: abstractToConcreteArgumentNames
        });
    }
    /**
     * Name of the Function.
     */
    get name() {
        var _a;
        return (_a = this.origin) === null || _a === void 0 ? void 0 : _a.name;
    }
    /**
     * Get this Function's properties. This function overrides the type of `Arguments<this>` so that we
     * can apply mappings between the argument names of the type signature and the argument names of
     * an action passed in as an argument to a dialog or stored on some variable.
     *
     * @param name property name
     * @returns a Thing value representing that property value.
     */
    getProperty(name) {
        const nameStr = typeof name === "string" ? name : name === null || name === void 0 ? void 0 : name.name;
        if (nameStr === "arguments" && this.abstractToConcreteArgumentNames !== undefined) {
            // the arguments type must have its properties mapped.
            return new ArgumentsThing(this.checker, `${this.token}[arguments]`, new type_1.Type(this.checker, this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Arguments), [this.type]), undefined, this);
        }
        return super.getProperty(name);
    }
    /**
     * Create a new FunctionThing where the argument names are mapped. Consumers will use the mapped interface
     * to supply or reference arguments. This is so that we can pass Functions around as arguments without
     * requiring the ArgumentDeclaration's signature have the same argument names.
     *
     * @param argumentNameMappings map of argument name to underlying argument name.
     * @returns a new copy of this Thing with mapped argument names.
     */
    withArgumentNameMappings(argumentNameMappings) {
        if (this.isAction()) {
            return new ActionThing(this.checker, this.token, this.type, this.origin, argumentNameMappings);
        }
        if (this.isDialog()) {
            return new DialogThing(this.checker, this.token, this.type, this.origin, argumentNameMappings);
        }
        return new FunctionThing(this.checker, this.token, this.type, this.origin, argumentNameMappings);
    }
}
exports.FunctionThing = FunctionThing;
/**
 * Represents an Action value within a Dialog Flow simulation.
 */
class ActionThing extends FunctionThing {
    constructor(checker, token, type, origin, abstractToConcreteArgumentNames) {
        super(checker, token, type, origin, abstractToConcreteArgumentNames);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "abstractToConcreteArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: abstractToConcreteArgumentNames
        });
        Object.defineProperty(this, "concreteToAbstractArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _ActionThing_locales.set(this, void 0);
        if (abstractToConcreteArgumentNames) {
            this.concreteToAbstractArgumentNames = {};
            for (const abstractArgumentName in abstractToConcreteArgumentNames) {
                // create a reverse lookup from the abstract action signature to a concrete action instance
                this.concreteToAbstractArgumentNames[abstractToConcreteArgumentNames[abstractArgumentName]] = abstractArgumentName;
            }
        }
    }
    /**
     * Name of the Action referenced by this Thing.
     */
    get actionName() {
        var _a;
        return (_a = this.name) === null || _a === void 0 ? void 0 : _a.name;
    }
    getArguments() {
        var _a;
        return (_a = this.getProperty("arguments")) === null || _a === void 0 ? void 0 : _a.asArguments();
    }
    /**
     * Get a named Argument from this Action.
     *
     * @param name name of the argument
     * @returns the Argument
     */
    getArgument(name) {
        var _a, _b;
        return (_b = (_a = this.getArguments()) === null || _a === void 0 ? void 0 : _a.getProperty(name)) === null || _b === void 0 ? void 0 : _b.asArgument();
    }
    /**
     * calculate the locales for the action
     * first collect all the type associated with this action (return type, generic type, property type)
     * find the locales supported by all the types
     * @returns
     */
    getLocales() {
        var _a, _b, _c;
        if (__classPrivateFieldGet(this, _ActionThing_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _ActionThing_locales, "f");
        }
        const types = [];
        const returnType = ((_a = this.origin) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" ? this.checker.getType((_b = this === null || this === void 0 ? void 0 : this.origin) === null || _b === void 0 ? void 0 : _b.returnType) : undefined;
        // add return type
        if (returnType) {
            types.push(returnType);
        }
        // add property type
        (_c = this.origin.arguments) === null || _c === void 0 ? void 0 : _c.forEach((argDecl) => {
            const propertyType = this.checker.getType(argDecl);
            if (propertyType) {
                if (propertyType.isFunction()) {
                    const functionReturnType = propertyType.getFunctionReturnType();
                    const argumentTypes = propertyType.getFunctionArgumentTypes();
                    if (functionReturnType) {
                        types.push(functionReturnType);
                    }
                    if (argumentTypes) {
                        types.push(...argumentTypes);
                    }
                }
                else {
                    types.push(propertyType);
                }
            }
        });
        // find the locales supported by all types
        let locales;
        for (const type of types) {
            const typeLocales = type.getLocales();
            if (typeLocales) {
                if (locales === undefined) {
                    locales = [...typeLocales];
                }
                else {
                    locales = locales.filter((locale) => typeLocales.includes(locale));
                }
            }
        }
        __classPrivateFieldSet(this, _ActionThing_locales, locales, "f");
        return __classPrivateFieldGet(this, _ActionThing_locales, "f");
    }
}
exports.ActionThing = ActionThing;
_ActionThing_locales = new WeakMap();
/**
 * Represents a Dialog value within a Dialog Flow simulation.
 */
class DialogThing extends FunctionThing {
    constructor(checker, token, type, origin, abstractToConcreteArgumentNames) {
        super(checker, token, type, origin, abstractToConcreteArgumentNames);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "abstractToConcreteArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: abstractToConcreteArgumentNames
        });
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _DialogThing_locales.set(this, void 0);
    }
    /**
     * calculate the locales for the dialog
     * first collect all the type associated with this dialog (return type, generic type, property type)
     * find the locales supported by all the types
     * @returns
     */
    getLocales() {
        var _a, _b, _c, _d;
        if (__classPrivateFieldGet(this, _DialogThing_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _DialogThing_locales, "f");
        }
        const types = [];
        const { checker } = this;
        const returnType = ((_a = this.origin) === null || _a === void 0 ? void 0 : _a.kind) === "DialogDeclaration" ? this.checker.getType((_b = this === null || this === void 0 ? void 0 : this.origin) === null || _b === void 0 ? void 0 : _b.returnType) : undefined;
        // add return type
        if (returnType) {
            types.push(returnType);
        }
        // add property type
        (_c = this.origin.arguments) === null || _c === void 0 ? void 0 : _c.forEach((argDecl) => {
            const propertyType = this.checker.getType(argDecl);
            if (propertyType) {
                if (propertyType.isFunction()) {
                    const functionReturnType = propertyType.getFunctionReturnType();
                    const argumentTypes = propertyType.getFunctionArgumentTypes();
                    if (functionReturnType)
                        types.push(functionReturnType);
                    if (argumentTypes)
                        types.push(...argumentTypes);
                }
                else {
                    types.push(propertyType);
                }
            }
        });
        // find the locales supported by all types
        let locales;
        for (const type of types) {
            const typeLocales = type.getLocales();
            if (typeLocales) {
                if (locales === undefined) {
                    locales = [...typeLocales];
                }
                else {
                    locales = locales.filter((locale) => typeLocales.includes(locale));
                }
            }
        }
        (_d = this.origin.samples) === null || _d === void 0 ? void 0 : _d.forEach((sample) => {
            (0, visit_1.visitEachChild)(sample, function updateLocales(node) {
                if (node.kind === "NameReference" || node.kind === "PropertyReference") {
                    const usedLocales = checker.collectLocaleInfo(node);
                    if (usedLocales.length > 0) {
                        if (locales === undefined) {
                            locales = [...usedLocales];
                        }
                        else {
                            locales = locales.filter((locale) => usedLocales.includes(locale));
                        }
                    }
                }
                else if (node.kind === "Call") {
                    const apply = checker.getApply(node);
                    const decl = apply === null || apply === void 0 ? void 0 : apply.decl;
                    if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration" || (decl === null || decl === void 0 ? void 0 : decl.kind) === "DialogDeclaration") {
                        const thing = checker.getThing(decl);
                        if (((thing === null || thing === void 0 ? void 0 : thing.isAction()) && (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi())) || (thing === null || thing === void 0 ? void 0 : thing.isDialog())) {
                            const usedLocales = thing.getLocales();
                            if (usedLocales) {
                                if (locales === undefined) {
                                    locales = [...usedLocales];
                                }
                                else {
                                    locales = locales.filter((locale) => usedLocales.includes(locale));
                                }
                            }
                        }
                    }
                    else if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "Type") {
                        const usedLocales = decl.getLocales();
                        if (usedLocales) {
                            if (locales === undefined) {
                                locales = [...usedLocales];
                            }
                            else {
                                locales = locales.filter((locale) => usedLocales.includes(locale));
                            }
                        }
                    }
                }
                (0, visit_1.visitEachChild)(node, updateLocales);
            });
        });
        __classPrivateFieldSet(this, _DialogThing_locales, locales, "f");
        return __classPrivateFieldGet(this, _DialogThing_locales, "f");
    }
}
exports.DialogThing = DialogThing;
_DialogThing_locales = new WeakMap();
class ArgumentThing extends BaseThing {
    get action() {
        var _a, _b;
        return ((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction()) ? this.parent.parent : undefined;
    }
    getReferencedActionArgumentTypeInformation() {
        var _a, _b, _c;
        const referenceInfo = this.getReferencedActionArgumentPropertyReferenceInformation();
        if (!referenceInfo) {
            return undefined;
        }
        const { declaration: actionDeclaration, argumentName, argumentPathSegments } = referenceInfo;
        const argumentDeclaration = (_a = actionDeclaration.arguments) === null || _a === void 0 ? void 0 : _a.find((argDecl) => { var _a; return ((_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name) === argumentName; });
        if (!(argumentDeclaration === null || argumentDeclaration === void 0 ? void 0 : argumentDeclaration.type) || !argumentPathSegments) {
            return undefined;
        }
        let currentType = this.checker.getType(argumentDeclaration.type);
        for (let i = 1; i < argumentPathSegments.length && currentType; i++) {
            const argumentPathSegment = argumentPathSegments[i];
            currentType = (_b = currentType.getPropertyMap().get(argumentPathSegment)) === null || _b === void 0 ? void 0 : _b.type;
        }
        return { argumentName, actionName: (_c = actionDeclaration.name) === null || _c === void 0 ? void 0 : _c.name, type: currentType };
    }
    /**
     * If the argument references an argument to another action
     * @returns
     * If the argument value is a property reference rooted in an API call (like getPizza.arguments.pizzaOrder.pizzaType)
     * returns an object with 4 properties:
     *    declaration has the declaration of the API (getPizza's declaration)
     *    argumentName has the name of the argument in the api ("pizzaOrder")
     *    argumentPath has the property path starting at the argument name ("pizzaOrder.pizzaType")
     *    argumentPAthSegments has ["pzzaOrder", "pizzaType"]
     */
    getReferencedActionArgumentPropertyReferenceInformation() {
        var _a, _b, _c, _d, _e;
        const argumentPathSegments = [];
        let argumentName;
        let actionDeclaration;
        // There are two main cases to get a referenced argument information
        if (((_b = (_a = this.origin) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
            // The first case is when the reference is from a PropertyReference like getWeather.arguments.city.name.
            // this.action will be null in this case and in order to find the information we have to...
            let currentExpression = this.origin.context;
            // Loop through the expressions
            while (currentExpression) {
                // untill we find a thing which is an ActionDeclaration
                const expressionThing = this.checker.getThing(currentExpression);
                if (((_c = expressionThing === null || expressionThing === void 0 ? void 0 : expressionThing.origin) === null || _c === void 0 ? void 0 : _c.kind) !== "ActionDeclaration") {
                    argumentPathSegments.push((_e = (_d = currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.name) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : "");
                    currentExpression = (currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.kind) === "PropertyReference" ? currentExpression.expression : undefined;
                    continue;
                }
                // When we find the action declaration, the previous property was "arguments" and one property before that
                // was the argument name
                if (argumentPathSegments.length < 2 || argumentPathSegments[argumentPathSegments.length - 1] !== "arguments") {
                    return undefined;
                }
                else {
                    argumentName = argumentPathSegments[argumentPathSegments.length - 2];
                    actionDeclaration = expressionThing.origin;
                    argumentPathSegments.reverse();
                    // remove "arguments"
                    argumentPathSegments.splice(0, 1);
                    break;
                }
            }
        }
        else if (this.action) {
            // The second case is for something like getWeather.arguments.CityName where this.action is defined
            actionDeclaration = this.action.origin;
            // in this case the argument will be in argumentName
            if (this.argumentName) {
                argumentName = this.argumentName;
                argumentPathSegments.push(argumentName);
            }
        }
        if (!actionDeclaration || !argumentName) {
            return undefined;
        }
        return {
            declaration: actionDeclaration,
            argumentName,
            argumentPathSegments,
            argumentPath: argumentPathSegments.join("."),
        };
    }
    getReferencedActionArgumentPropertyReferenceInformationOld() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (((_b = (_a = this.origin) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.kind) !== "PropertyReference") {
            return undefined;
        }
        const expressions = [];
        let currentExpression = this.origin.context;
        while ((currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.kind) === "PropertyReference") {
            expressions.push(currentExpression);
            currentExpression = currentExpression.expression;
        }
        expressions.reverse();
        if (expressions.length < 2 || (currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.kind) !== "NameReference" || ((_d = (_c = expressions[0]) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) !== "arguments") {
            return undefined;
        }
        const nameReferenceThing = this.checker.getThing(currentExpression);
        if (((_e = nameReferenceThing === null || nameReferenceThing === void 0 ? void 0 : nameReferenceThing.origin) === null || _e === void 0 ? void 0 : _e.kind) !== "ActionDeclaration") {
            return undefined;
        }
        return {
            declaration: nameReferenceThing.origin,
            argumentName: (_g = (_f = expressions[1].name) === null || _f === void 0 ? void 0 : _f.name) !== null && _g !== void 0 ? _g : "",
            argumentPathSegments: expressions.map((e) => { var _a, _b; return (_b = (_a = e.name) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : ""; }),
            argumentPath: expressions
                .slice(1)
                .map((x) => { var _a, _b; return (_b = (_a = x.name) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : ""; })
                .join("."),
        };
    }
    /**
     * An argument might reference an action argument when it uses something like getPizza.arguments.
     * This method returns the declaration for that action (like getPizza's declaration). There are two cases:
     *   1) argument references a "non object" action argument as in getPizza.arguments.pizzaType where pizzaType is of slot type PizzaType
     *   2) argument references an object action argument as in getPizza.arguments.pizzaOrder.pizzaType where pizzaOrder is
     *   of type PizzaOrder. The PizzaOrder type has a pizzaType property of slot type PizzaType
     * For case 1 the declaration is in action.origin.
     * For case 2 the declaration name is in the property reference and it needs to be lookedUp which is done in
     * this.getPropertyReferenceToAPIInformation
     * If the argument does not reference an action argument, this returns undefined
     * @returns the declaration of action referenced in argument
     */
    getReferencedActionArgumentActionDeclaration() {
        var _a;
        return (_a = this.getReferencedActionArgumentPropertyReferenceInformation()) === null || _a === void 0 ? void 0 : _a.declaration;
    }
    /**
     * If an argument references an action argument returns the property path to that argument
     */
    getReferencedActionArgumentPath() {
        var _a;
        return (_a = this.getReferencedActionArgumentPropertyReferenceInformation()) === null || _a === void 0 ? void 0 : _a.argumentPath;
    }
    get argumentName() {
        var _a;
        return ((_a = this.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name" ? this.origin.name : undefined;
    }
    get isOptional() {
        var _a, _b;
        return (_b = this.checker.root.getType((_a = this.origin) === null || _a === void 0 ? void 0 : _a.context)) === null || _b === void 0 ? void 0 : _b.isOptional();
    }
    /**
     * If an argument references an action argument returns the declaration for that action argument
     */
    getReferencedActionArgumentDeclaration() {
        var _a;
        const propertyReferenceInformation = this.getReferencedActionArgumentPropertyReferenceInformation();
        if (!propertyReferenceInformation) {
            return undefined;
        }
        return (_a = propertyReferenceInformation.declaration.arguments) === null || _a === void 0 ? void 0 : _a.find((argDecl) => { var _a; return ((_a = argDecl.name) === null || _a === void 0 ? void 0 : _a.name) === propertyReferenceInformation.argumentName; });
    }
}
exports.ArgumentThing = ArgumentThing;
class ArgumentsThing extends ObjectThing {
    constructor(checker, token, type, origin, parent) {
        super(checker, token, type, undefined, origin, parent);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parent
        });
    }
    getArgumentsList() {
        var _a, _b, _c, _d, _e;
        if (((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.origin) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_d = (_c = this.parent) === null || _c === void 0 ? void 0 : _c.origin) === null || _d === void 0 ? void 0 : _d.kind) === "DialogDeclaration") {
            return (_e = this.parent.origin.arguments) === null || _e === void 0 ? void 0 : _e.map((arg) => { var _a, _b; return (_b = super.getProperty((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name)) === null || _b === void 0 ? void 0 : _b.asArgument(); });
        }
        return undefined;
    }
    getProperty(name) {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = this.parent) === null || _a === void 0 ? void 0 : _a.abstractToConcreteArgumentNames) !== undefined) {
            const nameStr = typeof name === "string" ? name : name === null || name === void 0 ? void 0 : name.name;
            if (nameStr !== undefined) {
                return (_e = super.getProperty((_d = (_c = (_b = this.parent) === null || _b === void 0 ? void 0 : _b.abstractToConcreteArgumentNames) === null || _c === void 0 ? void 0 : _c[nameStr]) !== null && _d !== void 0 ? _d : nameStr)) === null || _e === void 0 ? void 0 : _e.asArgument();
            }
        }
        return (_f = super.getProperty(name)) === null || _f === void 0 ? void 0 : _f.asArgument();
    }
}
exports.ArgumentsThing = ArgumentsThing;
class TypeThing extends ObjectThing {
    constructor(checker, token, type, origin) {
        super(checker, token, type, undefined, origin, undefined);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
    }
}
exports.TypeThing = TypeThing;
class PrimitiveThing extends BaseThing {
    /**
     * The literal data value of this primitive thing (if it is specified).
     *
     * If this is an abstract thing, such as the result of an event, then `undefined` is returned.
     */
    get literal() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const lit = ((_a = this.type) === null || _a === void 0 ? void 0 : _a.isBoolean()) && typeof ((_b = this.apply) === null || _b === void 0 ? void 0 : _b.call.arguments) === "boolean"
            ? (_c = this.apply) === null || _c === void 0 ? void 0 : _c.call.arguments
            : ((_d = this.type) === null || _d === void 0 ? void 0 : _d.isStringLike()) && typeof ((_e = this.apply) === null || _e === void 0 ? void 0 : _e.call.arguments) === "string"
                ? this.apply.call.arguments
                : ((_f = this.type) === null || _f === void 0 ? void 0 : _f.isNumber()) && typeof ((_g = this.apply) === null || _g === void 0 ? void 0 : _g.call.arguments) === "number"
                    ? this.apply.call.arguments
                    : ((_h = this.type) === null || _h === void 0 ? void 0 : _h.isVoid()) && ((_j = this.apply) === null || _j === void 0 ? void 0 : _j.call.arguments) === null
                        ? null
                        : ((_k = this.type) === null || _k === void 0 ? void 0 : _k.isNothing()) && ((_l = this.apply) === null || _l === void 0 ? void 0 : _l.call.arguments) === null
                            ? null
                            : undefined;
        return lit;
    }
    isLiteral() {
        var _a;
        if ((_a = this.apply) === null || _a === void 0 ? void 0 : _a.isType()) {
            const args = this.apply.call.arguments;
            return args === null || typeof args === "boolean" || typeof args === "string" || typeof args === "number" || Array.isArray(args);
        }
        return false;
    }
}
class AnyThing extends BaseThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.AnyThing = AnyThing;
class NothingThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.NothingThing = NothingThing;
class VoidThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.VoidThing = VoidThing;
class BooleanThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.BooleanThing = BooleanThing;
class NumberThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.NumberThing = NumberThing;
class StringThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.StringThing = StringThing;
class ListThing extends PrimitiveThing {
    isLiteral() {
        var _a;
        return ask.isListLiteral((_a = this.apply) === null || _a === void 0 ? void 0 : _a.call.arguments);
    }
    getItems() {
        var _a;
        if (this.isLiteral()) {
            return (_a = this.apply) === null || _a === void 0 ? void 0 : _a.call.arguments.items.map((item) => this.checker.getThing(item, undefined, item));
        }
        return undefined;
    }
    getListItems() {
        var _a;
        if (this.isLiteral()) {
            return (_a = this.apply) === null || _a === void 0 ? void 0 : _a.call.arguments.items;
        }
        return undefined;
    }
}
exports.ListThing = ListThing;
/**
 * TODO: remove this class
 */
class UnionThing extends BaseThing {
    constructor(checker, token, type, origin, 
    /**
     *
     */
    things) {
        super(checker, token, type, undefined, origin, undefined);
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "things", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: things
        });
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Union"
        });
    }
}
exports.UnionThing = UnionThing;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGhpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFDN0IsK0JBQWtGO0FBS2xGLGlDQUE0QjtBQUM1QixtQ0FBdUM7QUFpRHZDLE1BQU0sU0FBUztJQUtiLFlBQ1csT0FBb0I7SUFDN0I7O09BRUc7SUFDTSxLQUFZO0lBQ3JCOztPQUVHO0lBQ00sSUFBVTtJQUNuQjs7T0FFRztJQUNNLEtBQXdCO0lBQ2pDOztPQUVHO0lBQ00sTUFBNEI7SUFDckM7O09BRUc7SUFDTSxNQUF5QjtJQUNsQzs7T0FFRztJQUNNLE1BQXNDLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxHQUFHO0lBQzFEOztPQUVHO0lBQ00sTUFBMEIsTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLEdBQUc7Ozs7O21CQTVCckM7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7UUFqQ1g7Ozs7bUJBQXlCLE9BQU87V0FBQztRQUVqQzs7Ozs7V0FBK0Q7SUFnQzVELENBQUM7SUFFSixJQUFXLElBQUk7UUFDYixJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQzdCLE9BQU8sSUFBVyxDQUFDO1NBQ3BCO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztJQUMxQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxTQUFTO1FBR2QsT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ3pELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksSUFBSSxDQUFDLElBQVUsRUFBRSxNQUFpQjtRQUN2QyxJQUFJLElBQUks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