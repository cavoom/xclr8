"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Flow = void 0;
const immutable_1 = __importDefault(require("immutable"));
const ask = __importStar(require("./ast"));
const checker_1 = require("./checker");
const thing_1 = require("./thing");
const expression_1 = require("./expression");
const apply_1 = require("./apply");
class Flow {
    constructor(
    /**
     * Type Checker environment for this branch.
     */
    checker, 
    /**
     * The next expression in this branch sequence.
     */
    expression, 
    /**
     * Branch before this node.
     */
    prev, 
    /**
     * Node to continue the branch from
     */
    stack, 
    /**
     * Map of node to resolved Thing at this point in the branch.
     */
    things = immutable_1.default.Map(), 
    /**
     * Maps a TypeParameter to its concrete Type.
     */
    types = immutable_1.default.Map()) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "expression", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: expression
        });
        Object.defineProperty(this, "prev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: prev
        });
        Object.defineProperty(this, "stack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: stack
        });
        Object.defineProperty(this, "things", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: things
        });
        Object.defineProperty(this, "types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types
        });
    }
    /**
     * This function will walk over each dialog flow, parse each ASKIR {@link ask.Expression} into a
     * high-level {@link Expression} class and call the provided call back.
     *
     * Those Expressions represent concepts like {@link Expect}, {@link InvokeApi}, {@link ConditionalBranch}, {@link DialogExpansion}, etc.
     *
     * The most basic usage:
     * ```
     * flow.interpret(function interpret(expr): InterpretResult<boolean> {
     *   // process this expression in the stream
     *   const result = process(expr);
     *   if (result !== undefined) {
     *      // terminate the interpreter and end with this result
     *      return result;
     *   }
     *   // return a callback to handle the next expression after this one in the stream.
     *   return interpret;
     * })
     * ``
     *
     * Usually, you want to track some state. Do this with recursive closures. Below,
     * we track a variable, `seenEvent`, which we'll set to true if we come across an Expect event.
     *
     * At the end of the Dialog Flow stream, we'll return this value.
     * ```
     * get a list of booleans indicating if each branch in this Dialog Flow contains an Expect event.
     * const seenEvents = flow.interpret(function interpret(expr, seenEvent = false) {
     *   if (expr.isExpect()) {
     *     // if we receive an Expect event, we'll return a closure that sets the seenEvent variable to `true`.
     *     return (nextExpr) => interpret(nextExpr, true)
     *   } else if (expr.isEnd()) {
     *     // at the end, we'll return the result
     *     return seenEvent;
     *   } else {
     *     // otherwise, recursively process the next expression and pass along the `seenEvent` state.
     *     return (nextExpr) => interpret(nextExpr, seenEvent);
     *   }
     * })
     *
     * if (seenEvents.find(seenEvent => seenEvent === true) {
     *   // all
     * }
     * ```
     *
     * @param interpreter callback function to interpret the next Expression and return a
     * @param prev the previous Expression seen in this interpreter stream.
     * @returns a list of {@link State} objects, one for each branch in the Dialog Flow stream.
     */
    interpret(interpreter, prev) {
        return this.walkEachBranch((flow) => {
            const expr = getExpression();
            if (expr !== undefined) {
                const next = interpreter(expr);
                if (typeof next === "function") {
                    return flow.interpret(next, expr);
                }
                return [next];
            }
            // this node does not define an expression that should be evaluated, so we skip to the next one.
            return flow.interpret(interpreter, prev);
            function getExpression() {
                var _a, _b, _c, _d, _e, _f;
                if (flow.expression === undefined) {
                    return new expression_1.End(prev, flow);
                }
                if (flow.expression.kind === "Condition") {
                    return new expression_1.ConditionalBranch(prev, flow, flow.checker.getThing(flow.expression.when));
                }
                if (flow.expression.kind === "Call") {
                    const apply = flow.checker.getApply(flow.expression);
                    if (apply === undefined) {
                        return undefined;
                    }
                    if (apply.isResponse()) {
                        return new expression_1.Response(prev, flow, apply, apply.getArgumentValueThing("response"), apply.getArgumentValueThing("act"), apply.getArgumentValueThing("nextAct"), apply.getArgumentValueThing("payload"), (_a = apply.getArgumentValueThing("surfaceForm")) === null || _a === void 0 ? void 0 : _a.asString());
                    }
                    if (apply.isConfirmAction()) {
                        return new expression_1.ConfirmAction(prev, flow, apply.getArgumentValueThing("response"), (_b = apply.getArgumentValueThing("actionName")) === null || _b === void 0 ? void 0 : _b.asAction(), apply.getArgumentValueThing("payload"));
                    }
                    if (apply.isConfirmArgs()) {
                        return new expression_1.ConfirmArgs(prev, flow, (_c = apply.getArgumentValueThing("confirmArgs")) === null || _c === void 0 ? void 0 : _c.asList());
                    }
                    if (apply.isEnsure()) {
                        return new expression_1.Ensure(prev, flow, (_d = apply.getArgumentValueThing("requestArgs")) === null || _d === void 0 ? void 0 : _d.asList());
                    }
                    if (apply.isExpect()) {
                        return new expression_1.Expect(prev, flow, apply.getArgumentValueThing("act"), apply.getArgumentValueThing("event"));
                    }
                    if (apply.isDelegateRequest()) {
                        return new expression_1.DelegateRequest(prev, flow, apply, apply.getArgumentValueThing("updatedRequest"));
                    }
                    if (apply.isDelegateToIntent()) {
                        return new expression_1.DelegateToIntent(prev, flow, apply, apply.getArgumentValueThing("intent"), apply.getArgumentValueThing("slots"));
                    }
                    if (apply.isUserDefinedApi()) {
                        const action = (_e = flow.checker.getThing(flow.checker.lookupCallDeclaration(apply.call))) === null || _e === void 0 ? void 0 : _e.asAction();
                        return new expression_1.InvokeApi(prev, flow, action, apply.getArgumentsThing());
                    }
                    if (apply.isDialog()) {
                        const dialog = (_f = flow.checker.getThing(flow.checker.lookupCallDeclaration(apply.call))) === null || _f === void 0 ? void 0 : _f.asDialog();
                        return new expression_1.DialogExpansion(prev, flow, dialog, apply.getArgumentsThing());
                    }
                }
                else if (flow.expression.kind === "Block") {
                    return new expression_1.BlockExpression(prev, flow);
                }
                return undefined;
            }
        });
    }
    /**
     * Push a Call or Condition node onto the Call Stack.
     *
     * @param node Call or Condition node to push onto the STack.
     * @returns a new Dialog Flow representing the environment within the Call or Condition
     */
    push(node) {
        return new Flow(this.checker, node, this, [node, ...this.stack], this.things);
    }
    /**
     * Steps to the next {@link expr} in the Dialog Flow.
     *
     * @param expr next expression in the flow
     * @returns a new Flow starting from the next {@link expr}
     */
    step(expr) {
        return new Flow(this.checker, expr, this, this.stack, expr ? this.things.set(expr, this.checker.getThing(expr)) : this.things);
    }
    /**
     * Walks back up the Stack to create a Flow continuing with the return value and next expression.
     *
     * @param returnValue the value returned from this Frame
     * @return Flow a new Data Flow reprsenting the continuation of this Flow after returning the value.
     */
    pop(returnValue) {
        var _a, _b;
        let { things } = this;
        let next;
        let stack;
        const checker = new checker_1.TypeChecker(this.checker.project, this.checker, this.things, this.types);
        // this code walks up the list of nodes in the call stack and sets the Thing value of each node to the `returnValue`,
        // it is implemented as low-level for and while loops to minimize stack frame allocation as this function is often called within
        // the highly recursive environment of Flow.interpret and Flow.walkEachBranch.
        for (let i = 0; i < this.stack.length; i++) {
            let frameNode = this.stack[i];
            let thing = returnValue;
            if (hasFunctions(returnValue)) {
                // if the returnValue's type contains Function definitions, we need to map the actual Function value's interface
                // to the interface expected by this environment
                thing = (_a = mapInterface(checker, returnValue, this.checker.root.getType(frameNode))) !== null && _a !== void 0 ? _a : thing;
            }
            checker.localThingIndex.set(frameNode, thing);
            things = things.set(frameNode, thing);
            if (frameNode !== undefined) {
                next = frameNode.next;
                if (next === undefined) {
                    // there was no adjacent expression, we will now walk up the context tree
                    // if we encounter a Block, then we break out of the loop and continue unrolling the stack (encountering a Block in the context should trigger a RETURN)
                    while (frameNode !== undefined && frameNode.kind !== "Block") {
                        if (frameNode.kind === "PropertyReference") {
                            // encountered a property reference, extract the property
                            // e.g, DialogCall().prop
                            thing = thing.getProperty(frameNode.name);
                        }
                        else if (frameNode.kind === "Call") {
                            const apply = this.checker.getApply(frameNode);
                            if (apply === null || apply === void 0 ? void 0 : apply.isGetListItem()) {
                                // we encountered a list index, e.g, DialogCall()[0], extract the item from the returned list
                                const index = (_b = apply.getArgumentValueThing("index")) === null || _b === void 0 ? void 0 : _b.asNumber();
                                if (index) {
                                    thing = thing.getItem(index);
                                }
                            }
                        }
                        // overwrite the mapping of Node->Thing in this environment
                        checker.localThingIndex.set(frameNode, thing);
                        things = things.set(frameNode, thing);
                        if (frameNode.next) {
                            // after un-rolling the stack, we found an adjacent node in a Block, we should stop unrolling here
                            next = frameNode.next;
                            break;
                        }
                        frameNode = frameNode.context;
                    }
                }
                if (next !== undefined) {
                    // pop the frames off of the stack.
                    stack = this.stack.slice(i + 1);
                    break;
                }
            }
        }
        return new Flow(checker, next, this, stack !== null && stack !== void 0 ? stack : [], things);
    }
    /**
     * Fork this Dialog Flow into a new dialog flow, starting from this {@link expr}.
     * @param expr expression from which we need to fork the dialog, e.g. a Call to a Dialog or Condition branch.
     * @returns a new Flow starting with the first expression in the forked Dialog Flow.
     */
    fork(expr) {
        var _a, _b, _c, _d;
        if (expr.kind === "Call") {
            const apply = this.checker.getApply(expr);
            if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
                const args = apply.getArguments();
                const genericArgs = apply.getGenericArguments();
                const decl = apply.decl.kind === "DialogDeclaration" ? apply.decl : apply.decl.declaration;
                // resolve the generic arguments and map the TypeParameter nodes to the concrete types
                const types = (_b = (_a = decl.genericArguments) === null || _a === void 0 ? void 0 : _a.map((typeParameter, i) => { var _a; return immutable_1.default.Map([[typeParameter, (_a = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs[i]) !== null && _a !== void 0 ? _a : null]]); }).reduce((a, b) => a.merge(b), this.types)) !== null && _b !== void 0 ? _b : immutable_1.default.Map();
                const checker = new checker_1.TypeChecker(this.checker.project, this.checker, this.things, types);
                // plumb the arguments through from the previous frame.
                const things = (_d = (_c = decl.arguments) === null || _c === void 0 ? void 0 : _c.map((arg) => {
                    var _a, _b, _c, _d;
                    let thing;
                    if (((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) && (args === null || args === void 0 ? void 0 : args[(_b = arg.name) === null || _b === void 0 ? void 0 : _b.name])) {
                        thing = apply.getArgumentValueThing(arg.name.name);
                    }
                    else if (((_c = arg.name) === null || _c === void 0 ? void 0 : _c.name) && arg.defaultExpression) {
                        thing = this.checker.root.getThing(arg.defaultExpression);
                    }
                    if (hasFunctions(thing)) {
                        // if the argument's type contains Function definitions, we need to map the actual Function value's interface
                        // to the interface expected by this environment
                        thing = (_d = mapInterface(checker, thing, this.checker.root.getType(arg))) !== null && _d !== void 0 ? _d : thing;
                    }
                    // HACK: mutate the localThingIndex of Node->Thing in the next TypeChecker environment
                    checker.localThingIndex.set(arg, thing);
                    return immutable_1.default.Map().set(arg, thing !== null && thing !== void 0 ? thing : null);
                }).reduce((a, b) => a.merge(b), this.things)) !== null && _d !== void 0 ? _d : this.things;
                return new Flow(checker, decl, this, this.stack, things, types);
            }
        }
        return new Flow(new checker_1.TypeChecker(this.checker.project, this.checker, this.things, this.types), expr, this, this.stack, this.things, this.types);
    }
    visitPrevious(hook) {
        if (this.prev) {
            return hook(this.prev);
        }
        return hook(undefined);
    }
    walkEachBranch(hook) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        let node = this.expression;
        if (node === undefined) {
            return hook(this);
        }
        if (node.kind === "DialogDeclaration") {
            return (_b = (_a = node.samples) === null || _a === void 0 ? void 0 : _a.map((sample) => hook(this.step(sample))).reduce((a, b) => a.concat(b), [])) !== null && _b !== void 0 ? _b : [];
        }
        if (node.kind === "NameDeclaration") {
            if (node.expression) {
                return hook(this.step(node.expression));
            }
        }
        else if (node.kind === "Sample") {
            return hook(this.step(node.scope));
        }
        else if (node.kind === "Block") {
            if ((_c = node.expressions) === null || _c === void 0 ? void 0 : _c[0]) {
                return hook(this.step((_d = node.expressions) === null || _d === void 0 ? void 0 : _d[0]));
            }
        }
        else if (node.kind === "Condition") {
            if (((_f = (_e = node.then) === null || _e === void 0 ? void 0 : _e.expressions) === null || _f === void 0 ? void 0 : _f.length) && ((_h = (_g = node.else) === null || _g === void 0 ? void 0 : _g.expressions) === null || _h === void 0 ? void 0 : _h.length)) {
                return [
                    //
                    ...hook(this.push(node).fork(node.then)),
                    ...hook(this.push(node).fork(node.else)),
                ];
            }
            if ((_k = (_j = node.then) === null || _j === void 0 ? void 0 : _j.expressions) === null || _k === void 0 ? void 0 : _k.length) {
                return hook(this.push(node).step(node.then));
            }
            if ((_m = (_l = node.else) === null || _l === void 0 ? void 0 : _l.expressions) === null || _m === void 0 ? void 0 : _m.length) {
                return hook(this.push(node).step(node.else));
            }
        }
        else if (node.kind === "Call") {
            const apply = this.checker.getApply(node);
            if (apply !== undefined) {
                if (apply.isDialog()) {
                    return this.push(node).fork(node).walkEachBranch(hook);
                }
                if (apply.isGetListItem()) {
                    return hook(this.step(apply.getArgumentValue("list")));
                }
            }
        }
        else if (node.kind === "PropertyReference") {
            return hook(this.step(node.expression));
        }
        while (node !== undefined) {
            if (node.next) {
                return hook(this.step(node.next));
            }
            if (node.kind === "Block") {
                return hook(this.pop(this.checker.getThing(node)));
            }
            node = node.context;
        }
        return [];
    }
    /**
     * Returns true if the resetArgumentsAction resets the argument with value argValueThing. Returns false otherwise.
     * Example of false return:
     * ```
     * policies = [ResetArguments{arguments = [getWeather.arguments.cityName]}] //only reset cityName
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   getWeather(weatherRequest.cityName) // weatherRequest.cityName is reset
     * }
     * ```
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   people = expect(Invoke, getPeopleEvent)
     *   getWeather(weatherRequest.cityName, weatherRequest.date)
     *
     *   getWeather(weatherRequest.cityName, weatherRequest.date) // invalid since weatherRequest.cityName has been reset
     * }
     * ```
     * @param argValueThing 'Thing' object for the argument value we are validating
     * @param argumentActionName action name for the argument being validated
     * @param resetArgumentsAction {@link Apply} object for a an {@link Action} that has a corresponding ResetArguments policy
     * @param resetArgumentsPolicy the ResetArgumentsPolicy for the resetArgumentsAction
     * @param actionChecker checker for resetArgumentsAction
     * @returns true if the resetArgumentsAction resets the argument with value argValueThing which means:
     * 1) argumentActionName and resetArgumentsAction refer to the same action
     * 2) resetArgumentsAction is passed argValueThing
     * 3) resetArgumentsPolicy mentions the argument to which argValueThing is passed in resetArgumentsAction
     */
    doesResetArgumentsResetArgument(argValueThing, argumentActionName, resetArgumentsAction, resetArgumentsPolicy, actionChecker) {
        var _a;
        // when the action has ResetArguments policy, check whether the following three requirements are met:
        // 1. The action with the policy is the same as the action in the argument being validated
        if (((_a = resetArgumentsAction.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== argumentActionName) {
            return false;
        }
        const resetArgumentsActionArgs = resetArgumentsAction.getArguments() || {};
        // 2. The argument value being validated is passed to the action with the policy
        for (const [resetArgumentsActionArgName, resetArgumentsActionArgValue] of Object.entries(resetArgumentsActionArgs)) {
            const resetArgumentsActionArgValueThing = actionChecker.getThing(resetArgumentsActionArgValue.value);
            if (!(resetArgumentsActionArgValueThing === null || resetArgumentsActionArgValueThing === void 0 ? void 0 : resetArgumentsActionArgValueThing.equals(argValueThing))) {
                continue;
            }
            // 3. The policy resets the argument being validated
            for (const policyArgName of resetArgumentsPolicy.arguments) {
                if (policyArgName === resetArgumentsActionArgName)
                    return true;
            }
        }
        return false;
    }
    /**
     * check whether the input argValue has been reset
     * @param argValueThing argValue to check whether it has been reset
     * @param argumentActionDecl The action declaration of the action which use the input argValue
     * @returns
     */
    isArgumentReset(argValueThing, argumentActionDecl) {
        var _a;
        const argumentActionName = (_a = argumentActionDecl.name) === null || _a === void 0 ? void 0 : _a.name;
        if (!argumentActionName) {
            return false;
        }
        const policyInfo = this.checker.project.getPolicyInfo();
        if (policyInfo === undefined || policyInfo.size === 0) {
            // If there's no reset policy configured, directly return false
            return false;
        }
        let isResetByResetArguments = false;
        let resetAllArgumentsSeen = false;
        const resetAllArgumentsArguments = new Set();
        for (let previousExpression = this.prev; previousExpression; previousExpression = previousExpression === null || previousExpression === void 0 ? void 0 : previousExpression.prev) {
            if ((previousExpression === null || previousExpression === void 0 ? void 0 : previousExpression.expression) === undefined) {
                break;
            }
            if (previousExpression.expression.kind !== "Call") {
                continue;
            }
            const previousApply = previousExpression.checker.getApply(previousExpression.expression);
            if (previousApply === undefined) {
                continue;
            }
            if (!previousApply.isUserDefinedApi()) {
                continue;
            }
            const actionName = previousApply.getName();
            if (!actionName) {
                continue;
            }
            const policyForCall = policyInfo.get(actionName);
            if (policyForCall) {
                if (policyForCall.type === "ResetArguments") {
                    if (this.doesResetArgumentsResetArgument(argValueThing, argumentActionName, previousApply, policyForCall, previousExpression.checker)) {
                        isResetByResetArguments = true;
                        break;
                    }
                }
                else if (policyForCall.type === "ResetAllArguments") {
                    resetAllArgumentsSeen = true;
                }
            }
            const previousCallArguments = previousApply.getArguments() || {};
            if (resetAllArgumentsSeen) {
                for (const resetArgumentsActionArgValue of Object.values(previousCallArguments)) {
                    const previousCallArgThing = previousExpression.checker.getThing(resetArgumentsActionArgValue.value);
                    if (!previousCallArgThing) {
                        continue;
                    }
                    resetAllArgumentsArguments.add(previousCallArgThing.token);
                }
            }
            continue;
        }
        if (isResetByResetArguments) {
            return true;
        }
        return resetAllArgumentsArguments.has(argValueThing.token);
    }
}
exports.Flow = Flow;
/**
 * Because of the unfortunate requirement of ACDL to reference an Action by its arguments. E.g. MyAction.arguments.argName
 * The abstract representation of a Function, e.g. `Function1<String, Void>`, does not capture the argument names,
 *
 * This function, `mapInterface`, maps between these interfaces. It is used by {@link Flow} when pushing or popping
 * a stack frame. This is because the expected interface of a caller or calee may be different than the actual value
 * during evaluation.
 *
 * Note: this code will mutate the TypeChecker instance passed into it. This is because we need a TypeChecker instance
 * prior constructing a Thing with a mapped interface. This is unfortuante and quite hacky, but it works for now.
 *
 * @param checker TypeChecker environment of the environment being mapped into into.
 * @param thing value of the Thing to map into the environment
 * @param type type of the Thing required in this environment
 * @returns a Thing with a mapped interface
 */
function mapInterface(checker, thing, type) {
    var _a, _b;
    if (type !== undefined && thing !== undefined) {
        if (thing.isFunction() && type.isFunctionN()) {
            return thing.withArgumentNameMappings(type.getFunctionArgumentDeclarationMappings(thing.type));
        }
        if (thing.isArguments()) {
            return new thing_1.ArgumentsThing(checker, thing.token, thing.type, thing.origin, (_b = mapInterface(checker, thing.parent, (_a = thing.type.genericArguments) === null || _a === void 0 ? void 0 : _a[0])) === null || _b === void 0 ? void 0 : _b.asFunction());
        }
        if (thing.isLiteral()) {
            // Literal Lists and Objects may contain literal Function references that need to be mapped, so we recurse over them.
            if (thing.isObject() && type.isObject()) {
                const props = thing.getProperties();
                if (props) {
                    Object.entries(props).forEach(([propName, propThing]) => {
                        var _a;
                        const arg = thing.apply.getArgument(propName);
                        propThing = (_a = mapInterface(checker, propThing, type.getPropertyType(propName))) !== null && _a !== void 0 ? _a : propThing;
                        if (propThing && arg) {
                            // here, we override the mapping between the arg Node and the Thing value
                            checker.localThingIndex.set(arg, propThing);
                            if (arg.value) {
                                checker.localThingIndex.set(arg.value, propThing);
                            }
                        }
                    });
                }
                return new thing_1.ObjectThing(checker, thing.token, thing.type, new apply_1.Apply(checker, thing.apply.call, thing.apply.decl), thing.origin, thing.parent, thing.loc, thing.uri);
            }
            if (thing.isList()) {
                if (ask.isListLiteral(thing.apply.call.arguments)) {
                    thing.apply.call.arguments.items.forEach((item, i) => {
                        if (item.item) {
                            const itemThing = mapInterface(checker, thing.getItem(i), type.getListItemType());
                            if (itemThing) {
                                // here, we override the mapping between the ListItem Nodes and the Thing value
                                checker.localThingIndex.set(item, itemThing);
                                checker.localThingIndex.set(item.item, itemThing);
                            }
                        }
                    });
                }
                return new thing_1.ListThing(checker, thing.token, thing.type, new apply_1.Apply(checker, thing.apply.call, thing.apply.decl), thing.origin, thing.parent, thing.loc, thing.uri);
            }
        }
    }
    return thing;
}
/**
 * Determines if a Type or Thing contains Function types as properties.
 */
function hasFunctions(thing, seen = immutable_1.default.Set()) {
    if (thing === undefined) {
        return undefined;
    }
    if (thing.kind === "Thing") {
        return hasFunctions(thing.type, seen);
    }
    if (seen.has(thing)) {
        return undefined;
    }
    seen = seen.add(thing);
    if (thing.isFunction()) {
        return true;
    }
    if (thing.isObject()) {
        for (const prop of thing.properties) {
            if (hasFunctions(prop.type, seen)) {
                return true;
            }
        }
    }
    else if (thing.isList()) {
        return hasFunctions(thing.getListItemType(), seen);
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxvdy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQWtDO0FBRWxDLDJDQUE2QjtBQUU3Qix1Q0FBa0Q7QUFDbEQsbUNBQXNFO0FBQ3RFLDZDQWNzQjtBQUV0QixtQ0FBOEI7QUFTOUIsTUFBYSxJQUFJO0lBQ2Y7SUFDRTs7T0FFRztJQUNNLE9BQW9CO0lBQzdCOztPQUVHO0lBQ00sVUFBYTtJQUN0Qjs7T0FFRztJQUNNLElBQXNCO0lBQy9COztPQUVHO0lBQ00sS0FBbUM7SUFDNUM7O09BRUc7SUFDTSxTQUFTLG1CQUFTLENBQUMsR0FBRyxFQUEwQjtJQUN6RDs7T0FFRztJQUNNLFFBQVEsbUJBQVMsQ0FBQyxHQUFHLEVBQWtDOzs7OzttQkFwQnZEOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7SUFDUixDQUFDO0lBRUo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0NHO0lBQ0ksU0FBUyxDQUNkLFdBQXlELEVBQ3pELElBQTZCO1FBRTdCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksRUFBVyxFQUFFO1lBQzNDLE1BQU0sSUFBSSxHQUFHLGFBQWEsRUFBRSxDQUFDO1lBQzdCLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtnQkFDdEIsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvQixJQUFJLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRTtvQkFDOUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQW9ELEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ25GO2dCQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNmO1lBQ0QsZ0dBQWdHO1lBQ2hHLE9BQU8s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