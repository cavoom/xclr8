import * as ask from "./ast";
import { ActionDeclaration, Locale } from "./ast";
import { Apply } from "./apply";
import { TypeChecker } from "./checker";
import { Token } from "./token";
import { Type } from "./type";
/**
 * A Thing refers to a some value within a Dialog Flow simulation.
 */
export type Thing = ActionThing | ArgumentThing | ArgumentsThing | BooleanThing | DialogThing | FunctionThing | ListThing | NothingThing | NumberThing | ObjectThing | StringThing | AnyThing | VoidThing | UnionThing;
export type Primitive = BooleanThing | NumberThing | StringThing | NothingThing | VoidThing;
/**
 * Nodes that represent a distinct instance of some value.
 */
export type ThingNode = ask.NameDeclaration | ask.ActionDeclaration | ask.ArgumentDeclaration | ask.Block | ask.Call | ask.Condition | ask.DialogDeclaration | ask.EnumDeclaration | ask.EnumItem | ask.ResponseTemplate | ask.PropertyReference | ask.SlotType | ask.TypeDeclaration | ask.Utterance;
declare class BaseThing {
    readonly checker: TypeChecker;
    /**
     * Unique token identifying this Thing.
     */
    readonly token: Token;
    /**
     * Represents the Type of this Thing.
     */
    readonly type: Type;
    /**
     * Optional `Apply` instance if this `Thing` is the result of a Call.
     */
    readonly apply: Apply | undefined;
    /**
     * The node that this Thing originates from.
     */
    readonly origin: ask.Node | undefined;
    /**
     * The parent of this THing, e.g. `person` in `person.name`.
     */
    readonly parent: Thing | undefined;
    /**
     * Location of this Thing in the Source Tree.
     */
    readonly loc: ask.SourceLocation | undefined;
    /**
     * URI of the SourceFile of this Thing.
     */
    readonly uri: string | undefined;
    readonly kind: "Thing";
    private propertiesIndex;
    constructor(checker: TypeChecker, 
    /**
     * Unique token identifying this Thing.
     */
    token: Token, 
    /**
     * Represents the Type of this Thing.
     */
    type: Type, 
    /**
     * Optional `Apply` instance if this `Thing` is the result of a Call.
     */
    apply: Apply | undefined, 
    /**
     * The node that this Thing originates from.
     */
    origin: ask.Node | undefined, 
    /**
     * The parent of this THing, e.g. `person` in `person.name`.
     */
    parent: Thing | undefined, 
    /**
     * Location of this Thing in the Source Tree.
     */
    loc?: ask.SourceLocation | undefined, 
    /**
     * URI of the SourceFile of this Thing.
     */
    uri?: string | undefined);
    get root(): Thing;
    /**
     * Checks if this Thing is a literal value.
     */
    isLiteral(): this is {
        apply: Apply;
    };
    /**
     * Get a new Thing representing this Thing refined to a more narrow type within a specific context.
     *
     * @returns the more narrowly typed thing.
     */
    cast(type: Type, origin?: ask.Node): Thing;
    /**
     * Check if this Thing equals the {@link other} Thing. Equality is determined by the unique {@link Thing.token}
     * given to the Thing.
     *
     * @param other other thing to compare against this Thing.
     * @returns `true` if they are the exact same value, `false` otherwise.
     */
    equals(other?: Thing): boolean;
    /**
     * Helper method to compare if this {@link Thing} complies with some type-narrowing assertion, {@link f};
     * @param f function which narrows the type of this thing.
     * @returns `true` if the condition passes or `false` otherwise.
     */
    is<T extends this>(f: (a: this) => a is T): this is T;
    /**
     * Casts this `Thing` to {@link T} if the condition {@link f} passes, otherwise returns `undefined`.
     *
     * @param f assertion function to apply to this Thing.
     * @returns casts this `Thing` to {@link T} if the condition {@link f} passes, otherwise returns `undefined`.
     */
    as<T extends this>(f: (a: this) => a is T): T | undefined;
    /**
     * Checks if this is a {@link NothingThing} instance.
     */
    isNothing(): this is NothingThing;
    /**
     * Checks if this is a {@link VoidThing} instance.
     */
    isVoid(): this is VoidThing;
    /**
     * Checks if this is a {@link ObjectThing} instance.
     */
    isObject(): this is ObjectThing;
    /**
     * Checks if this is a {@link AnyThing} instance.
     */
    isAny(): this is AnyThing;
    /**
     * Checks if this is a {@link Primitive} instance.
     */
    isPrimitive(): this is Primitive;
    /**
     * @returns a {@link Primitive} instance if this is one, otherwise `undefined`.
     */
    asPrimitive(): Primitive | undefined;
    /**
     * @returns a {@link StringThing} instance if this is one, otherwise `undefined`.
     */
    asString(): StringThing | undefined;
    /**
     * Checks if this is a {@link StringThing instance.
     */
    isString(): this is StringThing;
    /**
     * @returns a {@link NumberThing} instance if this is one, otherwise `undefined`.
     */
    asNumber(): NumberThing | undefined;
    isNumber(): this is NumberThing;
    asBoolean(): BooleanThing | undefined;
    isBoolean(): this is BooleanThing;
    asList(): ListThing | undefined;
    isList(): this is ListThing;
    asLiteralList(): (this & ListThing & {
        apply: Apply;
    }) | undefined;
    isLiteralList(): boolean;
    isFunction(): this is FunctionThing;
    asFunction(): FunctionThing | undefined;
    isAction(): this is ActionThing;
    asAction(): ActionThing | undefined;
    isArgument(): this is ArgumentThing;
    asArgument(): ArgumentThing | undefined;
    isArguments(): this is ArgumentsThing;
    asArguments(): ArgumentsThing | undefined;
    isDialog(): this is DialogThing;
    asDialog(): DialogThing | undefined;
    isUnion(): this is UnionThing;
    getPropertiesList(): (Thing | undefined)[];
    /**
     * @returns an object where the keys are the names of arguments and the values are {@link Thing} instances
     * representing values within a simulation or abstract values during type checking.
     */
    getProperties(): Record<string, Thing | undefined> | undefined;
    /**
     * If this {@link Thing} is an Object containing properties, or a {@link UnionThing} of many Object Types that
     * contain properties, then return a {@link Thing} representing that property. This interface applies in both the
     * abstract type-checking phase of the compiler as well as during evaluation of a Dialog {@link Flow}.
     *
     * @returns a {@link Thing} value representing the value of a property of "this" {@link Thing}. If this is not
     * an {@link ObjectThing} or the property does not exist, then `undefined` is returned.
     */
    getProperty(name: ask.Name | string | undefined): Thing | undefined;
    /**
     * If this is a {@link ListThing} or a {@link UnionThing} of many {@link ListThing} types, then return a {@link Thing}
     * representing the item at the specified {@link index} in the list.
     *
     * @param index the index of the item to access in the list. The index can either be a literal number or an abstract {@link NumberThing}
     * @param origin optional override of the node from which this {@link Thing} value originated from.
     * @returns a {@link Thing} representing the item if it exists or `undefined` otherwise.
     */
    getItem(index: number | NumberThing, origin?: ask.Node): Thing | undefined;
    /**
     * Find all locales this Base Thing support
     * The base thing depends on it's type to calculate locales
     *
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales(): Locale[] | undefined;
}
/**
 * Base type of all Things that contain Properties.
 */
export declare class ObjectThing extends BaseThing {
    /**
     * Checks if this is a literal Object or an abstract Object such as one received from an Event during simulation.
     */
    isLiteral(): this is {
        getProperties(): undefined;
        apply: Apply;
    };
}
/**
 * Represents a Function value within a Dialog Flow simulation.
 *
 * This class encapsulates the Tree and TypeChecker environment that contains this Function and provides
 * a friendly interface over it so that consumers such as {@link evaluateDialogFlow} are insulated from
 * the various mappings between abstract Function signatures and concrete Functions/Action/Dialogs passed
 * around during the simulation.
 */
export declare class FunctionThing extends ObjectThing {
    readonly type: Type;
    readonly origin: ask.ActionDeclaration | ask.DialogDeclaration | ask.ArgumentDeclaration | undefined;
    readonly abstractToConcreteArgumentNames?: Record<string, string> | undefined;
    constructor(checker: TypeChecker, token: Token, type: Type, origin: ask.ActionDeclaration | ask.DialogDeclaration | ask.ArgumentDeclaration | undefined, abstractToConcreteArgumentNames?: Record<string, string> | undefined);
    /**
     * Name of the Function.
     */
    get name(): ask.Name | undefined;
    /**
     * Get this Function's properties. This function overrides the type of `Arguments<this>` so that we
     * can apply mappings between the argument names of the type signature and the argument names of
     * an action passed in as an argument to a dialog or stored on some variable.
     *
     * @param name property name
     * @returns a Thing value representing that property value.
     */
    getProperty(name: string | ask.Name | undefined): Thing | undefined;
    /**
     * Create a new FunctionThing where the argument names are mapped. Consumers will use the mapped interface
     * to supply or reference arguments. This is so that we can pass Functions around as arguments without
     * requiring the ArgumentDeclaration's signature have the same argument names.
     *
     * @param argumentNameMappings map of argument name to underlying argument name.
     * @returns a new copy of this Thing with mapped argument names.
     */
    withArgumentNameMappings(argumentNameMappings?: Record<string, string>): this;
}
/**
 * Represents an Action value within a Dialog Flow simulation.
 */
export declare class ActionThing extends FunctionThing {
    #private;
    readonly type: Type;
    readonly origin: ask.ActionDeclaration;
    readonly abstractToConcreteArgumentNames?: Record<string, string> | undefined;
    readonly concreteToAbstractArgumentNames?: Record<string, string>;
    constructor(checker: TypeChecker, token: Token, type: Type, origin: ask.ActionDeclaration, abstractToConcreteArgumentNames?: Record<string, string> | undefined);
    /**
     * Name of the Action referenced by this Thing.
     */
    get actionName(): string | undefined;
    getArguments(): ArgumentsThing | undefined;
    /**
     * Get a named Argument from this Action.
     *
     * @param name name of the argument
     * @returns the Argument
     */
    getArgument(name: string | ask.Name): ArgumentThing | undefined;
    /**
     * calculate the locales for the action
     * first collect all the type associated with this action (return type, generic type, property type)
     * find the locales supported by all the types
     * @returns
     */
    getLocales(): Locale[] | undefined;
}
/**
 * Represents a Dialog value within a Dialog Flow simulation.
 */
export declare class DialogThing extends FunctionThing {
    #private;
    readonly type: Type;
    readonly origin: ask.DialogDeclaration;
    readonly abstractToConcreteArgumentNames?: Record<string, string> | undefined;
    constructor(checker: TypeChecker, token: Token, type: Type, origin: ask.DialogDeclaration, abstractToConcreteArgumentNames?: Record<string, string> | undefined);
    /**
     * calculate the locales for the dialog
     * first collect all the type associated with this dialog (return type, generic type, property type)
     * find the locales supported by all the types
     * @returns
     */
    getLocales(): Locale[] | undefined;
}
export declare class ArgumentThing extends BaseThing {
    get action(): ActionThing | undefined;
    getReferencedActionArgumentTypeInformation(): {
        argumentName: string;
        actionName: string | undefined;
        type: Type | undefined;
    } | undefined;
    /**
     * If the argument references an argument to another action
     * @returns
     * If the argument value is a property reference rooted in an API call (like getPizza.arguments.pizzaOrder.pizzaType)
     * returns an object with 4 properties:
     *    declaration has the declaration of the API (getPizza's declaration)
     *    argumentName has the name of the argument in the api ("pizzaOrder")
     *    argumentPath has the property path starting at the argument name ("pizzaOrder.pizzaType")
     *    argumentPAthSegments has ["pzzaOrder", "pizzaType"]
     */
    getReferencedActionArgumentPropertyReferenceInformation(): {
        declaration: ActionDeclaration;
        argumentName: string;
        argumentPath: string;
        argumentPathSegments: string[];
    } | undefined;
    getReferencedActionArgumentPropertyReferenceInformationOld(): {
        declaration: ActionDeclaration;
        argumentName: string;
        argumentPath: string;
        argumentPathSegments: string[];
    } | undefined;
    /**
     * An argument might reference an action argument when it uses something like getPizza.arguments.
     * This method returns the declaration for that action (like getPizza's declaration). There are two cases:
     *   1) argument references a "non object" action argument as in getPizza.arguments.pizzaType where pizzaType is of slot type PizzaType
     *   2) argument references an object action argument as in getPizza.arguments.pizzaOrder.pizzaType where pizzaOrder is
     *   of type PizzaOrder. The PizzaOrder type has a pizzaType property of slot type PizzaType
     * For case 1 the declaration is in action.origin.
     * For case 2 the declaration name is in the property reference and it needs to be lookedUp which is done in
     * this.getPropertyReferenceToAPIInformation
     * If the argument does not reference an action argument, this returns undefined
     * @returns the declaration of action referenced in argument
     */
    getReferencedActionArgumentActionDeclaration(): ActionDeclaration | undefined;
    /**
     * If an argument references an action argument returns the property path to that argument
     */
    getReferencedActionArgumentPath(): string | undefined;
    get argumentName(): string | undefined;
    get isOptional(): boolean | undefined;
    /**
     * If an argument references an action argument returns the declaration for that action argument
     */
    getReferencedActionArgumentDeclaration(): ask.ArgumentDeclaration | undefined;
}
export declare class ArgumentsThing extends ObjectThing {
    readonly type: Type;
    readonly parent: FunctionThing | undefined;
    constructor(checker: TypeChecker, token: Token, type: Type, origin: ask.Node | undefined, parent: FunctionThing | undefined);
    getArgumentsList(): ArgumentThing[] | undefined;
    getProperty(name: string | ask.Name | undefined): ArgumentThing | undefined;
}
export declare class TypeThing extends ObjectThing {
    readonly type: Type;
    constructor(checker: TypeChecker, token: Token, type: Type, origin: ask.Node | undefined);
}
declare class PrimitiveThing<T = any> extends BaseThing {
    /**
     * The literal data value of this primitive thing (if it is specified).
     *
     * If this is an abstract thing, such as the result of an event, then `undefined` is returned.
     */
    get literal(): T | undefined;
    isLiteral(): this is {
        getItems(): (Thing | undefined)[];
        apply: Apply & {
            call: {
                arguments: ask.ListLiteral;
            };
        };
    };
}
export declare class AnyThing extends BaseThing {
    thingKind: "any";
}
export declare class NothingThing extends PrimitiveThing {
    thingKind: "nothing";
}
export declare class VoidThing extends PrimitiveThing {
    thingKind: "void";
}
export declare class BooleanThing extends PrimitiveThing {
    thingKind: "boolean";
}
export declare class NumberThing extends PrimitiveThing {
    thingKind: "number";
}
export declare class StringThing extends PrimitiveThing {
    thingKind: "string";
}
export declare class ListThing extends PrimitiveThing {
    isLiteral(): this is {
        getItems(): (Thing | undefined)[];
        apply: Apply & {
            call: {
                arguments: ask.ListLiteral;
            };
        };
    };
    getItems(): (Thing | undefined)[] | undefined;
    getListItems(): (ask.ListItem<ask.Value> | undefined)[] | undefined;
}
/**
 * TODO: remove this class
 */
export declare class UnionThing extends BaseThing {
    readonly origin: ask.Node;
    /**
     *
     */
    readonly things: Thing[];
    readonly thingKind: "Union";
    constructor(checker: TypeChecker, token: Token, type: Type, origin: ask.Node, 
    /**
     *
     */
    things: Thing[]);
}
export {};
//# sourceMappingURL=thing.d.ts.map