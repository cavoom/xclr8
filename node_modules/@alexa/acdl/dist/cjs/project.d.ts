import * as ask from "./ast";
import { SourceFile } from "./source-file";
import { AskPackage } from "./package";
import { ProjectConfig } from "./project-config";
import { PolicyInfo, TypeChecker } from "./checker";
import { Apply } from "./apply";
import { Locale } from "./ast";
import { InteractionModel } from "./interaction-model";
/**
 * Synchronously load a Project from the file system.
 *
 * @param config project configuration
 */
export declare function loadProjectSync(config: ProjectConfig): Project;
/**
 * Asynchronously load a Project from the file system.
 *
 * @param config project configuration
 * @param skipFSPackageConfig true if we should use config when calling loadPackage as opposed to loading the configuration from FS
 */
export declare function loadProject(config: ProjectConfig, skipFSPackageConfig?: boolean): Promise<Project>;
/**
 * validate loaded modules
 * 1. for same module with same version, ignore the second one to avoid duplicates
 * 2. for same module with different version, report error
 * @param modules
 * @returns
 */
export declare function validateLoadedModules(modules: AskPackage[]): AskPackage[];
export interface ProjectProps {
    /**
     * Project Configuration.
     */
    config: ProjectConfig;
    /**
     * Source Files in the Project.
     */
    source: AskPackage;
    /**
     * Other assemblies to import Modules from.
     */
    external: AskPackage[];
}
export interface ModuleIndex {
    [uri: string]: SourceFile<ask.Module | undefined>;
}
/**
 * Parsed ACDL Project.
 */
export declare class Project {
    /**
     * Project Configuration.
     */
    readonly config: ProjectConfig;
    readonly responseTemplates: ask.ResponseTemplate[] | undefined;
    readonly slotTypes: ask.SlotType[] | undefined;
    readonly source: AskPackage;
    readonly external: AskPackage[];
    private readonly externalIndex;
    private readonly sourceIndex;
    /**
     * List of named call declarations indicated by an {@link ask.NameDeclaration} pointing to a {@link Apply} data structure
     */
    private callDeclarations;
    /**
     * The Global TypeChecker environment for this Project.
     */
    private checker;
    /**
     * Globally cached {@link PolicyInfo} for the configured Skill.
     */
    private policyInfo;
    /**
     * Globally cached root {@link ask.DialogDeclaration} instances. By root, we mean
     * the dialogs that constitute the entry-point of the skill.
     */
    private rootDialogs;
    constructor(props: ProjectProps);
    get modules(): SourceFile<ask.Module | undefined>[];
    get externalModules(): SourceFile<ask.Module | undefined>[];
    get sourceModules(): SourceFile<ask.Module | undefined>[];
    getModule(uri: string): SourceFile<ask.Module | undefined> | undefined;
    private clearCaches;
    remove(uri: string): void;
    isSource(uri: string): boolean;
    update(module: SourceFile<ask.Module | undefined>): void;
    getTypeChecker(): TypeChecker;
    /**
     * Check whether a project is a library
     * A library should not have the main property inside ask config
     */
    isLibrary(): boolean;
    /**
     * check whether a project is a skill
     * A skill must provide the main property inside ask config
     */
    isSkill(): boolean;
    /**
     * Find all skill actions used in project
     * @return An array of declaration and apply of all skill actions
     */
    findSkills(): {
        declaration?: ask.NameDeclaration;
        apply: Apply;
    }[];
    private findCallDeclarations;
    isRootDialog(dialog: ask.DialogDeclaration): boolean;
    /**
     * Get all dialogs in the Skill.
     */
    getAllDialogs(): ask.DialogDeclaration[];
    /**
     * Get the dialogs that are the skill's entry-point.
     *
     * This is computed in various different ways.
     * 1. when skill action exist and dialogs array provided, will read dialogs in the dialog array
     * 2. if skill action not exist or dialog array not exist, will traverse all the dialogs and filter out root dialogs by
     *   Condition 1. The dialog must use Nothing return type and has no arguments
     *   Condition 2. The dialog must not been called in other dialogs
     */
    getRootDialogs(): ask.DialogDeclaration[] | undefined;
    /**
     * Read the policy definitions defined in the skill action and converts
     * the PolicyInfo into a more readable structure
     *
     * e.g.
     * ```
     * namespace test
     * policies = [ResetArguments{arguments = [getWeather.arguments.cityName, getWeather.arguments.date]}, ResetAllArguments {action = getWeather2}]
     *
     * getPolicyInfo => Map {
     *    test.getWeather: {
     *        type: "ResetArguments",
     *        actionFqn: "test.getWeather",
     *        arguments: ["cityName", "date"]
     *    },
     *    test.getWeather2: {
     *        type: "ResetAllArguments",
     *        actionFqn: "test.getWeather2",
     *        arguments: []
     *    }
     * }
     * ```
     */
    getPolicyInfo(): Map<string, PolicyInfo> | undefined;
    generateInteractionModels(): Map<Locale, InteractionModel>;
}
//# sourceMappingURL=project.d.ts.map