import { ActionDeclaration } from "./action";
import { Call } from "./call";
import { DialogDeclaration } from "./dialog";
import { SourceLocation } from "./source-location";
import { Module } from "./module";
import { Name } from "./name";
import { NameDeclaration } from "./name-declaration";
import { Tree } from "./tree";
import { ArgumentDeclaration } from "./argument";
import { Annotation } from "./annotation";
/**
 * Check if an expression is a TypeDeclaration.
 */
export declare const isTypeDeclaration: (node: any) => node is TypeDeclaration;
/**
 * Type Declaration Expression.
 */
export declare class TypeDeclaration extends Tree<"TypeDeclaration", Module> {
    /**
     * Name of the Type.
     */
    readonly name?: Name | undefined;
    /**
     * Type properties.
     */
    readonly properties?: TypeProperty[] | undefined;
    /**
     * Optional list of type parameters.
     */
    readonly genericArguments?: TypeParameter[] | undefined;
    /**
     * Optional list of super types.
     */
    readonly extensions?: TypeReference[] | undefined;
    /**
     * Annotations attached to this Type Declaration.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    readonly comment?: string | undefined;
    constructor(
    /**
     * Name of the Type.
     */
    name?: Name | undefined, 
    /**
     * Type properties.
     */
    properties?: TypeProperty[] | undefined, 
    /**
     * Optional list of type parameters.
     */
    genericArguments?: TypeParameter[] | undefined, 
    /**
     * Optional list of super types.
     */
    extensions?: TypeReference[] | undefined, 
    /**
     * Annotations attached to this Type Declaration.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, comment?: string | undefined, loc?: SourceLocation);
    clone(): TypeDeclaration;
}
/**
 * Check if an expression is a TypeProperty.
 */
export declare const isTypeProperty: (node: any) => node is TypeProperty;
/**
 * Defines a property in type declaration.
 */
export declare class TypeProperty extends Tree<"TypeProperty", TypeDeclaration> {
    /**
     * Name of the property.
     */
    readonly name?: Name | undefined;
    /**
     * Type of the property.
     */
    readonly type?: TypeReference | undefined;
    /**
     * TODO: can we define this as a union type instead?
     */
    readonly optional?: boolean | undefined;
    /**
     * Annotations attached to this Type Property.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    readonly comment?: string | undefined;
    constructor(
    /**
     * Name of the property.
     */
    name?: Name | undefined, 
    /**
     * Type of the property.
     */
    type?: TypeReference | undefined, 
    /**
     * TODO: can we define this as a union type instead?
     */
    optional?: boolean | undefined, 
    /**
     * Annotations attached to this Type Property.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, comment?: string | undefined, loc?: SourceLocation | undefined);
    clone(): TypeProperty;
}
export declare const isTypeReference: (node: any) => node is TypeReference;
export type TypeReferenceParent = ActionDeclaration | ArgumentDeclaration | Call | DialogDeclaration | NameDeclaration | TypeDeclaration | TypeParameter | TypeProperty | TypeReference;
/**
 * Used to define type of variable, return type of an expression, type of event or action declaration.
 * <code> MyType<String> </code>
 * Here MyType is name of type and String is type argument.
 */
export declare class TypeReference extends Tree<"TypeReference", TypeReferenceParent> {
    /**
     * Name of the type being referenced.
     */
    readonly name: Name | undefined;
    /**
     * Annotations attached to this Type Reference.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    /**
     * If this TypeReference is using Function syntax, this array contains a mapping of position to argument name.
     * ex.
     * ```
     * foo(String str)
     * ```
     *
     * This is of type `Function1<String, Nothing>`.
     *
     * Its functionArgumentNames are `["str"]`, meaning the `String` type of `arg0` should be mapped to `str`.
     *
     * This data only exists when parsing ACDL syntax.
     *
     * TODO: should we create a separate Expression kind for this? We don't have one in ASKIR.
     */
    readonly functionArgumentNames?: string[] | undefined;
    /**
     * internal flag to indicate this type reference was inferred and should not have errors placed on it
     */
    readonly inferred?: boolean | undefined;
    /**
     * Generic Type arguments to this Type Reference.
     */
    readonly arguments: (TypeReference | undefined)[] | undefined;
    constructor(
    /**
     * Name of the type being referenced.
     */
    name: Name | undefined, 
    /**
     * Generic Type arguments to this Type Reference.
     */
    typeArgs?: (TypeReference | undefined)[] | undefined, 
    /**
     * Annotations attached to this Type Reference.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, 
    /**
     * If this TypeReference is using Function syntax, this array contains a mapping of position to argument name.
     * ex.
     * ```
     * foo(String str)
     * ```
     *
     * This is of type `Function1<String, Nothing>`.
     *
     * Its functionArgumentNames are `["str"]`, meaning the `String` type of `arg0` should be mapped to `str`.
     *
     * This data only exists when parsing ACDL syntax.
     *
     * TODO: should we create a separate Expression kind for this? We don't have one in ASKIR.
     */
    functionArgumentNames?: string[] | undefined, loc?: SourceLocation | undefined, 
    /**
     * internal flag to indicate this type reference was inferred and should not have errors placed on it
     */
    inferred?: boolean | undefined);
    clone(): TypeReference;
}
export declare const isTypeParameter: (node: any) => node is TypeParameter;
export type TypeParameterParent = TypeReference | TypeDeclaration | ActionDeclaration | DialogDeclaration;
/**
 * Generic type parameter.
 */
export declare class TypeParameter extends Tree<"TypeParameter", TypeParameterParent> {
    /**
     * Name of the Type Parameter.
     */
    readonly name?: Name | undefined;
    /**
     * Optional bound for the Type Parameter.
     */
    readonly constraints?: TypeReference[] | undefined;
    constructor(
    /**
     * Name of the Type Parameter.
     */
    name?: Name | undefined, 
    /**
     * Optional bound for the Type Parameter.
     */
    constraints?: TypeReference[] | undefined, loc?: SourceLocation);
    clone(): TypeParameter;
}
//# sourceMappingURL=type.d.ts.map