import { Argument } from "./argument";
import { Call } from "./call";
import { SourceLocation } from "./source-location";
import { Name } from "./name";
import { NameReference } from "./name-reference";
import { Tree } from "./tree";
import { Annotation } from "./annotation";
export type PropertyReferenceExpression = NameReference | Call | PropertyReference;
export type PropertyReferenceParent = PropertyReference | Argument;
/**
 * Asserts if the Expression is a `PropertyReference`.
 */
export declare const isPropRef: (node: any) => node is PropertyReference;
/**
 * Represents the access of a Property.
 */
export declare class PropertyReference extends Tree<"PropertyReference", PropertyReferenceParent> {
    /**
     * Name of the property being accessed.
     */
    readonly name: Name | undefined;
    /**
     * Expression containing the property being accessed.
     *
     * Names, Calls and other PropertyAccess nodes are supported.
     */
    readonly expression: PropertyReferenceExpression | undefined;
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    constructor(
    /**
     * Name of the property being accessed.
     */
    name: Name | undefined, 
    /**
     * Expression containing the property being accessed.
     *
     * Names, Calls and other PropertyAccess nodes are supported.
     */
    expression: PropertyReferenceExpression | undefined, annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, loc?: SourceLocation | undefined);
    clone(): PropertyReference;
    /**
     * Print the full prop chain with dot as the separator.
     *
     * @returns the dot-joined string from the called node to its root
     */
    printPropertyChainThroughRoot(sep?: string): string;
}
export declare namespace PropertyReference {
    /**
     * Tries to resolves a PropertyReference to a QualifiedName.
     *
     * When we parse qualified names, e.g. `com.amazon.MyIntent`, it is ambiguous
     * as to whether this is
     * 1. `PropertyReference(MyIntent, PropertyReference(amazon, NameReference(com)))`
     * 2. `NameReference(com.amazon.MyIntent)`
     *
     * This function flattens a PropertyReference tree to a qualified name so that it can be checked.
     *
     * @param expr
     */
    function tryResolveQualifiedName(expr?: PropertyReferenceExpression): string | undefined;
    /**
     * Tries to resolves a PropertyReference tree to a SourceLocation spanning the entire tree as
     * if it were a qualified name.
     *
     * When we parse qualified names, e.g. `com.amazon.MyIntent`, it is ambiguous
     * as to whether this is
     * 1. `PropertyReference(MyIntent, PropertyReference(amazon, NameReference(com)))`
     * 2. `NameReference(com.amazon.MyIntent)`
     *
     * @param expr
     */
    function tryResolveQualifiedNameLocation(expr?: PropertyReferenceExpression): SourceLocation | undefined;
}
//# sourceMappingURL=property-reference.d.ts.map