import { ActionDeclaration } from "./action";
import { Call } from "./call";
import { DialogDeclaration } from "./dialog";
import { SourceLocation } from "./source-location";
import { NameReference } from "./name-reference";
import { PropertyReference } from "./property-reference";
import { Tree } from "./tree";
import { TypeReference } from "./type";
import { Name } from "./name";
import { ListLiteral } from "./list-literal";
import { Utterance } from "./utterance";
import { Annotation } from "./annotation";
import { Expression } from "./expression";
export declare const isArgumentDeclaration: (node: any) => node is ArgumentDeclaration;
/**
 * The arguments for action or dialog.
 */
export declare class ArgumentDeclaration extends Tree<"ArgumentDeclaration", ActionDeclaration | DialogDeclaration> {
    /**
     * Name of argument.
     */
    readonly name?: Name | undefined;
    /**
     * Type of the argument.
     */
    readonly type?: TypeReference | undefined;
    /**
     * Default value for the argument, if value is not passed from caller.
     */
    readonly defaultExpression?: Expression | undefined;
    /**
     * Annotations attached to this Argument Declaration.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    readonly comment?: string | undefined;
    constructor(
    /**
     * Name of argument.
     */
    name?: Name | undefined, 
    /**
     * Type of the argument.
     */
    type?: TypeReference | undefined, 
    /**
     * Default value for the argument, if value is not passed from caller.
     */
    defaultExpression?: Expression | undefined, 
    /**
     * Annotations attached to this Argument Declaration.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, comment?: string | undefined, loc?: SourceLocation);
    clone(): this;
}
export declare const isArgument: (node: any) => node is Argument;
/**
 * Represents named argument.
 * Left side of the expression is name of the argument and right side of the expression is expression assigned to
 * argument.
 * Example 1:
 * <code>
 *    findParkingAPI(parkingRequest = findParkingRequest)
 * </code>
 * parkingRequest is name and findParkingRequest is NameExpr assigned to parkingRequest argument.
 * Example 2:
 * <code>
 *     action Restaurant findRestaurant(City cityName)
 *
 *     findRestaurant(city)
 * </code>
 * cityName is the name and city is the NameExpr assigned to the cityName argument.
 * Type of the NamedArgumentExpr should be the same as the type of expression assigned to argument.
 */
export declare class Argument extends Tree<"Argument", Call> {
    /**
     * Name of the Argument.
     */
    readonly name?: Name | undefined;
    /**
     * Index of the argument if provided positionally.
     */
    readonly index?: number | undefined;
    /**
     * Expression for the argument value.ß
     */
    readonly value?: ArgumentValue;
    constructor(
    /**
     * Name of the Argument.
     */
    name?: Name | undefined, 
    /**
     * Index of the argument if provided positionally.
     */
    index?: number | undefined, 
    /**
     * Expression for the argument value.ß
     */
    value?: ArgumentValue, loc?: SourceLocation);
    clone(): this;
}
/**
 * Types of nodes allowed a the value of an Argument.
 */
export type ArgumentValue = Call | NameReference | PropertyReference | undefined;
/**
 * Allowed values for the `Arguments` of a `Call`.
 */
export type Arguments = undefined | string | number | boolean | null | ListLiteral | Utterance | Argument[];
//# sourceMappingURL=argument.d.ts.map