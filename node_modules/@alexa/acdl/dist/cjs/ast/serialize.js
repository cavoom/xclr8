"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanStructure = exports.fromASKModule = exports.fromASKModuleJson = void 0;
const action_1 = require("./action");
const argument_1 = require("./argument");
const call_1 = require("./call");
const condition_1 = require("./condition");
const dialog_1 = require("./dialog");
const list_literal_1 = require("./list-literal");
const module_1 = require("./module");
const name_1 = require("./name");
const name_declaration_1 = require("./name-declaration");
const name_reference_1 = require("./name-reference");
const property_reference_1 = require("./property-reference");
const sample_1 = require("./sample");
const block_1 = require("./block");
const type_1 = require("./type");
const utterance_1 = require("./utterance");
const validate_1 = require("./validate");
const enum_1 = require("./enum");
const annotation_1 = require("./annotation");
const prelude_1 = require("./prelude");
const interaction_1 = require("./interaction");
const correction_1 = require("./correction");
const util_1 = require("../util");
/**
 * Parse a JSON form of ASK Module to the in-memory representation.
 *
 * @param data JSON string data
 * @param uri optional URI for the source of the ASKIR JSON
 */
function fromASKModuleJson(data, uri) {
    return fromASKModule((0, util_1.parseJSON)(data, uri), uri);
}
exports.fromASKModuleJson = fromASKModuleJson;
/**
 * Parse a serialized form of ASK Module to the in-memory representation.
 *
 * @param data parsed JSON data
 * @param uri optional URI for the source of the ASKIR JSON
 */
function fromASKModule(data, uri) {
    var _a, _b;
    cleanStructure(data);
    (0, validate_1.validateModuleSchema)(data, uri);
    return new module_1.Module(uri, module_1.ModuleSchema, undefined, undefined, (_a = data.exports) !== null && _a !== void 0 ? _a : [], (_b = data.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => readAsk(expr)));
}
exports.fromASKModule = fromASKModule;
/**
 * Clean a parsed ASKIR JSON file that does not exactly comply with the JSON schema.
 */
function cleanStructure(data) {
    if (typeof data === "object") {
        Object.entries(data).forEach(([name, value]) => {
            if ((name === "type" || name === "annotations") && value === null) {
                // UI exporter is incorrectly writing `"type": null`
                delete data[name];
            }
            else if (value && typeof value === "object") {
                cleanStructure(value);
            }
            else if (Array.isArray(value)) {
                value.forEach(cleanStructure);
            }
        });
    }
}
exports.cleanStructure = cleanStructure;
function readAsk(expr) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (expr === undefined) {
        return undefined;
    }
    if (Array.isArray(expr)) {
        return expr.map((d) => readAsk(d));
    }
    if (typeof expr === "string") {
        return new name_1.Name(expr);
    }
    if (typeof expr === "object") {
        if (expr.kind === "ActionDeclaration") {
            const action = new action_1.ActionDeclaration(new name_1.Name(expr.name), (_a = expr.arguments) === null || _a === void 0 ? void 0 : _a.map((a) => {
                const arg = new argument_1.ArgumentDeclaration(new name_1.Name(a.name), readAsk(a.type), readAsk(a.defaultExpression), readAnnotations(a.annotations));
                return arg;
            }), readAsk(expr.returnType), (_b = expr.genericArguments) === null || _b === void 0 ? void 0 : _b.map((a) => {
                var _a;
                const p = new type_1.TypeParameter(new name_1.Name(a.name), (_a = a.constraints) === null || _a === void 0 ? void 0 : _a.map((c) => readAsk(c)));
                return p;
            }), readAnnotations(expr.annotations), undefined);
            return action;
        }
        if (expr.kind === "Call") {
            let args = expr.arguments;
            if (Array.isArray(expr.arguments)) {
                if (expr.name === prelude_1.AlexaSchema.List &&
                    ((_d = (_c = expr.genericArguments) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.name) === prelude_1.AlexaConversations.Argument &&
                    expr.genericArguments[0].genericArguments === undefined) {
                    // List<Argument> - this is the old version of the core library, we will instead let the compiler infer the type
                    expr.name = undefined;
                    expr.genericArguments = undefined;
                }
                // list literal arguments, wrap them in a ListLiteral type
                args = new list_literal_1.ListLiteral(expr.arguments.map((arg, i) => new list_literal_1.ListItem(readAsk(arg), i)));
            }
            else if (expr.arguments && typeof expr.arguments === "object") {
                if (expr.name === prelude_1.AlexaConversations.utterances || expr.name === prelude_1.AlexaConversations.intent) {
                    if (Array.isArray(expr.genericArguments) && expr.genericArguments.length === 0) {
                        // empty array should be undefined
                        expr.genericArguments = undefined;
                    }
                    const { samples } = expr.arguments;
                    if (samples &&
                        samples.kind === "Call" &&
                        samples.name === prelude_1.AlexaSchema.List &&
                        ((_f = (_e = samples.genericArguments) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.name) === prelude_1.AlexaSchema.String) {
                        // List<String> instead of List<Utterance<T>>
                        // remove the types and let the compiler infer them.
                        samples.name = undefined;
                        samples.genericArguments = undefined;
                    }
                }
                args = Object.entries(expr.arguments).map(([name, arg], i) => new argument_1.Argument(new name_1.Name(name), i, readAsk(arg)));
            }
            else if (typeof expr.arguments === "string") {
                const names = (0, utterance_1.parseUtteranceSlotNames)(expr.arguments);
                if (names) {
                    args = new utterance_1.Utterance(expr.arguments, names.map((name) => new name_1.Name(name)));
                }
            }
            // The exported IR use 'lhs' and 'rhs' for operator arguments
            // convert it to 'left' and 'right'
            if (prelude_1.OPERATOR_ACTIONS_SET.has(expr.name)) {
                for (const arg of args) {
                    if (arg.name.name === "lhs") {
                        arg.name = "left";
                    }
                    else if (arg.name.name === "rhs") {
                        arg.name = "right";
                    }
                }
            }
            return new call_1.Call(new name_1.Name(expr.name), args, readAsk(expr.genericArguments), readAnnotations(expr.annotations));
        }
        if (expr.kind === "Condition") {
            const thenScope = new condition_1.ThenScope(readAsk(expr.then));
            const elseScope = new condition_1.ElseScope(readAsk(expr.else));
            return new condition_1.Condition(new condition_1.When(readAsk(expr.when)), thenScope, elseScope, readAnnotations(expr.annotations));
        }
        if (expr.kind === "Correction") {
            const actualScope = new correction_1.CorrectionScope(readAsk(expr.actual));
            const expectedScope = new correction_1.CorrectionScope(readAsk(expr.expected));
            return new correction_1.Correction(actualScope, expectedScope);
        }
        if (expr.kind === "DialogDeclaration") {
            return new dialog_1.DialogDeclaration(new name_1.Name(expr.name), (_g = expr.arguments) === null || _g === void 0 ? void 0 : _g.map((a) => {
                const arg = new argument_1.ArgumentDeclaration(new name_1.Name(a.name), readAsk(a.type), readAsk(a.defaultExpression), readAnnotations(expr.annotations));
                return arg;
            }), readAsk(expr.samples), readAsk(expr.returnType), (_h = expr.genericArguments) === null || _h === void 0 ? void 0 : _h.map((a) => {
                var _a;
                return new type_1.TypeParameter(new name_1.Name(a.name), (_a = a.constraints) === null || _a === void 0 ? void 0 : _a.map((c) => readAsk(c)));
            }), readAnnotations(expr.annotations));
        }
        if (expr.kind === "InteractionDeclaration") {
            return new interaction_1.InteractionDeclaration(new block_1.Block(readAsk(expr.expressions)), readAnnotations(expr.annotations));
        }
        if (expr.kind === "TypeReference") {
            return new type_1.TypeReference(new name_1.Name(renameType(expr.name)), readAsk(expr.arguments), readAnnotations(expr.annotations));
        }
        if (expr.kind === "TypeDeclaration") {
            return new type_1.TypeDeclaration(new name_1.Name(expr.name), expr.properties === undefined
                ? undefined
                : expr.properties.map((prop) => {
                    const typeProperty = new type_1.TypeProperty(new name_1.Name(prop.name), readAsk(prop.type), prop.optional, readAnnotations(expr.annotations));
                    return typeProperty;
                }), (_j = expr.genericArguments) === null || _j === void 0 ? void 0 : _j.map((arg) => {
                const typeParam = new type_1.TypeParameter(new name_1.Name(arg.name), readAsk(arg.constraints));
                return typeParam;
            }), readAsk(expr.extensions), readAnnotations(expr.annotations));
        }
        if (expr.kind === "NameDeclaration" || expr.kind === "QualifiedNameDeclaration" || expr.kind === "InteractionNameDeclaration") {
            return new name_declaration_1.NameDeclaration(new name_1.Name(expr.name), readAsk(expr.type), readAsk(expr.expression), readAnnotations(expr.annotations));
        }
        if (expr.kind === "NameReference") {
            return new name_reference_1.NameReference(new name_1.Name(renameType(expr.name)), readAnnotations(expr.annotations));
        }
        if (expr.kind === "PropertyReference") {
            return new property_reference_1.PropertyReference(readAsk(expr.name), readAsk(expr.expression), readAnnotations(expr.annotations));
        }
        if (expr.kind === "Sample") {
            return new sample_1.Sample(new block_1.Block(readAsk(expr.expressions)), readAnnotations(expr.annotations));
        }
        if (expr.kind === "Scope") {
        }
        else if (expr.kind === "EnumDeclaration") {
            return new enum_1.EnumDeclaration(new name_1.Name(expr.name), Array.isArray(expr.items) ? readAsk(expr.items) : undefined, readAnnotations(expr.annotations));
        }
        else if (expr.kind === "EnumItemDeclaration") {
            return new enum_1.EnumItem(readAsk(expr.name), readAnnotations(expr.annotations));
        }
    }
    throw new Error(`unexpected expression: ${JSON.stringify(expr)}`);
}
/**
 * Renames a type from the server-side representation to the client-side representation.
 */
function renameType(name) {
    // Even though we no longer map AlexaSchema.Type to AlexaConversations.Type
    // in compile.ts's compileExpression (from ACDL to ASKIR) we keep this so decompile works
    if (name === prelude_1.AlexaConversations.Type) {
        return prelude_1.AlexaSchema.Type;
    }
    if (name === prelude_1.AlexaConversations.Argument) {
        return prelude_1.AlexaSchema.Argument;
    }
    if (name === prelude_1.AlexaConversations.Arguments) {
        return prelude_1.AlexaSchema.Arguments;
    }
    return name;
}
function readAnnotations(calls) {
    return calls === null || calls === void 0 ? void 0 : calls.map((call) => new annotation_1.Annotation(readAsk(call)));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FzdC9zZXJpYWxpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQTJDO0FBQzNDLHlDQUF3RTtBQUN4RSxpQ0FBNEI7QUFDNUIsMkNBQWtFO0FBQ2xFLHFDQUEyQztBQUMzQyxpREFBcUQ7QUFDckQscUNBQWdFO0FBQ2hFLGlDQUE0QjtBQUM1Qix5REFBbUQ7QUFDbkQscURBQStDO0FBQy9DLDZEQUF1RDtBQUV2RCxxQ0FBZ0M7QUFDaEMsbUNBQThCO0FBQzlCLGlDQUFtRjtBQUNuRiwyQ0FBK0Q7QUFDL0QseUNBQWdEO0FBQ2hELGlDQUFpRDtBQUNqRCw2Q0FBd0M7QUFDeEMsdUNBQWdGO0FBQ2hGLCtDQUFxRDtBQUNyRCw2Q0FBeUQ7QUFDekQsa0NBQWtDO0FBaUpsQzs7Ozs7R0FLRztBQUNILFNBQWdCLGlCQUFpQixDQUFDLElBQVksRUFBRSxHQUFXO0lBQ3pELE9BQU8sYUFBYSxDQUFDLElBQUEsZ0JBQVMsRUFBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQUZELDhDQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixhQUFhLENBQUMsSUFBUyxFQUFFLEdBQVc7O0lBQ2xELGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQixJQUFBLCtCQUFvQixFQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNoQyxPQUFPLElBQUksZUFBTSxDQUNmLEdBQUcsRUFDSCxxQkFBWSxFQUNaLFNBQVMsRUFDVCxTQUFTLEVBQ1QsTUFBQyxJQUFJLENBQUMsT0FBb0IsbUNBQUksRUFBRSxFQUNoQyxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUF1QixDQUMxRSxDQUFDO0FBQ0osQ0FB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