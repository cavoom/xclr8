import { ActionDeclaration } from "./action";
import { ArgumentDeclaration, ArgumentValue } from "./argument";
import { Call } from "./call";
import { Condition } from "./condition";
import { DialogDeclaration } from "./dialog";
import { Module } from "./module";
import { Name } from "./name";
import { NameDeclaration } from "./name-declaration";
import { NameReference } from "./name-reference";
import { PropertyReference } from "./property-reference";
import { Node } from "./node";
import { Sample } from "./sample";
import { Block } from "./block";
import { TypeDeclaration, TypeParameter, TypeProperty, TypeReference } from "./type";
import { EnumDeclaration, EnumItem } from "./enum";
import { InteractionDeclaration } from "./interaction";
export type SerializedArguments = null | string | boolean | number | Serialized<ArgumentValue>[] | {
    [argument in string]: Serialized<ArgumentValue>;
};
/**
 * Maps an internal AST representation to its equivalent `@alexa/ask-module-spec` representation.
 */
export type Serialized<T = Node> = T extends Name ? string : T extends NameDeclaration ? {
    kind: "NameDeclaration" | "QualifiedNameDeclaration" | "InteractionNameDeclaration";
    name: string;
    expression: Serialized<NameDeclaration["expression"]>;
    type: Serialized<TypeReference>;
    annotations: Serialized<Call> | undefined;
} : T extends Sample ? {
    kind: "Sample";
    expressions: Serialized<T["scope"]>;
    type: Serialized<TypeReference>;
    annotations: Serialized<Call> | undefined;
} : T extends Block<infer E> ? Serialized<E>[] : T extends any[] ? {
    [i in keyof T]: Serialized<T[i]>;
} : T extends Call ? {
    kind: "Call";
    name: Serialized<Name>;
    arguments?: SerializedArguments;
    genericArguments?: Serialized<TypeReference>[];
    type: Serialized<TypeReference>;
    annotations: Serialized<Call> | undefined;
} : T extends ActionDeclaration ? {
    kind: "ActionDeclaration";
    name: Serialized<Name>;
    returnType: Serialized<TypeReference>;
    arguments?: Serialized<ArgumentDeclaration>[];
    genericArguments?: Serialized<TypeParameter>[];
    annotations: Serialized<Call> | undefined;
} : T extends DialogDeclaration ? {
    kind: "DialogDeclaration";
    name: Serialized<Name>;
    returnType: Serialized<TypeReference>;
    arguments?: Serialized<ArgumentDeclaration>[];
    genericArguments?: Serialized<TypeParameter>[];
    samples: Serialized<Sample>[];
    annotations: Serialized<Call> | undefined;
} : T extends InteractionDeclaration ? {
    kind: "InteractionDeclaration";
    expressions: Serialized<T["scope"]>;
    annotations: Serialized<Call> | undefined;
} : T extends ArgumentDeclaration ? {
    name: Serialized<Name>;
    type: Serialized<TypeReference>;
    defaultExpression?: Serialized<ArgumentDeclaration["defaultExpression"]>;
    annotations: Serialized<Call> | undefined;
} : T extends TypeDeclaration ? {
    kind: "TypeDeclaration";
    name: string;
    properties?: {
        name: string;
        type: Serialized<TypeReference>;
        optional?: boolean;
    }[];
    extensions?: Serialized<TypeReference>[];
    genericArguments?: Serialized<TypeParameter>[];
    annotations: Serialized<Call> | undefined;
} : T extends TypeProperty ? {
    name: Serialized<Name>;
    type: Serialized<TypeReference>;
    optional: boolean;
    annotations: Serialized<Call> | undefined;
} : T extends TypeParameter ? {
    name: Serialized<Name>;
    constraints?: Serialized<TypeReference>;
} : T extends EnumDeclaration ? {
    kind: "EnumDeclaration";
    name: string;
    items: Serialized<EnumItem>[];
    annotations: Serialized<Call> | undefined;
} : T extends Module ? Strip<T, "kind"> : T extends Condition | NameReference | PropertyReference ? Strip<T> & {
    type: Serialized<TypeReference>;
} : T extends Node ? Strip<T> : T;
type Strip<T, K extends keyof T = never> = Omit<{
    [p in keyof T]: Serialized<T[p]>;
}, K | "context" | "previous" | "next" | "loc" | "uri" | "clone" | "printHierarchy" | "setAsParentOn" | "toString" | "getModule" | "getSample" | "getDialog" | "getCorrection" | "getPropertyChainRootExpression" | "printPropertyChainThroughRoot" | "findInContext">;
/**
 * Parse a JSON form of ASK Module to the in-memory representation.
 *
 * @param data JSON string data
 * @param uri optional URI for the source of the ASKIR JSON
 */
export declare function fromASKModuleJson(data: string, uri: string): Module;
/**
 * Parse a serialized form of ASK Module to the in-memory representation.
 *
 * @param data parsed JSON data
 * @param uri optional URI for the source of the ASKIR JSON
 */
export declare function fromASKModule(data: any, uri: string): Module;
/**
 * Clean a parsed ASKIR JSON file that does not exactly comply with the JSON schema.
 */
export declare function cleanStructure(data: any): void;
export {};
//# sourceMappingURL=serialize.d.ts.map