import { ArgumentDeclaration } from "./argument";
import { SourceLocation } from "./source-location";
import { Module } from "./module";
import { Tree } from "./tree";
import { TypeParameter, TypeReference } from "./type";
import { Name } from "./name";
import { Annotation } from "./annotation";
/**
 * Check whether an expression is an `ActionDeclaration`.
 */
export declare const isActionDeclaration: (node: any) => node is ActionDeclaration;
/**
 * This node in AST represents an Action Declaration.
 * <code>
 *     action ReturnType actionName(Type1 arg1, Type2 arg2)
 *     action S actionName&lt;T, S&gt;(Type1 arg1, T arg2)
 * </code>
 */
export declare class ActionDeclaration extends Tree<"ActionDeclaration", Module> {
    /**
     * Name of the Action.
     */
    readonly name?: Name | undefined;
    /**
     * Return type for the Action.
     *
     * If an action doesn't define an output, it will be set Nothing.
     */
    readonly returnType?: TypeReference | undefined;
    /**
     * List of generic arguments in action.
     * <code>action S actionName<T, S>(Type1 arg1, T arg2)</code>
     * T and S are type parameters here.
     */
    readonly genericArguments?: TypeParameter[] | undefined;
    /**
     * Annotations attached to this Action Declaration.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    readonly comment?: string | undefined;
    /**
     * List of arguments to action.
     */
    readonly arguments?: ArgumentDeclaration[];
    constructor(
    /**
     * Name of the Action.
     */
    name?: Name | undefined, 
    /**
     * List of arguments to action.
     */
    args?: ArgumentDeclaration[], 
    /**
     * Return type for the Action.
     *
     * If an action doesn't define an output, it will be set Nothing.
     */
    returnType?: TypeReference | undefined, 
    /**
     * List of generic arguments in action.
     * <code>action S actionName<T, S>(Type1 arg1, T arg2)</code>
     * T and S are type parameters here.
     */
    genericArguments?: TypeParameter[] | undefined, 
    /**
     * Annotations attached to this Action Declaration.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, comment?: string | undefined, loc?: SourceLocation);
    clone(): this;
}
//# sourceMappingURL=action.d.ts.map