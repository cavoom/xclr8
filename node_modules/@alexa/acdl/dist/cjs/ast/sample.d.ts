import { Call } from "./call";
import { Condition } from "./condition";
import { DialogDeclaration } from "./dialog";
import { SourceLocation } from "./source-location";
import { NameDeclaration } from "./name-declaration";
import { Block } from "./block";
import { Tree } from "./tree";
import { NameReference } from "./name-reference";
import { Annotation } from "./annotation";
/**
 * Checks if the expression is a SampleExpression.
 */
export declare const isSampleExpression: (node: any) => node is Call<import("./call").CallContext> | Condition | NameDeclaration<import("./name-declaration").Named> | NameReference;
/**
 * Expressions allowed within a Sample.
 */
export type SampleExpression = Call | Condition | NameDeclaration | NameReference;
export interface SampleScope extends Block<SampleExpression, Sample> {
}
/**
 * Checks if the expression is a SampleDeclaration.
 */
export declare const isSample: (node: any) => node is Sample;
/**
 * Declares a Sample.
 */
export declare class Sample extends Tree<"Sample", DialogDeclaration> {
    /**
     * Top-level scope of the Sample.
     */
    readonly scope?: SampleScope | undefined;
    /**
     * Annotations attached to this Enum Declaration.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    constructor(
    /**
     * Top-level scope of the Sample.
     */
    scope?: SampleScope | undefined, 
    /**
     * Annotations attached to this Enum Declaration.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, loc?: SourceLocation);
    clone(): this;
}
//# sourceMappingURL=sample.d.ts.map