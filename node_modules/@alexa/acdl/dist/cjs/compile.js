"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileExpression = exports.compileModule = exports.compileProject = void 0;
const path_1 = __importDefault(require("path"));
const ask = __importStar(require("./ast"));
const ast_1 = require("./ast");
const util_1 = require("./util");
/**
 * Compile a Project to a record of relative build paths to serialized ASK IR files.
 *
 * @param project ACDL project to compile.
 */
function compileProject(project) {
    const compiledProject = {
        modules: {},
    };
    for (const source of project.sourceModules) {
        const sourcePath = (0, util_1.trimScheme)(source.uri);
        const relative = path_1.default.relative(source.baseDir, sourcePath);
        const relativeDir = path_1.default.dirname(relative);
        let fileName = `${path_1.default.basename(sourcePath, ".acdl")}`;
        if (!fileName.endsWith(".json")) {
            fileName = `${fileName}.json`;
        }
        const relativeFilePath = path_1.default.join(relativeDir, fileName);
        const compiledModule = compileModule(project, source.content);
        compiledProject.modules[relativeFilePath] = compiledModule;
    }
    return compiledProject;
}
exports.compileProject = compileProject;
/**
 * Compile source to valid ask-module JSON.
 *
 * @param project project containing the source.
 * @param module source module, either an ACDLFile or ask-module.
 * @param validateJsonSchema whether to validate JSON schema or not
 */
function compileModule(project, module, validateJsonSchema = false) {
    var _a, _b;
    const checker = project.getTypeChecker();
    const moduleUri = checker.getUri(module);
    if (!moduleUri) {
        throw new Error(`Cannot compile a Module when the Project instance doesn't load it.`);
    }
    const compiledModule = {
        schema: "https://amazonalexa.com/ask/2020/12/Module",
        exports: (_a = module.expressions) === null || _a === void 0 ? void 0 : _a.map((e) => {
            var _a;
            return e.kind === "ActionDeclaration" ||
                e.kind === "DialogDeclaration" ||
                e.kind === "EnumDeclaration" ||
                e.kind === "NameDeclaration" ||
                e.kind === "TypeDeclaration"
                ? (_a = e.name) === null || _a === void 0 ? void 0 : _a.name
                : undefined;
        }).filter((s) => s !== undefined),
        expressions: (_b = module.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => compileExpression(expr, { checker, moduleUri })),
    };
    if (validateJsonSchema) {
        ask.validateModuleSchema(compiledModule);
    }
    return compiledModule;
}
exports.compileModule = compileModule;
/**
 * Maps an internal AST Expression to its equivalent `@alexa/ask-module-spec` representation.
 *
 * @param data data to serialize
 */
function compileExpression(data, context) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const { checker, moduleUri } = context;
    if (data === undefined) {
        return undefined;
    }
    if (Array.isArray(data)) {
        return data.map((item) => compileExpression(item, context));
    }
    if (ask.isNode(data)) {
        if (data.kind === "ActionDeclaration") {
            const expr = {
                kind: "ActionDeclaration",
                name: compileExpression(data.name, context),
                arguments: (0, util_1.sanitize)(compileExpression(data.arguments, context)),
                returnType: compileExpression(data.returnType, context),
                genericArguments: (0, util_1.sanitize)(compileExpression(data.genericArguments, context)),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Annotation") {
            return compileExpression(data.call, context);
        }
        if (data.kind === "ArgumentDeclaration") {
            let type = context.checker.instantiateTypeReference(data.type);
            let defaultExpression = compileExpression(data.defaultExpression, context);
            if (type === undefined) {
                throw resolveTypeToReference(data);
            }
            const expr = {
                name: (_a = data.name) === null || _a === void 0 ? void 0 : _a.name,
                defaultExpression,
                type: compileExpression(type === null || type === void 0 ? void 0 : type.toTypeReference(data), context),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Argument") {
            const expr = compileExpression(data.value, context);
            return expr;
        }
        if (data.kind === "Call") {
            let action = checker.getApply(data);
            let returnType = (_b = checker.getThing(data)) === null || _b === void 0 ? void 0 : _b.type;
            if (action === undefined || returnType === undefined) {
                throw new Error(`cannot resolve Apply for ${data.kind}`);
            }
            let args;
            if (Array.isArray(data.arguments)) {
                if (action.isType() &&
                    action.getReturnType().isPrimitive() &&
                    data.arguments.length === 1 &&
                    ask.isCall(data.arguments[0].value)) {
                    // handle sub-types of primitives, e.g. CityName("New York")
                    args = data.arguments[0].value.arguments;
                }
                else {
                    const mappings = {};
                    if (action.decl.kind === "Type" && action.decl.isFunctionN() && ((_c = action.decl.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "TypeDeclaration") {
                        // this is a call to an abstract function, we must map its argument names to arg0, arg1, ..., argN
                        (_d = action.decl.getFunctionArgumentDeclarations()) === null || _d === void 0 ? void 0 : _d.forEach((arg, i) => {
                            var _a, _b;
                            if ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) {
                                mappings[(_b = arg.name) === null || _b === void 0 ? void 0 : _b.name] = `arg${i}`;
                            }
                        });
                    }
                    args = Object.entries(action.getArguments() || {})
                        .map(([name, arg]) => {
                        var _a;
                        if (name !== undefined) {
                            return {
                                // See comment in "Strip Optional from argument" test in askir.test.ts
                                [(_a = mappings[name]) !== null && _a !== void 0 ? _a : name]: compileExpression(arg.value, { ...context, blockOptionalTypeReferences: true }),
                            };
                        }
                        return {};
                    })
                        .reduce((a, b) => ({ ...a, ...b }), {});
                }
            }
            else if (ask.isListLiteral(data.arguments)) {
                args = data.arguments.items.map((item) => compileExpression(item.item, context));
            }
            else if (ask.isUtterance(data.arguments)) {
                args = data.arguments.text;
            }
            else {
                args = data.arguments;
            }
            const name = action.decl.kind === "Type" &&
                action.decl.isFunction() &&
                ((_e = action.decl.declaration) === null || _e === void 0 ? void 0 : _e.kind) !== "ActionDeclaration" &&
                ((_f = action.decl.declaration) === null || _f === void 0 ? void 0 : _f.kind) !== "DialogDeclaration"
                ? // this call is referencing an action defined as an argument or variable, so we should use its local name.
                    assertNotNull((_g = data.name) === null || _g === void 0 ? void 0 : _g.name, "Call.name must be defined.")
                : // otherwise use the declaration's name (fully qualified name).
                    typeof action.decl.name === "string"
                        ? action.decl.name
                        : (_h = action.decl.name) === null || _h === void 0 ? void 0 : _h.name;
            const serializedCall = {
                kind: "Call",
                name,
                genericArguments: (_j = action.getGenericArguments()) === null || _j === void 0 ? void 0 : _j.map((a) => compileExpression(a === null || a === void 0 ? void 0 : a.toTypeReference(data), context)),
                arguments: (0, util_1.sanitize)(args),
                type: resolveTypeToReference(data, returnType),
                annotations: compileExpression(data.annotations, context),
            };
            return serializedCall;
        }
        if (data.kind === "Condition") {
            const expr = {
                kind: "Condition",
                when: compileExpression(data.when, context),
                then: (0, util_1.sanitize)(compileExpression(data.then, context)),
                else: (0, util_1.sanitize)(compileExpression(data.else, context)),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "When") {
            return compileExpression(data.expression, context);
        }
        if (data.kind === "Correction") {
            const expr = {
                kind: "Correction",
                actual: (0, util_1.sanitize)(compileExpression(data.actual, context)),
                expected: (0, util_1.sanitize)(compileExpression(data.expected, context)),
            };
            return expr;
        }
        if (data.kind === "InteractionDeclaration") {
            const expr = {
                kind: "InteractionDeclaration",
                expressions: compileExpression(data.scope, context),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "DialogDeclaration") {
            // Non reusable dialog must return void otherwise it will not be recognized as a deployable dialog
            // by the backend that returns the error:
            //   The skill does not contain any deployable dialog for locale en_US.
            // That is why we use blockVoid in the returnType compileExpression.
            // The blockVoid in the samples is because the last expression inside the sample must also not be
            // void because the backend will throw a type mismatch
            // error between sample return of nothing and the last expression in the sample (say a response)
            // returning void
            const expr = {
                kind: "DialogDeclaration",
                name: (_k = data.name) === null || _k === void 0 ? void 0 : _k.name,
                arguments: (0, util_1.sanitize)(compileExpression(data.arguments, context)),
                genericArguments: (0, util_1.sanitize)(compileExpression(data.genericArguments, context)),
                returnType: compileExpression(data.returnType, { ...context, blockVoid: true }),
                samples: compileExpression(data.samples, { ...context, blockVoid: true }),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "EnumDeclaration") {
            if (((_l = data.name) === null || _l === void 0 ? void 0 : _l.name) === undefined) {
                throw new Error(`name undefined for 'enum'`);
            }
            if (data.items === undefined || data.items.length === 0) {
                throw new Error(`empty enum: '${data.name.name}'`);
            }
            const expr = {
                kind: "EnumDeclaration",
                name: data.name.name,
                items: (_m = data.items) === null || _m === void 0 ? void 0 : _m.map((item) => compileExpression(item, context)),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "EnumItemDeclaration") {
            if (((_o = data.name) === null || _o === void 0 ? void 0 : _o.name) === undefined) {
                throw new Error(`undefined name on enum item '${(_p = data.context.name) === null || _p === void 0 ? void 0 : _p.name}'`);
            }
            const expr = {
                kind: "EnumItemDeclaration",
                name: data.name.name,
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Name") {
            const name = checker.qualifyName(data, data.name);
            return name;
        }
        if (data.kind === "NameReference") {
            const name = {
                kind: "NameReference",
                name: checker.qualifyName(data, data.name),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return name;
        }
        if (data.kind === "NameDeclaration") {
            const expr = {
                kind: data.context.kind === "Module"
                    ? "QualifiedNameDeclaration"
                    : ask.isInteractionDeclaration(data.context.context) || ask.isCorrection(data.context.context)
                        ? "InteractionNameDeclaration"
                        : "NameDeclaration",
                name: compileExpression(data.name, context),
                type: resolveTypeToReference(data),
                expression: compileExpression(data.expression, context),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "PropertyReference") {
            const qualifiedName = ask.PropertyReference.tryResolveQualifiedName(data);
            if (checker.lookupQualifiedName(qualifiedName) !== undefined) {
                const name = {
                    kind: "NameReference",
                    name: qualifiedName,
                    type: resolveTypeToReference(data),
                    annotations: compileExpression(data.annotations, context),
                };
                return name;
            }
            const prop = {
                kind: "PropertyReference",
                name: (_q = data.name) === null || _q === void 0 ? void 0 : _q.name,
                expression: compileExpression(data.expression, context),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return prop;
        }
        if (data.kind === "Sample") {
            const expr = {
                kind: "Sample",
                expressions: compileExpression(data.scope, context),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Block") {
            return (_r = data.expressions) === null || _r === void 0 ? void 0 : _r.map((expr) => compileExpression(expr, context));
        }
        if (data.kind === "TypeDeclaration") {
            const expr = {
                kind: "TypeDeclaration",
                name: compileExpression(data.name, context),
                extensions: (0, util_1.sanitize)(compileExpression(data.extensions, context)),
                genericArguments: (0, util_1.sanitize)(compileExpression(data.genericArguments, context)),
                properties: (_s = data.properties) === null || _s === void 0 ? void 0 : _s.map((prop) => compileExpression(prop, context)),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "TypeParameter") {
            const expr = {
                name: compileExpression(data.name, context),
                constraints: (0, util_1.sanitize)(compileExpression(data.constraints, context)),
            };
            return expr;
        }
        if (data.kind === "TypeProperty") {
            const qualified = checker.qualifyName(data, (_t = data.type) === null || _t === void 0 ? void 0 : _t.name);
            const expr = {
                name: (_u = data.name) === null || _u === void 0 ? void 0 : _u.name,
                type: compileExpression(data.type, context),
                optional: qualified === ast_1.AlexaSchema.Optional || data.optional === true,
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "TypeReference") {
            return getSerializedTypeReference(data, (type) => {
                var _a;
                if (context.blockVoid && type.isVoid()) {
                    type = checker.nothing;
                }
                if (context.blockOptionalTypeReferences) {
                    while (type === null || type === void 0 ? void 0 : type.isOptional()) {
                        type = assertDefined(data, type === null || type === void 0 ? void 0 : type.getOptionalType());
                    }
                }
                else {
                    // flatten Optionals. Optional<Optional<Optional<T>>> into Optional<T>
                    while ((type === null || type === void 0 ? void 0 : type.isOptional()) && ((_a = type === null || type === void 0 ? void 0 : type.getOptionalType()) === null || _a === void 0 ? void 0 : _a.isOptional())) {
                        type = assertDefined(data, type === null || type === void 0 ? void 0 : type.getOptionalType());
                    }
                }
                return type;
            });
        }
        if (data.kind === "Utterance") {
            return data.text;
        }
    }
    throw new Error(`invalid ask expression: ${data}`);
    function assertNotNull(t, msg) {
        if (t === undefined) {
            throw new Error(msg);
        }
        return t;
    }
    function assertDefined(node, type) {
        var _a, _b;
        if (type === undefined) {
            throw new Error(`could not resolve type of '${node.kind}' expression at ${moduleUri}(${(_a = node === null || node === void 0 ? void 0 : node.loc) === null || _a === void 0 ? void 0 : _a.begin.line},${(_b = node === null || node === void 0 ? void 0 : node.loc) === null || _b === void 0 ? void 0 : _b.begin.character})`);
        }
        return type;
    }
    function getTypeOrThrow(node) {
        return assertDefined(node, checker.getType(node));
    }
    function resolveTypeToReference(node, type = checker.getType(node)) {
        return compileExpression(assertDefined(node, type).toTypeReference(node.context), context);
    }
    /**
     * Retrieves a serialized version of the typeReference with the type optionally transformed
     * @param typeReference Type reference node
     * @param typeTransformer optional transformer for the type
     * @returns a serialized version of the typeReference with the type optionally transformed
     */
    function getSerializedTypeReference(typeReference, typeTransformer = (type) => type) {
        let type = getTypeOrThrow(typeReference);
        const typeRef = typeTransformer(type).toTypeReference(typeReference);
        const expr = {
            kind: "TypeReference",
            name: compileExpression(typeRef.name, context),
            arguments: (0, util_1.sanitize)(compileExpression(typeRef.arguments, context)),
            annotations: compileExpression(typeReference.annotations, context),
        };
        return expr;
    }
}
exports.compileExpression = compileExpression;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21waWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0RBQXdCO0FBRXhCLDJDQUE2QjtBQUM3QiwrQkFBcUU7QUFJckUsaUNBQTRDO0FBUzVDOzs7O0dBSUc7QUFDSCxTQUFnQixjQUFjLENBQUMsT0FBZ0I7SUFDN0MsTUFBTSxlQUFlLEdBQW9CO1FBQ3ZDLE9BQU8sRUFBRSxFQUFFO0tBQ1osQ0FBQztJQUNGLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRTtRQUMxQyxNQUFNLFVBQVUsR0FBRyxJQUFBLGlCQUFVLEVBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLE1BQU0sUUFBUSxHQUFHLGNBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUMzRCxNQUFNLFdBQVcsR0FBRyxjQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNDLElBQUksUUFBUSxHQUFHLEdBQUcsY0FBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUN2RCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUMvQixRQUFRLEdBQUcsR0FBRyxRQUFRLE9BQU8sQ0FBQztTQUMvQjtRQUNELE1BQU0sZ0JBQWdCLEdBQUcsY0FBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDMUQsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBUSxDQUFDLENBQUM7UUFDL0QsZUFBZSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLGNBQWMsQ0FBQztLQUM1RDtJQUNELE9BQU8sZUFBZSxDQUFD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