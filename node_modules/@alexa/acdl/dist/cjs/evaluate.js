"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePriorResponseCall = exports.validatePriorDelegation = exports.evaluateConditionalBranch = exports.validateSampleStartWithInvoke = exports.validateSkillLevelResponses = exports.validateGlobalWelcome = exports.validatePayload = exports.evaluateInvokeApi = exports.validateRequestPromptInArgsList = exports.validatePrompt = exports.validateArgumentListThing = exports.validateArgumentList = exports.evaluateEnsure = exports.validateConfirmArgsFlow = exports.validateConfirmArgsAct = exports.evaluateConfirmArgs = exports.evaluateConfirmAction = exports.validateNextAct = exports.addPendingOfferIfAction = exports.validateResponseAct = exports.evaluateResponse = exports.evaluateDelegateToIntent = exports.evaluateDelegateRequest = exports.evaluateExpect = exports.evaluateDialogExpansion = exports.evaluateEnd = exports.evaluateExpression = exports.evaluateFlow = exports.evaluateDialogFlow = void 0;
const ask = __importStar(require("./ast"));
const ast_1 = require("./ast");
const error_1 = require("./error");
const error_factory_1 = require("./error-factory");
const util_1 = require("./util");
/**
 * Validates that the Dialog is deployable. A deployable dialog is one that accepts no arguments and returns `Nothing` or `Void`.
 */
function evaluateDialogFlow(flow, state) {
    // TODO: validate that it does not accept arguments
    var _a, _b;
    return [
        evaluateFlow(flow, state).map((state) => state.errors),
        (_b = (_a = flow.expression.samples) === null || _a === void 0 ? void 0 : _a.map((sample) => (0, exports.validateSampleStartWithInvoke)(flow.step(sample), state))) !== null && _b !== void 0 ? _b : [],
    ].flat(2);
}
exports.evaluateDialogFlow = evaluateDialogFlow;
/**
 * Validates that the data flow is correct.
 *
 * @param node
 * @param flow
 * @returns
 */
function evaluateFlow(flow, state) {
    return flow.interpret(function evaluate(expr, nextState = state) {
        if (expr.isEnd()) {
            return evaluateEnd(expr, nextState.pushExpr(expr));
        }
        nextState = evaluateExpression(expr, nextState).pushExpr(expr);
        if (nextState.isCircular) {
            // detected a circular reference, stop execution.
            return nextState;
        }
        return (next) => evaluate(next, nextState);
    }, undefined);
}
exports.evaluateFlow = evaluateFlow;
function evaluateExpression(expr, state) {
    if (!expr.isStart() && !expr.canFollowDelegation()) {
        state = state.withError(...(0, exports.validatePriorDelegation)(expr));
    }
    if (expr.isExpect()) {
        return (0, exports.evaluateExpect)(expr, state);
    }
    if (expr.isResponse()) {
        return (0, exports.evaluateResponse)(expr, state);
    }
    if (expr.isConfirmAction()) {
        return (0, exports.evaluateConfirmAction)(expr, state);
    }
    if (expr.isConfirmArgs()) {
        return (0, exports.evaluateConfirmArgs)(expr, state);
    }
    if (expr.isEnsure()) {
        return (0, exports.evaluateEnsure)(expr, state);
    }
    if (expr.isInvokeApi()) {
        return (0, exports.evaluateInvokeApi)(expr, state);
    }
    if (expr.isConditionalBranch()) {
        return (0, exports.evaluateConditionalBranch)(expr, state);
    }
    if (expr.isDelegateRequest()) {
        return (0, exports.evaluateDelegateRequest)(expr, state);
    }
    if (expr.isDelegateToIntent()) {
        return (0, exports.evaluateDelegateToIntent)(expr, state);
    }
    if (expr.isDialogExpansion()) {
        return evaluateDialogExpansion(expr, state);
    }
    return state;
}
exports.evaluateExpression = evaluateExpression;
/**
 * Called at the end of a single dialog flow. During evaluation, we often delay validation until
 * the end as an optimization. For example, checking if an argument is requested - if the ensure()
 * block is called later on in the dialog flow, we don't want to be searching forward all the time
 * because searching forward is slow. Instead, we track that in {@link EvaluationState} and then
 * perform the validation here. This reduces the time complexity significantly.
 */
function evaluateEnd(endExpr, state) {
    return state.withError(...validateLastExpressionEndsTurn(), ...evaluatePendingRequestPromptValidations());
    function isFlowExpressionTerminal(flow) {
        var _a;
        if (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
            const apply = flow.checker.getApply(flow === null || flow === void 0 ? void 0 : flow.expression);
            return (apply === null || apply === void 0 ? void 0 : apply.isResponse()) || (apply === null || apply === void 0 ? void 0 : apply.isDelegateToIntent()) || (apply === null || apply === void 0 ? void 0 : apply.isDelegateRequest());
        }
        return false;
    }
    // Validates the last expression in a sample is a response call or a return value from a reusable
    // dialog, or a delegate request.
    function validateLastExpressionEndsTurn() {
        var _a, _b;
        // The last flow containing an expression in the dialog sample
        const lastFlow = endExpr.flow.prev;
        if (isFlowExpressionTerminal(lastFlow)) {
            return [];
        }
        const isLastExprFromDialogCall = isFlowFromDialogCall(lastFlow);
        // Handle when a sample ends with a name reference and not a response call, in which case
        // we need to ensure the name reference is from a reusable dialog call that ends with response call/return value.
        if (((_a = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" && isLastExprFromDialogCall) {
            // The flow containing the second to last expression in the dialog sample
            let prevFlow = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.prev;
            // Go up the flow stack until we hit the previous expression
            while (((_b = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.expression) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                prevFlow = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.prev;
            }
            if (isFlowExpressionTerminal(prevFlow)) {
                return [];
            }
        }
        const errorFactory = isLastExprFromDialogCall
            ? error_factory_1.ValidationErrorFactory.InvalidLastExpressionInSampleFromDialogCall
            : error_factory_1.ValidationErrorFactory.InvalidLastExpressionInSample;
        return [errorFactory({ expr: lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression })];
    }
    /**
     * Under the right conditions produces one error message for each string in paths
     * @param expr API with error
     * @param argument argument that gave origin to the paths
     * @param paths paths where an error should be produced
     * @returns the errors for the paths
     */
    function getPendingRequestValidationError(expr, argument, paths) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        if (expr.isInvokeApi()) {
            if (argument.argumentName !== undefined) {
                const argValue = (_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue(argument);
                return paths.map((path) => {
                    var _a;
                    return error_factory_1.ValidationErrorFactory.MissingRequestPromptForRequiredApiArgument({
                        expr: argValue,
                        attributes: { argumentName: path, actionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName },
                    });
                });
            }
            else {
                return [];
            }
        }
        else if (expr.isEnsure() || expr.isConfirmArgs()) {
            const errors = [];
            const requestArgs = expr.isEnsure() ? expr.requestArgs : expr.confirmArgs;
            if (requestArgs !== undefined) {
                const items = requestArgs.getItems();
                if (items !== undefined) {
                    for (let requestArgumentsIndex = 0; requestArgumentsIndex < items.length; requestArgumentsIndex++) {
                        const requestArg = items[requestArgumentsIndex];
                        const args = (_b = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValueThing("arguments");
                        const argsNode = (_c = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("arguments");
                        if ((args === null || args === void 0 ? void 0 : args.isLiteral()) && args.isList()) {
                            const argsList = args.getItems();
                            if (argsList !== undefined) {
                                for (let argIndex = 0; argIndex < argsList.length; argIndex++) {
                                    const thisArg = argsList[argIndex];
                                    if (thisArg === argument) {
                                        const requestArgsNode = (_d = expr.apply) === null || _d === void 0 ? void 0 : _d.getArgumentValue(expr.isEnsure() ? "requestArgs" : "confirmArgs");
                                        let loc = expr.loc; // default to the entire `ensure` block
                                        loc = (_e = requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.loc) !== null && _e !== void 0 ? _e : loc;
                                        if ((requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.kind) === "Call" && ask.isListLiteral(requestArgsNode.arguments)) {
                                            // in-lined list, `ensure(RequestArguments { .. }, RequestArguments { .. }, ..)`
                                            const requestArgNode = requestArgsNode.arguments.items[requestArgumentsIndex].item;
                                            loc = (_f = requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.loc) !== null && _f !== void 0 ? _f : loc;
                                            if ((requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.kind) === "Call") {
                                                // this is the RequestArguments { .. } node, it is still inline so let's try and make the error even more granular
                                                loc = (_g = argsNode === null || argsNode === void 0 ? void 0 : argsNode.loc) !== null && _g !== void 0 ? _g : loc;
                                                if ((argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                                                    loc = (_h = argsNode.arguments.items[argIndex].item) === null || _h === void 0 ? void 0 : _h.loc;
                                                }
                                            }
                                        }
                                        errors.push(...paths.map((path) => {
                                            const errorArgument = {
                                                expr: { loc: loc !== null && loc !== void 0 ? loc : expr.loc, uri: expr.uri },
                                                attributes: {
                                                    argumentName: path,
                                                },
                                            };
                                            return expr.isEnsure()
                                                ? error_factory_1.ValidationErrorFactory.MissingRequestPromptForMultipleArguments(errorArgument)
                                                : error_factory_1.ValidationErrorFactory.MissingRequestPromptForConfirmArgs(errorArgument);
                                        }));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return errors;
        }
        else {
            // do our best to resolve the location of the argument missing the request prompt
            let loc = (_k = (_j = expr.actNode) === null || _j === void 0 ? void 0 : _j.loc) !== null && _k !== void 0 ? _k : expr.loc;
            // options:
            // response(Request { arguments = [ Foo.arguments.arg ] })
            // response(Request { arguments = nameRef })
            // response(nameRef)
            if (((_l = expr.actNode) === null || _l === void 0 ? void 0 : _l.kind) === "Call") {
                const argsNode = (_o = (_m = expr.act) === null || _m === void 0 ? void 0 : _m.apply) === null || _o === void 0 ? void 0 : _o.getArgumentValue("arguments");
                const args = (_s = (_r = (_q = (_p = expr.act) === null || _p === void 0 ? void 0 : _p.apply) === null || _q === void 0 ? void 0 : _q.getArgumentValueThing("arguments")) === null || _r === void 0 ? void 0 : _r.asLiteralList()) === null || _s === void 0 ? void 0 : _s.getItems();
                if (args !== undefined && (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                    for (const [i, arg] of args.entries()) {
                        if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && arg === argument) {
                            loc = (_u = (_t = argsNode.arguments) === null || _t === void 0 ? void 0 : _t.items) === null || _u === void 0 ? void 0 : _u[i].loc;
                            break;
                        }
                    }
                }
            }
            let errorExpr = (0, error_factory_1.getExpressionIfLocField)(expr.actNode, expr);
            if ((_w = (_v = expr.act) === null || _v === void 0 ? void 0 : _v.apply) === null || _w === void 0 ? void 0 : _w.isConfirmArgsAct()) {
                return paths.map((path) => error_factory_1.ValidationErrorFactory.MissingRequestPromptForConfirmArgs({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            else if (((_y = (_x = expr.act) === null || _x === void 0 ? void 0 : _x.apply) === null || _y === void 0 ? void 0 : _y.isRequestArguments()) || ((_0 = (_z = expr.act) === null || _z === void 0 ? void 0 : _z.apply) === null || _0 === void 0 ? void 0 : _0.isRequestAct())) {
                return paths.map((path) => error_factory_1.ValidationErrorFactory.MissingRequestPromptForMultipleArguments({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            return [];
        }
    }
    function evaluatePendingRequestPromptValidations() {
        const returnValue = [];
        const pendingRequests = Array.from(state.pendingRequestPromptValidation.entries());
        for (const [api, argumentsMap] of pendingRequests) {
            const sortedArgumentsAndPaths = Array.from(argumentsMap.entries())
                .map((argumentAndSet) => ({ argument: argumentAndSet[0], paths: Array.from(argumentAndSet[1]) }))
                .sort((a, b) => a.argument.argumentName.localeCompare(b.argument.argumentName));
            for (const argumentAndPaths of sortedArgumentsAndPaths) {
                returnValue.push(...getPendingRequestValidationError(api, argumentAndPaths.argument, argumentAndPaths.paths));
            }
        }
        return returnValue;
    }
}
exports.evaluateEnd = evaluateEnd;
function evaluateDialogExpansion(expr, state) {
    var _a, _b, _c;
    if (state.hasExpandedDialog(expr)) {
        const apply = expr.apply;
        for (const node of expr.flow.stack) {
            if (node.kind === "Call") {
                const prevApply = expr.flow.checker.getApply(node);
                if (apply.getName() === (prevApply === null || prevApply === void 0 ? void 0 : prevApply.getName())) {
                    const validationErrorExpr = (0, error_factory_1.getExpressionIfLocField)((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call);
                    return state.withCircular(true).withError(apply.decl.kind === "DialogDeclaration"
                        ? error_factory_1.ValidationErrorFactory.CircularReferenceDialog({
                            expr: validationErrorExpr,
                            attributes: {
                                dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                            },
                        })
                        : error_factory_1.ValidationErrorFactory.CircularReferenceName({
                            expr: validationErrorExpr,
                            attributes: {
                                name: (_c = apply.decl.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }), ...collectCallStackErrors(expr.flow));
                }
            }
        }
    }
    return state;
}
exports.evaluateDialogExpansion = evaluateDialogExpansion;
function collectCallStackErrors(flow) {
    var _a, _b;
    if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
        return [];
    }
    if (flow.expression.kind === "Call") {
        const apply = flow.checker.getApply(flow.expression);
        if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
            return [
                error_factory_1.ValidationErrorFactory.CircularReferenceDialog({
                    expr: (0, error_factory_1.getExpressionIfLocField)((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call),
                    attributes: {
                        dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
                ...flow.visitPrevious(collectCallStackErrors),
            ];
        }
    }
    return flow.visitPrevious(collectCallStackErrors);
}
/**
 * Validate the prior lines to expect.
 *
 * 1. `Invoke` must be first event or follow response with `Request`, `Notify`, `Offer`, `ReqMore`, or `ReqAlt` Acts. TODO: we must verify if it is valid to follow `Request` - our tests used this case but it is documented as invalid.
 * 2. `Affirm` or `Deny` must follow response with `ConfirmArgs`, `ConfirmAction`, `Offer` Acts or `confirmAction`.
 * 3. `Inform` must follow response with `Request` or `ReqAlt` Acts.
 *
 * @param expect expect being evaluated
 * @param expectActType expect's actType
 * @param expectActValue expect's act argument value from expect.apply?.getArgumentValue("act")
 * @param stateExpressionStack expression stack from the state
 * @returns errors from lines prior tp expect
 */
function validateEventPriorToExpect(expect, expectActType, expectActValue, stateExpressionStack) {
    var _a, _b;
    if (!expectActType) {
        return [];
    }
    for (const expr of stateExpressionStack) {
        if (expr.isInvokeApi() || expr.isExpect()) {
            const errorArguments = {
                expr: expectActValue,
                attributes: {
                    requestAct: expectActType.toString(expectActValue),
                },
            };
            if (expectActType.isInvoke()) {
                // TODO: verify if Invoke can follow 'Request' act.
                return [error_factory_1.ValidationErrorFactory.InvalidEventInvoke(errorArguments)];
            }
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [error_factory_1.ValidationErrorFactory.InvalidEventAffirmOrDeny(errorArguments)];
            }
            if (expectActType.isInform()) {
                return [error_factory_1.ValidationErrorFactory.InvalidEventInform(errorArguments)];
            }
            // catch all, we should never reach here since we first validate that expectActType is Invoke, Inform, Affirm or Deny
            return [error_factory_1.ValidationErrorFactory.InvalidEvent(errorArguments)];
        }
        if (expr.isEnsure() || expr.isDialogExpansion() || expr.isConfirmArgs() || expr.isBlock() || expr.isConditionalBranch()) {
            // ignore these calls since they do not affect the user/alexa lines.
            // TODO: why ignore ConfirmArgs?
            // return [];
        }
        else if (expr.isConfirmAction()) {
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [];
            }
            return [
                error_factory_1.ValidationErrorFactory.InvalidEventFollowingConfirmAction({
                    expr: expectActValue,
                    attributes: {
                        requestAct: expectActType.toString(expect.node),
                    },
                }),
            ];
        }
        else if (expr.isDelegateToIntent() || expr.isDelegateRequest()) {
            return [];
        }
        else if (expr.isResponse()) {
            const nextRequestActType = (_a = expr.nextAct) === null || _a === void 0 ? void 0 : _a.type;
            let requestActType = (_b = expr.act) === null || _b === void 0 ? void 0 : _b.type;
            if (nextRequestActType && !(nextRequestActType.isNothing() || nextRequestActType.isVoid())) {
                requestActType = nextRequestActType;
            }
            if (requestActType === undefined) {
                // could not resolve the request act, so ignore these validations
                return [];
            }
            if (requestActType.isOffer()) {
                // all dialog acts can follow Offer
                return [];
            }
            if (requestActType.isConfirmArgs() || requestActType.isConfirmAction()) {
                if (expectActType.isAffirm() || expectActType.isDeny()) {
                    return [];
                }
                return [invalidEventError("Affirm", "Deny")];
            }
            if (requestActType.isNotify() || requestActType.isReqMore() || requestActType.isBye()) {
                if (expectActType.isInvoke()) {
                    return [];
                }
                return [invalidEventError("Invoke")];
            }
            if (requestActType.isReqAlt()) {
                if (expectActType.isInvoke() || expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Invoke", "Inform")];
            }
            if (requestActType.isRequest()) {
                if (expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Inform")];
            }
            function invalidEventError(...expected) {
                const suggestions = expected.length === 1
                    ? `'${expected[0]}'`
                    : `${expected
                        .slice(0, expected.length - 1)
                        .map((e) => `'${e}'`)
                        .join(", ")} or '${expected[expected.length - 1]}'`;
                return error_factory_1.ValidationErrorFactory.InvalidEventResponse({
                    expr: (0, error_factory_1.getExpressionIfLocField)(expectActValue, expect),
                    attributes: {
                        responseAct: expectActType === null || expectActType === void 0 ? void 0 : expectActType.toString(expect.node),
                        requestAct: requestActType === null || requestActType === void 0 ? void 0 : requestActType.toString(expect.node),
                        suggestions,
                    },
                });
            }
        }
    }
    if (expectActType.isInvoke()) {
        return [];
    }
    return [
        error_factory_1.ValidationErrorFactory.InvalidFirstEvent({
            expr: expectActValue,
            attributes: {
                dialogAct: expectActType.toString(expect.node),
            },
        }),
    ];
}
/**
 * Called to perform Inform validations if the expect's act is inform
 * @param expect expect being evaluated
 * @returns errors for expect with Inform act
 */
function validateExpectInform(expect) {
    var _a, _b, _c;
    const errors = [];
    // Each sample sentence in "inform" event should contain at least one slot.
    const eventValue = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("event");
    if (!expect.checker.isNameReference(eventValue)) {
        // this case should already be caught by other validation
        return errors;
    }
    const nameDecl = expect.checker.resolveNameReference(eventValue);
    if (ask.isCall(nameDecl)) {
        const apply = expect.checker.getApply(nameDecl);
        if ((apply === null || apply === void 0 ? void 0 : apply.getName()) === ast_1.AlexaConversations.utterances) {
            let items = [];
            const value = apply.getArgumentValue("samples");
            if (expect.checker.isNameReference(value)) {
                const found = expect.checker.resolveNameReference(value);
                const foundType = expect.checker.getType(value);
                if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                    items = found.arguments.items;
                }
            }
            else if ((value === null || value === void 0 ? void 0 : value.kind) === "Call" && ask.isListLiteral(value.arguments)) {
                items = value.arguments.items;
            }
            for (const item of items) {
                if (item.item === undefined || item.item.kind !== "Call") {
                    // do nothing, because this case should already be caught by other validation
                }
                else if (typeof item.item.arguments === "string" ||
                    (ask.isUtterance(item.item.arguments) && ((_b = item.item.arguments.names) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
                    errors.push(error_factory_1.ValidationErrorFactory.InformUtteranceSampleMissingSlot({
                        expr: (0, error_factory_1.getExpressionIfLocField)((_c = expect.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("event"), expect),
                    }));
                    // only report this error once
                    break;
                }
            }
        }
    }
    return errors;
}
const evaluateExpect = (expect, state) => {
    var _a, _b, _c, _d, _e, _f;
    // for expect action, the RequestAct could only be Invoke, Inform, Affirm or Deny
    const value = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act");
    const actType = expect.getActType();
    if (actType === undefined) {
        // don't do anything when type is undefined as it should be caught by another validator
        return state;
    }
    if (!expect.isInvoke() && !expect.isInform() && !expect.isAffirm() && !expect.isDeny()) {
        return state.withError(error_factory_1.ValidationErrorFactory.InvalidRequestAct({
            expr: value,
            attributes: { actName: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
        }));
    }
    if ((actType.isAffirm() || actType.isDeny()) && ((_c = (_b = expect.event) === null || _b === void 0 ? void 0 : _b.apply) === null || _c === void 0 ? void 0 : _c.isUtterances())) {
        const utteranceType = (_f = (_e = (_d = expect.event) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getReturnType()) === null || _f === void 0 ? void 0 : _f.getUtteranceEventType();
        if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isNothing()) && !(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isThing())) {
            return state.withError(error_factory_1.ValidationErrorFactory.ExpectedEmptyRequestActType({
                expr: value,
                attributes: { typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName, actType: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
            }));
        }
        if (actType.isDeny()) {
            // resets pending offer if action is not affirmed
            state = state.clearPendingOffer();
        }
    }
    const eventErrors = validateEventPriorToExpect(expect, actType, value, state.expressionStack);
    if (actType.isInform()) {
        return state.withError(...eventErrors, ...validateExpectInform(expect));
    }
    return state.withError(...eventErrors);
};
exports.evaluateExpect = evaluateExpect;
/**
 * Validate DelegateRequest action used in dialog sample.
 *
 * - `delegateRequest`'s cannot be chained together.
 * - slots must come from an event or api call, optionally wrapped in a complex object.
 */
const evaluateDelegateRequest = (requestExpression, state) => {
    var _a, _b, _c, _d;
    const errors = [];
    if ((_b = (_a = requestExpression.updatedRequest) === null || _a === void 0 ? void 0 : _a.apply) === null || _b === void 0 ? void 0 : _b.isIntentRequest()) {
        const slots = ((_c = requestExpression.updatedRequest) === null || _c === void 0 ? void 0 : _c.isObject()) ? requestExpression.updatedRequest.getProperty("slots") : undefined;
        const genericArguments = (_d = requestExpression.updatedRequest.type.genericArguments) !== null && _d !== void 0 ? _d : [];
        const expectedSlotsType = genericArguments[0];
        evaluateUpdatedIntentRequest(requestExpression, expectedSlotsType, slots, errors);
    }
    return state.withError(...errors);
};
exports.evaluateDelegateRequest = evaluateDelegateRequest;
/**
 * Validate DelegateToIntent action used in dialog sample.
 *
 * - `delegateToIntent`'s cannot be chained together.
 * - slots must come from an event or api call, optionally wrapped in a complex object.
 */
const evaluateDelegateToIntent = (requestExpression, state) => {
    var _a;
    const errors = [];
    const genericArguments = (_a = requestExpression.apply.getGenericArguments()) !== null && _a !== void 0 ? _a : [];
    const expectedSlotsType = genericArguments[0];
    evaluateUpdatedIntentRequest(requestExpression, expectedSlotsType, requestExpression.slots, errors);
    return state.withError(...errors);
};
exports.evaluateDelegateToIntent = evaluateDelegateToIntent;
/**
 * Validate the slots of updated intent request passed to a delegation action.
 *
 * @param requestExpression Delegation action.
 * @param slots Value of slots to validate.
 * @param errors Mutable error list to append any errors found.
 */
const evaluateUpdatedIntentRequest = (requestExpression, expectedSlotsType, slots, errors) => {
    if (slots !== undefined && !slots.isNothing()) {
        const requestExpressionName = requestExpression.apply.getName();
        const callName = requestExpressionName ? (0, util_1.getName)(requestExpressionName) : undefined;
        if (expectedSlotsType === undefined || expectedSlotsType.isThing()) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidDelegationArgumentType({
                expr: requestExpression,
                attributes: {
                    callName,
                },
            }));
        }
        if (!originatesFromApiOrEvent(slots)) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidDelegationSlots({
                expr: requestExpression,
                attributes: {
                    callName,
                },
            }));
        }
    }
};
/**
 * Determines whether the thing values originate from API or event.
 * Complex objects and lists whose leaf values originate from API or event are also considered as valid.
 *
 * @param thing Thing to verify.
 * @param listAllowed Indicates whether lists are allowed. By default, lists are not allowed at top level.
 * @param allowedDepth Allowed depth of complex objects. By default, set to one to prevent nested complex objects.
 * @returns Whether the thing values originate from API or event.
 */
const originatesFromApiOrEvent = (thing, listAllowed = false, allowedDepth = 1) => {
    var _a, _b;
    // lists are not allowed at top level
    if (!listAllowed && ((_a = thing === null || thing === void 0 ? void 0 : thing.apply) === null || _a === void 0 ? void 0 : _a.isList())) {
        return false;
    }
    const originType = getOriginType(thing);
    // values coming from API or event are valid
    if (isFromOrigin(originType, "event", "api")) {
        return true;
    }
    // otherwise, it has to be either a complex object/list with values that originate from API or event
    if (!isFromOrigin(originType, "literal") || !(thing.isObject() || thing.isList())) {
        return false;
    }
    // in the first implementation, the complex objects within complex objects are not allowed (allowedDepth === 1)
    if (allowedDepth < 0 || (thing.isObject() && allowedDepth === 0)) {
        return false;
    }
    // for lists, all item values have to comply with same constraints
    if (thing.isList()) {
        const items = (_b = thing.asList()) === null || _b === void 0 ? void 0 : _b.getItems();
        if (items === undefined || items.length === 0) {
            return false;
        }
        for (const value of items) {
            // not sure when the item value can be undefined, so report an error in such case
            if (value === undefined) {
                return false;
            }
            // evaluate the value recursively with same allowed depth
            if (!originatesFromApiOrEvent(value, true, allowedDepth - 1)) {
                return false;
            }
        }
        return true;
    }
    // for complex objects, all field values have to comply with same constraints
    if (thing.isObject()) {
        const obj = thing.apply;
        if (obj === undefined) {
            return false;
        }
        for (const value of Object.values(obj.getArgumentsThing())) {
            // not sure when the field value can be undefined, so report an error in such case
            if (value === undefined) {
                return false;
            }
            // evaluate the value recursively with decreased allowed depth
            if (!originatesFromApiOrEvent(value, true, allowedDepth - 1)) {
                return false;
            }
        }
        return true;
    }
    return false;
};
/**
 * Validate Response action used in dialog sample
 * including specific validations to the four args (Response, ResponseAct, next ResponseAct, Payload)
 * and make sure those args are used in allowed combination
 */
const evaluateResponse = (response, state) => (0, exports.validateResponseAct)(response, state.withRequestedArguments(false, ...response.getIndividuallyRequestedArguments())).withError(
// 2. validations for the nextAct
...(0, exports.validateNextAct)(response, state), 
// 3. validations for the payload
...(0, exports.validatePayload)(response, state), 
// 4. validations for the prompt
...(0, exports.validatePrompt)(response.apply), ...(0, exports.validatePriorResponseCall)(response));
exports.evaluateResponse = evaluateResponse;
/**
 * Validate the act used in response action
 * 1. The act could only be one of valid ResponseAct: 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'
 * 2. ReqAlt cannot be the first act
 * 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
 * 4. for ConfirmArgs, make sure the payload property exist in argument list
 */
const validateResponseAct = (response, state) => {
    var _a, _b;
    const { act } = response;
    const actNode = response.apply.getArgumentValue("act");
    if (act === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return state;
    }
    // 1. The act could only be one of valid ResponseAct
    if (!act.type.isResponseAct()) {
        state = state.withError(error_factory_1.ValidationErrorFactory.InvalidDialogActArgument({
            expr: actNode,
            attributes: {
                dialogAct: act.type.toString(actNode),
            },
        }));
    }
    if (act.type.isConfirmAction()) {
        state = (0, exports.evaluateConfirmAction)(response, state);
    }
    // 2. ReqAlt cannot be the first act
    if (act.type.isReqAlt()) {
        state = state.withError(error_factory_1.ValidationErrorFactory.InvalidReqAltFirstAct({
            expr: actNode,
        }));
    }
    // 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
    if (act.isObject() && act.type.isConfirmArgs()) {
        const preErrorCount = state.errors.length;
        state = (0, exports.validateConfirmArgsAct)(response, state);
        // 4. for ConfirmArgs, make sure the payload property exist in argument list
        if (preErrorCount === state.errors.length) {
            if (act.isObject()) {
                const args = act.getProperty("arguments");
                const nameSet = new Set();
                if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
                    args.apply.call.arguments.items.forEach((item) => {
                        var _a, _b, _c, _d, _e;
                        if (response.checker.isNameReference(item.item)) {
                            const nameDecl = response.checker.resolveNameReference(item.item);
                            if ((nameDecl === null || nameDecl === void 0 ? void 0 : nameDecl.kind) !== undefined && nameDecl.kind === "PropertyReference" && ((_a = nameDecl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined) {
                                nameSet.add(nameDecl.name.name);
                            }
                        }
                        else if (((_b = item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                            if (((_d = (_c = item.item) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) !== undefined) {
                                nameSet.add((_e = item.item) === null || _e === void 0 ? void 0 : _e.name.name);
                            }
                        }
                    });
                }
                const payloadValue = response.apply.getPayloadValue();
                if ((payloadValue === null || payloadValue === void 0 ? void 0 : payloadValue.kind) === "Call") {
                    const payloadApply = response.checker.getApply(payloadValue);
                    if (payloadApply !== undefined && payloadApply.call.arguments !== undefined && Array.isArray(payloadApply.call.arguments)) {
                        for (const args of payloadApply.call.arguments) {
                            const name = typeof args.name === "string" ? args.name : (_a = args.name) === null || _a === void 0 ? void 0 : _a.name;
                            if (name !== undefined) {
                                if (!nameSet.has(name)) {
                                    state = state.withError(error_factory_1.ValidationErrorFactory.MismatchedConfirmArgsPayloadProperty({
                                        expr: payloadValue,
                                        attributes: {
                                            propertyName: name,
                                        },
                                    }));
                                }
                                else {
                                    nameSet.delete(name);
                                }
                            }
                        }
                        if (nameSet.size > 0) {
                            for (const name of nameSet) {
                                state = state.withError(error_factory_1.ValidationErrorFactory.MissingConfirmedArgsInPayload({
                                    expr: payloadValue,
                                    attributes: {
                                        argumentName: name,
                                    },
                                }));
                            }
                        }
                    }
                }
            }
        }
    }
    // 4. OfferAct arguments should belong to the Offered actionName
    if (act.isObject() && act.type.isOffer()) {
        const offerActionName = act.getProperty("actionName");
        const offerArguments = act.getProperty("arguments");
        const offerArgumentsNode = act.apply.getArgumentValue("arguments");
        if (offerArguments === undefined || offerActionName === undefined || !offerActionName.isAction()) {
            if (offerActionName) {
                return (0, exports.addPendingOfferIfAction)(act, state);
            }
            return state; // should not happen as actionName for Offer act is required
        }
        // return errors; // should not happen as the arguments for Offer act must be a List Call
        if (offerArguments.isList() && offerArguments.isLiteral()) {
            offerArguments.apply.call.arguments.items.forEach((arg, i) => {
                var _a, _b, _c, _d, _e;
                const argItem = response.checker.isNameReference(arg.item)
                    ? response.checker.resolveNameReference(arg.item)
                    : arg.item;
                if (!ask.isPropRef(argItem)) {
                    return; // TODO: check if "Call" can be assigned to argument(s)
                }
                // determine the precise location for this error
                let expr = response;
                if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                    expr = (0, error_factory_1.getExpressionIfLocField)(actNode, expr);
                    if ((offerArgumentsNode === null || offerArgumentsNode === void 0 ? void 0 : offerArgumentsNode.kind) === "Call") {
                        expr = (0, error_factory_1.getExpressionIfLocField)(offerArgumentsNode, expr);
                        if (ask.isListLiteral(offerArgumentsNode.arguments)) {
                            expr = (0, error_factory_1.getExpressionIfLocField)((_b = (_a = offerArgumentsNode.arguments) === null || _a === void 0 ? void 0 : _a.items[i]) === null || _b === void 0 ? void 0 : _b.item, expr);
                        }
                    }
                }
                const argValueStr = argItem.printPropertyChainThroughRoot();
                const argThing = response.checker.getThing(arg);
                if (((_d = (_c = argThing === null || argThing === void 0 ? void 0 : argThing.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.isAction()) && !argThing.parent.parent.equals(offerActionName)) {
                    state = state.withError(error_factory_1.ValidationErrorFactory.MismatchedActionArgumentsListValue({
                        expr,
                        attributes: {
                            argumentValue: argValueStr,
                            actionName: (_e = offerActionName.origin.name) === null || _e === void 0 ? void 0 : _e.name,
                        },
                    }));
                }
            });
        }
        // Offer.carryOverArguments
        const offerCarryoverArguments = act.getProperty("carryOverArguments");
        const offerCarryoverArgumentsNode = act.apply.getArgumentValue("carryOverArguments");
        if (offerCarryoverArguments === undefined || !offerCarryoverArguments.isList() || !offerCarryoverArguments.isLiteral()) {
            return state; // should not happen as the arguments for Offer act must be a List Call
        }
        (_b = offerCarryoverArguments.getItems()) === null || _b === void 0 ? void 0 : _b.forEach((carryOverArgument, i) => {
            var _a, _b, _c, _d, _e, _f;
            if ((carryOverArgument === null || carryOverArgument === void 0 ? void 0 : carryOverArgument.isObject()) && carryOverArgument.isLiteral()) {
                const arg = carryOverArgument.getProperty("argument");
                if ((arg === null || arg === void 0 ? void 0 : arg.type.isArgument()) && ((_b = (_a = arg.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction())) {
                    if (!arg.parent.parent.equals(offerActionName)) {
                        const carryOverValueStr = ask.isPropRef((_c = arg.origin) === null || _c === void 0 ? void 0 : _c.context) ? arg.origin.context.printPropertyChainThroughRoot() : "todo";
                        // determine the most precise location for the argument's error.
                        // TODO: this is gross, refactor it
                        let expr = response;
                        if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                            expr = (0, error_factory_1.getExpressionIfLocField)(actNode, expr);
                            if ((offerCarryoverArgumentsNode === null || offerCarryoverArgumentsNode === void 0 ? void 0 : offerCarryoverArgumentsNode.kind) === "Call") {
                                expr = (0, error_factory_1.getExpressionIfLocField)(offerCarryoverArgumentsNode, expr);
                                if (ask.isListLiteral(offerCarryoverArgumentsNode.arguments)) {
                                    const carryOverArgNode = (_e = (_d = offerCarryoverArgumentsNode.arguments) === null || _d === void 0 ? void 0 : _d.items[i]) === null || _e === void 0 ? void 0 : _e.item;
                                    if (carryOverArgNode !== undefined) {
                                        expr = (0, error_factory_1.getExpressionIfLocField)(carryOverArgNode, expr);
                                        if (carryOverArgNode.kind === "Call") {
                                            expr = (0, error_factory_1.getExpressionIfLocField)(carryOverArgument.apply.getArgumentValue("argument"), expr);
                                        }
                                    }
                                }
                            }
                        }
                        state = state.withError(error_factory_1.ValidationErrorFactory.MismatchedActionCarryOverArguments({
                            expr,
                            attributes: {
                                carryOverValue: carryOverValueStr,
                                actionName: (_f = offerActionName.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                            },
                        }));
                    }
                }
            }
        });
        return state;
    }
    // 5. validate ConfirmAction Act
    // if (act.type.isConfirmAction()) {
    //   errors.push(...validateConfirmAction(apply, checker));
    // }
    // 6. validate Request Act
    if (act.type.isRequest()) {
        const args = act.getProperty("arguments");
        if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
            state = state.withError(...validateArgumentList(act.apply.getArgumentValue("arguments"), act.getProperty("arguments")));
        }
        // If the argList contains multiple args, make sure each arg has request prompt
        state = (0, exports.validateRequestPromptInArgsList)(response, act, state);
    }
    // 7. For Notify Act, it can only use the last API action name and an API call can only be notified once
    if (act.type.isNotify() && act.isObject() && act.isLiteral()) {
        // const actValueApply = act.apply;
        const actionDecl = act.getProperty("actionName");
        if (actionDecl === null || actionDecl === void 0 ? void 0 : actionDecl.isAction()) {
            const validateNotify = (expr) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                if (expr === undefined) {
                    return [
                        error_factory_1.ValidationErrorFactory.InvalidNotifyActionNameUnusedAction({
                            expr: response,
                            attributes: {
                                actionName: (_a = actionDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                            },
                        }),
                    ];
                }
                if (expr.isInvokeApi()) {
                    const actionName = (_b = expr.action) === null || _b === void 0 ? void 0 : _b.actionName;
                    if (actionName && actionName !== ((_c = actionDecl.name) === null || _c === void 0 ? void 0 : _c.name)) {
                        return [
                            error_factory_1.ValidationErrorFactory.InvalidNotifyActionNameLastAction({
                                expr: (0, error_factory_1.getExpressionIfLocField)((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call" ? (_e = (_d = response.apply.getArgumentValueThing("act")) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValue("actionName") : actNode, response),
                                attributes: {
                                    currentActionName: (_f = actionDecl.name) === null || _f === void 0 ? void 0 : _f.name,
                                    previousActionName: actionName,
                                },
                            }),
                        ];
                    }
                    return [];
                }
                if (expr.isResponse()) {
                    const actionName = (_g = actionDecl.name) === null || _g === void 0 ? void 0 : _g.name;
                    const { act } = expr;
                    if ((act === null || act === void 0 ? void 0 : act.type.isNotify()) && act.isObject() && act.isLiteral()) {
                        const actionNameProp = act.getProperty("actionName");
                        if ((actionNameProp === null || actionNameProp === void 0 ? void 0 : actionNameProp.isAction()) && actionName === ((_h = actionNameProp.origin.name) === null || _h === void 0 ? void 0 : _h.name)) {
                            return [
                                error_factory_1.ValidationErrorFactory.InvalidNotifyActionNameAlreadyNotified({
                                    expr: response,
                                    attributes: {
                                        actionName: (_j = actionDecl.name) === null || _j === void 0 ? void 0 : _j.name,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return validateNotify(expr.prev);
            };
            state = (0, exports.addPendingOfferIfAction)(response.nextAct, state.withError(...validateNotify(response.prev)));
        }
    }
    return state;
};
exports.validateResponseAct = validateResponseAct;
/**
 * Modifies pending offer state if actionName is provided in Offer
 */
const addPendingOfferIfAction = (act, state) => {
    var _a, _b, _c, _d;
    if (act === null || act === void 0 ? void 0 : act.type.isOffer()) {
        const action = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("actionName");
        if (((_b = action === null || action === void 0 ? void 0 : action.origin) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" && ((_d = (_c = action === null || action === void 0 ? void 0 : action.origin) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name)) {
            return state.withPendingOffer(action.origin.name.name);
        }
    }
    return state;
};
exports.addPendingOfferIfAction = addPendingOfferIfAction;
/**
 * Validate nextAct used in response action
 * 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
 * 2. nextAct could only follow Notify act
 * 3. the ReqAlt act can only be the next Act to a Notify Act with "success = false"
 * 4. for ReqAlt, the items in the "arguments" list should be from the same Action
 * 5. for ReqAlt, actionName used in Notify and ReqAlt argument list should be consistent
 */
const validateNextAct = (response, state) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const errors = [];
    const { act } = response;
    const actArg = response.apply.getArgumentValue("act");
    const actionName = act === null || act === void 0 ? void 0 : act.getProperty("actionName");
    const actType = act === null || act === void 0 ? void 0 : act.type;
    if (actArg === undefined || act === undefined || actType === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return [];
    }
    const { nextAct } = response;
    const nextActArg = response.apply.getArgument("nextAct");
    const nextActType = nextAct === null || nextAct === void 0 ? void 0 : nextAct.type;
    if (nextActArg === undefined || nextAct === undefined || nextActType === undefined || nextActType.isNothing() || nextActType.isVoid()) {
        // don't do anything when type is undefined as it is an optional argument
    }
    else if (!nextActType.isOffer() && !nextActType.isBye() && !nextActType.isReqAlt() && !nextActType.isReqMore()) {
        // 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
        errors.push(error_factory_1.ValidationErrorFactory.InvalidNextAct({
            expr: nextActArg,
            attributes: {
                responseAct: nextActType.toString(nextActArg),
            },
        }));
    }
    else {
        // 2. nextAct could only follow Notify act
        if (!actType.isNotify()) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidNextActNotify({
                expr: actArg,
                attributes: {
                    responseAct: actType.toString(actArg),
                },
            }));
        }
        else {
            // validations for ReqAlt act
            if (nextAct.type.isReqAlt()) {
                const reqAltArguments = nextAct.getProperty("arguments");
                if ((reqAltArguments === null || reqAltArguments === void 0 ? void 0 : reqAltArguments.isList()) && reqAltArguments.isLiteral()) {
                    errors.push(...validateArgumentList((_a = nextAct === null || nextAct === void 0 ? void 0 : nextAct.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("arguments"), nextAct.getProperty("arguments")));
                }
                const successValue = act.getProperty("success");
                if (successValue === undefined || !successValue.isBoolean()) {
                    // should be caught by other validation
                    return errors;
                }
                if (successValue.literal === true) {
                    // 3. The ReqAlt act can only be the next Act to a Notify Act with "success = false"
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidReqAltNextAct({
                        expr: nextActArg,
                    }));
                }
                if (nextAct.isObject() && nextAct.isLiteral()) {
                    const reqAlt = nextAct.getProperty("arguments");
                    const reqAltNode = nextAct.apply.getArgumentValue("arguments");
                    if ((reqAlt === null || reqAlt === void 0 ? void 0 : reqAlt.isList()) && reqAlt.isLiteral()) {
                        const argumentListErrors = validateArgumentList(reqAltNode, reqAlt);
                        if (argumentListErrors.length > 0) {
                            errors.push(...argumentListErrors);
                        }
                        else {
                            // 5. actionName used in Notify and ReqAlt argument list should be consistent
                            // could rely on the first item to retrieve rootExpr cause we already checked the items in the list are from the same Action
                            const item = reqAlt.getItem(0);
                            if (((_c = (_b = item === null || item === void 0 ? void 0 : item.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.isAction()) && (actionName === null || actionName === void 0 ? void 0 : actionName.isAction())) {
                                if (((_d = item.parent.parent.origin.name) === null || _d === void 0 ? void 0 : _d.name) !== ((_e = actionName.origin.name) === null || _e === void 0 ? void 0 : _e.name)) {
                                    errors.push(error_factory_1.ValidationErrorFactory.MismatchedArgsInReqAlt({
                                        expr: reqAltNode,
                                        attributes: {
                                            reqAltActionName: (_f = item.parent.parent.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                                            notifyActionName: (_g = actionName.origin.name) === null || _g === void 0 ? void 0 : _g.name,
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateNextAct = validateNextAct;
/**
 * Validate confirmAction action used in dialog sample
 */
const evaluateConfirmAction = (confirm, state) => {
    var _a, _b, _c, _d, _e;
    let action;
    // location of the ConfirmAction act on which we will attach errors.
    let errorExpr;
    // let actionNameLoc: ask.SourceLocation | undefined;
    if (confirm.isResponse()) {
        if (!((_a = confirm.act) === null || _a === void 0 ? void 0 : _a.type.isConfirmAction())) {
            // why?
            return state;
        }
        const actionName = confirm.act.getProperty("actionName");
        if (actionName === null || actionName === void 0 ? void 0 : actionName.isAction()) {
            action = actionName;
            errorExpr =
                ((_b = confirm.actNode) === null || _b === void 0 ? void 0 : _b.kind) === "Call"
                    ? (0, error_factory_1.getExpressionIfLocField)((_c = confirm.act.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("actionName"), confirm.actNode, confirm)
                    : (0, error_factory_1.getExpressionIfLocField)(confirm.actNode, confirm);
        }
        else {
            return state;
        }
    }
    else if (confirm.isConfirmAction()) {
        action = confirm.actionName;
        errorExpr = (0, error_factory_1.getExpressionIfLocField)((_d = confirm.actionNameNode) === null || _d === void 0 ? void 0 : _d.value, confirm);
    }
    const confirmedPayload = confirm.payload;
    if (action === undefined) {
        return state;
    }
    if (!action.isAction()) {
        return state;
    }
    const actionName = (_e = action.origin.name) === null || _e === void 0 ? void 0 : _e.name;
    return state.withError(...[
        (0, exports.validatePayload)(confirm, state),
        confirm.flow.interpret((expr) => interpret(expr, state), confirm).map((state) => state.errors),
    ].flat(2));
    function interpret(expr, state, foundEvent = false) {
        var _a;
        const errorArguments = {
            expr: errorExpr,
            attributes: {
                actionName,
            },
        };
        const missingApiInvocationError = error_factory_1.ValidationErrorFactory.MissingApiInvocationAfterConfirmAction(errorArguments);
        const missingAffirmOrDenyError = error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmAction(errorArguments);
        if (expr.isEnd()) {
            return state.withError(missingApiInvocationError);
        }
        if (expr.isInvokeApi()) {
            if ((_a = expr.action) === null || _a === void 0 ? void 0 : _a.equals(action)) {
                if (!foundEvent) {
                    return state.withError(missingAffirmOrDenyError);
                }
                if (confirmedPayload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
        }
        else if (expr.isDelegateToIntent() || expr.isDelegateRequest()) {
            return state.withError(error_factory_1.ValidationErrorFactory.InvalidDelegationActionConfirmation(errorArguments));
        }
        else if (expr.isResponse() || expr.isConfirmAction()) {
            return foundEvent ? state.withError(missingApiInvocationError) : state.withError(missingAffirmOrDenyError, missingApiInvocationError);
        }
        else if (expr.isExpect()) {
            const type = expr.getActType();
            if (type !== undefined) {
                if (type.isAffirm() || (type === null || type === void 0 ? void 0 : type.isDeny())) {
                    if (type.isDeny()) {
                        // it's ok for an api call to not proceed a deny.
                        return state;
                    }
                    return (next) => interpret(next, state.pushExpr(expr), true);
                }
                return state.withError(missingAffirmOrDenyError);
            }
        }
        return (next) => interpret(next, state.pushExpr(expr), foundEvent);
    }
};
exports.evaluateConfirmAction = evaluateConfirmAction;
/**
 * Validate confirmArgs action used in dialog sample
 * traverse the confirmArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure all arguments in the argument list refer to the same action
 * 3. Make sure all arguments in the argument list has request prompt
 */
const evaluateConfirmArgs = (confirm, state) => {
    var _a, _b;
    if (confirm.node === undefined) {
        return state;
    }
    const errors = [];
    // const confirmArgs = act.getArgumentValueThing("confirmArgs");
    if (((_a = confirm.confirmArgs) === null || _a === void 0 ? void 0 : _a.isList()) && confirm.confirmArgs.isLiteral()) {
        if (confirm.isResponse())
            errors.push(...(0, exports.validateConfirmArgsFlow)(confirm, state));
        for (const arg of (_b = confirm.confirmArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            if ((arg === null || arg === void 0 ? void 0 : arg.type.isConfirmArguments()) && arg.isObject() && arg.isLiteral()) {
                errors.push(...(0, exports.validatePrompt)(arg.apply));
                const confirmedArgs = arg.getProperty("arguments");
                const confirmedArgsNode = arg.apply.getArgumentValue("arguments");
                if ((confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isList()) && (confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isLiteral())) {
                    // the items in the "arguments" list should be from the same Action
                    errors.push(...validateArgumentList(confirmedArgsNode, confirmedArgs));
                    // Make sure all arguments in the argument list has request prompt
                    state = (0, exports.validateRequestPromptInArgsList)(confirm, arg, state);
                }
            }
        }
    }
    return state.withError(...errors);
};
exports.evaluateConfirmArgs = evaluateConfirmArgs;
/**
 * Validate the ConfirmArgs act used in response action
 * 1. make sure the items in the "arguments" list should be from the same Action
 * 2. make sure all arguments in the argument list has request prompt
 * 3. make sure there exist Affirm or Deny event after ConfirmArgs Act
 * 4. make sure the next api call is consistent with the action whose arguments are been confirmed
 * @param response
 * @param confirmArgsAct
 * @param branch
 */
const validateConfirmArgsAct = (confirm, state) => {
    var _a, _b;
    const errors = [];
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    const argsNode = (_b = confirm.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValue("act");
    if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
        const argumentListErrors = validateArgumentList(argsNode, args);
        errors.push(...argumentListErrors);
        // when all arguments in the list are from the same action
        // make sure the next api call is consistent with the action whose arguments are been confirmed
        if (argumentListErrors.length === 0) {
            errors.push(...(0, exports.validateConfirmArgsFlow)(confirm, state));
        }
        // Make sure all arguments in the argument list has request prompt
        state = (0, exports.validateRequestPromptInArgsList)(confirm, confirm.act, state);
    }
    return state.withError(...errors);
};
exports.validateConfirmArgsAct = validateConfirmArgsAct;
/**
 * The next api call after Confirm Args dialog act must be consistent with the action which is been confirmed.
 */
const validateConfirmArgsFlow = (confirm, state) => {
    var _a, _b, _c;
    let actionDeclaration = undefined;
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    if (args === null || args === void 0 ? void 0 : args.isList()) {
        for (const arg of (_b = args.getItems()) !== null && _b !== void 0 ? _b : []) {
            const argItem = arg === null || arg === void 0 ? void 0 : arg.asArgument();
            if (!argItem) {
                continue;
            }
            actionDeclaration = argItem.getReferencedActionArgumentActionDeclaration();
            if (actionDeclaration) {
                break;
            }
        }
    }
    else if (args === null || args === void 0 ? void 0 : args.isUnion()) {
        // TODO: validate each variation of the arguments.
        // return state;
        throw new Error("should be impossible.");
    }
    if (actionDeclaration === undefined) {
        return [];
    }
    const actionName = (_c = actionDeclaration.name) === null || _c === void 0 ? void 0 : _c.name;
    const errorExpr = (0, error_factory_1.getExpressionIfLocField)(confirm.apply.getArgumentValue("act"), confirm);
    return confirm.flow
        .interpret((expr) => visit(expr, state), confirm)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state, affirmed = false) {
        var _a;
        const { flow } = expr;
        const missingEventAfterConfirmArgsError = error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
            expr: errorExpr,
            attributes: {
                actionName,
            },
        });
        if (expr.isEnd()) {
            const missingApiError = error_factory_1.ValidationErrorFactory.MissingApiInvocationAfterConfirmArgs({
                expr: errorExpr,
                attributes: {
                    actionName,
                },
            });
            return affirmed ? state.withError(missingApiError) : state.withError(missingEventAfterConfirmArgsError, missingApiError);
        }
        if (expr.isAction()) {
            if (expr === null || expr === void 0 ? void 0 : expr.isInvokeApi()) {
                if (!affirmed) {
                    return state.withError(missingEventAfterConfirmArgsError, error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeCall({
                        expr,
                        attributes: {
                            calledActionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName,
                            confirmedActionName: actionName,
                        },
                    }));
                }
                if (confirm.payload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
            if (expr.isExpect() && !affirmed) {
                const actType = expr.getActType();
                if ((actType === null || actType === void 0 ? void 0 : actType.isAffirm()) || (actType === null || actType === void 0 ? void 0 : actType.isDeny())) {
                    if (actType.isDeny()) {
                        return state;
                    }
                    return (next) => visit(next, state.pushExpr(expr), true);
                }
                if (actType) {
                    return state.withError(missingEventAfterConfirmArgsError, error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeExpect({
                        expr,
                        attributes: {
                            actionName,
                            requestAct: actType.toString(flow.expression),
                        },
                    }));
                }
            }
            else if (!affirmed && ((expr === null || expr === void 0 ? void 0 : expr.isResponse()) || (expr === null || expr === void 0 ? void 0 : expr.isConfirmAction()))) {
                return state.withError(error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
                    expr: confirm,
                    attributes: {
                        actionName,
                    },
                }));
            }
        }
        return (next) => visit(next, state.pushExpr(expr), affirmed);
    }
};
exports.validateConfirmArgsFlow = validateConfirmArgsFlow;
/**
 * Validate the arguments to an API match the payload in a previous ConfirmArgs or ConfirmAction act.
 */
function validateConfirmPayload(state, confirm, apiOrDelegate) {
    var _a;
    const confirmedPayload = confirm.isResponse() || confirm.isConfirmAction() ? confirm.payload : undefined;
    const payload = apiOrDelegate.getConfirmPayload();
    const errors = Object.entries((_a = payload.arguments) !== null && _a !== void 0 ? _a : {})
        .map(([name, arg]) => {
        var _a, _b;
        const actualArg = confirmedPayload === null || confirmedPayload === void 0 ? void 0 : confirmedPayload.getProperty(name);
        if (actualArg === undefined || actualArg.equals(arg)) {
            return [];
        }
        // return a pair of errors for the mis-matched argument
        return [
            error_factory_1.ValidationErrorFactory.MismatchedPayloadPropertyValueActionArgument({
                expr: (0, error_factory_1.getExpressionIfLocField)((_a = confirm.apply) === null || _a === void 0 ? void 0 : _a.getArgument("payload"), confirm),
                attributes: {
                    propertyName: name,
                    actionName: payload.actionName,
                },
            }),
            error_factory_1.ValidationErrorFactory.MismatchedPayloadPropertyValuePreviouslyConfirmed({
                expr: (0, error_factory_1.getExpressionIfLocField)((_b = apiOrDelegate.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValue(name), arg),
                attributes: {
                    argumentName: name,
                    actionName: payload.actionName,
                },
            }),
        ];
    })
        .reduce((a, b) => a.concat(b), []);
    return state.withError(...errors);
}
/**
 * Validate ensure action used in dialog sample
 * traverse the requestArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure each all arguments in the argument list refer to the same action
 * 3. When the arguments list of RequestArguments contains multiple args, make sure each arg has request prompt
 */
const evaluateEnsure = (ensure, state) => {
    var _a, _b;
    if (ensure.node === undefined) {
        return state;
    }
    const errors = [];
    state = state.withRequestedArguments(true, ...ensure.getIndividuallyRequestedArguments());
    // const requestArgsNode = ensure.requestArgs.origin;
    if (((_a = ensure.requestArgs) === null || _a === void 0 ? void 0 : _a.isList()) && ensure.requestArgs.isLiteral()) {
        for (const requestArg of (_b = ensure.requestArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            const args = requestArg === null || requestArg === void 0 ? void 0 : requestArg.getProperty("arguments");
            errors.push(...validateArgumentListThing(args, args === null || args === void 0 ? void 0 : args.origin));
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                errors.push(...(0, exports.validatePrompt)(requestArg.apply));
            }
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                state = (0, exports.validateRequestPromptInArgsList)(ensure, requestArg, state);
            }
        }
    }
    return state.withError(...errors);
};
exports.evaluateEnsure = evaluateEnsure;
/**
 * Validations of the List<Argument<Thing>> type
 * the items in the "arguments" list should be from the same Action
 * @param value
 * @param branch
 */
function validateArgumentList(value, valueThing) {
    return validateArgumentListThing(valueThing, value);
}
exports.validateArgumentList = validateArgumentList;
function validateArgumentListThing(list, expr) {
    var _a, _b;
    const parseErrors = [];
    if (list === undefined) {
        return parseErrors;
    }
    else if (list.isUnion()) {
        return list.things.map((t) => validateArgumentListThing(t, expr)).reduce((a, b) => a.concat(b), []);
    }
    else if ((list === null || list === void 0 ? void 0 : list.isLiteral()) && list.isList()) {
        const actionNamesSet = new Set();
        const items = (_a = list.getItems()) !== null && _a !== void 0 ? _a : [];
        if (items.length === 0) {
            parseErrors.push(error_factory_1.ValidationErrorFactory.ExpectedNonEmptyArgumentList({ expr }));
            return parseErrors;
        }
        for (const itemThing of (_b = list.getItems()) !== null && _b !== void 0 ? _b : []) {
            if (itemThing === undefined) {
                // This will happen when referring to the arguments of a reusable dialog:
                //    ensure(RequestArguments {arguments = [saveRating.arguments.arg0], response = feedback_prompt})
                // saveRating is an argument to the reusable dialog:
                //    dialog Nothing GetFeedback(Action1<Number, Nothing> saveRating)
                // For this case, currently skipping the validations for argument reference and type below
                continue;
            }
            if (!itemThing.isArgument()) {
                continue;
            }
            const argumentInformation = itemThing.getReferencedActionArgumentTypeInformation();
            if (!argumentInformation || !argumentInformation.actionName) {
                parseErrors.push(error_factory_1.ValidationErrorFactory.ArgumentMustReferToActionArgument({
                    expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                    attributes: { argumentName: itemThing.argumentName },
                }));
            }
            else {
                actionNamesSet.add(argumentInformation.actionName);
                if (argumentInformation.type && !argumentInformation.type.isValidForUtterance()) {
                    parseErrors.push(error_factory_1.ValidationErrorFactory.ArgumentMustReferToActionArgumentWithUtteranceType({
                        expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                        attributes: { argumentName: itemThing.argumentName, typeName: argumentInformation.type.toString() },
                    }));
                }
            }
        }
        if (actionNamesSet.size > 1) {
            const actionNames = Array.from(actionNamesSet.values())
                .map((n) => "'" + n + "'")
                .join(", ");
            return [
                error_factory_1.ValidationErrorFactory.MismatchedActionArgumentsList({
                    expr,
                    attributes: {
                        actionNames: actionNames,
                    },
                }),
            ];
        }
    }
    return parseErrors;
}
exports.validateArgumentListThing = validateArgumentListThing;
/**
 * Validate response argument in response, confirmAction, ensure and confirmArgs actions
 * The type of response should be APL-A
 *
 * Right now the type validation won't check response type cause the response type could be anything
 */
const validatePrompt = (apply) => {
    var _a, _b, _c;
    const errors = [];
    const promptNode = apply.getArgumentValue("response");
    const prompt = apply.getArgumentValueThing("response");
    if (prompt !== undefined) {
        if (((_a = prompt.type) === null || _a === void 0 ? void 0 : _a.isApla()) || ((_b = prompt.type) === null || _b === void 0 ? void 0 : _b.isMultiModalResponse())) {
            // APLA and MultiModalResponse are valid prompt
            // TODO: we should probably check if the APLA property is set, right?
        }
        else {
            errors.push(error_factory_1.ValidationErrorFactory.MissingAplaInResponse({
                expr: promptNode,
                attributes: {
                    type: (_c = prompt.type) === null || _c === void 0 ? void 0 : _c.toString(promptNode),
                },
            }));
        }
    }
    return errors;
};
exports.validatePrompt = validatePrompt;
const validateRequestPromptInArgsList = (expr, act, state) => {
    var _a, _b, _c, _d;
    if (act === undefined) {
        return state;
    }
    if (act.isUnion()) {
        // return args.things.map((thing) => validateRequestPromptInArgsList(thing, state)).reduce((a, b) => a.concat(b), []);
        throw new Error("this should be impossible.");
    }
    else if (expr.isConfirmArgs() || act.type.isRequest() || act.type.isRequestArguments() || act.type.isConfirmArgs()) {
        const args = (_c = (_b = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("arguments")) === null || _b === void 0 ? void 0 : _b.asLiteralList()) === null || _c === void 0 ? void 0 : _c.getItems();
        if (args && args.length > 1) {
            for (const arg of args) {
                const argName = (_d = arg === null || arg === void 0 ? void 0 : arg.origin) === null || _d === void 0 ? void 0 : _d.name;
                if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && argName !== undefined) {
                    if ((expr.isResponse() || expr.isEnsure() || expr.isConfirmArgs()) && !state.isArgumentRequested(arg)) {
                        state = state.withPendingRequestPromptValidation(expr, arg);
                    }
                }
            }
        }
    }
    return state;
};
exports.validateRequestPromptInArgsList = validateRequestPromptInArgsList;
/**
 * Validate the user Defined api call inside dialog sample
 * 1. make sure the argument is api result or event result
 * 2. make sure the required argument has Request Prompt
 * 3. make sure the argument(event result) has not been reset
 * 4. make sure all of the api arguments leaf types are primitive or backed by a catalog
 * 5. make sure the the api return value leaf types are primitive or backed by a catalog
 */
const evaluateInvokeApi = (api, state) => {
    var _a;
    if (api.node === undefined) {
        return state;
    }
    const apiName = (_a = api.action) === null || _a === void 0 ? void 0 : _a.actionName;
    const shortApiName = (0, util_1.getName)(apiName !== null && apiName !== void 0 ? apiName : "");
    const errors = [
        ...validateLoadContextIsCalledOnce(),
        ...validateArguments(),
        ...validateOfferedApiInvocation(),
        ...validateReturnValue(),
    ];
    return state.withError(...errors).clearPendingOffer();
    // Validate the return value of an api is not an empty type or contains an empty sub-type
    function validateReturnValue() {
        var _a;
        const returnType = (_a = api.apply) === null || _a === void 0 ? void 0 : _a.getReturnType();
        const invalidLeafs = returnType === null || returnType === void 0 ? void 0 : returnType.getEmptyLeafTypes();
        if (invalidLeafs === null || invalidLeafs === void 0 ? void 0 : invalidLeafs.length) {
            return [
                error_factory_1.ValidationErrorFactory.InvalidApiReturnType({
                    expr: api.node,
                    attributes: {
                        apiName: shortApiName,
                        unbackedMessage: unbackedCatalogMsg(invalidLeafs),
                    },
                }),
            ];
        }
        return [];
    }
    function validateArguments() {
        var _a, _b, _c, _d;
        return ((_d = (_c = (_b = (_a = api.action) === null || _a === void 0 ? void 0 : _a.getArguments()) === null || _b === void 0 ? void 0 : _b.getArgumentsList()) === null || _c === void 0 ? void 0 : _c.flatMap((arg) => {
            const argValueNode = api.apply.getArgumentValue(arg);
            const argValue = api.apply.getArgumentValueThing(arg);
            if (argValue !== undefined) {
                return validateArgValue(argValueNode, argValue, arg);
            }
            return [];
        })) !== null && _d !== void 0 ? _d : []);
    }
    function validateOfferedApiInvocation() {
        var _a, _b;
        const invokedAction = (_b = (_a = api.apply) === null || _a === void 0 ? void 0 : _a.decl.name) === null || _b === void 0 ? void 0 : _b.name;
        if (state.pendingOffer && state.pendingOffer != invokedAction) {
            return [
                error_factory_1.ValidationErrorFactory.InvokedActionNotOffered({
                    expr: api,
                    attributes: {
                        offeredAction: state.pendingOffer,
                        invokedAction: invokedAction,
                    },
                }),
            ];
        }
        return [];
    }
    /**
     * Validate argument value
     *
     * 1. make sure the argument value is api result or event result
     * 2. when the argValue is event result, make sure it has request prompt
     * 3. ensure the sub types of the argument are non-empty or backed by a catalog
     *
     * @param argValue the argument value
     * @param argDecl the declaration of the argument, we could know the argument name, type and whether the argument is optional based on it
     * @returns Parse errors
     */
    function validateArgValue(argValue, argValueThing, argDecl) {
        var _a, _b;
        const argDeclType = argDecl.type.getArgumentType();
        const invalidApiArgumentError = error_factory_1.ValidationErrorFactory.InvalidApiArgument({
            expr: argValue,
        });
        const errors = [...validateArgHasNoEmptyLeafTypes(argDeclType)];
        if (argValueThing.isNothing()) {
            return errors;
        }
        if (argValueThing.isLiteral()) {
            // A literal argument can only be a list
            if (argValueThing.isList()) {
                errors.push(...((_b = (_a = argValueThing.getItems()) === null || _a === void 0 ? void 0 : _a.flatMap(validateArgValueThing)) !== null && _b !== void 0 ? _b : []));
            }
            else {
                // TODO: validate type literal with multiple properties
                // errors.push(invalidApiArgumentError);
            }
        }
        else {
            errors.push(...validateArgValueThing(argValueThing));
        }
        return errors;
        // Validates that the base type or any sub-type is non empty.
        function validateArgHasNoEmptyLeafTypes(type) {
            const emptyLeaves = type === null || type === void 0 ? void 0 : type.getEmptyLeafTypes();
            if (emptyLeaves === null || emptyLeaves === void 0 ? void 0 : emptyLeaves.length) {
                return [
                    error_factory_1.ValidationErrorFactory.ApiArgumentWithNoCatalog({
                        expr: argValue,
                        attributes: {
                            argName: argDecl.argumentName,
                            apiName: shortApiName,
                            unbackedMessage: unbackedCatalogMsg(emptyLeaves),
                        },
                    }),
                ];
            }
            return [];
        }
        // Validates the origin of an argument. For now it must be from an API result or an entity produced by an event.
        function validateArgValueThing(argValueThing) {
            var _a;
            const origin = getOriginType(argValueThing);
            if (argValueThing === undefined || argValueThing.isNothing()) {
                return [];
            }
            if (argValueThing.isUnion()) {
                return argValueThing.things.map(validateArgValueThing).reduce((a, b) => a.concat(b), []);
            }
            if (argValueThing.parent === undefined) {
                // if we're directly referencing a value, it must be an API cal
                if (isFromOrigin(origin, "api") === false) {
                    return [invalidApiArgumentError];
                }
            }
            else if (isFromOrigin(origin, "event", "api") === false) {
                // if we're indexing an object, it can be from an event or an API call.
                return [invalidApiArgumentError];
            }
            if (isFromOrigin(origin, "event")) {
                if (!state.isArgumentRequested(argDecl, argValueThing)) {
                    if (!((argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isOptional()) || (argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isArgs()))) {
                        // if this is a required argument and it has not been requested in this dialog flow, we must keep track of it
                        // and only error if we don't find an `ensure` block later in the dialog flow.
                        // const arg = api.action?.getArgument(argDecl);
                        state = state.withPendingRequestPromptValidation(api, argDecl);
                    }
                }
            }
            // Both the eventResult and apiResult follow the same reset rule
            if (api.flow.isArgumentReset(argValueThing, api.apply.decl)) {
                const argumentName = (argValue === null || argValue === void 0 ? void 0 : argValue.kind) === "PropertyReference" ? argValue.printPropertyChainThroughRoot() : (_a = argValue === null || argValue === void 0 ? void 0 : argValue.name) === null || _a === void 0 ? void 0 : _a.name;
                return [
                    error_factory_1.ValidationErrorFactory.ResetArgument({
                        expr: argValue,
                        attributes: {
                            argumentName,
                        },
                    }),
                ];
            }
            return [];
        }
    }
    /**
     * A call to the configured loadContext action must be called at most once per dialog sample.
     *
     * @see https://github.com/alexa/ask-ac/issues/225
     */
    function validateLoadContextIsCalledOnce() {
        var _a, _b, _c;
        if (apiName && ((_c = (_b = (_a = state.skillContext) === null || _a === void 0 ? void 0 : _a.loadContext) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === apiName) {
            return api.flow.visitPrevious(function walk(flow) {
                var _a;
                if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
                    return [];
                }
                if (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
                    const apply = flow.checker.getApply(flow.expression);
                    if (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi()) {
                        const thisName = apply === null || apply === void 0 ? void 0 : apply.getName();
                        if (thisName) {
                            if (thisName === apiName) {
                                return [
                                    error_factory_1.ValidationErrorFactory.InvalidLoadContextMultipleCall({
                                        expr: api,
                                        attributes: {
                                            actionName: apiName,
                                        },
                                    }),
                                ];
                            }
                            return [
                                error_factory_1.ValidationErrorFactory.InvalidLoadContextNotFirstCall({
                                    expr: api,
                                    attributes: {
                                        actionName: apiName,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return flow.visitPrevious(walk);
            });
        }
        return [];
    }
    // Stringifies types into a readable catalog error message
    function unbackedCatalogMsg(types) {
        const stringifiedTypeNames = types.map((type) => `"${type.shortName}"`).join(", ");
        return types.length === 1
            ? `refers to a type ${stringifiedTypeNames} that has no properties and is not associated with a catalog.`
            : `refers to the types ${stringifiedTypeNames} that have no properties and are not associated with a catalog.`;
    }
};
exports.evaluateInvokeApi = evaluateInvokeApi;
/**
 * Validate payload argument in response and confirmAction action
 *
 * 1. the expression assigned to payload is either null, Thing, or an ObjectLiteral
 * 2. the value assigned to payload property can only be a name directly referring to an api result or a type used in an event
 * 3. validate payload against next api call
 *
 * The Simulator can only understand payload values to be either a slot in the event or the return value of an api invocation
 */
const validatePayload = (response, state) => {
    var _a;
    if (response.payload === undefined) {
        return [];
    }
    const errors = [];
    const expr = (0, error_factory_1.getExpressionIfLocField)((_a = response.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("payload"), response);
    validatePayloadThing(response.payload);
    return errors;
    function validatePayloadThing(payload) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (payload.isUnion()) {
            throw new Error("this should be impossible.");
            // payload.things.forEach(validatePayloadThing);
        }
        else if (payload.isPrimitive()) {
            if (payload.isLiteral() && (payload.isVoid() || payload.isNothing())) {
                // null and nothing literals are allowed.
            }
            else {
                // TODO: i need to properly handle Optional -> which is AnyThing right now
                errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadType({
                    expr,
                }));
            }
        }
        else if (!payload.isLiteral()) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadType({
                expr,
            }));
        }
        else {
            // now we have an object literal `{ prop = value }`
            Object.entries((_a = payload.getProperties()) !== null && _a !== void 0 ? _a : {}).forEach(([name, propThing]) => {
                if (propThing !== undefined) {
                    const origin = getOriginType(propThing);
                    if (propThing.parent === undefined) {
                        // if we're directly referencing a value, it must be an API cal
                        if (isFromOrigin(origin, "api") === false) {
                            errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadPropertyValue({
                                expr,
                            }));
                        }
                    }
                    else if (isFromOrigin(origin, "event", "api") === false) {
                        // if we're indexing an object, it can be from an event or an API call.
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadPropertyValue({
                            expr,
                        }));
                    }
                }
            });
        }
        // payload type should be consistent with response type
        if (((_c = (_b = response.response) === null || _b === void 0 ? void 0 : _b.type) === null || _c === void 0 ? void 0 : _c.genericArguments) && ((_e = (_d = response.response) === null || _d === void 0 ? void 0 : _d.type) === null || _e === void 0 ? void 0 : _e.genericArguments.length) > 0) {
            const responseGenericType = (_g = (_f = response.response) === null || _f === void 0 ? void 0 : _f.type) === null || _g === void 0 ? void 0 : _g.genericArguments[0];
            if (responseGenericType !== undefined && !payload.type.extends(responseGenericType)) {
                errors.push((0, error_1.typeError)(payload.type, responseGenericType, response.node, (0, error_factory_1.getExpressionIfLocField)((_h = response.apply) === null || _h === void 0 ? void 0 : _h.getArgumentValue("payload"), response)));
            }
        }
    }
};
exports.validatePayload = validatePayload;
function isFromOrigin(actualOrigin, ...expectedOrigin) {
    const allowedOrigins = new Set(expectedOrigin);
    if (actualOrigin === undefined) {
        return undefined;
    }
    if (typeof actualOrigin === "string") {
        return allowedOrigins.has(actualOrigin);
    }
    let accumulator = true;
    for (const o of actualOrigin) {
        if (o === undefined) {
            return undefined;
        }
        accumulator = allowedOrigins.has(o) && accumulator;
    }
    return accumulator;
}
function getOriginType(thing) {
    var _a;
    if (thing === undefined) {
        return undefined;
    }
    if (thing.parent !== undefined) {
        // a thing is from an API call or an Event if the root is from an API or expect event
        return getOriginType(thing.parent);
    }
    if (thing.isLiteral()) {
        return "literal";
    }
    if (thing.isUnion()) {
        return thing.things
            .map((t) => getOriginType(t))
            .reduce((a, b) => {
            if (Array.isArray(a) && Array.isArray(b)) {
                return a.concat(b);
            }
            if (Array.isArray(a)) {
                return [...a, b];
            }
            if (Array.isArray(b)) {
                return [a, ...b];
            }
            return [a, b];
        }, []);
    }
    if (((_a = thing.origin) === null || _a === void 0 ? void 0 : _a.kind) === "ArgumentDeclaration") {
        // origin is an argument declaration, this relies on re-usable dialog expansion logic ....
        // for now, return false?
        return "argument";
    }
    const { apply } = thing;
    if (apply === undefined) {
        return undefined;
    }
    if (apply.isExpect()) {
        return "event";
    }
    if (apply.isUserDefinedApi()) {
        return "api";
    }
    if (apply.isOperator()) {
        return "operator";
    }
    if (apply.isNativeAction()) {
        return "native";
    }
    if (apply.isBuiltin()) {
        return "built-in";
    }
    return undefined;
}
function validateGlobalWelcome(project, checker) {
    const welcomeCalls = project.modules
        .map((module) => {
        var _a, _b, _c;
        return (_c = (_b = (_a = module.content) === null || _a === void 0 ? void 0 : _a.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => {
            var _a;
            if (expr.kind === "Call" || (expr.kind === "NameDeclaration" && ((_a = expr.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call")) {
                const apply = checker.getApply(expr.kind === "Call" ? expr : expr.expression);
                if (apply === null || apply === void 0 ? void 0 : apply.isWelcome()) {
                    return [expr];
                }
            }
            return [];
        }).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : [];
    })
        .reduce((a, b) => a.concat(b), []);
    if (welcomeCalls.length > 1) {
        return welcomeCalls.map((welcome) => error_factory_1.ValidationErrorFactory.TooManyWelcomeCalls({
            expr: welcome,
            attributes: {
                welcomeCallCount: welcomeCalls.length,
            },
        }));
    }
    return [];
}
exports.validateGlobalWelcome = validateGlobalWelcome;
/**
 * validate all required prompts are exist in current skill
 */
function validateSkillLevelResponses(project) {
    var _a;
    const errors = [];
    const promptsNameSet = new Set();
    // Check if required prompts exist in current skill
    (_a = project.responseTemplates) === null || _a === void 0 ? void 0 : _a.forEach((prompt) => {
        if (prompt.isPrompt()) {
            promptsNameSet.add(prompt.name);
        }
    });
    Object.values(ask.AlexaConversationPrompts).forEach((requiredPrompt) => {
        if (!promptsNameSet.has(requiredPrompt)) {
            errors.push(error_factory_1.ValidationErrorFactory.MissingRequiredPrompts({
                attributes: {
                    promptName: requiredPrompt,
                },
            }));
        }
    });
    return errors;
}
exports.validateSkillLevelResponses = validateSkillLevelResponses;
/**
 * Verify the expect of Invoke event exists by recursively calling the @function doesSampleStartWithInvoke
 *
 * E.G. Below is a valid example, as it has expect with Invoke event:
 * dialog void A {
 *   sample {
 *     expect(Invoke, invocationUtterances)
 *     // ... conversation flow's logic
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * It makes sure all the branches have an Invoke event if conditional branches exist.
 * E.G. The dialog below is not a valid one as it misses Invoke in one condition branch:
 * dialog void B {
 *   sample {
 *     if (some_condition) {
 *       expect(RequestAlt, invocationUtterances)
 *     } else {
 *       expect(Invoke, invocationUtterances)
 *     }
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * @param sample sample node to validate through the expressions to find Invoke event
 * @param flow type checker
 * @returns
 */
const validateSampleStartWithInvoke = (flow, state) => {
    const sample = flow.expression;
    const dialogDecl = sample.context;
    return flow
        .interpret((expr) => visit(expr, state), undefined)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state) {
        var _a, _b, _c;
        if (expr.isEnd()) {
            // if we reach the end then don't report any error - the sample will be flagged as not having an expressions.
            return state;
        }
        if (expr.isDialogExpansion()) {
            // skip dialog expansion (treat it as transient).
            return (next) => visit(next, state);
        }
        if (expr.isExpect()) {
            if (expr.isInvoke()) {
                return state;
            }
            // TODO: specialize error message for the wrong act typ
            // TODO: is the origin location a bad idea?
            return state.withError(error_factory_1.ValidationErrorFactory.MissingExpectInvokeEvent({
                expr: (0, error_factory_1.getExpressionIfLocField)((_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act"), expr, sample),
                attributes: {
                    dialogName: (_b = dialogDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                },
            }));
        }
        if (expr.isEnsure() || expr.isConditionalBranch() || expr.isDialogExpansion() || expr.isBlock()) {
            // these blocks don't count as evaluated actions, so we  move to the next expressions
            // return expr.flow.interpret(state, EvaluationState.combine, evaluate);
            return (next) => visit(next, state.pushExpr(expr));
        }
        return state.withError(error_factory_1.ValidationErrorFactory.MissingExpectInvokeEvent({
            expr: (0, error_factory_1.getExpressionIfLocField)(expr, sample),
            attributes: {
                dialogName: (_c = dialogDecl.name) === null || _c === void 0 ? void 0 : _c.name,
            },
        }));
    }
};
exports.validateSampleStartWithInvoke = validateSampleStartWithInvoke;
/**
 * Returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 * This will recursevely follow conditionExpressionThing.parent to find the root parent. Once there
 * returns true if it is either:
 *   1) the last user defined API or
 *   2) an event out of an expect call or
 *   3) an operator or native action where at least one argument is 1) or 2)
 * @param conditionExpressionThing condition expression thing
 * @param lastApiName name of the last user defined API called
 * @returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 */
const isConditionExpressionFromLastApiOrFromExpect = (conditionExpressionThing, lastApiName) => {
    if (conditionExpressionThing === undefined) {
        return false;
    }
    if (conditionExpressionThing.parent !== undefined) {
        return isConditionExpressionFromLastApiOrFromExpect(conditionExpressionThing.parent, lastApiName);
    }
    if (!conditionExpressionThing.apply) {
        return false;
    }
    if (conditionExpressionThing.apply.isExpect()) {
        return true;
    }
    if (conditionExpressionThing.apply.isUserDefinedApi()) {
        return conditionExpressionThing.apply.getName() === lastApiName;
    }
    if (conditionExpressionThing.apply.isOperator() || conditionExpressionThing.apply.isNativeAction()) {
        for (const arg in conditionExpressionThing.apply.getArguments()) {
            const argThing = conditionExpressionThing.apply.getArgumentValueThing(arg);
            if (!argThing || isConditionExpressionFromLastApiOrFromExpect(argThing, lastApiName)) {
                return true;
            }
        }
    }
    return false;
};
/**
 * This function validates Condition.when for the following checkpoints:
 * 2. validate the when condition contains any data from the last API invocation call
 * 3. validate then when expression to have a boolean return type
 *
 * @param cond Condition.when Call | NameReference
 * @param condition type checker for querying the expressions
 * @returns type Validator<T>
 */
const evaluateConditionalBranch = (condition, state) => {
    var _a, _b;
    state = state.withError(...validateFirstExpressionInCondition());
    const { when } = condition.flow.expression;
    if ((when === null || when === void 0 ? void 0 : when.expression) === undefined) {
        return state;
    }
    if (!isConditionExpressionFromLastApiOrFromExpect(condition.expr, (_b = (_a = state.previousApi) === null || _a === void 0 ? void 0 : _a.apply) === null || _b === void 0 ? void 0 : _b.getName())) {
        return state.withError(error_factory_1.ValidationErrorFactory.ConditionWhenMustCompareApiResponse({
            expr: (0, error_factory_1.getExpressionIfLocField)(when, when.context),
        }));
    }
    return state;
    // check that the first expression in each conditional block is another ConditionalBranch, API invocation, Notify Response or Confirm Action
    function validateFirstExpressionInCondition() {
        return condition.flow
            .interpret(function visit(expr, block) {
            var _a;
            if (expr.isEnd() || !isInCondition(expr)) {
                // This Expression does not exist within the ConditionalBranch, so let the "a condition must contain at least one expression" validator catch this.
                return [
                    error_factory_1.ValidationErrorFactory.ExprRequiredInConditionBlock({
                        expr: (0, error_factory_1.getExpressionIfLocField)(block, condition),
                    }),
                ];
            }
            if (expr.isConditionalBranch()) {
                // if the next expression is a Conditional, it's valid
                return [];
            }
            if (expr.isBlock() && block === undefined) {
                // this is the first block encountered after the Conditional Branch, we should use this as the location of the errors.
                return (next) => visit(next, expr);
            }
            if (expr.isDialogExpansion() || expr.isEnsure() || expr.isConfirmArgs() || expr.isBlock()) {
                // if we encounter another conditional branch, dialog expansion or an ambient expression such as ensure or confirmArgs - continue evaluating the dialog flow
                return (expr) => visit(expr, block);
            }
            if (expr.isInvokeApi() || expr.isDelegateToIntent() || expr.isDelegateRequest()) {
                // we allow API invocations (including builtin delegation actions) and ConfirmAction
                // TODO: need to confirm whether ConfirmAction is allowed in a Conditional Branch. I can't remember why ... it doesn't seem to align with requirements?
                return [];
            }
            if (expr.isResponse()) {
                if (((_a = expr.act) === null || _a === void 0 ? void 0 : _a.type.isNotify()) === false) {
                    return [
                        error_factory_1.ValidationErrorFactory.InvalidFirstResponseInConditionBlock({
                            expr: (0, error_factory_1.getExpressionIfLocField)(expr.actNode, expr),
                        }),
                    ];
                }
                // Notify Response is valid, no error.
                return [];
            }
            return [
                error_factory_1.ValidationErrorFactory.InvalidFirstExprInConditionBlock({
                    expr,
                }),
            ];
        }, condition)
            .flat();
    }
    /**
     * HACK: Check if this Expression is directly in the context of the ConditionalBranch being expanded.
     *
     * We need this hack because of a short-coming of interpret (ugh!) - we don't know when an Expression
     * in the Stream originated from within a Condition or outside, making this validation difficult.
     */
    function isInCondition(expr) {
        if (expr.flow.stack.length === 0) {
            return false;
        }
        for (const prevExpr of expr.flow.stack) {
            if (prevExpr.kind === "Condition") {
                return prevExpr === condition.flow.expression;
            }
        }
        return false;
    }
};
exports.evaluateConditionalBranch = evaluateConditionalBranch;
/**
 * Validates that a `delegateToIntent` call was not the previous expression.
 *
 * @param expr - Expression that is not allowed to follow delegation
 * @param state - EvaluationState
 */
const validatePriorDelegation = (expr) => {
    const errors = [];
    const { prev } = expr;
    if ((prev === null || prev === void 0 ? void 0 : prev.isDelegateToIntent()) || (prev === null || prev === void 0 ? void 0 : prev.isDelegateRequest())) {
        const directive = prev;
        const callName = getCallName(expr);
        errors.push(error_factory_1.ValidationErrorFactory.InvalidExpressionAfterDelegation({
            expr: expr,
            attributes: {
                directiveName: directive.apply.getShortName(),
                callName: callName,
            },
        }));
    }
    return errors;
    // Gets a name for the invalid expression call that wasn't allowed after the delegate directive.
    function getCallName(expression) {
        var _a, _b;
        if (expression.kind === "Action") {
            return (_a = expression.apply) === null || _a === void 0 ? void 0 : _a.getShortName();
        }
        return ask.isCall(expression.node) ? (_b = expression.node.name) === null || _b === void 0 ? void 0 : _b.name : undefined;
    }
};
exports.validatePriorDelegation = validatePriorDelegation;
/**
 * Returns true if the flow originated from a dialog call.
 */
function isFlowFromDialogCall(flow) {
    if ((flow === null || flow === void 0 ? void 0 : flow.stack.length) !== 1) {
        return false;
    }
    const stackNode = flow.stack[0];
    if ((stackNode === null || stackNode === void 0 ? void 0 : stackNode.kind) === "Call") {
        const apply = flow.checker.getApply(stackNode);
        return apply === null || apply === void 0 ? void 0 : apply.isDialog();
    }
    return false;
}
/**
 * Validates if response calls with 'Request' request acts are called consecutively
 */
const validatePriorResponseCall = (response) => {
    var _a, _b, _c, _d;
    const errors = [];
    if ((_a = response.prev) === null || _a === void 0 ? void 0 : _a.isResponse()) {
        const reqAct = response.apply.getArgumentValue("act");
        const prevReqAct = response.prev.apply.getArgumentValue("act");
        if (((_b = reqAct === null || reqAct === void 0 ? void 0 : reqAct.name) === null || _b === void 0 ? void 0 : _b.name) === ((_c = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _c === void 0 ? void 0 : _c.name) && ((_d = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _d === void 0 ? void 0 : _d.name) === "Request") {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidEventInform({
                expr: response,
                attributes: {
                    requestAct: "Inform",
                },
            }));
        }
    }
    return errors;
};
exports.validatePriorResponseCall = validatePriorResponseCall;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZXZhbHVhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFJN0IsK0JBQTREO0FBRTVELG1DQUE0RDtBQW1CNUQsbURBQTZIO0FBRTdILGlDQUErQjtBQU8vQjs7R0FFRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLElBQWlDLEVBQUUsS0FBc0I7SUFDMUYsbURBQW1EOztJQUVuRCxPQUFPO1FBQ0wsWUFBWSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFDdEQsTUFBQSxNQUFBLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTywwQ0FBRSxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLElBQUEscUNBQTZCLEVBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxtQ0FBSSxFQUFFO0tBQ3hHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQztBQVBELGdEQU9DO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLElBQVUsRUFBRSxLQUFzQjtJQUM3RCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxRQUFRLENBQUMsSUFBSSxFQUFFLFNBQVMsR0FBRyxLQUFLO1FBQzdELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ2hCLE9BQU8sV0FBVyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDcEQ7UUFDRCxTQUFTLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FB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