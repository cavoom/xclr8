import { ParseError } from "./error";
import { ParseContext } from "./parse";
/**
 * A handler transforms a thrown error to a list of `ParseError`s.
 */
export type ErrorHandler = (error: unknown) => ParseError[];
export declare function isFailure(a: any): a is Failure;
export interface Failure {
    kind: "Failure";
    errors: ParseError[];
}
/**
 * Check if a value is an instance of `Try`.
 */
export declare function isTry(a: any): a is TryMonad<unknown>;
/**
 * Monad for safely calling a function that can throw errors.
 *
 * @param get function so safely call
 * @param errorHandler optional handler for transforming errors
 */
export declare function Try<T>(get: () => T, errorHandler?: ErrorHandler): TryMonad<T>;
/**
 * Encapsulates a computation that may throw errors.
 */
export declare class TryMonad<T> {
    readonly thunk: () => T;
    readonly errorHandler?: ErrorHandler | undefined;
    constructor(thunk: () => T, errorHandler?: ErrorHandler | undefined);
    map<U>(f: (t: T) => U, err?: ErrorHandler): TryMonad<U>;
    flatMap<U>(f: (t: T) => TryMonad<U>, err?: ErrorHandler): TryMonad<U>;
    resolve(context: ParseContext): T | undefined;
    getOrDefault<U>(t: U): T | U;
    getOrThrow(error?: any): T;
}
/**
 * Represents either `A` or `B` returned.
 */
export type Either<A, B> = Left<A> | Right<B>;
export interface Left<T> {
    left: T;
    right?: never;
}
export interface Right<T> {
    left?: never;
    right: T;
}
export declare const left: <T>(left: T) => Left<T>;
export declare const right: <T>(right: T) => Right<T>;
export declare const isLeft: <A, B>(a: Either<A, B>) => a is Left<A>;
export declare const isRight: <A, B>(a: Either<A, B>) => a is Right<B>;
//# sourceMappingURL=try.d.ts.map