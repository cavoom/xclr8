"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvaluationState = void 0;
const immutable_1 = require("immutable");
/**
 * The EvaluationState is an immutable class that tracks information observed while processing an
 * {@link Expression} stream with {@link Flow.interpret}. As the Dialog Flow forks on {@link DialogExpansion}
 * expansions and {@link ConditionalBranch}
 */
class EvaluationState {
    constructor(skillContext, 
    /**
     * Arguments that have been requested. The string is the argument name.
     */
    requestedArguments = (0, immutable_1.Map)(), pendingConfirmations = (0, immutable_1.Set)(), errors = [], 
    /**
     * A LIFO queue (Stack) of all expressions seen in the Flow until this time.
     */
    expressionStack = [], 
    /**
     * The most recent received Event.
     */
    previousEvent = undefined, 
    /**
     * The most recent API invocation.
     */
    previousApi = undefined, 
    /**
     * Most recent offer that has been affirmed but not invoked
     */ pendingOffer = undefined, 
    /**
     * API invocations that we have not yet ensured has a request prompt for each required argument.
     */
    pendingRequestPromptValidation = (0, immutable_1.Map)(), 
    /**
     * Set of Dialogs that have been expanded so far in this dialog flow. We use this to detect
     * circular references to dialogs.
     */
    expandedDialogs = (0, immutable_1.Set)(), 
    /**
     * Flag to indicate if a circular refrence has been detected.
     */
    isCircular = false) {
        Object.defineProperty(this, "skillContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: skillContext
        });
        Object.defineProperty(this, "requestedArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: requestedArguments
        });
        Object.defineProperty(this, "pendingConfirmations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: pendingConfirmations
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
        Object.defineProperty(this, "expressionStack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: expressionStack
        });
        Object.defineProperty(this, "previousEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: previousEvent
        });
        Object.defineProperty(this, "previousApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: previousApi
        });
        Object.defineProperty(this, "pendingOffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: pendingOffer
        });
        Object.defineProperty(this, "pendingRequestPromptValidation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: pendingRequestPromptValidation
        });
        Object.defineProperty(this, "expandedDialogs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: expandedDialogs
        });
        Object.defineProperty(this, "isCircular", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isCircular
        });
    }
    /**
     * Push an Expression onto the `expressionStack` and update `previousEvent` and `previousApi` accordingly.
     *
     * @param expression the next expression seen in the dialog flow.
     * @returns a new EvaluationState with the updated `expressionStack`, previousEvent` and `previousApi`.
     */
    pushExpr(expression) {
        var _a;
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, [expression, ...this.expressionStack], expression.isExpect() ? expression : this.previousEvent, expression.isInvokeApi() ? expression : this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, expression.isDialogExpansion() && ((_a = expression.dialog) === null || _a === void 0 ? void 0 : _a.origin.kind) === "DialogDeclaration"
            ? this.expandedDialogs.add(expression.dialog.origin)
            : this.expandedDialogs, this.isCircular);
    }
    hasExpandedDialog(dialog) {
        var _a;
        return ((_a = dialog.dialog) === null || _a === void 0 ? void 0 : _a.origin.kind) === "DialogDeclaration" ? this.expandedDialogs.has(dialog.dialog.origin) : false;
    }
    /**
     * For a given API argument, if the argument is a built in or slot type, only the argument needs to be requested.
     * If the argument type is built in or slot this will return [`person`] assuming argument.argumentName is 'person'
     * If the argument is an object type, then we need to get to all paths leading to built in and slot types.
     * If the argument type looks like:
     *
     * type Person {
     *    PersonName name
     *    Number age
     *    Car car
     *    optional Number friendCount;
     * }
     *
     *
     * type Car {
     *   CarModel model;
     * }
     *
     * Where CarModel and PersonName are slot types.
     *
     * This method will return [`person.properties.name`, `person.properties.age`, `person.properties.car.properties.model`]
     *
     * @param argument argument to retrieve property paths that should be requested from
     * @returns The properties paths that should be requested put of argument
     */
    getArgumentPaths(argument) {
        var _a, _b;
        const argumentType = (_a = argument.type.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        if (!argumentType || !argument.argumentName) {
            return [];
        }
        const returnValue = [];
        const queue = [{ path: argument.argumentName, type: argumentType }];
        const seen = new Set([argumentType.toString()]);
        while (queue.length !== 0) {
            const { path, type } = queue.shift();
            if (type.isObject()) {
                for (const property of (_b = type.properties) !== null && _b !== void 0 ? _b : []) {
                    if (!property.type || property.type.isOptional() || seen.has(property.type.toString())) {
                        continue;
                    }
                    seen.add(property.type.toString());
                    queue.push({ type: property.type, path: path + ".properties." + property.name });
                }
            }
            else {
                returnValue.push(path);
            }
        }
        return returnValue;
    }
    /**
     * Keep track of this API invocation and check later if it has all necessary request prompts.
     * Called for mandatory arguments of an invoked API originated from an event in evaluateInvokeApi or
     * for arguments to ensure/confirmArgs/response with more than one value in validateRequestPromptInArgsList
     * to add to pendingRequestPromptValidation
     * @param api api invocation
     * @param argName the name of the argument
     * @returns
     */
    withPendingRequestPromptValidation(api, arg) {
        var _a, _b;
        const argumentPaths = this.getArgumentPaths(arg);
        let apiPendingArguments = this.pendingRequestPromptValidation.get(api);
        if (apiPendingArguments) {
            const pendingArgPaths = (_b = (_a = apiPendingArguments.get(arg)) === null || _a === void 0 ? void 0 : _a.merge(argumentPaths)) !== null && _b !== void 0 ? _b : (0, immutable_1.Set)(argumentPaths);
            apiPendingArguments = apiPendingArguments.set(arg, pendingArgPaths);
        }
        else {
            apiPendingArguments = (0, immutable_1.Map)([[arg, (0, immutable_1.Set)(argumentPaths)]]);
        }
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation.set(api, apiPendingArguments), this.expandedDialogs, this.isCircular);
    }
    /**
     * Checks if this State has any outstanding/pending Confirmation Expressions such as
     * ConfirmAction and ConfirmArguments.
     */
    hasPendingConfirmation() {
        return !this.pendingConfirmations.isEmpty();
    }
    /**
     * Track a ConfirmAction or ConfirmArgs Response that is pending Confirmation.
     *
     * @param confirmation the response asking for confirmation from the user.
     */
    withPendingConfirmation(confirmation) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations.add(confirmation), this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    withCircular(isCircular) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, isCircular);
    }
    withPendingOffer(pendingOffer) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    clearPendingOffer() {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, undefined, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    /**
     * Add new discovered errors to the state.
     *
     * @param errors new errors
     */
    withError(...errors) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, 
        // TODO: why do we need to filter undefined errors ... there should never be any
        [...this.errors, ...errors.filter((e) => e !== undefined)], this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    /**
     * @returns `true` if this state contains errors, `false` otherwise.
     */
    hasErrors() {
        return this.errors.length > 0;
    }
    /**
     * Register some {@link ArgumentThing}s as individually requested and are guarnateed to exist.
     *
     * @param ambient whether this argument request is ambient (meaning order of expression does not matter). Only the `ensure` block counts as an ambient request.
     * @param requestedArgs list of arguments that have been individually requested from the user.
     */
    withRequestedArguments(ambient, ...requestedArgs) {
        var _a, _b, _c, _d, _e, _f, _g;
        let { requestedArguments } = this;
        let { pendingRequestPromptValidation } = this;
        for (const requestedArg of requestedArgs) {
            const referencedActionDeclaration = requestedArg.getReferencedActionArgumentActionDeclaration();
            const referencedArgumentName = (_b = (_a = requestedArg.getReferencedActionArgumentDeclaration()) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
            const referencedArgumentPath = requestedArg.getReferencedActionArgumentPath();
            if (!referencedArgumentName || !referencedActionDeclaration || !referencedArgumentPath) {
                continue;
            }
            requestedArguments = requestedArguments.update(referencedActionDeclaration, (0, immutable_1.Set)(), (args) => args.add(referencedArgumentName));
            if (!ambient) {
                continue;
            }
            for (let [expr, pendingArgs] of pendingRequestPromptValidation.entries()) {
                if (expr.isInvokeApi() && ((_c = expr.action) === null || _c === void 0 ? void 0 : _c.origin) === referencedActionDeclaration) {
                    deleteArg();
                }
                else if (expr.isResponse()) {
                    const args = (_f = (_e = (_d = expr.act) === null || _d === void 0 ? void 0 : _d.getProperty("arguments")) === null || _e === void 0 ? void 0 : _e.asLiteralList()) === null || _f === void 0 ? void 0 : _f.getItems();
                    if (args) {
                        for (const arg of args) {
                            if ((_g = arg === null || arg === void 0 ? void 0 : arg.asArgument()) === null || _g === void 0 ? void 0 : _g.equals(requestedArg)) {
                                deleteArg();
                            }
                        }
                    }
                }
                function deleteArg() {
                    for (const [pendingArg, pathsSet] of pendingArgs) {
                        if ((referencedArgumentName && pendingArg.argumentName === referencedArgumentName) || pendingArg.equals(requestedArg)) {
                            pendingRequestPromptValidation = pendingRequestPromptValidation.set(expr, pendingArgs.set(pendingArg, pathsSet.delete(referencedArgumentPath)));
                        }
                    }
                }
            }
        }
        return new EvaluationState(this.skillContext, requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    /**
     * Checks if an Action's argument is requested via previous Expressions.
     *
     * Case 1: `ensure` as a previous expression in this flow.
     * ```
     * ensure(
     *   RequestArguments {arguments = [foo.arguments.arg], response = apla }
     * )
     * // arg is requested by `ensure` above
     * foo(arg = argValue)
     * ```
     *
     * Case 2: a `response` with `Request` act.
     * ```
     * response(apla, Request { arguments = [foo.arguments.arg] })
     * // arg is requested by `response` above
     * foo(arg = argValue)
     * ```
     *
     * Case 3: same value passed to a previously requested argument.
     * ```
     * response(apla, Request { arguments = [foo.arguments.arg] })
     * foo(arg = argValue)
     * // because foo.arguments.arg is requested, argValue is considered requested for other actions also.
     * bar(arg = argValue)
     * ```
     *
     * TODO: this function does not cover the case where `ensure` is located AFTER an Expression. Implementing
     * this logic is accomplished by {@link Flow.isArgumentRequested} but is computationally expensive. Our
     * goal is to change that behavior and instead use {@link EvaluationState} to keep track of this until
     * the {@link End} of the Dialog Flow and then validate all actions lacking requested arguments then. That
     * way the validation will be constant time.
     *
     * @param arg the argument we are looking up a request prompt for
     * @param argValueThing the value of the argument
     * @returns true if the argument has been requested, false otherwise.
     */
    isArgumentRequested(arg, argValueThing) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const argId = arg === null || arg === void 0 ? void 0 : arg.token;
        if (argId === undefined) {
            return false;
        }
        const actionDeclaration = arg === null || arg === void 0 ? void 0 : arg.getReferencedActionArgumentActionDeclaration();
        const referencedArgumentName = (_b = (_a = arg === null || arg === void 0 ? void 0 : arg.getReferencedActionArgumentDeclaration()) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
        if (actionDeclaration && referencedArgumentName && ((_c = this.requestedArguments.get(actionDeclaration)) === null || _c === void 0 ? void 0 : _c.has(referencedArgumentName))) {
            // this argument is directly requested
            return true;
        }
        if (argValueThing === undefined) {
            // if we don't know the argument's value, then we can't determine if it is requested anymore.
            return false;
        }
        // now check if there is a call to another API with the same value where that argument was requested.
        for (const expr of this.expressionStack) {
            if (expr.isInvokeApi() && expr.action) {
                if (expr.arguments) {
                    const argsList = (_d = expr.action.getArguments()) === null || _d === void 0 ? void 0 : _d.getArgumentsList();
                    if (argsList !== undefined) {
                        for (const exprArg of argsList) {
                            const exprArgValue = (_e = expr.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValueThing(exprArg);
                            if (exprArgValue === null || exprArgValue === void 0 ? void 0 : exprArgValue.equals(argValueThing)) {
                                const exprArgReferencedArgumentName = (_g = (_f = exprArg === null || exprArg === void 0 ? void 0 : exprArg.getReferencedActionArgumentDeclaration()) === null || _f === void 0 ? void 0 : _f.name) === null || _g === void 0 ? void 0 : _g.name;
                                if (exprArgReferencedArgumentName && ((_h = this.requestedArguments.get(expr.action.origin)) === null || _h === void 0 ? void 0 : _h.has(exprArgReferencedArgumentName))) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
}
exports.EvaluationState = EvaluationState;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGlvbi1zdGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldmFsdWF0aW9uLXN0YXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUFtRTtBQVduRTs7OztHQUlHO0FBQ0gsTUFBYSxlQUFlO0lBQzFCLFlBQ1csWUFBc0M7SUFFL0M7O09BRUc7SUFDTSxxQkFBcUIsSUFBQSxlQUFZLEdBQStDLEVBQ2hGLHVCQUErRCxJQUFBLGVBQVksR0FBRSxFQUM3RSxTQUF5QixFQUFFO0lBQ3BDOztPQUVHO0lBQ00sa0JBQWdDLEVBQUU7SUFDM0M7O09BRUc7SUFDTSxnQkFBb0MsU0FBUztJQUN0RDs7T0FFRztJQUNNLGNBQXFDLFNBQVM7SUFFdkQ7O09BRUcsQ0FBVSxlQUFtQyxTQUFTO0lBRXpEOztPQUVHO0lBQ00saUNBQWlDLElBQUEsZUFBWSxHQUduRDtJQUVIOzs7T0FHRztJQUNNLGtCQUFrQixJQUFBLGVBQVksR0FBeUI7SUFFaEU7O09BRUc7SUFDTSxhQUFhLEtBQUs7Ozs7O21CQTFDbEI7Ozs7OzttQkFLQTs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJSTs7Ozs7O21CQUtKOzs7Ozs7bUJBU0E7Ozs7OzttQkFLQTs7SUFDUixDQUFDO0lBRUo7Ozs7O09BS0c7SUFDSSxRQUFRLENBQTBCLFVBQWdCOztRQUN2RCxPQUFPLElBQUksZUFBZSxDQUN4QixJQUFJLENBQUMsWUFBWSxFQUNqQixJQUFJLENBQUMsa0JBQWtCLEVBQ3ZCLElBQUksQ0FBQyxvQkFBb0IsRUFDekIsSUFBSSxDQUFDLE1BQU0sRUFDWCxDQUFDLFVBQVUsRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsRUFDckMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQ3ZELFVB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