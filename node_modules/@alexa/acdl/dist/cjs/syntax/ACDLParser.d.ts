import { ATN } from "antlr4ts/atn/ATN";
import { FailedPredicateException } from "antlr4ts/FailedPredicateException";
import { Parser } from "antlr4ts/Parser";
import { ParserRuleContext } from "antlr4ts/ParserRuleContext";
import { RuleContext } from "antlr4ts/RuleContext";
import { TerminalNode } from "antlr4ts/tree/TerminalNode";
import { TokenStream } from "antlr4ts/TokenStream";
import { Vocabulary } from "antlr4ts/Vocabulary";
import { ACDLParserListener } from "./ACDLParserListener";
import { ACDLParserVisitor } from "./ACDLParserVisitor";
export declare class ACDLParser extends Parser {
    static readonly NAMESPACE = 1;
    static readonly IMPORT = 2;
    static readonly DIALOG = 3;
    static readonly SAMPLE = 4;
    static readonly INTERACTION = 5;
    static readonly ACTION = 6;
    static readonly TYPE = 7;
    static readonly OPTIONAL = 8;
    static readonly IF = 9;
    static readonly ELSE = 10;
    static readonly ACTUAL = 11;
    static readonly EXPECTED = 12;
    static readonly DEFAULT = 13;
    static readonly NULL = 14;
    static readonly NOTHING = 15;
    static readonly VOID = 16;
    static readonly ENUM = 17;
    static readonly AT = 18;
    static readonly IS = 19;
    static readonly IN = 20;
    static readonly DASH = 21;
    static readonly PIPE = 22;
    static readonly NUMBER = 23;
    static readonly BOOL = 24;
    static readonly LPAREN = 25;
    static readonly RPAREN = 26;
    static readonly LBRACE = 27;
    static readonly RBRACE = 28;
    static readonly LBRACK = 29;
    static readonly RBRACK = 30;
    static readonly SEMI = 31;
    static readonly COMMA = 32;
    static readonly DOT = 33;
    static readonly COLON = 34;
    static readonly ASSIGN = 35;
    static readonly GT = 36;
    static readonly LT = 37;
    static readonly GE = 38;
    static readonly LE = 39;
    static readonly EQUAL = 40;
    static readonly NOTEQUAL = 41;
    static readonly NOT = 42;
    static readonly AND = 43;
    static readonly OR = 44;
    static readonly WS = 45;
    static readonly JSDOC = 46;
    static readonly COMMENT = 47;
    static readonly LINE_COMMENT = 48;
    static readonly IDENTIFIER = 49;
    static readonly ASTERISK = 50;
    static readonly STRING_START = 51;
    static readonly STRING_STOP = 52;
    static readonly STRING_CONTENT = 53;
    static readonly INCOMPLETE_STRING = 54;
    static readonly RULE_line = 0;
    static readonly RULE_jsdoc = 1;
    static readonly RULE_singleLineExpr = 2;
    static readonly RULE_module = 3;
    static readonly RULE_moduleExpression = 4;
    static readonly RULE_keyword = 5;
    static readonly RULE_identifier = 6;
    static readonly RULE_qualifiedName = 7;
    static readonly RULE_namespaceDeclaration = 8;
    static readonly RULE_importDeclaration = 9;
    static readonly RULE_enumDeclaration = 10;
    static readonly RULE_enumItem = 11;
    static readonly RULE_typeReference = 12;
    static readonly RULE_typeArguments = 13;
    static readonly RULE_typeDeclaration = 14;
    static readonly RULE_typeArgumentDeclarations = 15;
    static readonly RULE_typeArgumentDeclaration = 16;
    static readonly RULE_typeConstraint = 17;
    static readonly RULE_typeProperties = 18;
    static readonly RULE_typeProperty = 19;
    static readonly RULE_argumentDeclarations = 20;
    static readonly RULE_argumentDeclaration = 21;
    static readonly RULE_standardArgumentDeclaration = 22;
    static readonly RULE_functionArgumentDeclaration = 23;
    static readonly RULE_argumentDefault = 24;
    static readonly RULE_actionDeclaration = 25;
    static readonly RULE_interactionDeclaration = 26;
    static readonly RULE_dialogDeclaration = 27;
    static readonly RULE_dialogScope = 28;
    static readonly RULE_functionSignature = 29;
    static readonly RULE_sampleDeclaration = 30;
    static readonly RULE_block = 31;
    static readonly RULE_blockExpression = 32;
    static readonly RULE_qualifiedNameDeclaration = 33;
    static readonly RULE_nameDeclaration = 34;
    static readonly RULE_expression = 35;
    static readonly RULE_literal = 36;
    static readonly RULE_null = 37;
    static readonly RULE_nothing = 38;
    static readonly RULE_void = 39;
    static readonly RULE_number = 40;
    static readonly RULE_string = 41;
    static readonly RULE_string_content = 42;
    static readonly RULE_bool = 43;
    static readonly RULE_annotation = 44;
    static readonly RULE_annotationList = 45;
    static readonly RULE_call = 46;
    static readonly RULE_callArguments = 47;
    static readonly RULE_callArgument = 48;
    static readonly RULE_object = 49;
    static readonly RULE_objectKeyValue = 50;
    static readonly RULE_list = 51;
    static readonly RULE_condition = 52;
    static readonly RULE_otherwise = 53;
    static readonly RULE_correction = 54;
    static readonly RULE_relational = 55;
    static readonly RULE_equality = 56;
    static readonly ruleNames: string[];
    private static readonly _LITERAL_NAMES;
    private static readonly _SYMBOLIC_NAMES;
    static readonly VOCABULARY: Vocabulary;
    get vocabulary(): Vocabulary;
    get grammarFileName(): string;
    get ruleNames(): string[];
    get serializedATN(): string;
    protected createFailedPredicateException(predicate?: string, message?: string): FailedPredicateException;
    constructor(input: TokenStream);
    line(): LineContext;
    jsdoc(): JsdocContext;
    singleLineExpr(): SingleLineExprContext;
    module(): ModuleContext;
    moduleExpression(): ModuleExpressionContext;
    keyword(): KeywordContext;
    identifier(): IdentifierContext;
    qualifiedName(): QualifiedNameContext;
    namespaceDeclaration(): NamespaceDeclarationContext;
    importDeclaration(): ImportDeclarationContext;
    enumDeclaration(): EnumDeclarationContext;
    enumItem(): EnumItemContext;
    typeReference(): TypeReferenceContext;
    typeArguments(): TypeArgumentsContext;
    typeDeclaration(): TypeDeclarationContext;
    typeArgumentDeclarations(): TypeArgumentDeclarationsContext;
    typeArgumentDeclaration(): TypeArgumentDeclarationContext;
    typeConstraint(): TypeConstraintContext;
    typeProperties(): TypePropertiesContext;
    typeProperty(): TypePropertyContext;
    argumentDeclarations(): ArgumentDeclarationsContext;
    argumentDeclaration(): ArgumentDeclarationContext;
    standardArgumentDeclaration(): StandardArgumentDeclarationContext;
    functionArgumentDeclaration(): FunctionArgumentDeclarationContext;
    argumentDefault(): ArgumentDefaultContext;
    actionDeclaration(): ActionDeclarationContext;
    interactionDeclaration(): InteractionDeclarationContext;
    dialogDeclaration(): DialogDeclarationContext;
    dialogScope(): DialogScopeContext;
    functionSignature(): FunctionSignatureContext;
    sampleDeclaration(): SampleDeclarationContext;
    block(): BlockContext;
    blockExpression(): BlockExpressionContext;
    qualifiedNameDeclaration(): QualifiedNameDeclarationContext;
    nameDeclaration(): NameDeclarationContext;
    expression(): ExpressionContext;
    expression(_p: number): ExpressionContext;
    literal(): LiteralContext;
    null(): NullContext;
    nothing(): NothingContext;
    void(): VoidContext;
    number(): NumberContext;
    string(): StringContext;
    string_content(): String_contentContext;
    bool(): BoolContext;
    annotation(): AnnotationContext;
    annotationList(): AnnotationListContext;
    call(): CallContext;
    callArguments(): CallArgumentsContext;
    callArgument(): CallArgumentContext;
    object(): ObjectContext;
    objectKeyValue(): ObjectKeyValueContext;
    list(): ListContext;
    condition(): ConditionContext;
    otherwise(): OtherwiseContext;
    correction(): CorrectionContext;
    relational(): RelationalContext;
    equality(): EqualityContext;
    sempred(_localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    private expression_sempred;
    private static readonly _serializedATNSegments;
    private static readonly _serializedATNSegment0;
    private static readonly _serializedATNSegment1;
    static readonly _serializedATN: string;
    static __ATN: ATN;
    static get _ATN(): ATN;
}
export declare class LineContext extends ParserRuleContext {
    singleLineExpr(): SingleLineExprContext;
    EOF(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class JsdocContext extends ParserRuleContext {
    JSDOC(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class SingleLineExprContext extends ParserRuleContext {
    typeDeclaration(): TypeDeclarationContext | undefined;
    actionDeclaration(): ActionDeclarationContext | undefined;
    nameDeclaration(): NameDeclarationContext | undefined;
    qualifiedNameDeclaration(): QualifiedNameDeclarationContext | undefined;
    call(): CallContext | undefined;
    correction(): CorrectionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ModuleContext extends ParserRuleContext {
    namespaceDeclaration(): NamespaceDeclarationContext | undefined;
    EOF(): TerminalNode;
    jsdoc(): JsdocContext | undefined;
    moduleExpression(): ModuleExpressionContext[];
    moduleExpression(i: number): ModuleExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ModuleExpressionContext extends ParserRuleContext {
    importDeclaration(): ImportDeclarationContext | undefined;
    actionDeclaration(): ActionDeclarationContext | undefined;
    typeDeclaration(): TypeDeclarationContext | undefined;
    dialogDeclaration(): DialogDeclarationContext | undefined;
    interactionDeclaration(): InteractionDeclarationContext | undefined;
    enumDeclaration(): EnumDeclarationContext | undefined;
    qualifiedNameDeclaration(): QualifiedNameDeclarationContext | undefined;
    expression(): ExpressionContext | undefined;
    jsdoc(): JsdocContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class KeywordContext extends ParserRuleContext {
    ACTION(): TerminalNode | undefined;
    TYPE(): TerminalNode | undefined;
    DIALOG(): TerminalNode | undefined;
    INTERACTION(): TerminalNode | undefined;
    ENUM(): TerminalNode | undefined;
    IN(): TerminalNode | undefined;
    IS(): TerminalNode | undefined;
    IF(): TerminalNode | undefined;
    ELSE(): TerminalNode | undefined;
    ACTUAL(): TerminalNode | undefined;
    EXPECTED(): TerminalNode | undefined;
    VOID(): TerminalNode | undefined;
    OPTIONAL(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class IdentifierContext extends ParserRuleContext {
    IDENTIFIER(): TerminalNode | undefined;
    keyword(): KeywordContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class QualifiedNameContext extends ParserRuleContext {
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext;
    DOT(): TerminalNode[];
    DOT(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class NamespaceDeclarationContext extends ParserRuleContext {
    NAMESPACE(): TerminalNode;
    qualifiedName(): QualifiedNameContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ImportDeclarationContext extends ParserRuleContext {
    IMPORT(): TerminalNode;
    qualifiedName(): QualifiedNameContext;
    DOT(): TerminalNode | undefined;
    ASTERISK(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class EnumDeclarationContext extends ParserRuleContext {
    ENUM(): TerminalNode;
    qualifiedName(): QualifiedNameContext;
    LBRACE(): TerminalNode;
    RBRACE(): TerminalNode;
    jsdoc(): JsdocContext | undefined;
    annotationList(): AnnotationListContext | undefined;
    enumItem(): EnumItemContext[];
    enumItem(i: number): EnumItemContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class EnumItemContext extends ParserRuleContext {
    identifier(): IdentifierContext;
    jsdoc(): JsdocContext | undefined;
    annotationList(): AnnotationListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypeReferenceContext extends ParserRuleContext {
    qualifiedName(): QualifiedNameContext;
    annotationList(): AnnotationListContext | undefined;
    typeArguments(): TypeArgumentsContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypeArgumentsContext extends ParserRuleContext {
    LT(): TerminalNode;
    typeReference(): TypeReferenceContext[];
    typeReference(i: number): TypeReferenceContext;
    GT(): TerminalNode;
    COMMA(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypeDeclarationContext extends ParserRuleContext {
    TYPE(): TerminalNode;
    qualifiedName(): QualifiedNameContext;
    jsdoc(): JsdocContext | undefined;
    annotationList(): AnnotationListContext | undefined;
    typeArgumentDeclarations(): TypeArgumentDeclarationsContext | undefined;
    typeConstraint(): TypeConstraintContext[];
    typeConstraint(i: number): TypeConstraintContext;
    typeProperties(): TypePropertiesContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypeArgumentDeclarationsContext extends ParserRuleContext {
    LT(): TerminalNode;
    typeArgumentDeclaration(): TypeArgumentDeclarationContext[];
    typeArgumentDeclaration(i: number): TypeArgumentDeclarationContext;
    GT(): TerminalNode;
    COMMA(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypeArgumentDeclarationContext extends ParserRuleContext {
    identifier(): IdentifierContext;
    typeConstraint(): TypeConstraintContext[];
    typeConstraint(i: number): TypeConstraintContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypeConstraintContext extends ParserRuleContext {
    COLON(): TerminalNode;
    typeReference(): TypeReferenceContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypePropertiesContext extends ParserRuleContext {
    LBRACE(): TerminalNode;
    RBRACE(): TerminalNode;
    typeProperty(): TypePropertyContext[];
    typeProperty(i: number): TypePropertyContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class TypePropertyContext extends ParserRuleContext {
    typeReference(): TypeReferenceContext;
    jsdoc(): JsdocContext | undefined;
    annotationList(): AnnotationListContext | undefined;
    OPTIONAL(): TerminalNode | undefined;
    identifier(): IdentifierContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ArgumentDeclarationsContext extends ParserRuleContext {
    LPAREN(): TerminalNode;
    RPAREN(): TerminalNode;
    argumentDeclaration(): ArgumentDeclarationContext[];
    argumentDeclaration(i: number): ArgumentDeclarationContext;
    COMMA(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ArgumentDeclarationContext extends ParserRuleContext {
    standardArgumentDeclaration(): StandardArgumentDeclarationContext | undefined;
    functionArgumentDeclaration(): FunctionArgumentDeclarationContext | undefined;
    jsdoc(): JsdocContext | undefined;
    annotationList(): AnnotationListContext | undefined;
    OPTIONAL(): TerminalNode | undefined;
    ASSIGN(): TerminalNode | undefined;
    argumentDefault(): ArgumentDefaultContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class StandardArgumentDeclarationContext extends ParserRuleContext {
    typeReference(): TypeReferenceContext;
    identifier(): IdentifierContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class FunctionArgumentDeclarationContext extends ParserRuleContext {
    functionSignature(): FunctionSignatureContext;
    DIALOG(): TerminalNode | undefined;
    ACTION(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ArgumentDefaultContext extends ParserRuleContext {
    expression(): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ActionDeclarationContext extends ParserRuleContext {
    ACTION(): TerminalNode;
    functionSignature(): FunctionSignatureContext;
    jsdoc(): JsdocContext | undefined;
    annotationList(): AnnotationListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class InteractionDeclarationContext extends ParserRuleContext {
    INTERACTION(): TerminalNode;
    block(): BlockContext;
    annotationList(): AnnotationListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class DialogDeclarationContext extends ParserRuleContext {
    DIALOG(): TerminalNode;
    functionSignature(): FunctionSignatureContext;
    dialogScope(): DialogScopeContext;
    annotationList(): AnnotationListContext | undefined;
    jsdoc(): JsdocContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class DialogScopeContext extends ParserRuleContext {
    LBRACE(): TerminalNode;
    RBRACE(): TerminalNode;
    sampleDeclaration(): SampleDeclarationContext[];
    sampleDeclaration(i: number): SampleDeclarationContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class FunctionSignatureContext extends ParserRuleContext {
    qualifiedName(): QualifiedNameContext | undefined;
    identifier(): IdentifierContext | undefined;
    void(): VoidContext | undefined;
    typeReference(): TypeReferenceContext | undefined;
    typeArgumentDeclarations(): TypeArgumentDeclarationsContext | undefined;
    argumentDeclarations(): ArgumentDeclarationsContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class SampleDeclarationContext extends ParserRuleContext {
    SAMPLE(): TerminalNode;
    block(): BlockContext;
    annotationList(): AnnotationListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class BlockContext extends ParserRuleContext {
    LBRACE(): TerminalNode;
    RBRACE(): TerminalNode;
    blockExpression(): BlockExpressionContext[];
    blockExpression(i: number): BlockExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class BlockExpressionContext extends ParserRuleContext {
    nameDeclaration(): NameDeclarationContext | undefined;
    expression(): ExpressionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class QualifiedNameDeclarationContext extends ParserRuleContext {
    qualifiedName(): QualifiedNameContext;
    ASSIGN(): TerminalNode;
    expression(): ExpressionContext;
    jsdoc(): JsdocContext | undefined;
    annotationList(): AnnotationListContext | undefined;
    typeReference(): TypeReferenceContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class NameDeclarationContext extends ParserRuleContext {
    identifier(): IdentifierContext;
    ASSIGN(): TerminalNode;
    expression(): ExpressionContext;
    jsdoc(): JsdocContext | undefined;
    typeReference(): TypeReferenceContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ExpressionContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ExpressionContext): void;
}
export declare class ConditionExprContext extends ExpressionContext {
    condition(): ConditionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class CorrectionExprContext extends ExpressionContext {
    correction(): CorrectionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class CallExprContext extends ExpressionContext {
    call(): CallContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class LiteralExprContext extends ExpressionContext {
    list(): ListContext | undefined;
    object(): ObjectContext | undefined;
    null(): NullContext | undefined;
    nothing(): NothingContext | undefined;
    number(): NumberContext | undefined;
    string(): StringContext | undefined;
    bool(): BoolContext | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class IsExprContext extends ExpressionContext {
    expression(): ExpressionContext;
    IS(): TerminalNode;
    typeReference(): TypeReferenceContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ListIndexContext extends ExpressionContext {
    expression(): ExpressionContext;
    LBRACK(): TerminalNode;
    number(): NumberContext;
    RBRACK(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class PropertyReferenceContext extends ExpressionContext {
    expression(): ExpressionContext;
    DOT(): TerminalNode;
    identifier(): IdentifierContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class InExprContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    IN(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class BinaryExprContext extends ExpressionContext {
    _left: ExpressionContext;
    _right: ExpressionContext;
    NOT(): TerminalNode | undefined;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    relational(): RelationalContext | undefined;
    equality(): EqualityContext | undefined;
    AND(): TerminalNode | undefined;
    OR(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class IdentifierExprContext extends ExpressionContext {
    identifier(): IdentifierContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ParenthesizedExprContext extends ExpressionContext {
    LPAREN(): TerminalNode;
    expression(): ExpressionContext;
    RPAREN(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class LiteralContext extends ParserRuleContext {
    null(): NullContext | undefined;
    nothing(): NothingContext | undefined;
    number(): NumberContext | undefined;
    string(): StringContext | undefined;
    bool(): BoolContext | undefined;
    list(): ListContext | undefined;
    object(): ObjectContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class NullContext extends ParserRuleContext {
    NULL(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class NothingContext extends ParserRuleContext {
    NOTHING(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class VoidContext extends ParserRuleContext {
    VOID(): TerminalNode;
    annotationList(): AnnotationListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class NumberContext extends ParserRuleContext {
    NUMBER(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class StringContext extends ParserRuleContext {
    STRING_START(): TerminalNode;
    STRING_STOP(): TerminalNode;
    string_content(): String_contentContext[];
    string_content(i: number): String_contentContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class String_contentContext extends ParserRuleContext {
    STRING_CONTENT(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class BoolContext extends ParserRuleContext {
    BOOL(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class AnnotationContext extends ParserRuleContext {
    AT(): TerminalNode;
    call(): CallContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class AnnotationListContext extends ParserRuleContext {
    annotation(): AnnotationContext[];
    annotation(i: number): AnnotationContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class CallContext extends ParserRuleContext {
    qualifiedName(): QualifiedNameContext;
    LPAREN(): TerminalNode;
    RPAREN(): TerminalNode;
    typeArguments(): TypeArgumentsContext | undefined;
    callArguments(): CallArgumentsContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class CallArgumentsContext extends ParserRuleContext {
    callArgument(): CallArgumentContext[];
    callArgument(i: number): CallArgumentContext;
    COMMA(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class CallArgumentContext extends ParserRuleContext {
    expression(): ExpressionContext;
    identifier(): IdentifierContext | undefined;
    ASSIGN(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ObjectContext extends ParserRuleContext {
    LBRACE(): TerminalNode;
    RBRACE(): TerminalNode;
    typeReference(): TypeReferenceContext | undefined;
    objectKeyValue(): ObjectKeyValueContext[];
    objectKeyValue(i: number): ObjectKeyValueContext;
    COMMA(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ObjectKeyValueContext extends ParserRuleContext {
    identifier(): IdentifierContext;
    ASSIGN(): TerminalNode | undefined;
    expression(): ExpressionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ListContext extends ParserRuleContext {
    LBRACK(): TerminalNode;
    RBRACK(): TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    COMMA(): TerminalNode[];
    COMMA(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class ConditionContext extends ParserRuleContext {
    IF(): TerminalNode;
    LPAREN(): TerminalNode;
    expression(): ExpressionContext;
    RPAREN(): TerminalNode;
    block(): BlockContext;
    otherwise(): OtherwiseContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class OtherwiseContext extends ParserRuleContext {
    ELSE(): TerminalNode | undefined;
    condition(): ConditionContext | undefined;
    block(): BlockContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class CorrectionContext extends ParserRuleContext {
    ACTUAL(): TerminalNode;
    block(): BlockContext[];
    block(i: number): BlockContext;
    EXPECTED(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class RelationalContext extends ParserRuleContext {
    GT(): TerminalNode | undefined;
    GE(): TerminalNode | undefined;
    LT(): TerminalNode | undefined;
    LE(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
export declare class EqualityContext extends ParserRuleContext {
    EQUAL(): TerminalNode | undefined;
    NOTEQUAL(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: ACDLParserListener): void;
    exitRule(listener: ACDLParserListener): void;
    accept<Result>(visitor: ACDLParserVisitor<Result>): Result;
}
//# sourceMappingURL=ACDLParser.d.ts.map