import immutable from "immutable";
import * as ask from "./ast";
/**
 * Fully qualified name bindings.
 */
export type LexicalScope = immutable.Map<string, ask.Node[] | ask.Node | undefined>;
export declare function emptyLexicalScope(): LexicalScope;
export type ExpressionWithName = Extract<ask.Node, {
    name?: ask.Name;
}>;
/**
 * Computes the lexical scope for an array of named expressions.
 */
export declare function computeLexicalScope(expressions: ExpressionWithName[] | undefined): LexicalScope;
export declare function mergeLexicalScope(a: LexicalScope, b: LexicalScope): LexicalScope;
export declare function mergeLexicalScopeNode(a: ask.Node | ask.Node[] | undefined, b: ask.Node | ask.Node[] | undefined): ask.Argument | ask.Annotation<ask.AnnotatedNode> | ask.Correction | ask.When | ask.ActionDeclaration | ask.ArgumentDeclaration | ask.Call<ask.CallContext> | ask.Condition | ask.InteractionDeclaration | ask.DialogDeclaration | ask.EnumDeclaration | ask.NameDeclaration<ask.Named> | ask.NameReference | ask.PropertyReference | ask.Sample | ask.TypeDeclaration | ask.EnumItem | ask.Import | ask.ListLiteral<ask.Value> | ask.ListItem<ask.Value> | ask.Module | ask.Name | ask.Block<ask.Expression, ask.Node> | ask.TypeParameter | ask.TypeReference | ask.TypeProperty | ask.Utterance | ask.ResponseTemplate<ask.ResponseTemplateType> | ask.SlotType | ask.Node[] | undefined;
//# sourceMappingURL=lexical-scope.d.ts.map