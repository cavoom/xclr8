import * as ask from "./ast";
import { Project } from "./project";
import { Thing } from "./thing";
import { Apply } from "./apply";
import { ParseError } from "./error";
import { TypeChecker } from "./checker";
import { Flow } from "./flow";
import { EvaluationState } from "./evaluation-state";
import { ConditionalBranch, ConfirmAction, ConfirmArgs, DelegateRequest, DelegateToIntent, DialogExpansion, End, Ensure, Expect, Expression, InvokeApi, Response } from "./expression";
import { LocationObject } from "./error-factory";
/**
 * An evaluator is a function that takes an expression and evaluates it to a Thing.
 */
export type Evaluator<T> = (expr: T, state: EvaluationState) => EvaluationState;
/**
 * Validates that the Dialog is deployable. A deployable dialog is one that accepts no arguments and returns `Nothing` or `Void`.
 */
export declare function evaluateDialogFlow(flow: Flow<ask.DialogDeclaration>, state: EvaluationState): ParseError[];
/**
 * Validates that the data flow is correct.
 *
 * @param node
 * @param flow
 * @returns
 */
export declare function evaluateFlow(flow: Flow, state: EvaluationState): EvaluationState[];
export declare function evaluateExpression(expr: Expression, state: EvaluationState): EvaluationState;
/**
 * Called at the end of a single dialog flow. During evaluation, we often delay validation until
 * the end as an optimization. For example, checking if an argument is requested - if the ensure()
 * block is called later on in the dialog flow, we don't want to be searching forward all the time
 * because searching forward is slow. Instead, we track that in {@link EvaluationState} and then
 * perform the validation here. This reduces the time complexity significantly.
 */
export declare function evaluateEnd(endExpr: End, state: EvaluationState): EvaluationState;
export declare function evaluateDialogExpansion(expr: DialogExpansion, state: EvaluationState): EvaluationState;
export declare const evaluateExpect: Evaluator<Expect>;
/**
 * Validate DelegateRequest action used in dialog sample.
 *
 * - `delegateRequest`'s cannot be chained together.
 * - slots must come from an event or api call, optionally wrapped in a complex object.
 */
export declare const evaluateDelegateRequest: Evaluator<DelegateRequest>;
/**
 * Validate DelegateToIntent action used in dialog sample.
 *
 * - `delegateToIntent`'s cannot be chained together.
 * - slots must come from an event or api call, optionally wrapped in a complex object.
 */
export declare const evaluateDelegateToIntent: Evaluator<DelegateToIntent>;
/**
 * Validate Response action used in dialog sample
 * including specific validations to the four args (Response, ResponseAct, next ResponseAct, Payload)
 * and make sure those args are used in allowed combination
 */
export declare const evaluateResponse: Evaluator<Response>;
/**
 * Validate the act used in response action
 * 1. The act could only be one of valid ResponseAct: 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'
 * 2. ReqAlt cannot be the first act
 * 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
 * 4. for ConfirmArgs, make sure the payload property exist in argument list
 */
export declare const validateResponseAct: (response: Response, state: EvaluationState) => EvaluationState;
/**
 * Modifies pending offer state if actionName is provided in Offer
 */
export declare const addPendingOfferIfAction: (act: Thing | undefined, state: EvaluationState) => EvaluationState;
/**
 * Validate nextAct used in response action
 * 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
 * 2. nextAct could only follow Notify act
 * 3. the ReqAlt act can only be the next Act to a Notify Act with "success = false"
 * 4. for ReqAlt, the items in the "arguments" list should be from the same Action
 * 5. for ReqAlt, actionName used in Notify and ReqAlt argument list should be consistent
 */
export declare const validateNextAct: (response: Response, state: EvaluationState) => ParseError[];
/**
 * Validate confirmAction action used in dialog sample
 */
export declare const evaluateConfirmAction: (confirm: Response | ConfirmAction, state: EvaluationState) => EvaluationState;
/**
 * Validate confirmArgs action used in dialog sample
 * traverse the confirmArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure all arguments in the argument list refer to the same action
 * 3. Make sure all arguments in the argument list has request prompt
 */
export declare const evaluateConfirmArgs: Evaluator<ConfirmArgs>;
/**
 * Validate the ConfirmArgs act used in response action
 * 1. make sure the items in the "arguments" list should be from the same Action
 * 2. make sure all arguments in the argument list has request prompt
 * 3. make sure there exist Affirm or Deny event after ConfirmArgs Act
 * 4. make sure the next api call is consistent with the action whose arguments are been confirmed
 * @param response
 * @param confirmArgsAct
 * @param branch
 */
export declare const validateConfirmArgsAct: (confirm: Response, state: EvaluationState) => EvaluationState;
/**
 * The next api call after Confirm Args dialog act must be consistent with the action which is been confirmed.
 */
export declare const validateConfirmArgsFlow: (confirm: Response, state: EvaluationState) => ParseError[];
/**
 * Validate ensure action used in dialog sample
 * traverse the requestArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure each all arguments in the argument list refer to the same action
 * 3. When the arguments list of RequestArguments contains multiple args, make sure each arg has request prompt
 */
export declare const evaluateEnsure: Evaluator<Ensure>;
/**
 * Validations of the List<Argument<Thing>> type
 * the items in the "arguments" list should be from the same Action
 * @param value
 * @param branch
 */
export declare function validateArgumentList(value: ask.Value, valueThing: Thing | undefined): ParseError<import("./error-factory").Error, string>[];
export declare function validateArgumentListThing(list: Thing | undefined, expr: LocationObject | undefined): ParseError[];
/**
 * Validate response argument in response, confirmAction, ensure and confirmArgs actions
 * The type of response should be APL-A
 *
 * Right now the type validation won't check response type cause the response type could be anything
 */
export declare const validatePrompt: (apply: Apply) => ParseError<import("./error-factory").Error, string>[];
export declare const validateRequestPromptInArgsList: (expr: Expression, act: Thing | undefined, state: EvaluationState) => EvaluationState;
/**
 * Validate the user Defined api call inside dialog sample
 * 1. make sure the argument is api result or event result
 * 2. make sure the required argument has Request Prompt
 * 3. make sure the argument(event result) has not been reset
 * 4. make sure all of the api arguments leaf types are primitive or backed by a catalog
 * 5. make sure the the api return value leaf types are primitive or backed by a catalog
 */
export declare const evaluateInvokeApi: Evaluator<InvokeApi>;
/**
 * Validate payload argument in response and confirmAction action
 *
 * 1. the expression assigned to payload is either null, Thing, or an ObjectLiteral
 * 2. the value assigned to payload property can only be a name directly referring to an api result or a type used in an event
 * 3. validate payload against next api call
 *
 * The Simulator can only understand payload values to be either a slot in the event or the return value of an api invocation
 */
export declare const validatePayload: (response: Response | ConfirmAction, state: EvaluationState) => ParseError[];
export declare function validateGlobalWelcome(project: Project, checker: TypeChecker): ParseError[];
/**
 * validate all required prompts are exist in current skill
 */
export declare function validateSkillLevelResponses(project: Project): ParseError[];
/**
 * Verify the expect of Invoke event exists by recursively calling the @function doesSampleStartWithInvoke
 *
 * E.G. Below is a valid example, as it has expect with Invoke event:
 * dialog void A {
 *   sample {
 *     expect(Invoke, invocationUtterances)
 *     // ... conversation flow's logic
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * It makes sure all the branches have an Invoke event if conditional branches exist.
 * E.G. The dialog below is not a valid one as it misses Invoke in one condition branch:
 * dialog void B {
 *   sample {
 *     if (some_condition) {
 *       expect(RequestAlt, invocationUtterances)
 *     } else {
 *       expect(Invoke, invocationUtterances)
 *     }
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * @param sample sample node to validate through the expressions to find Invoke event
 * @param flow type checker
 * @returns
 */
export declare const validateSampleStartWithInvoke: (flow: Flow<ask.Sample>, state: EvaluationState) => ParseError[];
/**
 * This function validates Condition.when for the following checkpoints:
 * 2. validate the when condition contains any data from the last API invocation call
 * 3. validate then when expression to have a boolean return type
 *
 * @param cond Condition.when Call | NameReference
 * @param condition type checker for querying the expressions
 * @returns type Validator<T>
 */
export declare const evaluateConditionalBranch: Evaluator<ConditionalBranch>;
/**
 * Validates that a `delegateToIntent` call was not the previous expression.
 *
 * @param expr - Expression that is not allowed to follow delegation
 * @param state - EvaluationState
 */
export declare const validatePriorDelegation: (expr: Expression) => ParseError[];
/**
 * Validates if response calls with 'Request' request acts are called consecutively
 */
export declare const validatePriorResponseCall: (response: Response) => ParseError[];
//# sourceMappingURL=evaluate.d.ts.map