import immutable from "immutable";
import * as ask from "./ast";
import { AnnotationTarget } from "./ast";
import { Property } from "./property";
import { Type } from "./type";
import { TypeChecker } from "./checker";
import { Environment } from "./environment";
import { ResponseInfo } from "./responseInfo";
import { ArgumentThing, Thing } from "./thing";
export type DialogApply = Apply & {
    decl: ask.DialogDeclaration | (Type & {
        declaration: ask.DialogDeclaration;
    });
};
/**
 * An Apply represents a Call to an Action, Dialog or Type.
 *
 * This class provides a lazily-evaluated API for querying this call's AST
 * for type checking and type inference.
 */
export declare class Apply {
    readonly checker: TypeChecker;
    readonly call: ask.Call;
    readonly decl: Type | ask.TypeDeclaration | ask.ActionDeclaration | ask.DialogDeclaration;
    readonly kind: "Apply";
    readonly argumentDeclarations: (ask.ArgumentDeclaration | Property)[] | undefined;
    readonly argumentDeclIndex: Record<string, ask.ArgumentDeclaration | Property>;
    readonly requiredArguments: readonly string[];
    private returnType;
    private arguments;
    private genericEnvironment;
    private genericArguments;
    constructor(checker: TypeChecker, call: ask.Call, decl: Type | ask.TypeDeclaration | ask.ActionDeclaration | ask.DialogDeclaration);
    constructor(checker: TypeChecker, call: ask.Call, decl: Type | ask.TypeDeclaration | ask.ActionDeclaration | ask.DialogDeclaration, prev: Apply, returnType: Type | null | undefined, argumentIndex: Record<string, ask.Argument> | undefined | null, genericEnvironment: Environment | null | undefined, genericArguments: Type[] | null | undefined);
    /**
     * Instantiate this static Apply instance within a local TypeChecker environment.
     *
     * @param localChecker the new environment in which to instantiate the Apply.
     */
    instantiate(localChecker: TypeChecker): Apply | undefined;
    isList(): this is {
        decl: Type;
    };
    getListItems(): ask.Value[] | undefined;
    isArgs(): this is {
        decl: Type;
    };
    isType(): this is {
        decl: Type | ask.TypeDeclaration;
    };
    isIs(): boolean;
    isIsInCatalog(): boolean;
    isIn(): boolean;
    isWhen(): boolean;
    isEq(): boolean;
    isNeq(): boolean;
    isAnd(): boolean;
    isOr(): boolean;
    isNot(): boolean;
    isGt(): boolean;
    isGte(): boolean;
    isLt(): boolean;
    isLte(): boolean;
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.skill` action.
     */
    isSkillAction(): boolean;
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.Skill` type.
     */
    isSkillType(): boolean;
    /**
     * Checks if this apply is targeting the core `annotation` action.
     */
    isAnnotationAction(): boolean;
    /**
     * Checks if the target of this Apply is an action annotated with the `@annotation` meta-annotation?
     */
    isAnnotation(): this is {
        decl: ask.ActionDeclaration;
    };
    /**
     * Get the `allowMultiple` field from an instance of the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * @returns true/false if this is an instance of `Annotation`, otherwise `undefined.
     */
    getAnnotationAllowMultiple(): boolean | undefined;
    /**
     * Get the `targets` field if this is a call to the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * Ex.
     * ```
     * // returns [AnnotationTarget.Type]
     * @Annotation(targets = [AnnotationTarget.Type])
     * ..
     * ```
     */
    getAnnotationTargets(): AnnotationTarget[] | undefined;
    isAction(): boolean;
    isBuiltin(): boolean;
    isUserDefinedApi(): boolean;
    isDialog(): this is DialogApply;
    isBinaryOperator(): boolean;
    isOperator(): boolean;
    isNativeAction(): boolean;
    isFileAccessAction(): boolean;
    isGetListItem(): boolean;
    isEnsure(): boolean;
    isExpect(): boolean;
    isConfirmAction(): boolean;
    isConfirmActionAct(): boolean;
    /**
     * Checks if this is a call to the `confirmArgs` action.
     */
    isConfirmArgs(): boolean;
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArgsAct(): this is {
        decl: Type;
    };
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArguments(): this is {
        decl: Type;
    };
    isUtterances(): boolean;
    isTouch(): boolean;
    isMultiModalEvent(): boolean;
    isEventDecl(): boolean;
    isCatalogDecl(): boolean;
    isUtterance(): boolean;
    isIntent(): boolean;
    isAlexaLine(): boolean;
    isResponse(): boolean;
    isDelegateToIntent(): boolean;
    isIntentRequest(): boolean;
    isDelegateRequest(): boolean;
    isReceived(): boolean;
    isRequestArguments(): boolean;
    isResetAllArguments(): boolean;
    isResetArguments(): boolean;
    isEnsureArgOrder(): boolean;
    isRequestAct(): this is {
        decl: Type;
    };
    isLength(): boolean;
    isAlexaSchemaNamespace(): boolean;
    isAlexaConversationsNamespace(): boolean;
    isAlexaBuiltinsNamespace(): boolean;
    isSize(): boolean;
    isUserSays(): boolean;
    isExists(): boolean;
    isEvents(): boolean;
    isWelcome(): boolean;
    isLocaleAction(): boolean;
    isVarArgs(): boolean;
    isValidateArg(): boolean;
    isVariations(): boolean;
    isAplaAction(): boolean;
    isAplAction(): boolean;
    isReferableAction(): boolean;
    isCatalogAction(): boolean;
    isCatalogType(): boolean;
    isListBasedCatalogAction(): boolean;
    isExtendCatalogAction(): boolean;
    isBuiltinCatalogAction(): boolean;
    isGeneratedAction(): boolean;
    isGetAllNamesAction(): boolean;
    getName(): string | undefined;
    getShortName(): string | undefined;
    /**
     * Gets a Thing representing an Argument Value.
     *
     * @param name name of the argument value.
     * @returns a Thing representing the value (if it can be determined) or `undefined`.
     */
    getArgumentValueThing(name: string | ask.Name | ArgumentThing): Thing | undefined;
    /**
     * Gets a List of Thing representing all the argument values
     * @returns a List of Thing representing all the argument values
     */
    getArgumentValueThingList(): (Thing | undefined)[];
    /**
     * Get the specific argument value by name
     * @param name name string or ask.Name
     */
    getArgumentValue(name: string | ask.Name | ArgumentThing): ask.Value | undefined;
    /**
     * Get the specific argument by name
     * @param name name string or ask.Name
     */
    getArgument(name: string | ask.Name | ArgumentThing | undefined): ask.Argument | undefined;
    /**
     * Get the specific argument value by name, if it's a nameReference, resolve it
     * @param name name string or ask.Name
     * @returns
     */
    getArgumentValueAndResolveIfNameRef(name: string | ask.Name): ask.Node | undefined;
    /**
     * Get the specific argument value by name, if the value kind is nameReference, resolve it to the call
     *
     * E.G.
     * ```
     * apla = APLA {}
     * temp = apla
     * response(temp, Bye {})
     *
     * if we have the response apply
     * apply.getArgumentValueAndResolveToCallIfNameRef('response') => APLA {}
     * ```
     * @param name name string or ask.Name
     */
    getArgumentValueAndResolveToCallIfNameRef(name: string | ask.Name): ask.Value | undefined;
    getArgumentsList(): ask.Argument[];
    getArgumentsThing(): Record<string, Thing | undefined>;
    /**
     * Get a map or argument name to the ArgumentValue node passed to this call.
     */
    getArguments(): Record<string, ask.Argument> | undefined;
    /**
     * Get the return type of this call.
     *
     * Infers generic arguments and computing generic return type if necessary
     *
     * @returns the return type if it is known, otherwise `undefined`.
     */
    getReturnType(seen?: immutable.Set<ask.Node>): Type | undefined;
    private resolveReturnType;
    /**
     * Get the type of an argument or property
     */
    getType(arg: ask.Argument | ask.ArgumentDeclaration | ask.TypeProperty | Property | undefined, context?: ask.Node | undefined): Type | undefined;
    /**
     * Retuns a mapping of generic argument names to their inferred type. For instance consider the action declaration:
     *
     *    action Nothing getWeather<T,K>(T something, K somethingElse)
     *
     * For the call/apply below:
     *    sample {
     *      ...
     *      getWeather('x', 1)
     *      ...
     *    }
     * The return value will be: { "T" : <Type object refering to string>, "K": <Type object refering to number>}
     *
     * For anonymous functions the generic arguments are also types as opposed to something like T or K above.
     * For instance consider the reusable dialog declaration containing an anonymous function receiving Optional<T>
     * and returning Nothing:
     *     dialog Nothing reusableDialog<T>( Action1<Optional<T>, Nothing> anonAction, T value) {
     *        sample {
     *            ...
     *            anonAction(value);
     *            ...
     *        }
     *     }
     * for the call/apply inside the sample the generic arguments are the types Optional<T> and Nothing
     * seen in Action1<Optional<T>, Nothing> anonAction
     * The return value for this call is {"T": <Type object refering to T>, "Nothing": <Type object refering to Nothing>}
     * @param seen used  to prevent infinite recursion in type lookups
     */
    getGenericEnvironment(seen?: immutable.Set<ask.Node>): Environment | undefined;
    /**
     * Does the actual work in getGenericEnvironment.
     * @param seen used  to prevent infinite recursion in type lookups
     */
    private resolveGetGenericEnvironment;
    getGenericArguments(seen?: immutable.Set<ask.Node>): (Type | undefined)[] | undefined;
    private resolveGenericArguments;
    /**
     * a util function help retrieve payload argumentDeclarations
     * @param apply
     */
    getPayloadValue(): ask.Value | undefined;
    /**
     * get detailed response info for an Alexa response
     *
     * In current acdl, there's four response actions and eight response acts, it's hard to retrieve property in different kind of responses
     * This function try to collect all info an Alexa Response may have and represent them as ResponseInfo interface,
     * this new layer make it easier to get a specific property in an Alexa response
     *
     * E.G.
     * ```
     * ensure(
     *      RequestArguments {arguments = [getPerson.arguments.name], response = greeting_apla},
     *      RequestArguments {arguments = [getPerson.arguments.age], response = bye_apla}
     * )
     *
     * =>
     *
     * [
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.name],
     *     prompt: greeting_apla
     *   },
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.age],
     *     prompt: bye_apla
     *   }
     * ]
     * ```
     *
     * @returns
     */
    getResponseInfo(): ResponseInfo[];
}
//# sourceMappingURL=apply.d.ts.map