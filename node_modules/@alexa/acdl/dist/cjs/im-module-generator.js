"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionModelModuleGenerator = void 0;
const ask = __importStar(require("./ast"));
const ast_1 = require("./ast");
const constants_1 = require("./constants");
const source_file_1 = require("./source-file");
const util_1 = require("./util");
const error_factory_1 = require("./error-factory");
/**
 * Generates interaction model ASKIR modules from a projects interaction model files.
 */
class InteractionModelModuleGenerator {
    constructor(dir, interactionModelFiles) {
        /**
         * Directory that is used when specifying the generated module source files uri.
         */
        Object.defineProperty(this, "dir", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Interaction model file absolute file paths.
         */
        Object.defineProperty(this, "interactionModelFiles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Map from locale to the parsed interaction model content.
         */
        Object.defineProperty(this, "interactionModels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dir = dir;
        this.interactionModelFiles = interactionModelFiles;
    }
    /**
     * Loads the interaction models asyncly.
     */
    loadInteractionModelsSync() {
        if (this.interactionModels === undefined) {
            const map = {};
            for (const interactionModelFile of this.interactionModelFiles) {
                const im = (0, util_1.readJsonFileSync)(interactionModelFile.file);
                if (im !== undefined) {
                    map[interactionModelFile.locale] = im;
                }
            }
            this.interactionModels = map;
        }
    }
    /**
     * Loads the interaction models syncly.
     */
    async loadInteractionModels() {
        if (this.interactionModels === undefined) {
            const map = {};
            for (const interactionModelFile of this.interactionModelFiles) {
                const im = await (0, util_1.readJsonFile)(interactionModelFile.file);
                if (im !== undefined) {
                    map[interactionModelFile.locale] = im;
                }
            }
            this.interactionModels = map;
        }
    }
    /**
     * Generates ASKIR Modules that will be compiled and built with a projects source modules.
     *
     * @returns Generated interaction model modules
     */
    async generateInteractionModelModules() {
        if (this.interactionModelFiles.length === 0) {
            return [];
        }
        await this.loadInteractionModels();
        return [...this.generateCatalogModules(), ...this.generateIntentModules()];
    }
    /**
     * Generates ASKIR Modules that will be compiled and built with a projects source modules.
     *
     * @returns Generated interaction model modules
     */
    generateInteractionModelModulesSync() {
        if (this.interactionModelFiles.length === 0) {
            return [];
        }
        this.loadInteractionModelsSync();
        return [...this.generateCatalogModules(), ...this.generateIntentModules()];
    }
    /**
     * Generates the following modules:
     *
     * - `ask.interactionModel.catalogs.{locale}`
     * - `ask.interactionModel.catalogs`
     * - `ask.interactionModel.slotTypes`
     *
     * This function creates a module for each interaction model locale, and will store a variation
     * map that stores a catalog name as the key and locales as the values. The variation map is used
     * to generate the root catalogs module, and is also used for generating the slotTypes module.
     *
     * @returns Generated interaction model catalog and slotTypes modules
     */
    generateCatalogModules() {
        // Map of catalog name to locales. We will use this to create the variations.
        const variations = {};
        const catalogIntentModules = Object.entries(this.interactionModels)
            .map(([locale, im]) => {
            var _a, _b;
            if (((_b = (_a = im === null || im === void 0 ? void 0 : im.interactionModel) === null || _a === void 0 ? void 0 : _a.languageModel) === null || _b === void 0 ? void 0 : _b.types) === undefined) {
                return undefined;
            }
            const namespaceLocale = locale.replace("-", "");
            const namespace = `${constants_1.Namespaces.catalogs}.${namespaceLocale}`;
            const expressions = im.interactionModel.languageModel.types
                .map((catalog) => {
                if ((0, util_1.isAmazonBuiltin)(catalog.name)) {
                    return undefined;
                }
                const { name } = catalog;
                const listBastedCatalog = this.generateListBasedCatalog(catalog);
                if (variations[name] === undefined) {
                    variations[name] = [];
                }
                variations[name].push(namespaceLocale);
                return new ask.NameDeclaration(new ask.Name(`${namespace}.${name}`), undefined, listBastedCatalog, [
                    this.generateGeneratedAnnotation("interactionModel"),
                    this.generateLocaleAnnotation(locale.replace("-", "_")),
                ]);
            })
                .filter(util_1.isNotUndefined);
            return this.interactionModelSourceModule(`catalog-${namespaceLocale}`, namespace, expressions);
        })
            .filter(util_1.isNotUndefined);
        // Now we generate the catalogs and slotTypes modules with the variations.
        return [...catalogIntentModules, this.generateCatalogVariationModules(variations), this.generateSlotTypesModule(variations)];
    }
    /**
     * Generates the `ask.interactionModel.catalogs` module.
     *
     * This module will contain all of the variations of each interaction model catalogs.
     *
     * @param catalogMap map of catalog names to locales it's defined in (MyPlanetSlot -> [enUS, deDE])
     * @returns Generated catalog variation ASKIR module
     */
    generateCatalogVariationModules(catalogMap) {
        return this.generateVariationModule("catalogs", catalogMap, constants_1.Namespaces.catalogs);
    }
    /**
     * Generates the `ask.interactionModel.slotTypes` module.
     *
     * This module will contain all of the type declarations of the interaction model slot types.
     *
     * @param catalogMap map of catalog names to locales it's defined in (MyPlanetSlot -> [enUS, deDE])
     * @returns Generated slotTypes ASKIR module
     */
    generateSlotTypesModule(catalogMap) {
        const namespace = constants_1.Namespaces.slotTypes;
        const expressions = Object.keys(catalogMap)
            .map((name) => {
            if ((0, util_1.isAmazonBuiltin)(name)) {
                return undefined;
            }
            return new ask.TypeDeclaration(new ask.Name(`${namespace}.${name}`), undefined, undefined, [new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.String))], [this.generateGeneratedAnnotation("interactionModel"), this.generateCatalogAnnotation(`${constants_1.Namespaces.catalogs}.${name}`)]);
        })
            .filter(util_1.isNotUndefined);
        return this.interactionModelSourceModule("slotTypes", namespace, expressions);
    }
    /**
     *
     * Generates the following modules:
     *
     * - `ask.interactionModel.intentTypes`
     * - `ask.interactionModel.intents.{locale}`
     * - `ask.interactionModel.intents`
     *
     * This function creates a module for each interaction model locale, and will store a variation
     * map that stores an intent name as the key and locales as the values. The variation map is used
     * to generate the root intents module.
     *
     * The function first gets the `intentType` module which will also return a set of strings containing
     * the intent names that are identically defined in every interaction model. The function uses the set to generate
     * intents ONLY IF the intent type is defined.
     *
     * @returns The generated ASKIR intent modules.
     */
    generateIntentModules() {
        const variations = {};
        const { validIntents, intentTypeModule } = this.generateIntentTypeModule();
        const intentLocaleModules = Object.entries(this.interactionModels).map(([locale, im]) => {
            var _a, _b, _c, _d;
            const namespaceLocale = locale.replace("-", "");
            const namespace = `${constants_1.Namespaces.intents}.${namespaceLocale}`;
            const errors = [];
            const expressions = ((_d = (_c = (_b = (_a = im === null || im === void 0 ? void 0 : im.interactionModel) === null || _a === void 0 ? void 0 : _a.languageModel) === null || _b === void 0 ? void 0 : _b.intents) === null || _c === void 0 ? void 0 : _c.map((intent) => {
                var _a, _b, _c;
                if (!validIntents.has(intent.name) || !((_a = intent.samples) === null || _a === void 0 ? void 0 : _a.length) || (0, util_1.isAmazonBuiltin)(intent.name)) {
                    return undefined;
                }
                // Generate the samples for the intent action
                const samples = new ask.Call(new ask.Name(ast_1.AlexaSchema.List), new ask.ListLiteral((_c = (_b = intent.samples) === null || _b === void 0 ? void 0 : _b.map((sample, idx) => new ask.ListItem(new ask.Call(new ask.Name(ast_1.AlexaConversations.Utterance), sample, [
                    new ask.TypeReference(new ask.Name(`${constants_1.Namespaces.intentTypes}.${intent.name}`)),
                ]), idx))) !== null && _c !== void 0 ? _c : []), [
                    new ask.TypeReference(new ask.Name(ast_1.AlexaConversations.Utterance), [
                        new ask.TypeReference(new ask.Name(`${constants_1.Namespaces.intentTypes}.${intent.name}`)),
                    ]),
                ]);
                // Generate the name declaration that will be a call to intent<T>(samples)
                const intentDeclaration = new ask.NameDeclaration(new ask.Name(`${namespace}.${intent.name}`), undefined, new ask.Call(new ask.Name(ast_1.AlexaConversations.intent), [new ask.Argument(new ask.Name("samples"), 0, samples)], [new ask.TypeReference(new ask.Name(`${constants_1.Namespaces.intentTypes}.${intent.name}`))]), [this.generateGeneratedAnnotation("interactionModel"), this.generateLocaleAnnotation(locale.replace("-", "_"))]);
                if (variations[intent.name] === undefined) {
                    variations[intent.name] = [];
                }
                variations[intent.name].push(namespaceLocale);
                return intentDeclaration;
            })) !== null && _d !== void 0 ? _d : []).filter((x) => x !== undefined);
            return this.interactionModelSourceModule(`intents-${namespaceLocale}`, namespace, expressions, errors);
        });
        const res = [...intentLocaleModules, intentTypeModule, this.generateIntentVariationModule(variations)];
        return res;
    }
    /**
     *
     * Generates the `ask.interactionModel.intentTypes` module.
     *
     * This module will contain the type declarations for intent types that exist in all
     * interaction models.
     *
     * This function finds the intents that are defined in all models and validates that they
     * have the same structure. If an intent has the same name in another model but has a different
     * structure, it will emit a parse error warning and skip the generation for that intent.
     *
     * Currently this function is three steps:
     *
     * 1. Go through interaction models and gather all intents
     * 2. Validate the remaining intents have the same structure
     * 3. Generate the ASKIR intent type declarations
     *
     *
     * Returns the source module for intentTypes and all of the valid intents. We need to skip
     * intents that don't have a valid intent type.
     *
     * @returns A set of all valid intents and the generated ASKIR intentType module
     */
    generateIntentTypeModule() {
        var _a, _b, _c, _d;
        // Intents that are valid i.e if defined in multiple locales, they have the same structure
        const validIntents = new Set();
        // Map from an intent name to each model's actual intent
        const nameToIntents = new Map();
        // Warnings to emit if intents have different structures in different models
        const errors = [];
        // 1. Gather all intents
        const ims = Object.values(this.interactionModels);
        ims.forEach((im) => {
            var _a, _b, _c;
            (_c = (_b = (_a = im === null || im === void 0 ? void 0 : im.interactionModel) === null || _a === void 0 ? void 0 : _a.languageModel) === null || _b === void 0 ? void 0 : _b.intents) === null || _c === void 0 ? void 0 : _c.forEach((intent) => {
                if ((0, util_1.isAmazonBuiltin)(intent.name)) {
                    return;
                }
                validIntents.add(intent.name);
                if (nameToIntents.has(intent.name)) {
                    nameToIntents.get(intent.name).push(intent);
                }
                else {
                    nameToIntents.set(intent.name, [intent]);
                }
            });
        });
        // 2. Validate the remaining intents have the same structure
        for (const intentName of nameToIntents.keys()) {
            // The base intent we'll validate against
            const baseIntent = nameToIntents.get(intentName)[0];
            let intentValid = true;
            for (const intentToCheck of nameToIntents.get(intentName)) {
                if (((_a = baseIntent.slots) === null || _a === void 0 ? void 0 : _a.length) !== ((_b = intentToCheck.slots) === null || _b === void 0 ? void 0 : _b.length)) {
                    intentValid = false;
                    break;
                }
                // Validate the slots match
                for (const slotToCheck of (_c = intentToCheck.slots) !== null && _c !== void 0 ? _c : []) {
                    let slotMatch = false;
                    // Looping through incase the slot type is defined in a different position but has same structure
                    for (const slot of (_d = baseIntent.slots) !== null && _d !== void 0 ? _d : []) {
                        if (slot.name === slotToCheck.name && slot.type === slotToCheck.type) {
                            slotMatch = true;
                            break;
                        }
                    }
                    // No matching slot was found, mark intent as invalid
                    if (!slotMatch) {
                        intentValid = false;
                        break;
                    }
                }
            }
            if (!intentValid) {
                // Skip generation of this intent
                errors.push(error_factory_1.ValidationErrorFactory.NonMatchingInteractionModelIntents({
                    attributes: {
                        intentName,
                    },
                }));
                validIntents.delete(intentName);
            }
        }
        // 3. Generate the ASKIR type declarations, we need to check if it's a builtin type or a custom type
        const namespace = constants_1.Namespaces.intentTypes;
        const expressions = Array.from(validIntents).map((intentName) => {
            var _a;
            const intent = nameToIntents.get(intentName)[0];
            // The properties on the generated intent type
            const typeProperties = (_a = intent.slots) === null || _a === void 0 ? void 0 : _a.map((slot) => {
                var _a;
                const type = slot.type ? this.generateSlotTypeReference(slot.type, (_a = slot.multipleValues) === null || _a === void 0 ? void 0 : _a.enabled) : undefined;
                return new ask.TypeProperty(new ask.Name(slot.name), type, true);
            });
            return new ask.TypeDeclaration(new ask.Name(`${namespace}.${intentName}`), typeProperties, undefined, undefined, [
                this.generateGeneratedAnnotation("interactionModel"),
            ]);
        });
        return {
            validIntents: validIntents,
            intentTypeModule: this.interactionModelSourceModule(`intentTypes`, namespace, expressions, errors),
        };
    }
    /**
     *
     * Generates the `ask.interactionModel.intents` module.
     *
     * This module will contain the variations for all intents defined in the interaction model.
     *
     * @param intentMap map of intent name to locales (enUS) using the intent
     * @returns the generated ASKIR intents variation module
     */
    generateIntentVariationModule(intentMap) {
        return this.generateVariationModule("intents", intentMap, constants_1.Namespaces.intents);
    }
    /**
     * Takes in a object mapping from name declaration to locales and generates
     * a module with variations for each name declaration in the given namespace.
     *
     * It searches namespace.{locale} to get the name reference.
     *
     * @param uri the uri of the source file and ask.Module.
     * @param variations map from name declaration string to locales (enUS, frFR, ...)
     * @param namespace the namespace of the module.
     * @returns a generated ASKIR module with variation calls for each locale name declaration.
     */
    generateVariationModule(uri, variations, namespace) {
        const localeImports = new Set();
        const expressions = Object.entries(variations).map(([name, locales]) => {
            return new ask.NameDeclaration(new ask.Name(`${namespace}.${name}`), undefined, new ask.Call(new ask.Name(ast_1.AlexaConversations.variations), [
                new ask.Argument(new ask.Name("variations"), 0, new ask.Call(new ask.Name(ast_1.AlexaConversations.Args), new ask.ListLiteral(locales.map((locale, idx) => {
                    localeImports.add(locale);
                    return new ask.ListItem(new ask.NameReference(new ask.Name(`${namespace}.${locale}.${name}`)), idx);
                })))),
            ], undefined, [this.generateGeneratedAnnotation("interactionModel")]));
        });
        return this.interactionModelSourceModule(uri, namespace, expressions);
    }
    /**
     * Generates a `@generated` annotation with a given name.
     */
    generateGeneratedAnnotation(generatorName) {
        return new ask.Annotation(new ask.Call(new ask.Name(ast_1.AlexaConversations.generated), [
            new ask.Argument(new ask.Name("generatorName"), 0, new ask.Call(new ask.Name(ast_1.AlexaSchema.String), generatorName)),
        ]));
    }
    /**
     * Generates a `@catalog` annotation that references the given name.
     */
    generateCatalogAnnotation(nameReference) {
        return new ask.Annotation(new ask.Call(new ask.Name(ast_1.AlexaConversations.catalog), [
            new ask.Argument(new ask.Name("catalog"), 0, new ask.NameReference(new ask.Name(nameReference))),
        ]));
    }
    /**
     * Generates the ask.Locale annotation for the given locale.
     *
     * @param locale - The locale to generate the annotation for. In the form of `en_US`, `fr_FR`.
     * @returns The ask.Annotation for the given locale.
     */
    generateLocaleAnnotation(locale) {
        return new ask.Annotation(new ask.Call(new ask.Name(ast_1.AlexaConversations.locale), [
            new ask.Argument(new ask.Name("locales"), 0, new ask.Call(new ask.Name(ast_1.AlexaConversations.Args), new ask.ListLiteral([
                new ask.ListItem(new ask.PropertyReference(new ask.Name(locale), new ask.NameReference(new ask.Name("Locale"))), 0),
            ]), 
            // TODO: Check this generic works
            [new ask.TypeReference(new ask.Name(ast_1.AlexaConversations.Locale))])),
        ]));
    }
    /**
     * Generates the ASKIR `ListBasedCatalog<T>` from an interaction model slot type.
     *
     * @param catalog the slot type to use for generating the listBasedCatalog
     * @returns The ask.Call to the listBasedCatalog<T> action
     */
    generateListBasedCatalog(catalog) {
        var _a, _b;
        // Generated list of 'CatalogItem<T> {...}'
        const catalogItems = new ask.ListLiteral((_b = (_a = catalog.values) === null || _a === void 0 ? void 0 : _a.map((value, idx) => {
            var _a, _b, _c;
            return new ask.ListItem(new ask.Call(new ask.Name(ast_1.AlexaConversations.CatalogItem), [
                new ask.Argument(new ask.Name("value"), undefined, new ask.Call(new ask.Name(ast_1.AlexaSchema.String), value.name.value)),
                new ask.Argument(new ask.Name("synonyms"), undefined, new ask.Call(new ask.Name(ast_1.AlexaSchema.List), new ask.ListLiteral((_c = (_b = (_a = value.name) === null || _a === void 0 ? void 0 : _a.synonyms) === null || _b === void 0 ? void 0 : _b.map((synonym, idx) => new ask.ListItem(new ask.Call(new ask.Name(ast_1.AlexaSchema.String), synonym), idx))) !== null && _c !== void 0 ? _c : []), [new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.String))])),
            ], [this.generateSlotTypeReference(catalog.name)]), idx);
        })) !== null && _b !== void 0 ? _b : []);
        // Generate the call to 'listBasedCatalog'
        return new ask.Call(new ask.Name(ast_1.AlexaConversations.listBasedCatalog), [
            new ask.Argument(new ask.Name("items"), undefined, new ask.Call(new ask.Name(ast_1.AlexaConversations.Args), catalogItems, [
                new ask.TypeReference(new ask.Name(ast_1.AlexaConversations.CatalogItem), [this.generateSlotTypeReference(catalog.name)]),
            ])),
        ], undefined, [this.generateGeneratedAnnotation("interactionModel")]);
    }
    /**
     * Generates a SourceFile<ask.Module> for generated interaction model modules.
     *
     * The exports will be generated from the given expressions.
     *
     * Module uri will be in the form of `dir/generated-im-{uriSuffix}`.
     *
     * @param uriSuffix the suffix to append to the generated module uri.
     * @param namespace the namespace to give the module.
     * @param expressions the module expressions.
     * @param errors any parse errors to include in the module that will be reported during validations.
     * @return A SourceFile<ask.Module> for the generated interaction model module.
     */
    interactionModelSourceModule(uriSuffix, namespace, expressions, errors) {
        const uri = `${this.dir}/${constants_1.GeneratedInteractionModelModule.uriPrefix}-${uriSuffix}.acdl`;
        const exports = getExports();
        const module = new ask.Module(uri, "https://amazonalexa.com/ask/2020/12/Module", new ask.Name(`${namespace}`), [
            new ask.Import("ImportNamespace", "com.amazon.alexa.ask.conversations"),
            new ask.Import("ImportNamespace", "com.amazon.alexa.schema"),
        ], exports, expressions);
        return (0, source_file_1.sourceFile)(this.dir, uri, module, errors);
        function getExports() {
            return expressions === null || expressions === void 0 ? void 0 : expressions.map((e) => { var _a; return (e.kind === "NameDeclaration" || e.kind === "TypeDeclaration" ? (_a = e.name) === null || _a === void 0 ? void 0 : _a.name : undefined); }).filter((x) => x !== undefined);
        }
    }
    /**
     * Generates a TypeReference to the ask.interactionModels.slotTypes or
     * com.amazon.ask.types.builtins.AMAZON namespace.
     *
     * @param name - Name of the slot type
     * @param multipleValues - Whether this slot has multiple values enabled
     */
    generateSlotTypeReference(name, multipleValues) {
        // Type reference to the slot type or builtin type
        let typeReference = (0, util_1.isAmazonBuiltin)(name)
            ? new ask.TypeReference(new ask.Name(`${constants_1.Namespaces.builtinTypes}.${name.substring(7)}`))
            : new ask.TypeReference(new ask.Name(`${constants_1.Namespaces.slotTypes}.${name}`));
        if (multipleValues) {
            // If multiple values are allowed, then we should return a list
            return new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.List), [typeReference]);
        }
        return typeReference;
    }
}
exports.InteractionModelModuleGenerator = InteractionModelModuleGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW0tbW9kdWxlLWdlbmVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbS1tb2R1bGUtZ2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBRTdCLCtCQUF5RTtBQUN6RSwyQ0FBd0U7QUFHeEUsK0NBQXFEO0FBRXJELGlDQUF1RjtBQUN2RixtREFBdUQ7QUFFdkQ7O0dBRUc7QUFDSCxNQUFhLCtCQUErQjtJQWMxQyxZQUFZLEdBQVcsRUFBRSxxQkFBNkM7UUFidEU7O1dBRUc7UUFDSDs7Ozs7V0FBNkI7UUFDN0I7O1dBRUc7UUFDSDs7Ozs7V0FBK0Q7UUFDL0Q7O1dBRUc7UUFDSDs7Ozs7V0FBNEQ7UUFHMUQsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMscUJBQXFCLEdBQUcscUJBQXFCLENBQUM7SUFDckQsQ0FBQztJQUVEOztPQUVHO0lBQ0sseUJBQXlCO1FBQy9CLElBQUksSUFBSSxDQUFDLGlCQUFpQixLQUFLLFNBQVMsRUFBRTtZQUN4QyxNQUFNLEdBQUcsR0FBcUMsRUFBRSxDQUFDO1lBQ2pELEtBQUssTUFBTSxvQkFBb0IsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7Z0JBQzdELE1BQU0sRUFBRSxHQUFHLElBQUEsdUJBQWdCLEVBQW1CLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN6RSxJQUFJLEVBQUUsS0FBSyxTQUFTLEVBQUU7b0JBQ3BCLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFHLENBQUM7aUJBQ3hDO2FBQ0Y7WUFDRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxDQUFDO1NBQzlCO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssS0FBSyxDQUFDLHFCQUFxQjtRQUNqQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsS0FBSyxTQUFTLEVBQUU7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