"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQualifiedName = exports.parseIdentifierLocation = exports.parseIdentifier = exports.parseNameDeclaration = exports.parseArgumentDeclaration = exports.parseArgumentDeclarations = exports.parseFunctionSignature = exports.parseActionDeclaration = exports.parseListIndex = exports.parseList = exports.parseObjectProperty = exports.parseObject = exports.parseInOperator = exports.parseIsOperator = exports.createLiteral = exports.getSlotLocation = exports.parseUtteranceQualifiedName = exports.parseSlotValues = exports.parseLiteral = exports.parseArgumentValue = exports.parseCall = exports.parseBooleanOperator = exports.parseBinaryExpression = exports.parseCorrection = exports.parseCondition = exports.parsePropertyReference = exports.parseNameReference = exports.parseExpression = exports.parseInteractionDeclaration = exports.parseScopeExpression = exports.parseScope = exports.parseSampleDeclaration = exports.parseDialogDeclaration = exports.parseNamespaceDeclaration = exports.parseTypeProperty = exports.parseTypeReference = exports.parseTypeArgumentDeclaration = exports.parseTypeArgumentDeclarations = exports.parseTypeDeclaration = exports.parseAnnotationList = exports.parseEnumItem = exports.parseEnumDeclaration = exports.parseModuleLevelNameDeclaration = exports.parseACDLFile = exports.loadACDLFile = exports.loadACDLFileSync = exports.loadModuleFile = exports.loadModuleFileSync = exports.ParseContext = exports.Counter = void 0;
exports.parseJsDoc = exports.parseLocation = void 0;
const antlr = __importStar(require("antlr4ts"));
const acdl = __importStar(require("./syntax"));
const ask = __importStar(require("./ast"));
const source_file_1 = require("./source-file");
const try_1 = require("./try");
const util_1 = require("./util");
const ast_1 = require("./ast");
const error_factory_1 = require("./error-factory");
class Counter {
    constructor(counter = 0) {
        Object.defineProperty(this, "counter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: counter
        });
    }
    nextId() {
        this.counter += 1;
        return this.counter;
    }
}
exports.Counter = Counter;
class ParseContext {
    constructor(uri, namespace, nameCounter, errors, scope, imports) {
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uri
        });
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: namespace
        });
        Object.defineProperty(this, "nameCounter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: nameCounter
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
        Object.defineProperty(this, "scope", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: scope
        });
        Object.defineProperty(this, "imports", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: imports
        });
    }
    hasOptionalImported() {
        return (this.imports.find((i) => (i.kind === "ImportName" && i.name === ast_1.AlexaSchema.Optional) ||
            (i.kind === "ImportNamespace" && i.name === (0, util_1.getNamespace)(ast_1.AlexaSchema.Optional))) !== undefined);
    }
    withScope(scope) {
        return new ParseContext(this.uri, this.namespace, this.nameCounter, this.errors, scope, this.imports);
    }
    addError(err) {
        this.errors.push(err);
    }
    newName() {
        return `var${this.nameCounter.nextId()}`;
    }
}
exports.ParseContext = ParseContext;
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
function loadModuleFileSync(baseDir, uri) {
    const json = (0, util_1.readJsonFileSync)((0, util_1.trimScheme)(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return (0, source_file_1.sourceFile)(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
exports.loadModuleFileSync = loadModuleFileSync;
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
async function loadModuleFile(baseDir, uri) {
    const json = await (0, util_1.readJsonFile)((0, util_1.trimScheme)(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return (0, source_file_1.sourceFile)(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
exports.loadModuleFile = loadModuleFile;
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
function loadACDLFileSync(dir, uri, content) {
    return (0, source_file_1.sourceFile)(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : (0, util_1.readFileSync)(uri)));
}
exports.loadACDLFileSync = loadACDLFileSync;
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
async function loadACDLFile(dir, uri, content) {
    return (0, source_file_1.sourceFile)(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : (await (0, util_1.readFile)(uri))));
}
exports.loadACDLFile = loadACDLFile;
/**
 * Parse an ACDL file.
 *
 * @param content ACDL file content
 */
function parseACDLFile(uri, content) {
    const lexer = new acdl.ACDLLexer(antlr.CharStreams.fromString(content));
    const tokenStream = new antlr.CommonTokenStream(lexer);
    const parser = new acdl.ACDLParser(tokenStream);
    const errors = [];
    parser.removeErrorListeners();
    parser.addErrorListener({
        syntaxError: (recognizer, offendingSymbol, line, charPositionInLine, msg) => {
            errors.push(error_factory_1.ValidationErrorFactory.SyntaxError({
                expr: {
                    uri,
                    loc: {
                        begin: { line, character: charPositionInLine },
                        end: { line, character: charPositionInLine },
                    },
                },
                overrideMessage: msg,
            }));
        },
    });
    let module;
    try {
        const unit = parser.module();
        const nameCounter = new Counter();
        const imports = [];
        const namespaceNode = (0, try_1.Try)(() => unit.namespaceDeclaration())
            .flatMap((ns) => (0, try_1.Try)(() => ns === null || ns === void 0 ? void 0 : ns.qualifiedName()))
            .getOrDefault(undefined);
        const context = new ParseContext(uri, namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, nameCounter, errors, [], imports);
        const namespace = new ask.Name(namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, namespaceNode ? parseLocation(namespaceNode) : undefined);
        unit.moduleExpression().forEach((expr) => {
            if (expr.importDeclaration()) {
                imports.push(new ask.Import(expr.importDeclaration().ASTERISK() ? "ImportNamespace" : "ImportName", expr.importDeclaration().qualifiedName().text, parseLocation(expr)));
            }
        });
        const expressions = unit
            .moduleExpression()
            .map((expr) => {
            if (expr.actionDeclaration()) {
                return parseActionDeclaration(expr.actionDeclaration(), context);
            }
            if (expr.dialogDeclaration()) {
                return parseDialogDeclaration(expr.dialogDeclaration(), context);
            }
            if (expr.interactionDeclaration()) {
                return parseInteractionDeclaration(expr.interactionDeclaration(), context);
            }
            if (expr.qualifiedNameDeclaration()) {
                return parseNameDeclaration(expr.qualifiedNameDeclaration(), context);
            }
            if (expr.typeDeclaration()) {
                return parseTypeDeclaration(expr.typeDeclaration(), context);
            }
            if (expr.enumDeclaration()) {
                return parseEnumDeclaration(expr.enumDeclaration(), context);
            }
            if (expr.expression()) {
                return parseExpression(expr.expression(), context);
            }
            return undefined;
        })
            .filter((e) => e !== undefined);
        const exports = expressions.map((e) => { var _a; return e.kind !== "InteractionDeclaration" && ((_a = e === null || e === void 0 ? void 0 : e.name) === null || _a === void 0 ? void 0 : _a.name); }).filter((n) => n !== undefined);
        module = new ask.Module(uri, ask.ModuleSchema, namespace, imports, exports, expressions);
    }
    catch (err) {
        module = undefined;
    }
    return [module, errors || undefined];
}
exports.parseACDLFile = parseACDLFile;
/**
 * Parse the qualified name component of a module-level declaration.
 *
 * That include:
 * - ActionDeclaration
 * - DialogDeclaration
 * - QualifiedNameDeclaration
 * - TypeDeclaration
 */
function parseModuleLevelNameDeclaration(node, context) {
    let name = parseQualifiedName(node);
    if (name.name) {
        if (name.name.includes(".")) {
            name = new ask.Name(name.name, name.loc);
        }
        else if (context.namespace) {
            name = new ask.Name(`${context.namespace}.${name.name}`, name.loc);
        }
        else {
            name = new ask.Name(name.name, name.loc);
        }
    }
    return name;
}
exports.parseModuleLevelNameDeclaration = parseModuleLevelNameDeclaration;
function parseEnumDeclaration(type, context) {
    return new ask.EnumDeclaration(parseModuleLevelNameDeclaration(type.qualifiedName(), context), type.enumItem().map((id) => parseEnumItem(id, context)), parseAnnotationList(type.annotationList(), context), parseJsDoc(type.jsdoc()), parseLocation(type));
}
exports.parseEnumDeclaration = parseEnumDeclaration;
function parseEnumItem(item, context) {
    return new ask.EnumItem(parseIdentifier(item.identifier()), parseAnnotationList(item.annotationList(), context), parseJsDoc(item.jsdoc()), parseLocation(item));
}
exports.parseEnumItem = parseEnumItem;
function parseAnnotationList(annotationList, context) {
    var _a;
    const list = ((_a = annotationList === null || annotationList === void 0 ? void 0 : annotationList.annotation()) === null || _a === void 0 ? void 0 : _a.map((annotation) => new ask.Annotation(parseCall(annotation.call(), context)), undefined)) || undefined;
    if (list === undefined || list.length === 0) {
        return undefined;
    }
    return list;
}
exports.parseAnnotationList = parseAnnotationList;
function parseTypeDeclaration(type, context) {
    var _a;
    const name = parseModuleLevelNameDeclaration(type.qualifiedName(), context);
    return new ask.TypeDeclaration(name, (0, util_1.sanitize)((0, try_1.Try)(() => type.typeProperties())
        .flatMap((typeBody) => (0, try_1.Try)(() => typeBody === null || typeBody === void 0 ? void 0 : typeBody.typeProperty()).map((typeProperties) => typeProperties === null || typeProperties === void 0 ? void 0 : typeProperties.map((typeProperty) => parseTypeProperty(typeProperty, context))))
        .resolve(context)), (0, util_1.sanitize)(parseTypeArgumentDeclarations(type.typeArgumentDeclarations(), context)), (0, util_1.sanitize)((_a = type.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((e) => parseTypeReference(e.typeReference(), context))), parseAnnotationList(type.annotationList(), context), parseJsDoc(type.jsdoc()), parseLocation(type));
}
exports.parseTypeDeclaration = parseTypeDeclaration;
function parseTypeArgumentDeclarations(args, context) {
    return args === null || args === void 0 ? void 0 : args.typeArgumentDeclaration().map((arg) => parseTypeArgumentDeclaration(arg, context));
}
exports.parseTypeArgumentDeclarations = parseTypeArgumentDeclarations;
function parseTypeArgumentDeclaration(arg, context) {
    var _a;
    return new ask.TypeParameter(parseIdentifier(arg.identifier()), (0, util_1.sanitize)((_a = arg.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((constraint) => parseTypeReference(constraint.typeReference(), context))), parseLocation(arg));
}
exports.parseTypeArgumentDeclaration = parseTypeArgumentDeclaration;
function parseTypeReference(reference, context) {
    var _a, _b;
    let loc;
    if (reference.typeArguments() === undefined) {
        loc = parseIdentifierLocation(reference.qualifiedName());
    }
    else {
        loc = parseLocation(reference);
    }
    return new ask.TypeReference((0, try_1.Try)(() => reference.qualifiedName())
        .map((name) => parseQualifiedName(name))
        .resolve(context), (0, util_1.sanitize)((_b = (_a = reference
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context))), parseAnnotationList(reference.annotationList(), context), undefined, loc);
}
exports.parseTypeReference = parseTypeReference;
function parseTypeProperty(property, context) {
    return new ask.TypeProperty(property.identifier() ? parseIdentifier(property.identifier()) : undefined, (0, try_1.Try)(() => property.typeReference())
        .map((t) => parseTypeReference(t, context))
        .resolve(context), (0, try_1.Try)(() => property.OPTIONAL())
        .map((o) => !!o)
        .resolve(context), parseAnnotationList(property.annotationList(), context), parseJsDoc(property.jsdoc()), parseLocation(property));
}
exports.parseTypeProperty = parseTypeProperty;
function parseNamespaceDeclaration(namespace, context) {
    return new ask.Name((0, try_1.Try)(() => namespace.qualifiedName())
        .map((name) => name.text)
        .resolve(context), parseLocation(namespace));
}
exports.parseNamespaceDeclaration = parseNamespaceDeclaration;
function parseDialogDeclaration(dialog, context) {
    const functionDecl = parseFunctionSignature(dialog.functionSignature(), context);
    return new ask.DialogDeclaration(functionDecl.name, functionDecl.args, (0, try_1.Try)(() => dialog.dialogScope())
        .flatMap((body) => (0, try_1.Try)(() => body === null || body === void 0 ? void 0 : body.sampleDeclaration()).map((samples) => (samples === null || samples === void 0 ? void 0 : samples.map((s) => parseSampleDeclaration(s, context))) || []))
        .resolve(context), functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(dialog.annotationList(), context), parseJsDoc(dialog.jsdoc()), parseLocation(dialog));
}
exports.parseDialogDeclaration = parseDialogDeclaration;
function parseSampleDeclaration(sample, context) {
    return new ask.Sample((0, try_1.Try)(() => sample.block())
        .map((_) => parseScope(_, context, ask.Block))
        .resolve(context), parseAnnotationList(sample.annotationList(), context), parseLocation(sample));
}
exports.parseSampleDeclaration = parseSampleDeclaration;
function parseScope(body, context, ctor) {
    return (0, try_1.Try)(() => body.blockExpression())
        .map((expressions) => {
        const scopeExpressions = [];
        const scopeContext = context;
        for (const expr of expressions) {
            const parsedExpr = parseScopeExpression(expr, scopeContext);
            if (parsedExpr !== undefined) {
                scopeExpressions.push(parsedExpr); // TODO: assert
            }
        }
        return new ctor(scopeExpressions, parseLocation(body));
    })
        .resolve(context);
}
exports.parseScope = parseScope;
function parseScopeExpression(expr, context) {
    if (expr.nameDeclaration()) {
        return parseNameDeclaration(expr.nameDeclaration(), context);
    }
    if (expr.expression()) {
        return parseExpression(expr.expression(), context);
    }
    return undefined;
}
exports.parseScopeExpression = parseScopeExpression;
function parseInteractionDeclaration(expr, context) {
    return new ask.InteractionDeclaration((0, try_1.Try)(() => expr.block())
        .map((_) => parseScope(_, context, ask.InteractionScope))
        .resolve(context), parseAnnotationList(expr.annotationList(), context), parseLocation(expr));
}
exports.parseInteractionDeclaration = parseInteractionDeclaration;
function parseExpression(expr, context) {
    if (expr instanceof acdl.ParenthesizedExprContext) {
        return (0, try_1.Try)(() => expr.expression())
            .map((expr) => parseExpression(expr, context))
            .resolve(context);
    }
    if (expr instanceof acdl.LiteralExprContext || expr instanceof acdl.LiteralContext) {
        return parseLiteral(expr, context).resolve(context);
    }
    if (expr instanceof acdl.ObjectContext) {
        return (0, try_1.Try)(() => parseObject(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.PropertyReferenceContext) {
        return parsePropertyReference(expr, context);
    }
    if (expr instanceof acdl.ListIndexContext) {
        return (0, try_1.Try)(() => parseListIndex(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.CallExprContext) {
        return (0, try_1.Try)(() => parseCall(expr.call(), context)).resolve(context);
    }
    if (expr instanceof acdl.BinaryExprContext) {
        return parseBinaryExpression(expr, context).resolve(context);
    }
    if (expr instanceof acdl.NameDeclarationContext || expr instanceof acdl.QualifiedNameDeclarationContext) {
        return (0, try_1.Try)(() => parseNameDeclaration(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.ConditionExprContext) {
        return (0, try_1.Try)(() => parseCondition(expr.condition(), context)).resolve(context);
    }
    if (expr instanceof acdl.CorrectionExprContext) {
        return (0, try_1.Try)(() => parseCorrection(expr.correction(), context)).resolve(context);
    }
    if (expr instanceof acdl.IdentifierExprContext) {
        return parseNameReference(expr, context);
    }
    if (expr instanceof acdl.IsExprContext) {
        return parseIsOperator(expr, context);
    }
    if (expr instanceof acdl.InExprContext) {
        return parseInOperator(expr, context);
    }
    const errorFactory = expr.text
        ? error_factory_1.ValidationErrorFactory.UnexpectedOperatorWithText
        : error_factory_1.ValidationErrorFactory.UnexpectedOperator;
    const error = errorFactory({
        expr: {
            uri: context.uri,
            loc: parseLocation(expr),
        },
        attributes: {
            expressionText: expr.text,
            constructorName: expr.constructor.name,
        },
    });
    context.addError(error);
    return undefined;
}
exports.parseExpression = parseExpression;
function parseNameReference(expr, context) {
    return new ask.NameReference(parseIdentifier(expr.identifier()), undefined, parseIdentifierLocation(expr.identifier()));
}
exports.parseNameReference = parseNameReference;
function parsePropertyReference(expr, context) {
    var _a, _b;
    const child = parseExpression(expr.expression(), context); // TODO: type check
    if (child === undefined) {
        return undefined;
    }
    const id = parseIdentifier(expr.identifier());
    const loc = parseLocation(expr);
    if (loc) {
        loc.end = (_b = (_a = id === null || id === void 0 ? void 0 : id.loc) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : loc.end;
    }
    const prop = new ask.PropertyReference(id, child, undefined, loc);
    return prop;
}
exports.parsePropertyReference = parsePropertyReference;
function parseCondition(expr, context) {
    var _a, _b, _c, _d;
    const loc = parseLocation(expr);
    let elseScope;
    if (((_a = expr.otherwise()) === null || _a === void 0 ? void 0 : _a.condition()) !== undefined) {
        const elseIfCondition = parseCondition((_b = expr.otherwise()) === null || _b === void 0 ? void 0 : _b.condition(), context);
        elseScope = new ask.ElseScope(elseIfCondition ? [elseIfCondition] : undefined);
    }
    else if (((_c = expr.otherwise()) === null || _c === void 0 ? void 0 : _c.block()) !== undefined) {
        elseScope = parseScope((_d = expr.otherwise()) === null || _d === void 0 ? void 0 : _d.block(), context, ask.ElseScope);
    }
    return new ask.Condition(new ask.When((0, try_1.Try)(() => expr.expression())
        .map((when) => parseExpression(when, context))
        .resolve(context)), // TODO: check,
    (0, try_1.Try)(() => expr.block())
        .map((body) => (body ? parseScope(body, context, ask.ThenScope) : undefined))
        .resolve(context), elseScope, undefined, loc);
}
exports.parseCondition = parseCondition;
function parseCorrection(expr, context) {
    return new ask.Correction((0, try_1.Try)(() => expr.block(0))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), (0, try_1.Try)(() => expr.block(1))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), parseLocation(expr));
}
exports.parseCorrection = parseCorrection;
function parseBinaryExpression(expr, context) {
    const loc = parseLocation(expr);
    return (0, try_1.Try)(() => {
        if (expr._left) {
            return new ask.Call(new ask.Name(parseBooleanOperator(expr, context)), [asArgumentValue(expr._left, "left"), asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        if (expr.NOT()) {
            return new ask.Call(new ask.Name(ast_1.AlexaConversations.Not), [asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        throw [
            error_factory_1.ValidationErrorFactory.UnexpectedBooleanExpression({
                expr: {
                    loc,
                },
                attributes: {
                    expressionText: expr.text,
                },
            }),
        ];
    });
    function asArgumentValue(expr, name) {
        return new ask.Argument(new ask.Name(name), undefined, parseExpression(expr, context), parseLocation(expr));
    }
}
exports.parseBinaryExpression = parseBinaryExpression;
function parseBooleanOperator(expr, context) {
    var _a, _b, _c, _d, _e, _f;
    const loc = parseLocation(expr);
    if (expr.AND()) {
        return ast_1.AlexaConversations.And;
    }
    if (expr.OR()) {
        return ast_1.AlexaConversations.Or;
    }
    if ((_a = expr.relational()) === null || _a === void 0 ? void 0 : _a.GE()) {
        return ast_1.AlexaConversations.Gte;
    }
    if ((_b = expr.relational()) === null || _b === void 0 ? void 0 : _b.GT()) {
        return ast_1.AlexaConversations.Gt;
    }
    if ((_c = expr.relational()) === null || _c === void 0 ? void 0 : _c.LE()) {
        return ast_1.AlexaConversations.Lte;
    }
    if ((_d = expr.relational()) === null || _d === void 0 ? void 0 : _d.LT()) {
        return ast_1.AlexaConversations.Lt;
    }
    if ((_e = expr.equality()) === null || _e === void 0 ? void 0 : _e.EQUAL()) {
        return ast_1.AlexaConversations.Eq;
    }
    if ((_f = expr.equality()) === null || _f === void 0 ? void 0 : _f.NOTEQUAL()) {
        return ast_1.AlexaConversations.Neq;
    }
    context.addError(error_factory_1.ValidationErrorFactory.UnexpectedBooleanOperator({
        expr: {
            loc,
        },
        attributes: {
            expressionText: expr.text,
        },
    }));
    return undefined;
}
exports.parseBooleanOperator = parseBooleanOperator;
function parseCall(expr, context) {
    var _a, _b;
    const name = (0, try_1.Try)(() => expr.qualifiedName())
        .map((fqn) => parseQualifiedName(fqn))
        .resolve(context);
    const args = (0, try_1.Try)(() => expr.callArguments())
        .flatMap((list) => (0, try_1.Try)(() => list === null || list === void 0 ? void 0 : list.callArgument()).map((argumentList) => argumentList === null || argumentList === void 0 ? void 0 : argumentList.map((a, i) => parseArgumentValue(a, context, i))))
        .resolve(context);
    const genericArguments = (0, util_1.sanitize)((_b = (_a = expr
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context)));
    return new ask.Call(name, args, genericArguments, undefined, parseLocation(expr));
}
exports.parseCall = parseCall;
function parseArgumentValue(argument, context, index) {
    const name = (0, try_1.Try)(() => argument.identifier())
        .map((i) => (i ? parseIdentifier(i) : undefined))
        .resolve(context);
    const value = (0, try_1.Try)(() => argument.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context); // TODO: type-check
    const loc = name && name.loc && (value === null || value === void 0 ? void 0 : value.loc) ? ask.appendLocation(name.loc, value.loc) : value === null || value === void 0 ? void 0 : value.loc;
    return new ask.Argument(name, index, value, loc);
}
exports.parseArgumentValue = parseArgumentValue;
function parseLiteral(literal, context) {
    const literalValue = literal.text;
    const litLoc = parseLocation(literal);
    const loc = {
        begin: litLoc.begin,
        end: {
            line: litLoc.begin.line,
            character: litLoc.begin.character + literal.text.length,
        },
    };
    return (0, try_1.Try)(() => {
        var _a;
        if (literal.null()) {
            return createLiteral(ast_1.AlexaSchema.Void, null, loc);
        }
        if (literal.nothing()) {
            return createLiteral(ast_1.AlexaSchema.Nothing, null, loc);
        }
        if (literal.string()) {
            const vars = parseSlotValues(literal);
            const text = literalValue.slice(1, literalValue.length - 1);
            let value = text;
            if (vars && vars.length > 0) {
                value = new ask.Utterance(text, vars.map((v) => parseUtteranceQualifiedName(v, literal.string())), parseLocation(literal));
            }
            return createLiteral(ast_1.AlexaSchema.String, value, loc);
        }
        if (literal.number()) {
            const num = !literalValue.includes(".") ? parseInt(literalValue, 10) : parseFloat(literalValue);
            return createLiteral(ast_1.AlexaSchema.Number, num, loc);
        }
        if (literal.bool()) {
            return createLiteral(ast_1.AlexaSchema.Boolean, ((_a = literal.bool()) === null || _a === void 0 ? void 0 : _a.text.toLocaleLowerCase()) === "true", loc);
        }
        if (literal.object()) {
            return parseObject(literal.object(), context);
        }
        if (literal.list()) {
            return parseList(literal.list(), context);
        }
        console.error(literal);
        throw new Error("unexpected node type");
    });
}
exports.parseLiteral = parseLiteral;
function parseSlotValues(string) {
    if (!string) {
        return undefined;
    }
    // capture '{slotValue}' from the string - slotValue can contain alphabets,numbers and special characters, or can be empty '{}'.
    // all specials characters except '_' and '.' are valid in some MFT cases. for ex. "What's the weather {date|tomorrow's} in {cityName|San Jose, CA} in North America"
    let regex = /{([- a-zA-Z 0-9 _.|,' \s ]+)*}/g;
    let match = string.text.match(regex);
    // remove braces from the match and ignore all values following the pipe '|'
    return match ? match.map((value) => value.replace(/{|}/g, "").split("|")[0]) : undefined;
}
exports.parseSlotValues = parseSlotValues;
function parseUtteranceQualifiedName(fullName, context, prefix = "") {
    const lastDot = fullName.indexOf(".");
    const identifier = lastDot === -1 ? fullName : fullName.substring(lastDot + 1);
    const qualifier = lastDot === -1 ? undefined : fullName.substring(0, lastDot);
    return new ask.Name(qualifier === undefined ? `${prefix}${identifier}` : `${qualifier}.${identifier}`, getSlotLocation(context, identifier));
}
exports.parseUtteranceQualifiedName = parseUtteranceQualifiedName;
function getSlotLocation(context, id) {
    const string = context.text;
    const stringLoc = parseLocation(context);
    const index = string.indexOf(`{${id}}`) + 1;
    let slotLocation = {
        begin: {
            line: stringLoc.begin.line,
            character: index,
        },
        end: {
            line: stringLoc.end.line,
            character: index + string.length,
        },
    };
    return slotLocation;
}
exports.getSlotLocation = getSlotLocation;
function createLiteral(type, value, loc) {
    return new ask.Call(new ask.Name(type), value, undefined, undefined, loc);
}
exports.createLiteral = createLiteral;
function parseIsOperator(expr, context) {
    return new ask.Call(new ask.Name(ast_1.AlexaConversations.is /* TODO: map the IS token to a source location */), [new ask.Argument(new ask.Name("thing"), 0, parseExpression(expr.expression(), context))], [parseTypeReference(expr.typeReference(), context)]);
}
exports.parseIsOperator = parseIsOperator;
function parseInOperator(expr, context) {
    return new ask.Call(new ask.Name(ast_1.AlexaConversations.in), [
        new ask.Argument(new ask.Name("entity"), 0, parseExpression(expr.expression(0), context)),
        new ask.Argument(new ask.Name("entities"), 0, parseExpression(expr.expression(1), context)),
    ]);
}
exports.parseInOperator = parseInOperator;
function parseObject(obj, context) {
    const objectType = (0, try_1.Try)(() => obj.typeReference())
        .map((type) => (type ? parseTypeReference(type, context) : undefined))
        .resolve(context);
    return new ask.Call(objectType === null || objectType === void 0 ? void 0 : objectType.name, (0, try_1.Try)(() => obj.objectKeyValue())
        .map((pairs) => pairs.map((pair) => parseObjectProperty(pair, context)))
        .resolve(context), objectType === null || objectType === void 0 ? void 0 : objectType.arguments, undefined, parseLocation(obj));
}
exports.parseObject = parseObject;
function parseObjectProperty(member, context) {
    const name = parseIdentifier(member.identifier());
    const expr = member.expression();
    const value = (expr === undefined
        ? // if no value is explicitly provided, default to a name reference
            // name = "hello"
            // person Person { name }
            // equiv. { name = name }
            new ask.NameReference(name, undefined, name.loc)
        : parseExpression(expr, context));
    return new ask.Argument(name, undefined, value, parseLocation(member));
}
exports.parseObjectProperty = parseObjectProperty;
/**
 * Parse a List literal to a call
 *
 * ```
 * list = ["a", "b"]
 * // or
 * list = List<String> ["a", "b"]
 *
 * // translates to an internal representations
 * alexa.lang.expression<List<String>>(items = ["a", "b"])
 * ```
 *
 * @param expr
 * @param parent
 * @param errors
 */
function parseList(expr, context) {
    const loc = parseLocation(expr);
    const list = new ask.ListLiteral(expr
        .expression()
        .map((expr, index) => new ask.ListItem(parseExpression(expr, context), index, parseLocation(expr))), loc);
    return new ask.Call(undefined, list, undefined, undefined, parseLocation(expr));
}
exports.parseList = parseList;
/**
 * Parse syntactic sugar for accessing a list.
 *
 * ```
 * List<String> list = ...
 *
 * // access a list by index 0
 * list[0]
 *
 * // is syntactic sugar for the `inList` action:
 * com.amazon.alexa.ask.conversations.inList(list = list, index = 0)
 * com.amazon.alexa.ask.conversations.inList(list, 0)
 * ```
 *
 * TODO: support accessing properties in a List.
 * ```
 * // how should we translate this?
 * c = list[0].a.b.c
 *
 * // perhaps generate a variable for the result of accessing the list
 * var1 = inList(list, 0)
 * // and then a name expression?
 * c = var1.a.b.c
 * ```
 *
 * @param expr syntax for the list
 * @param parent
 * @param errors
 */
function parseListIndex(expr, context) {
    const list = parseExpression(expr.expression(), context); // TODO: type-check
    const listArg = new ask.Argument(new ask.Name("list"), 0, list, parseLocation(expr));
    const indexNumber = (0, try_1.Try)(() => parseInt(expr.number().text, 10)).resolve(context);
    const indexLiteral = createLiteral(ast_1.AlexaSchema.Number, indexNumber, parseLocation(expr.number()));
    const indexArg = new ask.Argument(new ask.Name("index"), 1, indexLiteral);
    return new ask.Call(new ask.Name(ast_1.AlexaConversations.getListItem), [listArg, indexArg], undefined, undefined, parseLocation(expr));
}
exports.parseListIndex = parseListIndex;
function parseActionDeclaration(action, context) {
    const functionDecl = parseFunctionSignature(action.functionSignature(), context);
    return new ask.ActionDeclaration(functionDecl.name, functionDecl.args, functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(action.annotationList(), context), parseJsDoc(action.jsdoc()), parseLocation(action));
}
exports.parseActionDeclaration = parseActionDeclaration;
function parseFunctionSignature(action, context, isTopLevel = true) {
    var _a, _b;
    let returnType;
    const _void = action.void();
    if (_void !== undefined || action.typeReference() === undefined) {
        returnType = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Void), undefined, parseAnnotationList(_void === null || _void === void 0 ? void 0 : _void.annotationList(), context), undefined, _void ? parseLocation(_void) : undefined);
    }
    else {
        returnType = parseTypeReference(action.typeReference(), context);
    }
    const functionDecl = {
        name: isTopLevel
            ? parseModuleLevelNameDeclaration((_a = action.qualifiedName()) !== null && _a !== void 0 ? _a : action.identifier(), context)
            : parseQualifiedName((_b = action.qualifiedName()) !== null && _b !== void 0 ? _b : action.identifier()),
        // TODO: what to do with this?
        args: (0, try_1.Try)(() => action.argumentDeclarations())
            .map((p) => (p ? parseArgumentDeclarations(p, context) : undefined))
            .resolve(context),
        returnType,
        genericArguments: parseTypeArgumentDeclarations(action.typeArgumentDeclarations(), context),
    };
    return functionDecl;
}
exports.parseFunctionSignature = parseFunctionSignature;
function parseArgumentDeclarations(argumentDecls, context) {
    return argumentDecls.argumentDeclaration().map((p) => parseArgumentDeclaration(p, context));
}
exports.parseArgumentDeclarations = parseArgumentDeclarations;
function parseArgumentDeclaration(argument, context) {
    var _a, _b;
    const defaultExpression = ((_a = argument.argumentDefault()) === null || _a === void 0 ? void 0 : _a.expression())
        ? parseExpression(argument.argumentDefault().expression(), context)
        : undefined;
    const isOptional = argument.OPTIONAL() !== undefined || ((defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.kind) === "Call" && ((_b = defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaSchema.Nothing);
    if (argument.functionArgumentDeclaration()) {
        return parseFunctionArgumentDeclaration(argument.functionArgumentDeclaration());
    }
    if (argument.standardArgumentDeclaration()) {
        return parseStandardArgumentDeclaration(argument.standardArgumentDeclaration());
    }
    // fatal error, only these two options should be possible.
    throw new Error(`could not parse argument declaration: ${argument.text}`);
    function parseStandardArgumentDeclaration(argDecl) {
        var _a, _b;
        let type;
        if (isOptional) {
            if ((argDecl === null || argDecl === void 0 ? void 0 : argDecl.typeReference()) !== undefined) {
                const innerType = parseTypeReference(argDecl.typeReference(), context);
                if (((_a = innerType.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Optional || (((_b = innerType.name) === null || _b === void 0 ? void 0 : _b.name) === "Optional" && context.hasOptionalImported())) {
                    // type is already Optional, flatten.
                    // innerType.parent = self;
                    type = innerType;
                }
                else {
                    type = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Optional), [innerType], undefined, // innerType.annotations?.map((a) => a.clone()),
                    undefined);
                }
            }
            else {
                type = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Optional), [new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Nothing), undefined, undefined, undefined)], undefined, undefined);
            }
        }
        else if (argDecl.typeReference() !== undefined) {
            type = parseTypeReference(argDecl.typeReference(), context);
        }
        else {
            type = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Nothing), undefined, undefined);
        }
        return new ask.ArgumentDeclaration(argDecl.identifier() ? parseIdentifier(argDecl.identifier()) : undefined, type, defaultExpression, parseAnnotationList(argument.annotationList(), context), parseJsDoc(argument.jsdoc()), parseLocation(argument));
    }
    function parseFunctionArgumentDeclaration(fun) {
        var _a, _b, _c, _d, _e, _f, _g;
        const functionSignature = parseFunctionSignature(fun.functionSignature(), context, false);
        const functionArgumentNames = (_c = (_b = (_a = fun
            .functionSignature()
            .argumentDeclarations()) === null || _a === void 0 ? void 0 : _a.argumentDeclaration()) === null || _b === void 0 ? void 0 : _b.map((a, i) => {
            var _a, _b, _c, _d;
            // TODO: this is probably risky??? ACDL will give syntax error though ...
            const defaultArgName = `arg${i}`;
            if (a.standardArgumentDeclaration()) {
                return (_b = (_a = a.standardArgumentDeclaration().identifier()) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : defaultArgName;
            }
            if (a.functionArgumentDeclaration()) {
                return (_d = (_c = a.functionArgumentDeclaration().functionSignature().identifier()) === null || _c === void 0 ? void 0 : _c.text) !== null && _d !== void 0 ? _d : defaultArgName;
            }
            return defaultArgName;
        })) !== null && _c !== void 0 ? _c : [];
        const functionArity = functionArgumentNames.length;
        const typeRefLoc = ((_d = functionSignature.name) === null || _d === void 0 ? void 0 : _d.loc)
            ? ask.betweenLocations(parseLocation(fun), (_e = functionSignature.name) === null || _e === void 0 ? void 0 : _e.loc)
            : parseLocation(fun);
        const typeRefName = fun.ACTION()
            ? (0, ast_1.ActionTypeName)(functionArity)
            : fun.DIALOG()
                ? (0, ast_1.DialogTypeName)(functionArity)
                : (0, ast_1.FunctionTypeName)(functionArity);
        const type = new ask.TypeReference(new ask.Name(typeRefName, typeRefLoc), [...((_g = (_f = functionSignature.args) === null || _f === void 0 ? void 0 : _f.map((arg) => arg.type /* use an object to represent undefined */)) !== null && _g !== void 0 ? _g : []), functionSignature.returnType], undefined, functionArgumentNames, typeRefLoc);
        return new ask.ArgumentDeclaration(functionSignature.name, isOptional ? new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Optional, type.loc), [type]) : type, defaultExpression, parseAnnotationList(argument.annotationList(), context));
    }
}
exports.parseArgumentDeclaration = parseArgumentDeclaration;
/**
 * Parse a name initialization expression.
 *
 * ```acdl
 * a = <expr>
 * ```
 *
 * @param nameDecl name parse tree
 * @param parent parent expression
 */
function parseNameDeclaration(nameDecl, context) {
    const name = nameDecl instanceof acdl.QualifiedNameDeclarationContext
        ? parseModuleLevelNameDeclaration(nameDecl.qualifiedName(), context)
        : parseIdentifier(nameDecl.identifier());
    const type = nameDecl.typeReference() ? parseTypeReference(nameDecl.typeReference(), context) : undefined;
    const expr = (0, try_1.Try)(() => nameDecl.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context);
    return new ask.NameDeclaration(name, type, expr, nameDecl instanceof acdl.QualifiedNameDeclarationContext ? parseAnnotationList(nameDecl.annotationList(), context) : undefined, parseJsDoc(nameDecl.jsdoc()), parseLocation(nameDecl));
}
exports.parseNameDeclaration = parseNameDeclaration;
/**
 * Parse an identifier.
 *
 * @param id identifier parse tree
 * @param context parse context
 */
function parseIdentifier(id) {
    return new ask.Name(id.text === "<missing IDENTIFIER>" ? undefined : id.text, parseIdentifierLocation(id));
}
exports.parseIdentifier = parseIdentifier;
function parseIdentifierLocation(id) {
    const location = parseLocation(id);
    const loc = {
        begin: {
            line: location.begin.line,
            character: location.begin.character,
        },
        end: {
            line: location.begin.line,
            character: location.begin.character + id.text.length,
        },
    };
    return loc;
}
exports.parseIdentifierLocation = parseIdentifierLocation;
/**
 * Parse a qualified name.
 *
 * @param name identifier or qualified name.
 * @param parent parent expression
 */
function parseQualifiedName(name, prefix = "") {
    const fullName = name.text;
    const lastDot = fullName.indexOf(".");
    const identifier = lastDot === -1 ? fullName : fullName.substring(lastDot + 1);
    const qualifier = lastDot === -1 ? undefined : fullName.substring(0, lastDot);
    // TODO: match name with regex and report errors.
    return new ask.Name(qualifier === undefined ? `${prefix}${identifier}` : `${qualifier}.${identifier}`, parseIdentifierLocation(name));
}
exports.parseQualifiedName = parseQualifiedName;
/**
 * Parse the location from a node in the parse tree.
 *
 * @param node parse tree node.
 */
function parseLocation(node) {
    var _a, _b;
    const begin = {
        line: node.start.line,
        character: node.start.charPositionInLine,
    };
    // Antlr only gives us the "start of token" position.
    // To get "end of token" position we need to add the token length,
    // plus we need to adjust the line and column if there are newlines in the token's text
    const stopTokenText = (_a = node.stop) === null || _a === void 0 ? void 0 : _a.text;
    const stopTokenLines = (stopTokenText === null || stopTokenText === void 0 ? void 0 : stopTokenText.split("\\n")) || [];
    // Stop token has no text - no adjustment is needed
    if ((Array.isArray(stopTokenLines) && stopTokenLines.length > 0) || ((_b = node.stop) === null || _b === void 0 ? void 0 : _b.type) === antlr.Token.EOF) {
        return {
            begin,
            end: {
                line: node.stop.line,
                character: node.stop.charPositionInLine + 1,
            },
        };
    }
    const lastLineLength = stopTokenLines[stopTokenLines.length - 1].length;
    const tokenEnd = stopTokenLines.length === 1 ? node.stop.charPositionInLine + stopTokenText.length : lastLineLength;
    return {
        begin,
        end: {
            line: node.stop.line + stopTokenLines.length - 1,
            character: tokenEnd + 1,
        },
    };
}
exports.parseLocation = parseLocation;
function parseJsDoc(context) {
    return context === null || context === void 0 ? void 0 : context.text;
}
exports.parseJsDoc = parseJsDoc;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0RBQWtDO0FBQ2xDLCtDQUFpQztBQUNqQywyQ0FBNkI7QUFFN0IsK0NBQXFEO0FBRXJELCtCQUFvQztBQUNwQyxpQ0FBa0g7QUFDbEgsK0JBQXdHO0FBQ3hHLG1EQUFvRjtBQUVwRixNQUFhLE9BQU87SUFDbEIsWUFBb0IsVUFBa0IsQ0FBQzs7Ozs7bUJBQW5COztJQUFzQixDQUFDO0lBRXBDLE1BQU07UUFDWCxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQztRQUNsQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztDQUNGO0FBUEQsMEJBT0M7QUFFRCxNQUFhLFlBQVk7SUFDdkIsWUFDa0IsR0FBVyxFQUNYLFNBQTZCLEVBQzdCLFdBQW9CLEVBQ3BCLE1BQW9CLEVBQ3BCLEtBQXVCLEVBQ3ZCLE9BQXFCOzs7OzttQkFMckI7Ozs7OzttQkFDQTs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7Ozs7OzttQkFDQTs7Ozs7O21CQUNBOztJQUNmLENBQUM7SUFFRyxtQkFBbUI7UUFDeEIsT0FBTyxDQUNMLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUNmLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDSixDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssWUFBWSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssaUJBQVcsQ0FBQyxRQUFRLENBQUM7WUFDNUQsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLGlCQUFpQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBQSxtQkFBWSxFQUFDLGlCQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FDbEYsS0FBSyxTQUFTLENBQ2hCLENBQUM7SUFDSixDQUFDO0lBRU0sU0FBUyxDQUFDLEtBQXVCO1FBQ3RDLE9BQU8s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