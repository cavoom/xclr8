"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeChecker = void 0;
const immutable = __importStar(require("immutable"));
const ask = __importStar(require("./ast"));
const apply_1 = require("./apply");
const ast_1 = require("./ast");
const global_1 = require("./global");
const lexical_scope_1 = require("./lexical-scope");
const util_1 = require("./util");
const type_1 = require("./type");
// TODO: decide whether we should implement our own immutable set instead of depending on `immutable-js`
const lazy_1 = require("./lazy");
const visit_1 = require("./visit");
const thing_1 = require("./thing");
const token_1 = require("./token");
let i = 0;
/**
 * API for querying a Module for error checking, type checking, descriptions and suggestions.
 */
class TypeChecker {
    constructor(
    /**
     * Project context of the module being checked.
     */
    project, 
    /**
     * Previous TypeChecker environment.
     */
    prev, 
    /**
     * Map of Node to resolved Thing.
     */
    things, 
    /**
     * Map of TypeParameter to resolved Type.
     */
    types) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: project
        });
        Object.defineProperty(this, "prev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: prev
        });
        Object.defineProperty(this, "types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types
        });
        Object.defineProperty(this, "ID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (i += 1)
        });
        /**
         * Name bindings for expressions in the project.
         */
        Object.defineProperty(this, "global", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nothing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nothingToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "void", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "voidToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "boolean", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "number", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "string", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "enumeration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of Node to its {@link LexicalScope}.
         *
         * i.e. the names available in its lexical environment and a map of the node they point to.
         */
        Object.defineProperty(this, "lexicalScopeIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of a Module-scoped Node to its corresponding Thing value.
         *
         * This index is shared across all instances of a {@link TypeChecker} within a {@link Project}. I.e. it is a global index.
         */
        Object.defineProperty(this, "globalThingIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of a Node to its corresponding Type.
         */
        Object.defineProperty(this, "globalTypeIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Local index of a Node to its corresponding Thing value within the lexical environment represented by this {@link TypeCehcker}.
         */
        Object.defineProperty(this, "localThingIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        /**
         * Local index of a Node to its corresponding Apply within the lexical environment represented by this {@link TypeChecker}.
         */
        Object.defineProperty(this, "localApplyIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "tokens", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.globalTypeIndex = (_a = prev === null || prev === void 0 ? void 0 : prev.globalTypeIndex) !== null && _a !== void 0 ? _a : new WeakMap();
        this.tokens = (_b = prev === null || prev === void 0 ? void 0 : prev.tokens) !== null && _b !== void 0 ? _b : (0, token_1.tokens)();
        this.global = (_c = prev === null || prev === void 0 ? void 0 : prev.global) !== null && _c !== void 0 ? _c : (0, global_1.computeGlobal)(project);
        this.globalThingIndex = (_d = prev === null || prev === void 0 ? void 0 : prev.globalThingIndex) !== null && _d !== void 0 ? _d : new Map();
        this.lexicalScopeIndex = (_e = prev === null || prev === void 0 ? void 0 : prev.lexicalScopeIndex) !== null && _e !== void 0 ? _e : new WeakMap();
        this.thing = (_f = prev === null || prev === void 0 ? void 0 : prev.thing) !== null && _f !== void 0 ? _f : this.instantiateAlexaSchemaType(ast_1.AlexaSchema.Thing);
        this.nothing = (_g = prev === null || prev === void 0 ? void 0 : prev.nothing) !== null && _g !== void 0 ? _g : this.instantiateAlexaSchemaType(ast_1.AlexaSchema.Nothing);
        this.void = (_h = prev === null || prev === void 0 ? void 0 : prev.void) !== null && _h !== void 0 ? _h : this.instantiateAlexaSchemaType(ast_1.AlexaSchema.Void);
        this.nothingToken = (_j = prev === null || prev === void 0 ? void 0 : prev.nothingToken) !== null && _j !== void 0 ? _j : this.nextToken();
        this.voidToken = (_k = prev === null || prev === void 0 ? void 0 : prev.voidToken) !== null && _k !== void 0 ? _k : this.nextToken();
        this.boolean = (_l = prev === null || prev === void 0 ? void 0 : prev.boolean) !== null && _l !== void 0 ? _l : this.instantiateAlexaSchemaType(ast_1.AlexaSchema.Boolean);
        this.number = (_m = prev === null || prev === void 0 ? void 0 : prev.number) !== null && _m !== void 0 ? _m : this.instantiateAlexaSchemaType(ast_1.AlexaSchema.Number);
        this.string = (_o = prev === null || prev === void 0 ? void 0 : prev.string) !== null && _o !== void 0 ? _o : this.instantiateAlexaSchemaType(ast_1.AlexaSchema.String);
        this.enumeration = (_p = prev === null || prev === void 0 ? void 0 : prev.enumeration) !== null && _p !== void 0 ? _p : (0, lazy_1.memoize)(() => this.instantiateAlexaSchemaType(ast_1.AlexaConversations.Enumeration));
        // this.apl = prev?.apl ?? memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.APL));
        // this.apla = prev?.apla ?? memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.APLA));
        if (prev === undefined) {
            const checker = this;
            for (const expr of this.global.scope.values()) {
                if (expr === undefined) {
                    // return;
                }
                else if (Array.isArray(expr)) {
                    expr.forEach((expr) => { var _a; return checker.globalThingIndex.set(expr, (_a = checker.getThing(expr)) !== null && _a !== void 0 ? _a : null); });
                }
                else {
                    checker.globalThingIndex.set(expr, (_q = checker.getThing(expr)) !== null && _q !== void 0 ? _q : null);
                }
            }
        }
        if (things) {
            for (const [node, thing] of things.entries()) {
                this.localThingIndex.set(node, thing);
            }
        }
    }
    /**
     * Returns a reference to the root TypeChecker instance. TypeCheckers form a chain as we descend into
     * Dialog Sample Blocks and Conditional Blocks. This `root` instance refers to the global TypeChecker.
     *
     * We use this, for example, to look at the raw type signature of an ArgumentDeclaration instead of
     * looking at the type of the value passed into that argument within a Dialog Flow:
     *
     * ```
     * action myAction(String string)
     *
     * Foo(MyAction)
     *
     * dialog Foo(
     *   action bar(String arg)
     * ) {
     *   sample {
     *     // TypeChecker.root.getThing(NameReference(bar)) will return `action bar(String arg)`
     *     // If the TypeChecker is for the scope of this sample when `Foo` was called, then it would refer to `myAction` instead since that was passed in.
     *     bar("hello")
     *   }
     * }
     * ```
     */
    get root() {
        let curr = this;
        while (curr.prev !== undefined) {
            curr = curr.prev;
        }
        return curr;
    }
    /**
     * Get the next unique token.
     */
    nextToken() {
        return this.tokens.next().value;
    }
    /**
     * Find the URI of the Module containing this node.
     *
     * @param node
     */
    getUri(node) {
        const mod = node.getModule();
        if (mod) {
            for (const file of this.project.sourceModules.concat(this.project.externalModules)) {
                if ((file === null || file === void 0 ? void 0 : file.content) === mod) {
                    return file.uri;
                }
            }
        }
        return undefined;
    }
    /**
     * Lookup an expression by its FQN.
     *
     * @param fqn fully qualified name of the expression.
     */
    lookupQualifiedName(fqn) {
        const found = fqn ? this.global.scope.get(fqn) : undefined;
        return Array.isArray(found) ? found[0] : found;
    }
    /**
     * List all known types in a namespace.
     * @param namespace
     */
    listNamespace(namespace) {
        return this.global.namespaces.get(namespace);
    }
    /**
     * Qualify a name within a scope.
     *
     * @param scope to qualify the name within
     * @param name name to qualify
     * @returns the qualified name
     */
    qualifyName(scope, query) {
        var _a, _b;
        const name = typeof query === "object" ? query === null || query === void 0 ? void 0 : query.name : query;
        if (name === undefined) {
            return undefined;
        }
        if ((0, util_1.isQualifiedNamePattern)(name)) {
            // For backward compatibility reasons, the names within `slotTypes` namespace
            // are translated into `ask.interactionModel.slotTypes` namespace.
            // The `slotTypes` namespace is deprecated.
            if (name.startsWith("slotTypes.")) {
                return `ask.interactionModel.slotTypes.${name.substring("slotTypes.".length)}`;
            }
            return name;
        }
        const found = this.lookupName(scope, name);
        if ((found === null || found === void 0 ? void 0 : found.kind) === "NameDeclaration") {
            return (_a = found.name) === null || _a === void 0 ? void 0 : _a.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "TypeParameter") {
            return name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "TypeDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "ActionDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "DialogDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "EnumDeclaration") {
            return (_b = found.name) === null || _b === void 0 ? void 0 : _b.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "SlotType") {
            return found.name.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "ResponseTemplate") {
            if (found.isPrompt()) {
                return `${ask.PromptsNamespace}.${found.name}`;
            }
            if (found.isDisplay()) {
                return `${ask.DisplayNamespace}.${found.name}`;
            }
        }
        return name;
    }
    /**
     * Find where a name is declared in the stack.
     *
     * @param scope scope to trace back from
     * @param name name to find
     */
    lookupName(scope, name) {
        if (name === undefined) {
            return undefined;
        }
        const nameStr = typeof name === "string" ? name : name.name;
        if (this.global.scope.has(nameStr)) {
            const found = this.global.scope.get(nameStr);
            return Array.isArray(found) ? found[0] : found;
        }
        const lexicalScope = this.getVisibleNames(scope);
        if (lexicalScope) {
            const found = lexicalScope.get(nameStr);
            return Array.isArray(found) ? found[0] : found;
        }
        return undefined;
    }
    lookupNameReference(ref) {
        return this.lookupName(ref, ref.name);
    }
    /**
     * Recursively resolve the name reference when it's NameDeclaration
     * Stop when it's no longer a NameReference expression, or it's no longer a NameDeclaration
     *
     * @param ref nameReference to resolve
     * @returns the last resolved node
     */
    resolveNameReference(ref) {
        const decl = this.resolveNameReferenceToDecl(ref);
        if (ask.isNameDeclaration(decl)) {
            return decl.expression;
        }
        return decl;
    }
    /**
     * Recursively resolve the name reference to find the NameDeclaration
     * Stop when it's no longer a NameReference expression
     *
     * @param ref nameReference to resolve
     * @returns the last resolved NameDecl node
     */
    resolveNameReferenceToDecl(ref, seen = new Set()) {
        const found = ask.isPropRef(ref)
            ? this.lookupQualifiedName(ask.PropertyReference.tryResolveQualifiedName(ref))
            : this.lookupNameReference(ref);
        if (found === undefined) {
            return undefined;
        }
        if (seen.has(found)) {
            // circular reference
            return undefined;
        }
        seen.add(found);
        if (ask.isNameDeclaration(found)) {
            return this.isNameReference(found.expression)
                ? this.resolveNameReferenceToDecl(found.expression, seen)
                : found;
        }
        return found;
    }
    /**
     * Recursively resolve the name reference until find a call
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToCall(ref) {
        const found = this.resolveNameReference(ref);
        return ask.isCall(found) ? found : undefined;
    }
    /**
     * Recursively resolve the name reference until find a propertyReference
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToPropReference(ref) {
        const found = this.resolveNameReference(ref);
        return ask.isPropRef(found) ? found : undefined;
    }
    /**
     * Computes and caches the visible names at a Node.
     *
     * @param node the node in which we are looking for visible names
     * @param allowDescend a flag to set whether the code should descend into a Correction's `expected` block and include names in that block within this ${node}'s lexical scope.
     */
    getVisibleNames(node, allowDescend = true) {
        var _a, _b;
        if (node === undefined) {
            return immutable.Map();
        }
        // we skip caching the Correction block since its lexical scope varies on how it is approached (unfortunately)
        // 1. when the Correction Node is within a Block node, we consider the names in `expected` as a part of the lexical scope
        // 2. when we are in the Correction's `expected` or `actual` blocks, we do not consider the `expected` block as part of the lexical scope
        // we need this special behavior the Correction's expected block has abnormal lexical scope laws
        const useCache = node.kind !== "Correction";
        if (useCache && this.lexicalScopeIndex.has(node)) {
            return this.lexicalScopeIndex.get(node);
        }
        const inheritedNames = this.getVisibleNames((_a = node.previous) !== null && _a !== void 0 ? _a : node.context, ((_b = node.previous) === null || _b === void 0 ? void 0 : _b.kind) === "Correction");
        const producedNames = this.getProducedNames(node, allowDescend);
        const lexicalScope = inheritedNames !== undefined && producedNames !== undefined
            ? // TODO: check for conflicts or allow shadowing?
                inheritedNames.merge(producedNames)
            : inheritedNames === undefined
                ? producedNames
                : inheritedNames;
        if (useCache) {
            this.lexicalScopeIndex.set(node, lexicalScope);
        }
        return lexicalScope;
    }
    /**
     * Collect the names produced by a Node.
     */
    getProducedNames(node, allowDescend) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (node.kind === "Module") {
            const imports = (_b = (_a = node.imports) === null || _a === void 0 ? void 0 : _a.map((imprt) => {
                var _a;
                if (imprt.name) {
                    if (imprt.kind === "ImportName") {
                        const namespace = (0, util_1.getNamespace)(imprt.name);
                        const name = (0, util_1.getName)(imprt.name);
                        const expr = (_a = this.global.namespaces.get(namespace)) === null || _a === void 0 ? void 0 : _a.get(name);
                        if (expr) {
                            return immutable.Map({
                                [name]: expr,
                            });
                        }
                    }
                    else {
                        return this.global.namespaces.get(imprt.name);
                    }
                }
                return undefined;
            }).filter((scope) => scope !== undefined)) !== null && _b !== void 0 ? _b : [];
            // regard content in same namespace as import
            const thisNamespace = ((_c = node.namespace) === null || _c === void 0 ? void 0 : _c.name) ? this.global.namespaces.get(node.namespace.name) : undefined;
            const declared = (_e = (_d = node.expressions) === null || _d === void 0 ? void 0 : _d.map((expr) => {
                var _a;
                if (expr.kind !== "InteractionDeclaration" &&
                    ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name) &&
                    (expr.kind === "ActionDeclaration" ||
                        expr.kind === "DialogDeclaration" ||
                        expr.kind === "EnumDeclaration" ||
                        expr.kind === "NameDeclaration" ||
                        expr.kind === "TypeDeclaration")) {
                    if (node.namespace !== undefined) {
                        // we're in an ACDL module so import the short name into lexical scope
                        return immutable.Map({
                            [expr.name.name]: expr,
                            [(0, util_1.getName)(expr.name.name)]: expr,
                        });
                    }
                    return immutable.Map({
                        [expr.name.name]: expr,
                    });
                }
                return undefined;
            }).filter((scope) => scope !== undefined)) !== null && _e !== void 0 ? _e : [];
            return [...imports, thisNamespace, ...declared].reduce(lexical_scope_1.mergeLexicalScope, (0, lexical_scope_1.emptyLexicalScope)()).map((value) => {
                if (Array.isArray(value)) {
                    const set = new Set(value);
                    if (set.size === 1) {
                        return value[0];
                    }
                    return Array.from(set);
                }
                return value;
            });
        }
        if ((node.kind === "NameDeclaration" || node.kind === "EnumDeclaration") && ((_f = node.name) === null || _f === void 0 ? void 0 : _f.name) !== undefined) {
            return immutable.Map({
                [node.name.name]: node,
            });
        }
        if ((node === null || node === void 0 ? void 0 : node.kind) === "ActionDeclaration" || (node === null || node === void 0 ? void 0 : node.kind) === "DialogDeclaration" || (node === null || node === void 0 ? void 0 : node.kind) === "TypeDeclaration") {
            const genericArguments = (0, lexical_scope_1.computeLexicalScope)(node.genericArguments);
            if (node.kind === "DialogDeclaration") {
                const argumentsScope = (0, lexical_scope_1.computeLexicalScope)(node.arguments);
                return genericArguments.merge(argumentsScope);
            }
            return genericArguments;
        }
        if (node.kind === "Correction" && allowDescend) {
            if ((_h = (_g = node.expected) === null || _g === void 0 ? void 0 : _g.expressions) === null || _h === void 0 ? void 0 : _h.length) {
                return this.getVisibleNames(node.expected.expressions[node.expected.expressions.length - 1]);
            }
        }
        else if (node.kind === "Argument") {
            // special lexical scoping logic for validateArg, see https://github.com/alexa/ask-ac/issues/690
            const annotationName = this.lookupName(node.context, node.context.name);
            if ((annotationName === null || annotationName === void 0 ? void 0 : annotationName.kind) === "ActionDeclaration" && ((_j = annotationName.name) === null || _j === void 0 ? void 0 : _j.name) === ast_1.AlexaConversations.validateArg) {
                if (((_k = node.name) === null || _k === void 0 ? void 0 : _k.name) === "condition" || (node.name === undefined && node.index === 0)) {
                    // we only want the argument names to be visible for the `condition` argument.
                    if (node.context.context.kind === "Annotation" && node.context.context.context.kind === "ActionDeclaration") {
                        return (0, lexical_scope_1.computeLexicalScope)(node.context.context.context.arguments);
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Find the {@link ask.Name} located at a specific position in the file.
     *
     * @param uri module uri to search
     * @param position line and column number
     */
    findName(uri, position) {
        const found = this.findNode(uri, position);
        return ask.isName(found) ? found : undefined;
    }
    /**
     * Finds a {@link ask.Name} or {@link ask.Import} at a specific position in the file.
     *
     * @param uri module uri to search
     * @param position line and column number
     */
    findNode(uri, position) {
        var _a;
        const module = this.project.getModule(uri);
        const { expressions, imports, namespace } = (_a = module === null || module === void 0 ? void 0 : module.content) !== null && _a !== void 0 ? _a : {};
        return this.find(expressions, position) || this.find(imports, position) || this.find(namespace, position);
    }
    /**
     * Finds a {@link ask.Name} or {@link ask.Import} node at a specific position in the file.
     *
     * @param node node to search
     * @param position line and column number
     * @returns the `Name` or `Import` node
     */
    find(node, position) {
        if (node === undefined || node === null) {
            return undefined;
        }
        if (Array.isArray(node)) {
            for (const i of node) {
                const found = this.find(i, position);
                if (found !== undefined) {
                    return found;
                }
            }
        }
        else if (typeof node === "object") {
            if ((node === null || node === void 0 ? void 0 : node.loc) !== undefined) {
                if (ask.locationContains(node.loc, position, true)) {
                    if (ask.isName(node) || ask.isImport(node)) {
                        return node;
                    }
                }
            }
            for (const [name, value] of Object.entries(node)) {
                if (name === "context" || name === "previous") {
                    continue;
                }
                const found = this.find(value, position);
                if (found !== undefined) {
                    return found;
                }
            }
        }
        return undefined;
    }
    /**
     * Finds the type referenced by a TypeReference.
     *
     * @param type type reference to lookup
     */
    lookupTypeReference(type) {
        var _a;
        const target = this.lookupName(type, (_a = type.name) === null || _a === void 0 ? void 0 : _a.name);
        if ((target === null || target === void 0 ? void 0 : target.kind) === "ActionDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "DialogDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "EnumDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "TypeDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "TypeParameter" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "SlotType") {
            return target;
        }
        return undefined;
    }
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupCallDeclaration(call) {
        var _a;
        const target = this.lookupName(call, (_a = call.name) === null || _a === void 0 ? void 0 : _a.name);
        if (target !== undefined &&
            (target.kind === "ActionDeclaration" ||
                target.kind === "ArgumentDeclaration" ||
                target.kind === "DialogDeclaration" ||
                target.kind === "NameDeclaration" ||
                target.kind === "SlotType" ||
                target.kind === "TypeDeclaration")) {
            return target;
        }
        return undefined;
    }
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupTypeDeclaration(fqn) {
        const names = this.global.scope.get(fqn);
        const expr = Array.isArray(names) ? names[0] : names;
        if ((expr === null || expr === void 0 ? void 0 : expr.kind) === "TypeDeclaration") {
            return expr;
        }
        return undefined;
    }
    /**
     * Get auto-completion suggestions for the Node.
     */
    getCompletions(node) {
        var _a, _b, _c, _d, _e, _f;
        // TODO: type safe interface
        if (node.kind === "Name") {
            const { context } = node;
            if (context.kind === "Utterance") {
                const type = (_a = this.getType(context.context)) === null || _a === void 0 ? void 0 : _a.getUtteranceType();
                if (type !== undefined) {
                    const alreadyProvided = new Set((_b = context.names) === null || _b === void 0 ? void 0 : _b.map((n) => n.name).filter((n) => n !== undefined && n !== node.name));
                    return (_c = type.properties) === null || _c === void 0 ? void 0 : _c.map((prop) => prop.name).filter((n) => n !== undefined && !alreadyProvided.has(n)).map((label) => ({
                        label,
                    }));
                }
            }
            else if (context.kind === "Block") {
                return Object.keys(this.getVisibleNames(node) || {}).map((label) => ({ label }));
            }
            else {
                return this.getCompletions(node.context);
            }
        }
        else if (this.isNameReference(node)) {
            return Object.keys(this.getVisibleNames(node) || {})
                .filter((label) => !label.includes("."))
                .map((label) => ({
                label,
            }));
        }
        else if (node.kind === "PropertyReference") {
            const exprType = this === null || this === void 0 ? void 0 : this.getType(node.expression);
            if (exprType) {
                return (_d = exprType.properties) === null || _d === void 0 ? void 0 : _d.map((property) => ({
                    label: property.name,
                }));
            }
        }
        else if (node.kind === "Argument") {
            return (_f = (_e = this.getApply(node.context)) === null || _e === void 0 ? void 0 : _e.argumentDeclarations) === null || _f === void 0 ? void 0 : _f.map((arg) => {
                var _a;
                return ({
                    label: typeof arg.name === "string" ? arg.name : (_a = arg.name) === null || _a === void 0 ? void 0 : _a.name,
                });
            });
        }
        return undefined;
    }
    /**
     * Compute a detailed description of the expression.
     *
     * @param node expression to describe.
     */
    getDescription(node) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (node !== undefined) {
            if (node.kind === "Name") {
                const { context } = node;
                if (context.kind === "Utterance") {
                    const type = (_a = this.getType(context.context)) === null || _a === void 0 ? void 0 : _a.getUtteranceType();
                    if (type && node.name) {
                        return `(property) ${type.toString(node)} ${node.name}`;
                    }
                }
                return this.getDescription(context);
            }
            if (node.kind === "NameReference") {
                const type = this.getType(node);
                if (type && ((_b = node.name) === null || _b === void 0 ? void 0 : _b.name)) {
                    return `(name) ${type.toString(node)} ${node.name.name}`;
                }
            }
            else if (node.kind === "NameDeclaration") {
                if (((_c = node.name) === null || _c === void 0 ? void 0 : _c.name) && node.expression) {
                    const type = this.getType(node);
                    if (type) {
                        return `(name) ${type.toString(node)} ${node.name.name}`;
                    }
                }
            }
            else if (node.kind === "PropertyReference") {
                if (this.isNameReference(node)) {
                    const type = this.getType(node);
                    if (type && ((_d = node.name) === null || _d === void 0 ? void 0 : _d.name)) {
                        return `(name) ${type.toString(node)} ${node.name.name}`;
                    }
                }
                const propertyName = (_e = node.name) === null || _e === void 0 ? void 0 : _e.name;
                const returnType = this.getType(node);
                if (returnType && propertyName) {
                    return `(property) ${returnType.toString(node)} ${propertyName}`;
                }
            }
            else if (node.kind === "TypeReference") {
                const type = this.getType(node);
                if (((_f = node.name) === null || _f === void 0 ? void 0 : _f.name) && type) {
                    const label = ((_g = type === null || type === void 0 ? void 0 : type.declaration) === null || _g === void 0 ? void 0 : _g.kind) === "TypeParameter" ? "type parameter" : "type";
                    return `(${label}) ${type.toString(node)}`;
                }
            }
            else if (node.kind === "Type") {
                return node.toString(node.declaration);
            }
            else if (node.kind === "TypeParameter") {
                if ((_h = node.name) === null || _h === void 0 ? void 0 : _h.name) {
                    return `(type parameter) ${node.name.name}`;
                }
            }
            else if (node.kind === "TypeProperty") {
                const type = this.getType(node.type);
                if (type && ((_j = node.name) === null || _j === void 0 ? void 0 : _j.name)) {
                    return `(property) ${type.toString(node)} ${node.name.name}`;
                }
            }
            else if (node.kind === "TypeDeclaration") {
                return `(type declaration) ${(_k = node.name) === null || _k === void 0 ? void 0 : _k.name}${node.genericArguments ? `<${node.genericArguments.map((arg) => (0, util_1.stringifyTypeParameter)(arg))}>` : ""}`;
            }
            else if (node.kind === "EnumDeclaration") {
                return `(enum declaration) ${(_l = node.name) === null || _l === void 0 ? void 0 : _l.name}`;
            }
            else if (node.kind === "EnumItemDeclaration") {
                return `(enum item) ${(_m = node.name) === null || _m === void 0 ? void 0 : _m.name}`;
            }
            else if (node.kind === "DialogDeclaration" || node.kind === "ActionDeclaration") {
                const type = node.kind === "ActionDeclaration" ? "action" : "dialog";
                const returnType = this.getType(node.returnType);
                const argumentDeclarations = node.arguments && node.arguments.length > 0
                    ? `(\n  ${node.arguments.map((a) => { var _a, _b; return `${(_a = this.getType(a)) === null || _a === void 0 ? void 0 : _a.toString(node)} ${(_b = a.name) === null || _b === void 0 ? void 0 : _b.name}`; }).join(",\n  ")}\n)`
                    : "()";
                if (returnType && ((_o = node.name) === null || _o === void 0 ? void 0 : _o.name)) {
                    return `${type} ${returnType.toString(node)} ${node.name.name}${argumentDeclarations}`;
                }
            }
            else if (node.kind === "ArgumentDeclaration") {
                const type = this.getType(node.type);
                if (type && ((_p = node.name) === null || _p === void 0 ? void 0 : _p.name)) {
                    return `(argument) ${type.toString(node)} ${(_q = node.name) === null || _q === void 0 ? void 0 : _q.name}`;
                }
            }
            else if (node.kind === "Argument") {
                const type = this.getType(node.value);
                if (type && ((_r = node.name) === null || _r === void 0 ? void 0 : _r.name)) {
                    return `(argument) ${type.toString(node)} ${(_s = node.name) === null || _s === void 0 ? void 0 : _s.name}`;
                }
            }
            else if (node.kind === "Call") {
                return this.getDescription((_t = this.getApply(node)) === null || _t === void 0 ? void 0 : _t.decl);
            }
        }
        return undefined;
    }
    /**
     * Gets a `Thing` instance representing the value of some Node.
     *
     * @param node AST node to get a Thing to represent.
     * @param backtrack backtrack to control type interface
     * @param seen nodes seen so far in this traversal to detect infinite loops
     */
    getThing(node, token, origin = node, seen = immutable.Set()) {
        var _a, _b, _c;
        if (node === undefined) {
            return undefined;
        }
        if (seen.has(node)) {
            // circular reference
            return undefined;
        }
        const checker = this;
        seen = seen.add(node);
        if (this.globalThingIndex.has(node)) {
            return (_a = this.globalThingIndex.get(node)) !== null && _a !== void 0 ? _a : undefined;
        }
        if (!this.localThingIndex.has(node)) {
            this.localThingIndex.set(node, (_b = getThing(node, seen)) !== null && _b !== void 0 ? _b : null);
        }
        return (_c = this.localThingIndex.get(node)) !== null && _c !== void 0 ? _c : undefined;
        function getThing(node, seen) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            if (node.kind === "NameReference" ||
                node.kind === "PropertyReference" ||
                (node.kind === "Call" && ((_a = checker.getApply(node, undefined, seen)) === null || _a === void 0 ? void 0 : _a.isGetListItem()))) {
                let rootThing = undefined;
                if (node.kind === "PropertyReference") {
                    const nameRef = checker.lookupName(node, ask.PropertyReference.tryResolveQualifiedName(node));
                    if (nameRef) {
                        rootThing = checker.getThing(nameRef, token, node, seen);
                    }
                    else {
                        rootThing = (_b = checker.getThing(node.expression, undefined, undefined, seen)) === null || _b === void 0 ? void 0 : _b.getProperty(node.name);
                    }
                }
                else if (node.kind === "Call") {
                    const apply = checker.getApply(node);
                    const index = (_c = checker.getThing(apply.getArgumentValue("index"))) === null || _c === void 0 ? void 0 : _c.asNumber();
                    let listThing = checker.getThing(apply.getArgumentValue("list"), undefined, undefined, seen);
                    // If listThing is Optional<List> then we need to unwrap the List from the generic
                    // argument and transform it from an AnyThing to a ListThing.
                    if (!(listThing === null || listThing === void 0 ? void 0 : listThing.isList()) && (listThing === null || listThing === void 0 ? void 0 : listThing.type.isOptional())) {
                        const genericType = (_e = (_d = listThing === null || listThing === void 0 ? void 0 : listThing.type) === null || _d === void 0 ? void 0 : _d.genericArguments) === null || _e === void 0 ? void 0 : _e[0];
                        if (genericType && genericType.isList()) {
                            listThing = genericType.getThing(checker.nextToken(), origin, listThing, apply);
                        }
                    }
                    if (index) {
                        rootThing = (_f = listThing === null || listThing === void 0 ? void 0 : listThing.asList()) === null || _f === void 0 ? void 0 : _f.getItem(index, node);
                    }
                }
                else {
                    rootThing = checker.getThing(checker.lookupNameReference(node), token, undefined, seen);
                }
                if (rootThing === undefined) {
                    return undefined;
                }
                return search(node.context);
                function search(context) {
                    if (context === undefined) {
                        return rootThing;
                    }
                    if (context.kind === "Block") {
                        if (context instanceof ast_1.ThenScope) {
                            if (context.context.when) {
                                return descend(context.context.when.expression, search(context.context));
                            }
                            return search(context.context);
                        }
                        if (context.context.kind === "Sample") {
                            const sample = context.context;
                            if (sample.annotations) {
                                for (const annotation of sample.annotations) {
                                    const annotationApply = checker.getApply(annotation.call);
                                    if (annotationApply === null || annotationApply === void 0 ? void 0 : annotationApply.isWhen()) {
                                        const condition = annotationApply.getArgumentValue("condition");
                                        if (condition) {
                                            return descend(condition, search(context.context));
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else if (context.kind === "Argument") {
                        const apply = checker.getApply(context.context);
                        if (apply === null || apply === void 0 ? void 0 : apply.isAnd()) {
                            const left = apply.getArgument("left");
                            const right = apply.getArgument("right");
                            if (left === context) {
                                return search(context.context);
                            }
                            if (right === context) {
                                return descend(left, search(context.context));
                            }
                        }
                    }
                    return search(context.context);
                }
                function descend(when, thing) {
                    var _a;
                    if (when === undefined) {
                        return thing;
                    }
                    if (when.kind === "Argument") {
                        return descend(when.value, thing);
                    }
                    if (when.kind === "Call") {
                        const apply = checker.getApply(when, true, seen);
                        if (apply) {
                            if (apply.isIs()) {
                                const isThing = apply.getArgumentValueThing("thing");
                                const type = (_a = apply.getGenericArguments()) === null || _a === void 0 ? void 0 : _a[0];
                                if (type && (isThing === null || isThing === void 0 ? void 0 : isThing.equals(thing))) {
                                    return thing.cast(thing.type.narrow(type));
                                }
                            }
                            else if (apply.isAnd()) {
                                const left = descend(apply.getArgumentValue("left"), thing);
                                const right = descend(apply.getArgumentValue("right"), left);
                                if (left === undefined && right === undefined) {
                                    return search(when.context);
                                }
                                if (left === undefined || right === undefined) {
                                    return left || right;
                                }
                                const intersection = left.type.narrow(right.type);
                                if (intersection) {
                                    return search(when.context).cast(intersection);
                                }
                            }
                            else if (apply.isOr()) {
                                const left = descend(apply.getArgumentValue("left"), thing);
                                const right = descend(apply.getArgumentValue("right"), thing);
                                const union = left.type.union(right.type);
                                if (union) {
                                    return thing.cast(union);
                                }
                            }
                            else if (apply.isEq() || apply.isNeq()) {
                                const left = apply.getArgumentValueThing("left");
                                const right = apply.getArgumentValueThing("right");
                                if ((left === null || left === void 0 ? void 0 : left.equals(thing)) || (right === null || right === void 0 ? void 0 : right.equals(thing))) {
                                    const operand = (left === null || left === void 0 ? void 0 : left.equals(thing)) ? right : left;
                                    if ((operand === null || operand === void 0 ? void 0 : operand.type.isVoid()) || (operand === null || operand === void 0 ? void 0 : operand.type.isNothing())) {
                                        if (apply.isEq()) {
                                            return new thing_1.VoidThing(checker, thing.token, checker.void, thing.apply, thing.origin, thing.parent);
                                        }
                                        let { type } = thing;
                                        while (type === null || type === void 0 ? void 0 : type.isOptional()) {
                                            type = type.getOptionalType();
                                        }
                                        return type ? thing.cast(type) : thing;
                                    }
                                    return thing;
                                }
                            }
                        }
                    }
                    return thing;
                }
            }
            if (node.kind === "NameDeclaration") {
                const expr = checker.getThing(node.expression, token !== null && token !== void 0 ? token : checker.nextToken(), (_g = node.expression) !== null && _g !== void 0 ? _g : node, seen);
                if (node.type && (expr === null || expr === void 0 ? void 0 : expr.type.isNothing())) {
                    return (_h = checker.getType(node.type)) === null || _h === void 0 ? void 0 : _h.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), (_j = node.expression) !== null && _j !== void 0 ? _j : node);
                }
                return expr;
            }
            if (node.kind === "Call") {
                const apply = checker.getApply(node, true, seen);
                if (apply !== undefined) {
                    if (apply.isType()) {
                        const returnType = apply.getReturnType(seen);
                        if (returnType === null || returnType === void 0 ? void 0 : returnType.isNothing()) {
                            return new thing_1.NothingThing(checker, checker.nothingToken, checker.nothing, apply, origin !== null && origin !== void 0 ? origin : node, undefined);
                        }
                        if (returnType === null || returnType === void 0 ? void 0 : returnType.isVoid()) {
                            return new thing_1.VoidThing(checker, checker.voidToken, checker.void, apply, origin !== null && origin !== void 0 ? origin : node, undefined);
                        }
                        return returnType === null || returnType === void 0 ? void 0 : returnType.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node, undefined, apply);
                    }
                    if (apply.isAction()) {
                        return (_k = apply.getReturnType(seen)) === null || _k === void 0 ? void 0 : _k.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node, undefined, apply);
                    }
                    if (apply.isDialog()) {
                        return (_l = apply.getReturnType(seen)) === null || _l === void 0 ? void 0 : _l.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node);
                    }
                }
                return undefined;
            }
            if (node.kind === "Annotation") {
                return checker.getThing(node.call, token, undefined, seen);
            }
            if (node.kind === "Argument") {
                return checker.getThing(node.value, token, undefined, seen);
            }
            if (node.kind === "ListItem") {
                return checker.getThing(node.item, token, undefined, seen);
            }
            if (node.kind === "ListLiteral") {
                return checker.getThing(node.context, token, undefined, seen);
            }
            if (node.kind === "ResponseTemplate") {
                // TODO
            }
            else if (node.kind === "Sample") {
                return checker.getThing(node.scope, token !== null && token !== void 0 ? token : checker.nextToken(), node, seen);
            }
            else if (node.kind === "ActionDeclaration") {
                return new thing_1.ActionThing(checker, checker.nextToken(), checker.getType(node), node);
            }
            else if (node.kind === "DialogDeclaration") {
                return new thing_1.DialogThing(checker, checker.nextToken(), checker.getType(node), node);
            }
            else if (node.kind === "Condition") {
                const then = ((_o = (_m = node.then) === null || _m === void 0 ? void 0 : _m.expressions) === null || _o === void 0 ? void 0 : _o.length)
                    ? checker.getThing(node.then.expressions[node.then.expressions.length - 1], undefined, undefined, seen)
                    : checker.void.getThing(checker.nextToken(), node);
                const _else = ((_q = (_p = node.else) === null || _p === void 0 ? void 0 : _p.expressions) === null || _q === void 0 ? void 0 : _q.length)
                    ? checker.getThing(node.else.expressions[node.else.expressions.length - 1], undefined, undefined, seen)
                    : checker.void.getThing(checker.nextToken(), node);
                if (then && _else) {
                    return new thing_1.UnionThing(checker, checker.nextToken(), checker.getType(node), node, [then, _else]);
                }
                if (then) {
                    return new thing_1.UnionThing(checker, checker.nextToken(), checker.getType(node), node, [then]);
                }
                return undefined;
            }
            else if (node.kind === "Block" && node.expressions && node.expressions.length > 0) {
                return checker.getThing(node.expressions[node.expressions.length - 1]);
            }
            else if (node.kind === "When") {
                return checker.getThing(node.expression, token, origin, seen);
            }
            // recursion
            return ((_r = checker.getType(node)) !== null && _r !== void 0 ? _r : checker.thing).getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node);
        }
    }
    /**
     * Gets the type of a Node.
     *
     * @param node to determine the type of
     * @param backtrack backtrack to control the behavior of the get type search
     * @param seen a set of seen nodes for detecting circular references
     * @returns instantiate type of the node or undefined if it cannot be determined
     */
    getType(node, backtrack = true, seen = immutable.Set()) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (node === undefined || seen.has(node)) {
            return undefined;
        }
        if (node.kind === "Call") {
            const apply = this.getApply(node, backtrack);
            if (apply === null || apply === void 0 ? void 0 : apply.isGetListItem()) {
                return (_a = this.getThing(node, undefined, undefined, seen)) === null || _a === void 0 ? void 0 : _a.type;
            }
            return apply === null || apply === void 0 ? void 0 : apply.getReturnType(seen.add(node));
        }
        if (node.kind === "Annotation") {
            return this.getType(node.call, backtrack, seen);
        }
        if (node.kind === "Utterance") {
            return this.getType(node.context, backtrack);
        }
        if (node.kind === "NameDeclaration") {
            if (node.type) {
                return this.instantiateTypeReference(node.type);
            }
            // infer the type from the expression
            return (_b = this.getThing(node.expression, undefined, node, seen.add(node))) === null || _b === void 0 ? void 0 : _b.type;
        }
        if (node.kind === "NameReference") {
            return (_c = this.getThing(node, undefined, node, seen)) === null || _c === void 0 ? void 0 : _c.type;
        }
        if (node.kind === "PropertyReference") {
            return (_d = this.getThing(node, undefined, node, seen)) === null || _d === void 0 ? void 0 : _d.type;
        }
        if (node.kind === "ListLiteral") {
            // empty list defaults to List<Thing>, otherwise List<T> where T is the intersection of all Types in the List.
            // TODO: should it default to List<Nothing> so that it is a List compatible with all lists? Probably...
            const itemType = node.items.length === 0
                ? this.thing
                : node.items
                    .map((item) => this.getType(item.item, false, seen))
                    // reduce the list of types to a single type which is their shared sub type
                    // if two types have an `undefined` intersection, assume as `Thing`
                    // initial value of reduction is nothing (0, "zero") - nothing intersects with all types, so the first value in the list always takes precedence
                    .reduce((a, b) => { var _a; return (_a = a === null || a === void 0 ? void 0 : a.union(b)) !== null && _a !== void 0 ? _a : this.thing; }, this.nothing);
            if (itemType === undefined) {
                return undefined;
            }
            if (node.context.kind === "Call" && ((_e = node.context.name) === null || _e === void 0 ? void 0 : _e.name) === ast_1.AlexaConversations.Args) {
                return this.instantiateAlexaSchemaType(ast_1.AlexaConversations.Args, itemType);
            }
            return this.instantiateAlexaSchemaType(ast_1.AlexaSchema.List, itemType);
        }
        if (node.kind === "ArgumentDeclaration") {
            return this.instantiateTypeReference(node.type);
        }
        if (node.kind === "TypeReference") {
            return this.instantiateTypeReference(node);
        }
        if (node.kind === "Condition") {
            const then = (_f = this.getType(node.then, backtrack, seen)) !== null && _f !== void 0 ? _f : this.nothing; // then as `undefined` is impossible
            const _else = node.else ? (_g = this.getType(node.else, backtrack, seen)) !== null && _g !== void 0 ? _g : this.nothing : this.void;
            return then === null || then === void 0 ? void 0 : then.union(_else);
        }
        if (node.kind === "Correction") {
            return this.void;
        }
        if (node.kind === "When") {
            return this.getType(node.expression);
        }
        if (node.kind === "Block") {
            if (node.expressions && node.expressions.length > 0) {
                return this.getType(node.expressions[node.expressions.length - 1], backtrack, seen);
            }
            return this.void;
        }
        if (node.kind === "ActionDeclaration" || node.kind === "DialogDeclaration") {
            return new type_1.Type(this, node, undefined);
        }
        if (node.kind === "TypeDeclaration") {
            // Type<T>
            const typeType = this.lookupTypeDeclaration(ast_1.AlexaSchema.Type);
            const type = this.instantiateTypeDeclaration(node, undefined);
            if (type) {
                return new type_1.Type(this, typeType, [type]);
            }
        }
        else if (node.kind === "TypeParameter") {
            return this.instantiateTypeParameter(node);
        }
        else if (node.kind === "ResponseTemplate") {
            if (node.type === ask.ResponseTemplateType.Display) {
                return this.instantiateTypeDeclaration(this.lookupTypeDeclaration(ast_1.AlexaConversations.APL), [this.thing]);
            }
            if (node.type === ask.ResponseTemplateType.Prompt) {
                return this.instantiateTypeDeclaration(this.lookupTypeDeclaration(ast_1.AlexaConversations.APLA), [this.thing]);
            }
        }
        else if (node.kind === "SlotType") {
            return this.instantiateTypeDeclaration(node);
        }
        else if (node.kind === "Sample") {
            return this.getType(node.scope, backtrack, seen);
        }
        else if (node.kind === "ListItem") {
            return this.getType(node.item, backtrack, seen);
        }
        else if (node.kind === "Argument") {
            return this.getType(node.value, backtrack, seen);
        }
        else if (node.kind === "TypeProperty") {
            let propertyType = (_h = this.getType(node.type, backtrack, seen)) !== null && _h !== void 0 ? _h : this.nothing;
            if (node.optional === true && !propertyType.isOptional()) {
                propertyType = new type_1.Type(this, this.lookupTypeDeclaration(ast_1.AlexaSchema.Optional), [propertyType]);
            }
            return new type_1.Type(this, this.lookupTypeDeclaration(ast_1.AlexaSchema.Property), [propertyType]);
        }
        else if (node.kind === "EnumDeclaration") {
            const typeType = this.lookupTypeDeclaration(ast_1.AlexaSchema.Type);
            const type = this.instantiateTypeDeclaration(node);
            if (type) {
                /**
                 * e.g.
                 * ```
                 * enum A {
                 *   a
                 * }
                 *
                 * A // type: `Type<A>`
                 * A.a // type: `A`
                 * ``
                 */
                return new type_1.Type(this, typeType, [type]);
            }
        }
        else if (node.kind === "EnumItemDeclaration") {
            return (_j = this.getType(node.context, backtrack, seen)) === null || _j === void 0 ? void 0 : _j.getTypeType();
        }
        return undefined;
    }
    /**
     * Get the type of a Call implied by its context.
     *
     * @param call
     */
    getImpliedType(call) {
        var _a, _b, _c;
        const callContext = call.context;
        if ((callContext.kind === "NameDeclaration" || callContext.kind === "ArgumentDeclaration") && callContext.type) {
            return this.instantiateTypeReference(callContext.type);
        }
        if (callContext.kind === "ListItem") {
            return (_b = (_a = this.getApply(callContext.context.context, true)) === null || _a === void 0 ? void 0 : _a.getReturnType()) === null || _b === void 0 ? void 0 : _b.getListItemType();
        }
        if (callContext.kind === "Argument") {
            return (_c = this.getApply(callContext.context, true)) === null || _c === void 0 ? void 0 : _c.getType(callContext);
        }
        return undefined;
    }
    /**
     * Get an Apply for this call.
     *
     * @param call to analyze
     * @param backtrack whether to look back up the tree to infer types
     */
    getApply(call, backtrack = true, seenNames = immutable.Set()) {
        var _a, _b;
        const checker = this;
        if (!backtrack) {
            return getApply();
        }
        if (!this.localApplyIndex.has(call)) {
            this.localApplyIndex.set(call, (_a = getApply()) !== null && _a !== void 0 ? _a : null);
        }
        return (_b = this.localApplyIndex.get(call)) !== null && _b !== void 0 ? _b : undefined;
        function getApply() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            if (checker.prev) {
                return (_a = checker.root.getApply(call, backtrack, seenNames)) === null || _a === void 0 ? void 0 : _a.instantiate(checker);
            }
            if (((_b = call.name) === null || _b === void 0 ? void 0 : _b.name) === undefined) {
                if (backtrack) {
                    let impliedType = checker.getImpliedType(call);
                    while (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isOptional()) {
                        // if the implied type is optional and we have a non-null call, then we know we are instantiating the Some type
                        impliedType = impliedType.getOptionalType();
                    }
                    if (ask.isListLiteral(call.arguments) && (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isThing())) {
                        // if checker is a list literal in an argument that is of type, `Thing`, then infer the the type of the list from the literal items.
                        impliedType = checker.getType(call.arguments);
                    }
                    const implied = impliedType === null || impliedType === void 0 ? void 0 : impliedType.apply(call);
                    if (implied) {
                        return implied;
                    }
                }
                if (ask.isListLiteral(call.arguments)) {
                    return (_c = checker.getType(call.arguments, backtrack, seenNames)) === null || _c === void 0 ? void 0 : _c.apply(call);
                }
                return undefined;
            }
            if (((_d = call.name) === null || _d === void 0 ? void 0 : _d.name) === ast_1.AlexaSchema.String && (typeof call.arguments === "string" || ask.isUtterance(call.arguments))) {
                // string literal, let's check if this string should be treated as an utterance or some other specialized string
                if (backtrack) {
                    const impliedType = checker.getImpliedType(call);
                    if (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isStringLike()) {
                        return impliedType.apply(call);
                    }
                }
            }
            else if (call.name.name === ast_1.AlexaSchema.Number && typeof call.arguments === "number") {
                // number literal, let's check if it should be up-casted to a specialized string based on context
                // e.g. Ordinal ord = 1
                // `1` should be interpreted as Ordinal(1), not Number(1)
                if (backtrack) {
                    const impliedType = checker.getImpliedType(call);
                    if (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isNumber()) {
                        return impliedType.apply(call);
                    }
                }
            }
            const decl = checker.lookupCallDeclaration(call);
            if (decl === undefined) {
                return undefined;
            }
            if (decl.kind === "TypeDeclaration") {
                if (decl.genericArguments === undefined) {
                    // concrete type
                    return (_e = checker.instantiateTypeDeclaration(decl, undefined)) === null || _e === void 0 ? void 0 : _e.apply(call);
                }
                if (((_f = call.genericArguments) === null || _f === void 0 ? void 0 : _f.length) === decl.genericArguments.length) {
                    // generic with explicits
                    return (_g = checker
                        .instantiateTypeDeclaration(decl, call.genericArguments.map((a) => checker.instantiateTypeReference(a)))) === null || _g === void 0 ? void 0 : _g.apply(call);
                }
                return new apply_1.Apply(checker, call, decl);
            }
            if (decl.kind === "SlotType") {
                return (_h = checker.instantiateTypeDeclaration(decl)) === null || _h === void 0 ? void 0 : _h.apply(call);
            }
            if (decl.kind === "ArgumentDeclaration" || decl.kind === "NameDeclaration") {
                // either a concrete reference to an action or an abstract action signature (argument declaration).
                const actionThing = checker.getThing(decl);
                if (!actionThing || !actionThing.type || ((_j = actionThing.origin) === null || _j === void 0 ? void 0 : _j.kind) === "ActionDeclaration") {
                    return undefined;
                }
                // actual type of the argument declaration
                const actualType = actionThing.type.isOptional() ? actionThing.type.getOptionalType() : actionThing.type;
                // abstract type of the argument declaration, e.g. FunctionN<..>
                const abstractType = checker.root.getType(decl);
                if (abstractType && (actualType === null || actualType === void 0 ? void 0 : actualType.isFunction())) {
                    return new apply_1.Apply(checker, call, actualType);
                }
                return undefined;
            }
            return new apply_1.Apply(checker, call, decl);
        }
    }
    /**
     * Find an Argument's TypeProperty based on its position or name in a Call to a TypeDeclaration.
     *
     * @param type type declaration called
     * @param argument argument value in the call
     */
    findArgumentTypeProperty(type, argument) {
        var _a;
        if (type.properties === undefined) {
            return undefined;
        }
        if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
            return type.getProperty(argument.name.name);
        }
        if (typeof argument.index === "number") {
            return type.getProperty(argument.index);
        }
        return undefined;
    }
    /**
     * Find an Argument's declaration based on its name or position
     *
     * @param action action or dialog declaration
     * @param argument argument value in the call
     */
    findArgumentDeclaration(action, argument) {
        var _a, _b;
        if (action.arguments === undefined) {
            return undefined;
        }
        if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
            // named argument
            return (_b = action.arguments) === null || _b === void 0 ? void 0 : _b.find((arg) => { var _a, _b; return ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) === ((_b = argument.name) === null || _b === void 0 ? void 0 : _b.name); });
        }
        if (argument.index) {
            return action.arguments[argument.index];
        }
        return undefined;
    }
    instantiateActionDeclaration(decl, call) {
        return new apply_1.Apply(this, call, decl);
    }
    /**
     * Instantiate a TypeDeclaration given some typeArgs and a type environment.
     *
     * @param type type declaration to instantiate
     * @param typeArgs known type arguments
     * @param env type environment
     */
    instantiateTypeDeclaration(type, typeArgs, functionArgumentNames, functionName) {
        var _a;
        if (typeArgs === undefined) {
            const cached = this.globalTypeIndex.get(type);
            if (cached !== undefined) {
                return cached;
            }
        }
        let newType = new type_1.Type(this, type, typeArgs, functionArgumentNames, functionName);
        if (newType.isReturnValue()) {
            // compute the intrinsic type alias `ReturnValue<A>`
            // we substitute this type with the type of the value returned by the action or dialog
            const returnValueType = newType.getReturnValueType();
            if ((returnValueType === null || returnValueType === void 0 ? void 0 : returnValueType.isAction()) || (returnValueType === null || returnValueType === void 0 ? void 0 : returnValueType.isDialog())) {
                const returnType = (_a = returnValueType.getPropertyType("returnType")) === null || _a === void 0 ? void 0 : _a.getTypeType();
                if (returnType) {
                    newType = returnType;
                }
            }
        }
        if (typeArgs === undefined) {
            // cache a forward-reference to the constructed type if there are no type arguments
            this.globalTypeIndex.set(type, newType);
        }
        return newType;
    }
    /**
     * Instantiate a type by substituting all type parameters and propagating the types to all super types.
     *
     * @param type type reference to instantiate
     * @param env optional lookup table of known names
     */
    instantiateTypeReference(type, env) {
        var _a, _b, _c, _d, _e;
        if (type === undefined) {
            return undefined;
        }
        if (env === null || env === void 0 ? void 0 : env[(_a = type.name) === null || _a === void 0 ? void 0 : _a.name]) {
            return env === null || env === void 0 ? void 0 : env[(_b = type.name) === null || _b === void 0 ? void 0 : _b.name];
        }
        const typeDecl = this.lookupTypeReference(type);
        if ((typeDecl === null || typeDecl === void 0 ? void 0 : typeDecl.kind) === "TypeParameter") {
            return this.instantiateTypeParameter(typeDecl);
        }
        if (typeDecl !== undefined) {
            let typeArgs;
            if (typeDecl.kind === "TypeDeclaration" || typeDecl.kind === "ActionDeclaration" || typeDecl.kind === "DialogDeclaration") {
                if (typeDecl.genericArguments) {
                    if (type.arguments === undefined || ((_c = type.arguments) === null || _c === void 0 ? void 0 : _c.length) === 0) {
                        typeArgs = typeDecl.genericArguments.map((arg) => {
                            const type = this.getType(arg);
                            if ((type === null || type === void 0 ? void 0 : type.extensions) === undefined || type.extensions.length === 0) {
                                return this.thing;
                            }
                            if (type.extensions.length === 1) {
                                return type.extensions[0];
                            }
                            // TODO: how should we handle a multiple-inheritance lower bound.
                            return this.thing;
                        });
                    }
                    else {
                        typeArgs = (_d = type.arguments) === null || _d === void 0 ? void 0 : _d.map((arg) => this.instantiateTypeReference(arg, env));
                    }
                    // infer the type arguments
                }
            }
            return this.instantiateTypeDeclaration(typeDecl, typeArgs, type.functionArgumentNames, type.functionArgumentNames !== undefined && type.context.kind === "ArgumentDeclaration" ? (_e = type.context.name) === null || _e === void 0 ? void 0 : _e.name : undefined);
        }
        return undefined;
    }
    /**
     * Instantiate a TypeParameter.
     *
     * @param param type parameter.
     */
    instantiateTypeParameter(param) {
        return new type_1.Type(this, param, undefined);
    }
    instantiateAlexaSchemaType(name, ...genericArguments) {
        const decl = this.lookupQualifiedName(name);
        if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "TypeDeclaration") {
            const type = this.instantiateTypeDeclaration(decl, genericArguments.length > 0 ? genericArguments : undefined);
            if (type) {
                return type;
            }
        }
        throw new Error(`could not find alexa schema type: ${name}`);
    }
    /**
     * determine if the a propertyReference is a type used in an event
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * u = utterances<Person>(["Hi {name}"])
     * personInfo = expect(Invoke, u)
     * a = personInfo.name
     * ```
     * `a` is a property reference and it's from the event expr, thus should return true
     *
     */
    isPropertyReferenceFromEvent(value) {
        const rootExpr = this.getPropertyChainRootExpression(value);
        if (this.isNameReference(rootExpr)) {
            const rootExprValue = this.resolveNameReferenceToCall(rootExpr);
            if (rootExprValue !== undefined) {
                const rootExprValueApply = this.getApply(rootExprValue);
                // TODO: don't use hard code once know how to determine the type is from event
                if ((rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isExpect()) || (rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isUserSays())) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * determine if the a propertyReference is refer to api result
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * action Person getPerson()
     * person = getPerson()
     *
     *
     * a = person.name
     * ```
     * `a` is a property reference and it's refer to api result, thus should return true
     *
     */
    isPropertyReferenceFromApiInvocation(value) {
        const rootExpr = this.getPropertyChainRootExpression(value);
        if (this.isNameReference(rootExpr)) {
            const rootExprValue = this.resolveNameReferenceToCall(rootExpr);
            if (rootExprValue !== undefined) {
                const rootExprValueApply = this.getApply(rootExprValue);
                if (rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isUserDefinedApi()) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get all Nodes referenced by a source Node.
     *
     * @param source node to start the search from
     * @returns a set of all Nodes referenced by this
     */
    getReferences(source) {
        const checker = this;
        const references = new Set();
        (0, visit_1.visitEachChild)(source, findReferences);
        return references;
        function findReferences(node) {
            var _a;
            const ref = (node === null || node === void 0 ? void 0 : node.kind) === "Type" ? node.declaration : node;
            if (node === undefined || ref === undefined || references.has(ref)) {
                return;
            }
            references.add(ref);
            if (node.kind === "Call") {
                const apply = checker.getApply(node);
                // findReferences(apply?.decl);
                const decl = (apply === null || apply === void 0 ? void 0 : apply.decl.kind) === "Type" ? apply.decl.declaration : apply === null || apply === void 0 ? void 0 : apply.decl;
                if (decl) {
                    findReferences(decl);
                }
                (0, visit_1.visitEachChild)(node, findReferences);
            }
            else if (node.kind === "NameReference") {
                findReferences(checker.lookupNameReference(node));
            }
            else if (node.kind === "Type") {
                (_a = node.getReferences()) === null || _a === void 0 ? void 0 : _a.forEach((ref) => references.add(ref));
            }
            else {
                (0, visit_1.visitEachChild)(node, findReferences);
            }
            return false;
        }
    }
    /**
     * Get all response call used in a module.
     *
     * @param module module where to retrieve the responses
     * @returns a set of all responses
     */
    getResponseInfosInModule(module) {
        if (module === undefined) {
            return [];
        }
        const checker = this;
        return (0, visit_1.collectArray)(module, findResponses);
        function findResponses(node) {
            if (node === undefined) {
                return [];
            }
            if (node.kind === "Call") {
                const apply = checker.getApply(node);
                if ((apply === null || apply === void 0 ? void 0 : apply.isResponse()) || (apply === null || apply === void 0 ? void 0 : apply.isConfirmAction()) || (apply === null || apply === void 0 ? void 0 : apply.isConfirmArgs()) || (apply === null || apply === void 0 ? void 0 : apply.isEnsure())) {
                    return [...apply.getResponseInfo()];
                }
            }
            return (0, visit_1.collectArray)(node, findResponses);
        }
    }
    /**
     * Find the very beginning expr of property chain
     *
     * ```
     * a.b.c => a
     * a().b.c => a()
     * com.api.a.b.c => com.api.a
     * ```
     */
    getPropertyChainRootExpression(propertyRef) {
        let temp = propertyRef;
        while ((temp === null || temp === void 0 ? void 0 : temp.kind) === "PropertyReference") {
            const fullName = ask.PropertyReference.tryResolveQualifiedName(temp);
            if (fullName !== undefined && this.lookupQualifiedName(fullName) !== undefined) {
                return temp;
            }
            temp = temp.expression;
        }
        return temp;
    }
    /**
     * check whether the node is a nameReference
     *
     * 1. if node is of "NameReference" Type, then it's a nameReference
     * 2. if node is of "PropertyReference", then check whether it's QFN point to a node. E.G. test.getPerson,
     *    "test" is a namespace, thus this should also be treated as nameReference
     */
    isNameReference(node) {
        if (node === undefined) {
            return false;
        }
        if (node.kind === "NameReference") {
            return true;
        }
        if (node.kind === "PropertyReference") {
            const fqn = ask.PropertyReference.tryResolveQualifiedName(node);
            if (this.lookupQualifiedName(fqn) !== undefined) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get all NameDeclarations under module scope
     */
    getAllModuleScopeNameDeclarations() {
        const nameDecls = [];
        this.global.scope.forEach((value) => {
            if (value) {
                if (Array.isArray(value)) {
                    value.forEach((node) => {
                        if (node.kind === "NameDeclaration") {
                            nameDecls.push(node);
                        }
                    });
                }
                else if (value.kind === "NameDeclaration") {
                    nameDecls.push(value);
                }
            }
        });
        return nameDecls;
    }
    /**
     * collect locale info based on input
     *
     * E.G.
     * 1. when input is a nameDecl
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     *
     * collectLocaleInfo(myWelcome) => ['en_US']
     * ```
     *
     * 2. when input is a nameReference
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(temp) => ['en_US']
     * ```
     *
     * 3. when input is a propertyReference
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(test.temp) => ['en_US']
     *
     * 4. when input is variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeEN = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeGB)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB']
     *
     * 5. when input is nested variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeUS = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcomeEN = variations(myWelcomeEN, myWelcomeGB)
     *
     * @locale(Locale.ja_JP)
     * myWelcomeJP = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeJP)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB', 'en_JP']
     */
    collectLocaleInfo(input) {
        var _a, _b, _c, _d, _e, _f, _g;
        const locales = [];
        // handle variations action call
        if (input.kind === "Call") {
            const apply = this.getApply(input);
            if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                const argumentValueThing = apply.getArgumentValueThing("variations");
                if (argumentValueThing === null || argumentValueThing === void 0 ? void 0 : argumentValueThing.isList()) {
                    const items = argumentValueThing.getListItems();
                    items === null || items === void 0 ? void 0 : items.forEach((item) => {
                        var _a, _b;
                        if (((_a = item === null || item === void 0 ? void 0 : item.item) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = item === null || item === void 0 ? void 0 : item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                            locales.push(...this.collectLocaleInfo(item.item));
                        }
                    });
                }
            }
            return locales;
        }
        // handle nameDecl
        if (ask.isNameDeclaration(input)) {
            if (((_a = input.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
                const apply = this.getApply(input.expression);
                if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                    return this.collectLocaleInfo(input.expression);
                }
                else if (((_c = (_b = input.expression) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === "MultiModalResponse") {
                    const apla = apply === null || apply === void 0 ? void 0 : apply.getArgumentValue("apla");
                    const apl = apply === null || apply === void 0 ? void 0 : apply.getArgumentValue("apl");
                    return [...getArgumentValueLocales(apla, this), ...getArgumentValueLocales(apl, this)];
                }
            }
            (_d = input.annotations) === null || _d === void 0 ? void 0 : _d.forEach((annotation) => {
                if (annotation.kind === "Annotation" && annotation.call && annotation.call.kind === "Call") {
                    const apply = this.getApply(annotation.call);
                    if (apply !== undefined && apply.isLocaleAction()) {
                        const localeValueThing = apply.getArgumentValueThing("locales");
                        if (localeValueThing === null || localeValueThing === void 0 ? void 0 : localeValueThing.isList()) {
                            const items = localeValueThing.getListItems();
                            items === null || items === void 0 ? void 0 : items.forEach((item) => {
                                var _a, _b, _c;
                                if (ask.isPropRef(item === null || item === void 0 ? void 0 : item.item) && ((_b = (_a = item === null || item === void 0 ? void 0 : item.item.expression) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === "Locale" && ((_c = item.item.name) === null || _c === void 0 ? void 0 : _c.name)) {
                                    locales.push(item.item.name.name);
                                }
                            });
                        }
                    }
                }
            });
        }
        // handle nameReference and propertyReference
        if (input.kind === "NameReference" || input.kind === "PropertyReference") {
            const thing = this.getThing(input);
            if (ask.isNameDeclaration((_e = thing === null || thing === void 0 ? void 0 : thing.origin) === null || _e === void 0 ? void 0 : _e.context)) {
                return this.collectLocaleInfo((_f = thing === null || thing === void 0 ? void 0 : thing.origin) === null || _f === void 0 ? void 0 : _f.context);
            }
            if (thing === null || thing === void 0 ? void 0 : thing.isObject()) {
                return (_g = thing.getLocales()) !== null && _g !== void 0 ? _g : [];
            }
        }
        return locales;
        function getArgumentValueLocales(value, checker) {
            if ((value && checker.isNameReference(value)) || ask.isNameDeclaration(value)) {
                return checker.collectLocaleInfo(value);
            }
            return [];
        }
    }
}
exports.TypeChecker = TypeChecker;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGVja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXVDO0FBQ3ZDLDJDQUE2QjtBQUU3QixtQ0FBOEI7QUFDOUIsK0JBQWlGO0FBQ2pGLHFDQUErQztBQUMvQyxtREFBd0c7QUFFeEcsaUNBQTZGO0FBRzdGLGlDQUE0QjtBQUM1Qix3R0FBd0c7QUFDeEcsaUNBQStCO0FBQy9CLG1DQUFxRDtBQUVyRCxtQ0FBNkY7QUFDN0YsbUNBQXNDO0FBRXRDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVWOztHQUVHO0FBQ0gsTUFBYSxXQUFXO0lBMER0QjtJQUNFOztPQUVHO0lBQ2EsT0FBZ0I7SUFDaEM7O09BRUc7SUFDYSxJQUFrQjtJQUNsQzs7T0FFRztJQUNILE1BQThDO0lBQzlDOztPQUVHO0lBQ00sS0FBcUQ7Ozs7OzttQkFaOUM7Ozs7OzttQkFJQTs7Ozs7O21CQVFQOztRQXpFWDs7OzttQkFBYyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7V0FBQztRQUV2Qjs7V0FFRztRQUNIOzs7OztXQUF3QjtRQUV4Qjs7Ozs7V0FBdUI7UUFFdkI7Ozs7O1dBQTZCO1FBRTdCOzs7OztXQUFxQjtRQUVyQjs7Ozs7V0FBb0I7UUFFcEI7Ozs7O1dBQTBCO1FBRTFCOzs7OztXQUF1QjtRQUV2Qjs7Ozs7V0FBc0I7UUFFdEI7Ozs7O1dBQXNCO1FBRXRCOzs7OztXQUFpQztRQUVqQzs7OztXQUlHO1FBQ0g7Ozs7O1dBQTREO1FBRTVEOzs7O1dBSUc7UUFDSDs7Ozs7V0FBdUQ7UUFFdkQ7O1dBRUc7UUFDSDs7Ozs7V0FHRTtRQUVGOztXQUVHO1FBQ0g7Ozs7bUJBQTJCLElBQUksR0FBRyxFQUEwQjtXQUFDO1FBRTdEOztXQUVHO1FBQ0g7Ozs7bUJBQTJCLElBQUksR0FBRyxFQUEwQjtXQUFDO1FBMEY3RDs7Ozs7V0FB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