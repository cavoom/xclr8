"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionModelMerger = exports.SlotTypeMerger = exports.SlotTypeValueMerger = exports.IntentSlotMerger = exports.mergeArrays = void 0;
function toMap(items, keySelector) {
    const result = {};
    for (const item of items) {
        result[keySelector(item)] = item;
    }
    return result;
}
function mergeStrings(first, second) {
    return first !== undefined || second !== undefined ? [...new Set([...(first !== null && first !== void 0 ? first : []), ...(second !== null && second !== void 0 ? second : [])]).values()] : undefined;
}
function mergeArrays(first, second, itemMerger) {
    const result = [];
    const firstByName = toMap(first, itemMerger.keySelector);
    const secondByName = toMap(second, itemMerger.keySelector);
    for (const firstItem of first) {
        const secondItem = secondByName[itemMerger.keySelector(firstItem)];
        if (secondItem === undefined) {
            result.push(firstItem);
        }
        else {
            try {
                result.push(itemMerger.merge(firstItem, secondItem));
            }
            catch (e) {
                itemMerger.handleError(firstItem, secondItem, e);
            }
        }
    }
    for (const secondItem of second) {
        const firstItem = firstByName[itemMerger.keySelector(secondItem)];
        if (firstItem === undefined) {
            result.push(secondItem);
        }
    }
    return result;
}
exports.mergeArrays = mergeArrays;
/**
 * Merges intents.
 */
class IntentMerger {
    constructor(intentSlotMerger) {
        Object.defineProperty(this, "intentSlotMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: intentSlotMerger
        });
    }
    keySelector(item) {
        return item.name;
    }
    merge(first, second) {
        var _a, _b;
        const samples = mergeStrings(first.samples, second.samples);
        return {
            ...first,
            slots: mergeArrays((_a = first.slots) !== null && _a !== void 0 ? _a : [], (_b = second.slots) !== null && _b !== void 0 ? _b : [], this.intentSlotMerger),
            ...(samples ? { samples } : {}),
        };
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge intent '${first.name}': ${err.message}`);
    }
}
/**
 * Merges intent slots.
 */
class IntentSlotMerger {
    keySelector(item) {
        return item.name;
    }
    merge(first, second) {
        if (first.type === second.type) {
            const samples = mergeStrings(first.samples, second.samples);
            return {
                ...first,
                ...(samples ? { samples } : {}),
            };
        }
        else {
            throw new Error(`Intent slot type differs: '${first.type}' != '${second.type}'`);
        }
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge intent slot '${first.name}': ${err.message}`);
    }
}
exports.IntentSlotMerger = IntentSlotMerger;
/**
 * Merges slot type values.
 */
class SlotTypeValueMerger {
    keySelector(item) {
        return item.name.value;
    }
    merge(first, second) {
        var _a;
        if (first.id !== second.id) {
            throw new Error(`Slot type value identifier differs: ${first.id} != ${second.id}`);
        }
        const synonyms = (_a = mergeStrings(first.name.synonyms, second.name.synonyms)) !== null && _a !== void 0 ? _a : [];
        return {
            ...first,
            name: {
                ...first.name,
                ...(synonyms ? { synonyms } : {}),
            },
        };
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge slot type value '${first.name.value}': ${err.message}`);
    }
}
exports.SlotTypeValueMerger = SlotTypeValueMerger;
/**
 * Merges slot types.
 */
class SlotTypeMerger {
    constructor(slotTypeValueMerger) {
        Object.defineProperty(this, "slotTypeValueMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: slotTypeValueMerger
        });
    }
    keySelector(item) {
        return item.name;
    }
    merge(first, second) {
        var _a, _b;
        if (!first.valueSupplier && !second.valueSupplier) {
            return {
                ...first,
                values: mergeArrays((_a = first.values) !== null && _a !== void 0 ? _a : [], (_b = second.values) !== null && _b !== void 0 ? _b : [], this.slotTypeValueMerger),
            };
        }
        else {
            throw new Error(`Slot type already exists with different value supplier.`);
        }
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge slot type '${first.name}': ${err.message}`);
    }
}
exports.SlotTypeMerger = SlotTypeMerger;
Object.defineProperty(SlotTypeMerger, "INSTANCE", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new SlotTypeMerger(new SlotTypeValueMerger())
});
/**
 * Merges two interaction models into one (the second one into the first one).
 *
 * Takes all fields from the first interaction model, except for these which are combined together
 * - `intents`
 *   - `slots` - fails if they differ in `type`
 *     - `samples` - union of both samples
 *   - `samples` - union of both samples
 * - `types` - fails if they differ in `valueSupplier`
 *   - `values` - fails if they differ in `id`
 *     - `synonyms` - union of both synonyms
 *
 * ~~~
 * {
 *   interactionModel: {
 *     languageModel: {
 *       intents: [
 *         {
 *           name: 'intentName',
 *           slots: [
 *             {
 *               name: 'slotName',
 *               samples: [...]
 *             }
 *           ]
 *           samples: [...]
 *         }, ...
 *       ]
 *       types: [
 *         {
 *           name: 'typeName'
 *           values: [
 *             {
 *               name: {
 *                 value: 'valueName',
 *                 synonyms: [...]
 *               }
 *             }
 *           ]
 *         }, ...
 *       ]
 *     }
 *   }
 * }
 * ~~~
 *
 * Intents are merged from both models. If same intent is defined in both models, their slots and samples are merged.
 * If the intent slot types do not match, an error will be raised.
 *
 * Slot types are merged from both models. If same slot type is defined in both models, an error will be raised.
 *
 * Note: The code should be written in a way that when new fields are added, they are preserved.
 */
class InteractionModelMerger {
    constructor(intentMerger, slotTypeMerger) {
        Object.defineProperty(this, "intentMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: intentMerger
        });
        Object.defineProperty(this, "slotTypeMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: slotTypeMerger
        });
    }
    /**
     * Merges two interaction models into one (the second one into the first one).
     *
     * @param first First interaction model data.
     * @param second Second interaction model data.
     * @returns The merged interaction model.
     */
    mergeInteractionModels(first, second) {
        return {
            ...first,
            interactionModel: this.mergeInteractionModelSchemas(first.interactionModel, second.interactionModel),
        };
    }
    mergeInteractionModelSchemas(first, second) {
        return {
            ...first,
            languageModel: this.mergeLanguageModels(first.languageModel, second.languageModel),
        };
    }
    mergeLanguageModels(first, second) {
        var _a, _b;
        const types = first.types !== undefined || second.types !== undefined
            ? mergeArrays((_a = first.types) !== null && _a !== void 0 ? _a : [], (_b = second.types) !== null && _b !== void 0 ? _b : [], this.slotTypeMerger)
            : undefined;
        return {
            ...first,
            intents: mergeArrays(first.intents, second.intents, this.intentMerger),
            ...(types ? { types } : {}),
        };
    }
}
exports.InteractionModelMerger = InteractionModelMerger;
Object.defineProperty(InteractionModelMerger, "INSTANCE", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new InteractionModelMerger(new IntentMerger(new IntentSlotMerger()), SlotTypeMerger.INSTANCE)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJhY3Rpb24tbW9kZWwtbWVyZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVyYWN0aW9uLW1vZGVsLW1lcmdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxTQUFTLEtBQUssQ0FBSSxLQUFVLEVBQUUsV0FBZ0M7SUFDNUQsTUFBTSxNQUFNLEdBQXNCLEVBQUUsQ0FBQztJQUVyQyxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtRQUN4QixNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQ2xDO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEtBQTJCLEVBQUUsTUFBNEI7SUFDN0UsT0FBTyxLQUFLLEtBQUssU0FBUyxJQUFJLE1BQU0sS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLGFBQUwsS0FBSyxjQUFMLEtBQUssR0FBSSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUNoSSxDQUFDO0FBUUQsU0FBZ0IsV0FBVyxDQUFJLEtBQVUsRUFBRSxNQUFXLEVBQUUsVUFBeUI7SUFDL0UsTUFBTSxNQUFNLEdBQVEsRUFBRSxDQUFDO0lBQ3ZCLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRTNELEtBQUssTUFBTSxTQUFTLElBQUksS0FBSyxFQUFFO1FBQzdCLE1BQU0sVUFB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