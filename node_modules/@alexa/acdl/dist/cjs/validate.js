"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateGetAllNamesAction = exports.validateCorrection = exports.validateInteractionDeclaration = exports.validateBuiltinCatalogAction = exports.validateCatalogCallContext = exports.validateEnsureArgOrder = exports.validateConditionBlock = exports.validateCondition = exports.validateUtterance = exports.validateBinaryOperator = exports.validateNamedArguments = exports.validateRequireCall = exports.validateValidateArgAnnotation = exports.validateCallContext = exports.validateVariations = exports.validateUtteranceString = exports.validateCall = exports.validateUtteranceTypeWrapper = exports.validatePropertyReference = exports.validateTypeReference = exports.validateTypeReferences = exports.validateTypeParameter = exports.validateTypeParameters = exports.validateTypeDeclarationProperties = exports.validateTypeDeclaration = exports.validateEnumDeclaration = exports.validateArgumentDeclaration = exports.validateArgumentDeclarations = exports.validateAnnotatedActionDeclaration = exports.validateActionDeclaration = exports.validateName = exports.validateNameReference = exports.validateNameDeclaration = exports.validateDuplicateNames = exports.validateSample = exports.validateDialogDeclaration = exports.validateExpression = exports.validateAnnotation = exports.validateDialogDeclarationAnnotations = exports.validateTypeDeclarationAnnotations = exports.validateNameDeclarationAnnotations = exports.validateAnnotations = exports.validateCircularReferences = exports.validateImports = exports.validateNamespace = exports.validateBlock = exports.validateModule = exports.validateProject = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const ask = __importStar(require("./ast"));
const error_1 = require("./error");
const ast_1 = require("./ast");
const util_1 = require("./util");
const constants_1 = require("./constants");
const evaluate_1 = require("./evaluate");
const flow_1 = require("./flow");
const validate_skill_1 = require("./validate-skill");
const evaluation_state_1 = require("./evaluation-state");
const visit_1 = require("./visit");
const error_factory_1 = require("./error-factory");
const property_node_1 = require("./property-node");
const lazy_1 = require("./lazy");
const get_all_names_1 = require("./get-all-names");
/**
 * Validate the entire project for correctness and return and errors.
 *
 * @param project project to validate.
 * @param isSkill whether the project is a skill
 * @param skipSemanticValidations skip semantic validations
 * @returns array of all errors if detected.
 */
function validateProject(project, isSkill, skipSemanticValidations) {
    var _a, _b, _c;
    const checker = project.getTypeChecker();
    const errors = [];
    const skills = checker.project.findSkills();
    errors.push(...project.sourceModules.flatMap((srcModule) => {
        var _a;
        return [
            // syntax errors from module errors
            ...((_a = srcModule.errors) !== null && _a !== void 0 ? _a : []),
            // syntax errors from validateRootExpressions
            ...(srcModule.content ? validateRootExpressions(srcModule.content, checker) : []),
            // semantic errors from validateModule
            ...(srcModule.content && !skipSemanticValidations ? (0, exports.validateModule)(srcModule.content, checker) : []),
        ];
    }));
    if (skipSemanticValidations) {
        return errors;
    }
    errors.push(...(0, evaluate_1.validateGlobalWelcome)(project, checker));
    // now that type checking has passed, let's pass over the AST and create a tree with all types resolved.
    // project = resolveProject(project);
    // checker = project.getTypeChecker();
    const isParsingSkill = isSkill !== null && isSkill !== void 0 ? isSkill : (project.isSkill() || skills.length > 0);
    if (!isParsingSkill) {
        // if we're not parsing a skill, then we should treat all dialogs as deployable
        // FIXME: this logic is wrong, we should validateDialogFlow of all dialogs and handle cases where the dialog "could be called"
        // e.g don't error when there is no prior expect event for a dialog that may be called.
        // This can be improved as part of our re-usability QA drive.
        (_a = checker.project
            .getRootDialogs()) === null || _a === void 0 ? void 0 : _a.forEach((dialog) => errors.push(...(0, evaluate_1.evaluateDialogFlow)(new flow_1.Flow(checker, dialog, undefined, []), new evaluation_state_1.EvaluationState(undefined))));
    }
    else {
        if (skills.length > 1) {
            errors.push(...skills.map((skill) => {
                var _a;
                return error_factory_1.ValidationErrorFactory.TooManySkillDeclarations({
                    expr: (0, error_factory_1.getExpressionIfLocField)((_a = skill.declaration) === null || _a === void 0 ? void 0 : _a.name, skill.declaration, skill.apply.call),
                    attributes: {
                        skillNames: skills
                            .filter((s) => s !== skill)
                            .map((s) => { var _a; return (s.declaration ? `'${(_a = s.declaration.name) === null || _a === void 0 ? void 0 : _a.name}'` : "anonymous"); })
                            .join(", "),
                    },
                });
            }));
        }
        if (project.config.skill === undefined) {
            // no `package.json` or `ask.json` configuration, attempt to derive it from the context
            if (skills.length === 0) {
                // this skill contains no `skill()` declarations, so look for deployable dialogs and global `response/prompts` responses.
                errors.push(...validateDeployableDialogs(checker));
                errors.push(...(0, evaluate_1.validateSkillLevelResponses)(project));
                (_b = checker.project
                    .getRootDialogs()) === null || _b === void 0 ? void 0 : _b.forEach((dialog) => errors.push(...(0, evaluate_1.evaluateDialogFlow)(new flow_1.Flow(checker, dialog, undefined, []), new evaluation_state_1.EvaluationState(undefined))));
            }
            else {
                // skill declarations exist, validate each one.
                skills.forEach((skill) => errors.push(...(0, validate_skill_1.validateSkill)(skill.apply, checker)));
            }
        }
        else {
            // the skill is configured in `package.json` or `ask.json`, let's validate it.
            const skill = checker.lookupQualifiedName(project.config.skill);
            if (skill === undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.SkillNotFound({
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
            else if (skill.kind === "NameDeclaration" && ((_c = skill.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
                const apply = checker.getApply(skill.expression);
                if (apply) {
                    if (apply.isSkillAction()) {
                        errors.push(...(0, validate_skill_1.validateSkill)(apply, checker));
                    }
                    else {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidSkillExpression({
                            expr: skill,
                            attributes: {
                                skillName: project.config.skill,
                            },
                        }));
                    }
                }
            }
            else {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidSkillExpression({
                    expr: skill,
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
        }
    }
    return (0, error_1.sortErrors)((0, error_1.filterDuplicateErrors)(errors));
}
exports.validateProject = validateProject;
/**
 * validate the skill has deployable dialog
 * This function should be used when there's no skill action call
 */
function validateDeployableDialogs(checker) {
    const deployableDialogs = checker.project.getRootDialogs();
    if (deployableDialogs === undefined || deployableDialogs.length === 0) {
        return [error_factory_1.ValidationErrorFactory.NoDeployableDialog()];
    }
    return [];
}
/**
 * Validate all expressions in a module in the context of a Project.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
const validateModule = (module, checker) => [
    ...(0, exports.validateImports)(module, checker),
    ...(0, exports.validateNamespace)(module, checker),
    ...(0, exports.validateBlock)(module, checker),
];
exports.validateModule = validateModule;
/**
 * Returns errors for root expressions (expressions directly at the module level) that are not allowed in the ASKIR schema
 * @param module module we are validating
 * @param checker unused
 * @returns errors for root expressions that are not allowed in the ASKIR schema
 */
const validateRootExpressions = (module, checker) => {
    var _a, _b;
    const errors = [];
    // As seen on https://github.com/alexa/ask-expressions/blob/9a88ebd49ea69dd49ecd2952d2cd6682d41d6b85/packages/%40alexa/ask-expressions-spec/schemas/Module.json#L37
    const validRootExpressions = new Set([
        "ActionDeclaration",
        "DialogDeclaration",
        "InteractionDeclaration",
        "EnumDeclaration",
        "NameDeclaration",
        "TypeDeclaration",
        "Call",
    ]);
    for (const expression of module.expressions || []) {
        if (!validRootExpressions.has(expression.kind)) {
            errors.push(error_factory_1.ValidationErrorFactory.DeclarationExpected({
                expr: expression,
                attributes: {
                    text: expression.kind === "InteractionDeclaration" ? "" : ((_a = expression.name) === null || _a === void 0 ? void 0 : _a.name) || "",
                },
            }));
        }
        if (expression.kind === "Call") {
            const apply = checker.getApply(expression);
            if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidDialogCall({
                    expr: expression,
                    attributes: {
                        dialogName: (_b = apply.getName()) !== null && _b !== void 0 ? _b : "",
                    },
                }));
            }
        }
    }
    return errors;
};
const validateBlock = (scope, checker) => {
    var _a;
    return [
        ...(0, exports.validateDuplicateNames)(scope, checker),
        ...((_a = scope.expressions) !== null && _a !== void 0 ? _a : []).map((expr) => (0, exports.validateExpression)(expr, checker)).reduce((a, b) => a.concat(b), []),
    ];
};
exports.validateBlock = validateBlock;
const validateNamespace = (module, checker) => {
    var _a;
    const nameSpace = (_a = module.namespace) === null || _a === void 0 ? void 0 : _a.name;
    // make sure the namespace doesn't contain reserved prefix
    const errors = [];
    if (nameSpace !== undefined) {
        constants_1.Constants.RESERVED_PREFIXES.forEach((prefix) => {
            if (nameSpace.startsWith(prefix)) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidNamespace({
                    expr: module.namespace,
                    attributes: {
                        prefix,
                    },
                }));
            }
        });
    }
    return errors;
};
exports.validateNamespace = validateNamespace;
/**
 * Validate the imports in a module.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
const validateImports = (module, checker) => {
    var _a;
    return ((_a = module.imports) === null || _a === void 0 ? void 0 : _a.map((imprt) => {
        if (imprt.kind === "ImportName") {
            if (checker.lookupQualifiedName(imprt.name) === undefined) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidImport({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        else {
            const namespace = checker.listNamespace(imprt.name);
            if (namespace === undefined) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidImportNamespace({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        return [];
    }).reduce((a, b) => a.concat(b), [])) || [];
};
exports.validateImports = validateImports;
const validateCircularReferences = (source, checker) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (source.kind === "TypeReference" || source.kind === "TypeDeclaration") {
        const type = source.kind === "TypeReference" ? checker.getType(source) : (_a = checker.getType(source)) === null || _a === void 0 ? void 0 : _a.getTypeType();
        if (type !== undefined) {
            if ((type === null || type === void 0 ? void 0 : type.properties) && type.declaration) {
                for (const prop of type.properties) {
                    if (prop.type === undefined || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()) || ((_c = prop.type) === null || _c === void 0 ? void 0 : _c.isList()) || prop.type.isNothing()) {
                        continue;
                    }
                    else if (prop.type.extends(type) || prop.type.getReferences().has(type.declaration)) {
                        return [
                            error_factory_1.ValidationErrorFactory.CircularReferenceType({
                                expr: source.name,
                                attributes: {
                                    typeName: (_d = type.toString(source)) !== null && _d !== void 0 ? _d : source.name,
                                },
                            }),
                        ];
                    }
                }
            }
        }
    }
    else if ((_e = checker.getReferences(source)) === null || _e === void 0 ? void 0 : _e.has(source)) {
        const expr = source.name;
        return [
            source.kind === "DialogDeclaration"
                ? error_factory_1.ValidationErrorFactory.CircularReferenceDialog({
                    expr,
                    attributes: {
                        dialogName: (_f = source.name) === null || _f === void 0 ? void 0 : _f.name,
                    },
                })
                : error_factory_1.ValidationErrorFactory.CircularReferenceName({
                    expr,
                    attributes: {
                        name: (_g = source.name) === null || _g === void 0 ? void 0 : _g.name,
                    },
                }),
        ];
    }
    return [];
};
exports.validateCircularReferences = validateCircularReferences;
/**
 * Validates all annotations on a node.
 */
const validateAnnotations = (node, checker) => {
    var _a, _b;
    return [
        ...(0, exports.validateNameDeclarationAnnotations)(node, checker),
        ...(0, exports.validateTypeDeclarationAnnotations)(node, checker),
        ...(0, exports.validateDialogDeclarationAnnotations)(node, checker),
        ...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.flatMap((ann) => (0, exports.validateAnnotation)(ann, checker))) !== null && _b !== void 0 ? _b : []),
    ];
};
exports.validateAnnotations = validateAnnotations;
/**
 * Validates annotations on name declarations.
 *
 * There are two cases:
 *
 * 1. When the value is a `NameReference`, we should not allow any annotations.
 * 2. When the value is a `variations` call, we should not allow `locale` annotations.
 */
const validateNameDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (!ask.isNameDeclaration(node)) {
        return errors;
    }
    if (ask.isNameReference(node.expression)) {
        errors.push(...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.map((ann) => error_factory_1.ValidationErrorFactory.InvalidAnnotationNameDeclarationNameReference({
            expr: ann,
        }))) !== null && _b !== void 0 ? _b : []));
    }
    if (((_c = node.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
        const apply = checker.getApply(node.expression);
        if ((apply === null || apply === void 0 ? void 0 : apply.isVariations()) && (node === null || node === void 0 ? void 0 : node.annotations)) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationNameDeclarationVariations({
                            expr: ann,
                        }));
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateNameDeclarationAnnotations = validateNameDeclarationAnnotations;
/**
 * Validates annotations on type declarations, and the properties of the type.
 *
 * There is one case:
 *
 * 1. We should not allow `referable` annotation on type properties that aren't catalogs.
 */
const validateTypeDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const errors = [];
    if (!ask.isTypeDeclaration(node)) {
        return errors;
    }
    for (const property of (_a = node.properties) !== null && _a !== void 0 ? _a : []) {
        for (const ann of (_b = property.annotations) !== null && _b !== void 0 ? _b : []) {
            const apply = checker.getApply(ann.call);
            if (apply === null || apply === void 0 ? void 0 : apply.isReferableAction()) {
                const type = checker.getType(property.type);
                if (!(type === null || type === void 0 ? void 0 : type.hasCatalog())) {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidReferableAnnotation({
                        expr: ann,
                        attributes: {
                            typeName: (_c = node.name) === null || _c === void 0 ? void 0 : _c.name,
                            propertyName: (_d = property.name) === null || _d === void 0 ? void 0 : _d.name,
                        },
                    }));
                }
            }
        }
    }
    for (const ann of (_e = node === null || node === void 0 ? void 0 : node.annotations) !== null && _e !== void 0 ? _e : []) {
        const annApply = checker.getApply(ann.call);
        if (annApply === null || annApply === void 0 ? void 0 : annApply.isCatalogAction()) {
            const catalog = annApply.getArgumentValue("catalog");
            const catalogType = (_g = (_f = checker.getType(catalog)) === null || _f === void 0 ? void 0 : _f.genericArguments) === null || _g === void 0 ? void 0 : _g[0];
            const declType = (_j = (_h = checker.getType(node)) === null || _h === void 0 ? void 0 : _h.genericArguments) === null || _j === void 0 ? void 0 : _j[0];
            if (!(declType === null || declType === void 0 ? void 0 : declType.extends(catalogType))) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidCatalogSubType({
                    expr: ann,
                    attributes: {
                        typeName: (_k = node.name) === null || _k === void 0 ? void 0 : _k.name,
                        catalogName: (_l = catalog === null || catalog === void 0 ? void 0 : catalog.name) === null || _l === void 0 ? void 0 : _l.name,
                    },
                }));
            }
        }
    }
    return errors;
};
exports.validateTypeDeclarationAnnotations = validateTypeDeclarationAnnotations;
/**
 * Validates annotations on dialog declarations.
 *
 * There are two cases:
 *
 * 1. When dialog is reusable, we should not allow the dialog to have a `locale` annotation.
 * 2. When dialog is reusable, we should not allow the dialog samples to have a `locale` annotation.
 */
const validateDialogDeclarationAnnotations = (node, checker) => {
    var _a;
    const errors = [];
    if (!ask.isDialogDeclaration(node)) {
        return errors;
    }
    // locale annotation is not allowed on reusable dialog
    if (!checker.project.isRootDialog(node)) {
        if (node.annotations && node.annotations.length > 0) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationReusableDialog({
                            expr: ann,
                        }));
                    }
                }
            }
        }
        // locale annotation is not allowed on reusable dialogs' samples
        (_a = node.samples) === null || _a === void 0 ? void 0 : _a.forEach((sample) => {
            if (sample.annotations && sample.annotations.length > 0) {
                for (const ann of sample === null || sample === void 0 ? void 0 : sample.annotations) {
                    if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                        const annApply = checker.getApply(ann.call);
                        if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                            errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationReusableDialogSample({
                                expr: ann,
                            }));
                        }
                    }
                }
            }
        });
        if (errors.length > 0)
            return errors;
    }
    return errors;
};
exports.validateDialogDeclarationAnnotations = validateDialogDeclarationAnnotations;
/**
 * Validate an Annotation's Call data structure:
 *
 * 1. the annotation type must also be annotated with the meta-annotation `@com.amazon.alexa.ask.conversations.Annotation`.
 * 2. the list of supported targets for the annotation must include the target this annotation is being applied to,
 */
const validateAnnotation = (annotation, checker) => {
    var _a, _b, _c;
    const errors = (0, exports.validateCall)(annotation.call, checker);
    const annotationTarget = ast_1.AnnotationTarget.from(annotation.context.kind);
    const target = checker.getApply(annotation.call);
    const decl = (target === null || target === void 0 ? void 0 : target.decl.kind) === "Type" ? target.decl.declaration : target === null || target === void 0 ? void 0 : target.decl;
    if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration") {
        const annotationDescription = (_a = decl.annotations) === null || _a === void 0 ? void 0 : _a.map((a) => checker.getApply(a.call)).find((a) => a === null || a === void 0 ? void 0 : a.isAnnotationAction());
        if (annotationDescription) {
            const allowMultiple = annotationDescription.getAnnotationAllowMultiple();
            if (allowMultiple === false) {
                const duplicates = (_b = annotation.context.annotations) === null || _b === void 0 ? void 0 : _b.filter((an) => { var _a, _b, _c, _d; return ((_c = (_b = (_a = checker.getApply(an.call)) === null || _a === void 0 ? void 0 : _a.decl) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === ((_d = decl.name) === null || _d === void 0 ? void 0 : _d.name); });
                if (duplicates && duplicates.length > 1) {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationMultiple({
                        expr: annotation,
                        attributes: {
                            annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        },
                    }));
                }
            }
            const targets = annotationDescription.getAnnotationTargets();
            if ((targets === null || targets === void 0 ? void 0 : targets.find((a) => a === annotationTarget)) === undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationTarget({
                    expr: annotation,
                    attributes: {
                        annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        annotationTarget,
                        expectedAnnotationTargets: (_c = targets === null || targets === void 0 ? void 0 : targets.map((t) => `'AnnotationTarget.${t}'`).join(", ")) !== null && _c !== void 0 ? _c : "",
                    },
                }));
            }
        }
        else {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationMetaAnnotation({
                expr: annotation,
                attributes: {
                    annotationType: target === null || target === void 0 ? void 0 : target.getName(),
                },
            }));
        }
    }
    return errors;
};
exports.validateAnnotation = validateAnnotation;
const validateExpression = (expr, checker) => {
    if (expr === undefined) {
        return [];
    }
    if (expr.kind === "Module") {
        // return validateModule(expr, checker);
    }
    else if (expr.kind === "InteractionDeclaration") {
        return (0, exports.validateInteractionDeclaration)(expr, checker);
    }
    else if (expr.kind === "Correction") {
        return (0, exports.validateCorrection)(expr, checker);
    }
    else if (expr.kind === "ActionDeclaration") {
        return (0, exports.validateActionDeclaration)(expr, checker);
    }
    else if (expr.kind === "Argument") {
        return (0, exports.validateExpression)(expr.value, checker);
    }
    else if (expr.kind === "Call") {
        return (0, exports.validateCall)(expr, checker);
    }
    else if (expr.kind === "Condition") {
        return (0, exports.validateCondition)(expr, checker);
    }
    else if (expr.kind === "DialogDeclaration") {
        return (0, exports.validateDialogDeclaration)(expr, checker);
    }
    else if (expr.kind === "EnumDeclaration") {
        return (0, exports.validateEnumDeclaration)(expr, checker);
    }
    else if (expr.kind === "NameDeclaration") {
        return (0, exports.validateNameDeclaration)(expr, checker);
    }
    else if (expr.kind === "NameReference") {
        return (0, exports.validateNameReference)(expr, checker);
    }
    else if (expr.kind === "Sample") {
        return (0, exports.validateSample)(expr, checker);
    }
    else if (expr.kind === "TypeDeclaration") {
        return (0, exports.validateTypeDeclaration)(expr, checker);
    }
    else if (expr.kind === "Block") {
        return (0, exports.validateBlock)(expr, checker);
    }
    else if (expr.kind === "PropertyReference") {
        return (0, exports.validatePropertyReference)(expr, checker);
    }
    else if (expr.kind === "When") {
        return (0, exports.validateExpression)(expr.expression, checker);
    }
    console.warn(`can not validate expression kind '${expr.kind}'`);
    return [];
};
exports.validateExpression = validateExpression;
const validateDialogDeclaration = (dialog, checker) => {
    var _a, _b, _c;
    return [
        ...(dialog.samples === undefined || dialog.samples.length === 0
            ? [
                error_factory_1.ValidationErrorFactory.EmptyDialog({
                    expr: dialog,
                    attributes: {
                        dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ]
            : []),
        ...(0, exports.validateTypeReference)(dialog.returnType, checker),
        ...(0, exports.validateTypeParameters)(dialog.genericArguments, checker),
        ...(dialog.arguments ? validateArgumentDeclarations(dialog.arguments, checker, true) : []),
        ...(0, exports.validateAnnotations)(dialog, checker),
        ...((_c = (_b = dialog.samples) === null || _b === void 0 ? void 0 : _b.map((sample) => (0, exports.validateSample)(sample, checker)).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : []),
        ...(0, exports.validateCircularReferences)(dialog, checker),
    ];
};
exports.validateDialogDeclaration = validateDialogDeclaration;
const validateSample = (sample, checker) => {
    var _a, _b;
    if (sample.scope === undefined) {
        return [];
    }
    const dialog = sample.context;
    const errors = [...(0, exports.validateBlock)(sample.scope, checker), ...(0, exports.validateAnnotations)(sample, checker)];
    if (errors.length > 0) {
        return errors; // return if basic parse errors exist for each sample, before checking from entire sample scope
    }
    if (sample.scope.expressions === undefined || sample.scope.expressions.length === 0) {
        errors.push(error_factory_1.ValidationErrorFactory.EmptySample({
            expr: sample,
            attributes: {
                dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
            },
        }));
    }
    const expectedType = checker.getType(dialog.returnType) || checker.void;
    const actualType = checker.getType(sample.scope) || checker.void;
    if (!expectedType.isVoid() && !expectedType.isNothing() && !actualType.extends(expectedType)) {
        const last = sample.scope.expressions[sample.scope.expressions.length - 1];
        if (last) {
            errors.push(error_factory_1.ValidationErrorFactory.TypeErrorDialogLastExpr({
                expr: last,
                attributes: {
                    dialogName: (_b = dialog.name) === null || _b === void 0 ? void 0 : _b.name,
                    expectedType: expectedType.toString(sample),
                    actualType: actualType.toString(sample),
                },
            }));
        }
    }
    return errors;
};
exports.validateSample = validateSample;
function hasName(expr) {
    var _a;
    return ((expr.kind === "NameDeclaration" ||
        expr.kind === "TypeDeclaration" ||
        expr.kind === "ActionDeclaration" ||
        expr.kind === "DialogDeclaration") &&
        ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined);
}
const validateDuplicateNames = (scope, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (scope.kind === "Module") {
        const moduleUri = checker.getUri(scope);
        (_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.forEach((expr) => {
            var _a;
            if (expr.kind !== "InteractionDeclaration" && ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                const declarations = checker.global.scope.get(expr.name.name);
                if (Array.isArray(declarations)) {
                    const files = Array.from(new Set(declarations
                        .map((d) => checker.getUri(d))
                        .filter((uri) => uri !== undefined && uri !== moduleUri)
                        .map((uri) => path_1.default.relative(checker.project.config.rootDir, uri))
                        .map((uri) => `'${(0, util_1.trimScheme)(uri)}'`)));
                    errors.push(error_factory_1.ValidationErrorFactory.DuplicateNameDeclarationInModule({
                        expr,
                        attributes: {
                            name: expr.name.name,
                            filesLength: files.length,
                            fileNames: files.join(", "),
                        },
                    }));
                }
            }
        });
    }
    else {
        const seen = new Set();
        const duplicates = new Set();
        const parentScope = checker.getVisibleNames(scope.context, false);
        (_b = scope.expressions) === null || _b === void 0 ? void 0 : _b.forEach((expr) => {
            if (hasName(expr)) {
                const name = expr.name.name;
                if (seen.has(name) || (parentScope === null || parentScope === void 0 ? void 0 : parentScope.has(name)) || checker.global.scope.has(name)) {
                    duplicates.add(name);
                }
                seen.add(name);
            }
        });
        (_c = scope.expressions) === null || _c === void 0 ? void 0 : _c.forEach((expr) => {
            var _a;
            if (hasName(expr) && duplicates.has((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                errors.push(error_factory_1.ValidationErrorFactory.DuplicateNameDeclaration({
                    expr: expr.name,
                    attributes: {
                        name: expr.name.name,
                    },
                }));
            }
        });
    }
    return errors;
};
exports.validateDuplicateNames = validateDuplicateNames;
/**
 * Validates a name expression.
 *
 * @param checker
 * @param name
 */
const validateNameDeclaration = (name, checker) => {
    var _a;
    const errors = name.expression ? [...(0, exports.validateExpression)(name.expression, checker)] : [];
    errors.push(...(0, exports.validateCircularReferences)(name, checker));
    errors.push(...(0, exports.validateAnnotations)(name, checker));
    const valueType = checker.getType(name.expression);
    const explicitType = name.type ? checker.instantiateTypeReference(name.type) : undefined;
    if (name.type !== undefined) {
        errors.push(...(0, exports.validateTypeReference)(name.type, checker));
    }
    if (explicitType !== undefined && valueType !== undefined) {
        if (!valueType.extends(explicitType)) {
            errors.push((0, error_1.typeError)(valueType, explicitType, name, name.name));
        }
    }
    if (valueType === undefined) {
    }
    // declare a name with an expression of type Nothing is invalid
    const nameType = checker.getType(name.expression);
    if ((nameType === null || nameType === void 0 ? void 0 : nameType.isNothing()) || (nameType === null || nameType === void 0 ? void 0 : nameType.isVoid())) {
        errors.push(error_factory_1.ValidationErrorFactory.InvalidNameDeclaration({
            expr: name.name,
            attributes: {
                name: (_a = name.name) === null || _a === void 0 ? void 0 : _a.name,
                nothingTypeName: checker.nothing.toString(name),
                voidTypeName: checker.void.toString(name),
            },
        }));
    }
    return errors;
};
exports.validateNameDeclaration = validateNameDeclaration;
const validateNameReference = (id, checker) => [...(0, exports.validateName)(id, checker)];
exports.validateNameReference = validateNameReference;
const validateName = (id, checker) => {
    var _a;
    const found = lookupName(id, id.name);
    if (found === undefined) {
        // For Call, it's valid when name is undefined, like listLiteral
        if (id.name !== undefined && id.kind !== "Call") {
            return [(0, error_1.nameNotFound)(id.name, id.loc, id)];
        }
    }
    else if (Array.isArray(found)) {
        const declares = found
            .map((f) => {
            if (f.kind === "ResponseTemplate") {
                return f.type === ask.ResponseTemplateType.Prompt ? `'prompts.${f.name}'` : `'displays.${f.name}'`;
            }
            return `'${f.name.name}'`;
        })
            .filter((f) => f !== undefined)
            .join(", ");
        return [
            error_factory_1.ValidationErrorFactory.AmbiguousNameReference({
                expr: id,
                attributes: {
                    name: (_a = id.name) === null || _a === void 0 ? void 0 : _a.name,
                    possibleName: declares,
                },
            }),
        ];
    }
    return [];
    function lookupName(scope, name) {
        if (name === undefined) {
            return undefined;
        }
        const nameStr = typeof name === "string" ? name : name.name;
        if (checker.global.scope.has(nameStr)) {
            return checker.global.scope.get(nameStr);
        }
        const lexicalScope = checker.getVisibleNames(scope);
        if (lexicalScope === null || lexicalScope === void 0 ? void 0 : lexicalScope.has(nameStr)) {
            return lexicalScope.get(nameStr);
        }
        return undefined;
    }
};
exports.validateName = validateName;
const validateActionDeclaration = (action, checker) => [
    ...(0, exports.validateTypeReference)(action.returnType, checker),
    ...(0, exports.validateTypeParameters)(action.genericArguments, checker),
    ...(action.arguments ? validateArgumentDeclarations(action.arguments, checker, false) : []),
    ...(0, exports.validateAnnotations)(action, checker),
    ...(0, exports.validateAnnotatedActionDeclaration)(action, checker),
];
exports.validateActionDeclaration = validateActionDeclaration;
/**
 * Validates that an ActionDeclaration that is annotated with the `@annotation` meta-annotation has a return type of void.
 */
const validateAnnotatedActionDeclaration = (action, checker) => {
    var _a, _b, _c;
    if (((_a = action.annotations) === null || _a === void 0 ? void 0 : _a.find((a) => checker.qualifyName(action, a.call.name) === ast_1.AlexaConversations.annotation)) !== undefined) {
        const actionDeclType = checker.getType(action);
        if ((actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.isAction()) && ((_b = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _b === void 0 ? void 0 : _b.getTypeType())) {
            const returnType = (_c = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _c === void 0 ? void 0 : _c.getTypeType();
            if (returnType && !(returnType.isVoid() || returnType.isNothing())) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidAnnotationMetaAnnotationReturnType({
                        expr: action.name,
                    }),
                ];
            }
        }
    }
    return [];
};
exports.validateAnnotatedActionDeclaration = validateAnnotatedActionDeclaration;
function validateArgumentDeclarations(args, checker, isDialogArgument) {
    var _a, _b, _c, _d, _e;
    const seen = new Set();
    const duplicates = new Set();
    const errors = [];
    let isRequiredArgAllowed = true;
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (seen.has(arg.name.name)) {
                duplicates.add(arg.name.name);
            }
            seen.add((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name);
        }
        const hasMoreArgs = args[i + 1] !== undefined;
        const type = checker.instantiateTypeReference(arg.type);
        if ((type === null || type === void 0 ? void 0 : type.isArgs()) && hasMoreArgs) {
            errors.push(error_factory_1.ValidationErrorFactory.VarArgsMustBeLast({
                expr: arg,
            }));
        }
        if (type === null || type === void 0 ? void 0 : type.isOptional()) {
            isRequiredArgAllowed = false;
        }
        else if (!(type === null || type === void 0 ? void 0 : type.isArgs()) && !isRequiredArgAllowed) {
            errors.push(error_factory_1.ValidationErrorFactory.RequiredArgExistAfterOptionalArg({
                expr: arg,
                attributes: {
                    argumentName: (_c = arg.name) === null || _c === void 0 ? void 0 : _c.name,
                },
            }));
        }
        errors.push(...validateArgumentDeclaration(arg, checker, isDialogArgument));
    }
    for (const arg of args) {
        if (((_d = arg.name) === null || _d === void 0 ? void 0 : _d.name) && duplicates.has((_e = arg.name) === null || _e === void 0 ? void 0 : _e.name)) {
            errors.push(error_factory_1.ValidationErrorFactory.DuplicateArgument({
                expr: arg.name,
                attributes: {
                    argumentName: arg.name.name,
                },
            }));
        }
    }
    return errors;
}
exports.validateArgumentDeclarations = validateArgumentDeclarations;
function validateArgumentDeclaration(arg, checker, isDialogArgument = false) {
    const errors = [
        ...(0, exports.validateExpression)(arg.defaultExpression, checker),
        ...(0, exports.validateTypeReference)(arg.type, checker),
        ...(0, exports.validateAnnotations)(arg, checker),
    ];
    if (arg.name === undefined) {
        errors.push(error_factory_1.ValidationErrorFactory.SyntaxError({
            expr: (0, error_factory_1.getExpressionIfLocField)(arg.type, arg),
            overrideMessage: "expected name for argument declaration.",
        }));
    }
    if (arg.defaultExpression) {
        const actualType = checker.getType(arg.defaultExpression);
        const expectedType = checker.getType(arg.type);
        if (actualType && expectedType && !actualType.extends(expectedType)) {
            errors.push((0, error_1.typeError)(actualType, expectedType, arg.defaultExpression, arg.defaultExpression));
        }
        // Arguments' default value must be nothing except dialogArgument
        if (!isDialogArgument) {
            const thing = checker.getThing(arg.defaultExpression);
            if (!((thing === null || thing === void 0 ? void 0 : thing.isNothing()) && thing.isLiteral())) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidApiArgumentDefaultValue({
                    expr: arg,
                }));
            }
        }
        else {
            // for dialogArgument, the default expression canâ€™t call dialogs, user defined APIs or branch with conditions
        }
    }
    return errors;
}
exports.validateArgumentDeclaration = validateArgumentDeclaration;
/**
 * Validate that an EnumDeclaration has at least one item and no duplicate items.
 *
 * ```acdl
 * enum E {} // invalid
 * enum E { // invalid
 *   A
 *   A
 * }
 * enum E { // valid
 *   A
 *   B
 * }
 * ```
 */
const validateEnumDeclaration = (enumDecl, checker) => {
    var _a, _b, _c, _d;
    if (enumDecl.items === undefined || enumDecl.items.length === 0) {
        return [
            error_factory_1.ValidationErrorFactory.EmptyEnumDeclaration({
                expr: enumDecl,
                attributes: {
                    enumName: (_a = enumDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                },
            }),
            ...(0, exports.validateAnnotations)(enumDecl, checker),
        ];
    }
    const names = new Set();
    const dups = new Set();
    (_b = enumDecl.items) === null || _b === void 0 ? void 0 : _b.forEach((item) => {
        var _a, _b;
        if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (names.has((_b = item.name) === null || _b === void 0 ? void 0 : _b.name)) {
                dups.add(item.name.name);
            }
            else {
                names.add(item.name.name);
            }
        }
    });
    if (dups.size === 0) {
        return [];
    }
    return [
        ...(0, exports.validateAnnotations)(enumDecl, checker),
        ...((_d = (_c = enumDecl.items) === null || _c === void 0 ? void 0 : _c.map((item) => {
            var _a;
            if (((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) && dups.has(item.name.name)) {
                return error_factory_1.ValidationErrorFactory.DuplicateEnumItem({
                    expr: item,
                    attributes: {
                        enumItemName: item.name.name,
                    },
                });
            }
            return undefined;
        }).filter((e) => e !== undefined)) !== null && _d !== void 0 ? _d : []),
    ];
};
exports.validateEnumDeclaration = validateEnumDeclaration;
const validateTypeDeclaration = (type, checker) => {
    var _a;
    return [
        ...(0, exports.validateTypeReferences)((_a = type.properties) === null || _a === void 0 ? void 0 : _a.map((p) => p.type).filter((t) => t !== undefined), checker),
        ...(0, exports.validateTypeReferences)(type.extensions, checker),
        ...(0, exports.validateTypeParameters)(type.genericArguments, checker),
        ...(0, exports.validateCircularReferences)(type, checker),
        ...(0, exports.validateAnnotations)(type, checker),
        ...(0, exports.validateTypeDeclarationProperties)(type, checker),
    ];
};
exports.validateTypeDeclaration = validateTypeDeclaration;
/**
 * validate the properties in typeDecl are not duplicate
 */
const validateTypeDeclarationProperties = (typeDecl, checker) => {
    var _a, _b, _c;
    const seen = new Set((_a = typeDecl.extensions) === null || _a === void 0 ? void 0 : _a.map((ext) => { var _a, _b, _c; return (_c = (_b = (_a = checker.getType(ext)) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.map((p) => p.name)) !== null && _c !== void 0 ? _c : []; }).reduce((a, b) => a.concat(b), []));
    return ((_c = (_b = typeDecl.properties) === null || _b === void 0 ? void 0 : _b.map((prop) => {
        var _a;
        const name = (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name;
        if (name === undefined) {
            return error_factory_1.ValidationErrorFactory.SyntaxError({
                expr: (0, error_factory_1.getExpressionIfLocField)(prop.type, prop),
                overrideMessage: "expected property name.",
            });
        }
        if (seen.has(name)) {
            return error_factory_1.ValidationErrorFactory.DuplicatePropertyRedeclared({
                expr: prop,
                attributes: {
                    propertyName: name,
                },
            });
        }
        seen.add(name);
        return undefined;
    }).filter((e) => e !== undefined)) !== null && _c !== void 0 ? _c : []);
};
exports.validateTypeDeclarationProperties = validateTypeDeclarationProperties;
const validateTypeParameters = (params, checker) => { var _a; return (_a = params === null || params === void 0 ? void 0 : params.map((param) => (0, exports.validateTypeParameter)(param, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
exports.validateTypeParameters = validateTypeParameters;
const validateTypeParameter = (param, checker) => (0, exports.validateTypeReferences)(param.constraints, checker);
exports.validateTypeParameter = validateTypeParameter;
const validateTypeReferences = (refs, checker) => { var _a; return (_a = refs === null || refs === void 0 ? void 0 : refs.map((ref) => (0, exports.validateTypeReference)(ref, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
exports.validateTypeReferences = validateTypeReferences;
const validateTypeReference = (ref, checker) => {
    var _a, _b;
    const errors = [];
    if (ref) {
        // check if the call name could be resolved, error if fail to resolve call name
        errors.push(...(0, exports.validateName)(ref, checker));
        if (errors.length > 0) {
            return errors;
        }
        errors.push(...(0, exports.validateCircularReferences)(ref, checker));
        const typeDecl = checker.lookupTypeReference(ref);
        if (typeDecl === undefined) {
            errors.push((0, error_1.nameNotFound)(ref.name));
        }
        if (ref.arguments) {
            for (const arg of ref.arguments) {
                errors.push(...(0, exports.validateTypeReference)(arg, checker));
            }
        }
        if (typeDecl && errors.length === 0) {
            const type = checker.instantiateTypeReference(ref);
            if (type !== undefined) {
                if (typeDecl.kind === "TypeDeclaration") {
                    if (typeDecl.genericArguments) {
                        if (typeDecl.genericArguments.length !== ((_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                            errors.push(error_factory_1.ValidationErrorFactory.TypeErrorRequiredTypeArguments({
                                expr: ref,
                                attributes: {
                                    typeDeclarationName: (_b = typeDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                                    numArguments: typeDecl.genericArguments.length,
                                },
                            }));
                        }
                        else {
                            type.genericArguments.forEach((genericArgument, i) => {
                                var _a, _b;
                                const typeParameter = (_a = typeDecl.genericArguments) === null || _a === void 0 ? void 0 : _a[i];
                                if (typeParameter !== undefined && typeParameter.constraints && genericArgument !== undefined) {
                                    for (const constraint of typeParameter.constraints) {
                                        const constraintType = checker.instantiateTypeReference(constraint, type.environment);
                                        if (constraintType && !genericArgument.extends(constraintType)) {
                                            errors.push((0, error_1.typeError)(genericArgument, constraintType, ref, (_b = ref.arguments) === null || _b === void 0 ? void 0 : _b[i]));
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateTypeReference = validateTypeReference;
/**
 * Validate an `alexa.lang.property` call to access a property on a type.
 *
 * @param ref call expression representing the access of a property on another expression
 */
const validatePropertyReference = (ref, checker) => {
    // property does not exist
    const { name } = ref;
    const expr = ref.expression;
    const exprType = checker.getType(expr);
    if ((name === null || name === void 0 ? void 0 : name.name) === undefined) {
        return [
            error_factory_1.ValidationErrorFactory.IdentifierExpected({
                expr: (0, error_factory_1.getExpressionIfLocField)(ref.name, ref),
            }),
        ];
    }
    const qualifiedName = ask.PropertyReference.tryResolveQualifiedName(ref);
    if (qualifiedName !== undefined && checker.lookupQualifiedName(qualifiedName) !== undefined) {
        return [];
    }
    if (exprType !== undefined) {
        const prop = exprType.getProperty(name.name);
        if (prop === undefined) {
            return [
                ...(0, exports.validateExpression)(expr, checker),
                error_factory_1.ValidationErrorFactory.UnknownProperty({
                    expr: (0, error_factory_1.getExpressionIfLocField)(ref.name, ref),
                    attributes: {
                        propertyName: name.name,
                        typeName: exprType.toString(ref),
                    },
                }),
            ];
        }
    }
    return (0, exports.validateExpression)(expr, checker);
};
exports.validatePropertyReference = validatePropertyReference;
const validateUtteranceTypeWrapper = (apply) => {
    const errors = [];
    if (!apply.isUtterances() && !apply.isIntent()) {
        return [];
    }
    const returnType = apply.getReturnType();
    const utteranceType = apply.isUtterances() ? returnType === null || returnType === void 0 ? void 0 : returnType.getUtteranceEventType() : returnType === null || returnType === void 0 ? void 0 : returnType.getIntentEventType();
    if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isValidUtteranceWrapper())) {
        errors.push(error_factory_1.ValidationErrorFactory.UtteranceEventTypeMustReferToWrapper({
            expr: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.declaration,
            attributes: {
                typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName,
                action: apply.isUtterances() ? "utterances" : "intent",
            },
        }));
    }
    return errors;
};
exports.validateUtteranceTypeWrapper = validateUtteranceTypeWrapper;
/**
 * Validate a Call to a Type or an Action:
 *
 * - Resolve its declaration and throw errors if it cannot be found.
 * - Infer generic arguments if they aren't provided and flag errors if that cannot be achieved.
 * - Validate that all required arguments are provided and that types of arguments match declaration.
 */
const validateCall = (call, checker) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const errors = [];
    // check if the call name could be resolved, error if fail to resolve call name
    errors.push(...(0, exports.validateName)(call, checker));
    const getPropertyMap = (0, lazy_1.memoize)((type) => type.getPropertyMap());
    if (errors.length > 0) {
        return errors;
    }
    const apply = checker.getApply(call);
    if (call.genericArguments) {
        errors.push(...(0, exports.validateTypeReferences)(call.genericArguments, checker));
    }
    if (apply === undefined) {
        if (((_a = call.name) === null || _a === void 0 ? void 0 : _a.name) === undefined) {
            // could not infer anonymous type
            errors.push(error_factory_1.ValidationErrorFactory.CouldNotInferAnonymousType({
                expr: call,
            }));
        }
        else {
            errors.push((0, error_1.nameNotFound)(call.name));
        }
    }
    else {
        errors.push(...(0, validate_skill_1.validateSkillCallContext)(apply));
        errors.push(...(0, exports.validateRequireCall)(apply, checker));
        errors.push(...(0, exports.validateValidateArgAnnotation)(apply, checker));
        if (apply.isAnnotation()) {
            // if this is a call to an Annotation, we must ensure that it is in an Annotation context.
            if (apply.call.context.kind !== "Annotation" && apply.call.getSample() !== undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationCall({
                    expr: call,
                    attributes: {
                        annotationTarget: apply.getName(),
                    },
                }));
            }
        }
        else if (apply.isEventDecl() ||
            apply.isIntent() ||
            apply.isFileAccessAction() ||
            apply.isSkillAction() ||
            apply.isWelcome() ||
            apply.isVariations()) {
            if (apply.isSkillAction()) {
                errors.push(...(0, validate_skill_1.validateSkillCallContext)(apply));
            }
            else if (call.context.kind !== "NameDeclaration" || ((_b = call.context.context) === null || _b === void 0 ? void 0 : _b.kind) !== "Module") {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidCallContextModuleNameDeclaration({
                    expr: call,
                    attributes: {
                        actionName: checker.qualifyName(call, (_c = call.name) === null || _c === void 0 ? void 0 : _c.name),
                    },
                }));
            }
            if (apply.isWelcome()) {
                const actionValue = apply.getArgumentValue("action");
                const actionType = checker.getType(actionValue);
                if (actionType === null || actionType === void 0 ? void 0 : actionType.isAction()) {
                    if (actionType.isBuiltIn()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidWelcomeAction({
                            expr: actionValue,
                        }));
                    }
                    const returnType = (_d = actionType.getPropertyType("returnType")) === null || _d === void 0 ? void 0 : _d.getTypeType();
                    if (returnType) {
                        if (returnType.isVoid() || returnType.isNothing()) {
                            errors.push(error_factory_1.ValidationErrorFactory.InvalidWelcomeActionReturnValue({
                                expr: actionValue,
                            }));
                        }
                    }
                }
            }
            else if (apply.isVariations()) {
                errors.push(...(0, exports.validateVariations)(call, checker));
            }
        }
        else if (apply.isType() || apply.isGetListItem()) {
            // TODO: should we allow operators and get list item?
            if (apply.isResetArguments() || apply.isResetAllArguments() || apply.isEnsureArgOrder()) {
                const argumentsValue = apply.getArgumentValue("arguments");
                // for ResetArguments, all the arguments in the list should from same api
                if (apply.isResetArguments()) {
                    errors.push(...(0, evaluate_1.validateArgumentListThing)(checker.getThing(argumentsValue), argumentsValue));
                }
                // for EnsureArgOrder, all the arguments in the list should be required args
                if (apply.isEnsureArgOrder()) {
                    errors.push(...(0, exports.validateEnsureArgOrder)(apply, checker));
                }
            }
            else if (apply.isCatalogType()) {
                const catalogType = (_e = apply.getGenericArguments()) === null || _e === void 0 ? void 0 : _e[0];
                if (!(catalogType === null || catalogType === void 0 ? void 0 : catalogType.isString())) {
                    error_factory_1.ValidationErrorFactory.CatalogTypeMustBeString({
                        expr: apply.call,
                    });
                }
            }
        }
        else if (apply.isCatalogDecl()) {
            errors.push(...(0, exports.validateCatalogCallContext)(apply, checker));
            if (apply.isBuiltinCatalogAction()) {
                errors.push(...(0, exports.validateBuiltinCatalogAction)(apply, checker));
            }
        }
        else if (apply.isGetAllNamesAction()) {
            errors.push(...(0, exports.validateGetAllNamesAction)(apply, checker));
        }
        else if (call.findInContext(ask.isAnnotation) === undefined) {
            errors.push(...(0, exports.validateCallContext)(call, checker));
        }
        if (apply.isUtterances() || apply.isIntent()) {
            errors.push(...(0, exports.validateUtteranceTypeWrapper)(apply, checker));
        }
        if ((apply.isUtterances() || apply.isIntent()) && checker.isNameReference((_f = apply.getArguments()) === null || _f === void 0 ? void 0 : _f.samples.value)) {
            errors.push(...(0, exports.validateNamedArguments)(apply, checker, false)); // check the arguments but don't type check - we will do this in a custom way
            // special case - we're calling utterances/intent with a name reference to a List.
            // we need to find that list and validate
            const value = (_g = apply.getArguments()) === null || _g === void 0 ? void 0 : _g.samples.value;
            const found = checker.resolveNameReference(value);
            const foundType = checker.getType(value);
            if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                // if empty list, throw error
                if (found.arguments.items.length === 0) {
                    errors.push(error_factory_1.ValidationErrorFactory.EmptyUtteranceSet({
                        expr: found.arguments,
                        attributes: {
                            actionName: apply.isUtterances() ? "utterances" : "intent",
                        },
                    }));
                }
                else if ((_h = foundType.getListItemType()) === null || _h === void 0 ? void 0 : _h.isString()) {
                    // yes, we are referencing a List<String> literal
                    const utteranceType = (_j = apply.getGenericArguments()) === null || _j === void 0 ? void 0 : _j[0];
                    for (const item of found.arguments.items) {
                        if (item.item !== undefined) {
                            // TODO: should we change the error message to provide more help? the error is associated with an afar list literal but attached to the name reference
                            errors.push(...(0, exports.validateUtterance)(item.item, utteranceType, getPropertyMap).map((e) => {
                                var _a;
                                return ({
                                    ...e,
                                    loc: value.loc,
                                    uri: (_a = e.uri) !== null && _a !== void 0 ? _a : value.uri,
                                });
                            }));
                        }
                    }
                }
            }
            else {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidUtteranceArg({
                    expr: value,
                }));
            }
        }
        else {
            if (apply.isUtterances() || apply.isIntent()) {
                const utteranceList = (_l = (_k = apply.getArguments()) === null || _k === void 0 ? void 0 : _k.samples) === null || _l === void 0 ? void 0 : _l.value;
                if ((utteranceList === null || utteranceList === void 0 ? void 0 : utteranceList.kind) === "Call" && ask.isListLiteral(utteranceList.arguments)) {
                    if (utteranceList.arguments.items.length === 0) {
                        errors.push(error_factory_1.ValidationErrorFactory.EmptyUtteranceSet({
                            expr: utteranceList.arguments,
                            attributes: {
                                actionName: apply.isUtterances() ? "utterances" : "intent",
                            },
                        }));
                    }
                    else {
                        let utteranceErrors = utteranceList.arguments.items.flatMap((listItem) => validateUtteranceString(listItem));
                        errors.push(...utteranceErrors);
                    }
                }
            }
            errors.push(...(0, exports.validateNamedArguments)(apply, checker));
            const genericArguments = apply.getGenericArguments();
            const genericEnvironment = apply.getGenericEnvironment();
            if (apply.decl.genericArguments !== undefined && genericArguments === undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.CouldNotInferGenericArguments({
                    expr: call,
                    attributes: {
                        argumentName: (_m = apply.decl.name) === null || _m === void 0 ? void 0 : _m.name,
                    },
                }));
            }
            else if (genericArguments && ((_o = apply.decl.genericArguments) === null || _o === void 0 ? void 0 : _o.length) === (genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments.length)) {
                const decl = apply.decl.kind === "Type" ? apply.decl.declaration : apply.decl;
                if (decl &&
                    decl.kind !== "TypeParameter" &&
                    decl.kind !== "SlotType" &&
                    decl.kind !== "EnumDeclaration" &&
                    decl.kind !== "EnumItemDeclaration" &&
                    decl.kind !== "TypeReference") {
                    (_p = decl.genericArguments) === null || _p === void 0 ? void 0 : _p.forEach((genericArgument, i) => {
                        var _a, _b;
                        const actualType = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i];
                        if (actualType && genericArgument.constraints) {
                            for (const constraint of genericArgument.constraints) {
                                const expectedType = checker.instantiateTypeReference(constraint, genericEnvironment);
                                if (expectedType && !actualType.extends(expectedType)) {
                                    errors.push((0, error_1.typeError)(actualType, expectedType, (_b = (_a = call === null || call === void 0 ? void 0 : call.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : call));
                                }
                            }
                        }
                    });
                }
            }
            const returnType = apply.getReturnType();
            if (apply.isType() && returnType) {
                // this is a Type expression, e.g. `Person { name = "sam" }` or `[1, 2]` or `"hello"`
                if (call.arguments === null && !(returnType.isVoid() || returnType.isNothing() || returnType.isOptional())) {
                    errors.push((0, error_1.typeError)(returnType, checker.void, call));
                }
                else if (typeof call.arguments === "string" && !returnType.isStringLike()) {
                    errors.push((0, error_1.typeError)(returnType, checker.string, call));
                }
                else if (typeof call.arguments === "number" && !returnType.isNumber()) {
                    errors.push((0, error_1.typeError)(returnType, checker.number, call));
                }
                else if (typeof call.arguments === "boolean" && !returnType.isBoolean()) {
                    errors.push((0, error_1.typeError)(returnType, checker.boolean, call));
                }
                else if (ask.isListLiteral(call.arguments) && !returnType.isList()) {
                    errors.push(error_factory_1.ValidationErrorFactory.TypeErrorListType({
                        expr: call,
                    }));
                }
                if (returnType.isUtterance()) {
                    const utteranceType = returnType.getUtteranceType();
                    errors.push(...(0, exports.validateUtterance)(call, utteranceType, getPropertyMap));
                }
                if (ask.isListLiteral(call.arguments) && returnType.isList()) {
                    const expectedType = returnType.getListItemType();
                    if (expectedType) {
                        for (const item of call.arguments.items) {
                            errors.push(...(0, exports.validateExpression)(item.item, checker));
                            const actualType = checker.getType(item.item);
                            if (actualType) {
                                if (!actualType.extends(expectedType)) {
                                    errors.push(error_factory_1.ValidationErrorFactory.TypeErrorListItem({
                                        expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                                        attributes: {
                                            actualType: actualType.toString(item.item),
                                            expectedType: expectedType.toString(item.item),
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateCall = validateCall;
/**
 * Validate utterance string to check if it contains empty curly braces
 */
function validateUtteranceString(item) {
    if (!ask.isCall(item.item))
        return [];
    let errors = [];
    let utterance = ask.isUtterance(item.item.arguments) ? item.item.arguments.text : item.item.arguments;
    if (typeof utterance !== "string")
        return [];
    let emptySlotReEexp = /\{\s*\}/g;
    let validSlotRegExp = /{([- a-zA-Z 0-9 _.|,' \s ]*)}/g;
    let braces = utterance.match(emptySlotReEexp);
    if (braces && (braces === null || braces === void 0 ? void 0 : braces.length) > 0) {
        errors.push(error_factory_1.ValidationErrorFactory.EmptyUtteranceBraces({
            expr: { loc: item.item.loc, uri: item.item.uri },
            attributes: {
                utterance,
            },
        }));
    }
    // removes valid '{..}' to check for invalid braces in the utterance
    let utteranceWithoutSlots = utterance.replace(validSlotRegExp, "");
    for (let char of utteranceWithoutSlots) {
        if (char === "}") {
            errors.push(error_factory_1.ValidationErrorFactory.MissingUtteranceOpeningBrace({
                expr: { loc: item.item.loc, uri: item.item.uri },
                attributes: {
                    utterance,
                },
            }));
            break;
        }
        else if (char === "{") {
            errors.push(error_factory_1.ValidationErrorFactory.MissingUtteranceClosingBrace({
                expr: { loc: item.item.loc, uri: item.item.uri },
                attributes: {
                    utterance,
                },
            }));
            break;
        }
    }
    return errors;
}
exports.validateUtteranceString = validateUtteranceString;
/**
 * validate the variations call
 * 1. The argument value can't use duplicate locale info
 * 2. SkillLevelResponses can't be used as an argument of variations call
 * 3. prompts.abc can't be used as an argument of variations call
 *
 * Invalid case example:
 * 1. duplicate locales
 * ```
 *  @locale(Locale.en_US)
 *  promptUS = utterances<Person>([
 *     "hi I am American my name is {name}",
 *     "hi I am American my name is {name} and i am {age} years old"
 *  ])
 *
 *  @locale(Locale.en_US, Locale.en_GB)
 *  promptGB = utterances<Person>([
 *    "hi I am British my name is {name}",
 *    "hi I am British my name is {name} and i am {age} years old"
 *  ])
 *  u = variations(promptUS, promptGB)
 * ```
 *
 * 2. SkillLevelResponses used as argument
 * ```
 * skillLevelResponsesEN = SkillLevelResponses { ... }
 * skillLevelResponsesGB = SkillLevelResponses { ... }
 *
 * skillLevelResponses = variations(skillLevelResponsesEN, skillLevelResponsesGB)
 * ```
 *
 * 3. prompts used as argument
 * ```
 * skillLevelResponses = variations(prompts.AlexaConversationsWelcome, prompts.AlexaConversationsOutOfDomain)
 * ```
 */
const validateVariations = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply === undefined) {
        return [];
    }
    const errors = [];
    const usedLocale = new Map();
    const argumentValueThing = apply.getArgumentValueThing("variations");
    if (argumentValueThing === null || argumentValueThing === void 0 ? void 0 : argumentValueThing.isList()) {
        const items = argumentValueThing.getListItems();
        items === null || items === void 0 ? void 0 : items.forEach((item) => {
            var _a, _b, _c;
            if (((_a = item === null || item === void 0 ? void 0 : item.item) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = item === null || item === void 0 ? void 0 : item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                // TODO: validate the item is not SkillLevelResponses or prompts
                const thing = checker.getThing(item.item);
                if (thing === null || thing === void 0 ? void 0 : thing.type.isSkillLevelResponses()) {
                    // SkillLevelResponses can't be used as an argument of variations call
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidVariationsArgumentSkillLevelResponses({
                        expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                    }));
                }
                else if (((_c = checker.resolveNameReference(item.item)) === null || _c === void 0 ? void 0 : _c.kind) === "ResponseTemplate") {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidVariationsArgumentResponsePrompts({
                        expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                    }));
                }
                else {
                    const locales = checker.collectLocaleInfo(item.item);
                    locales.forEach((locale) => {
                        var _a, _b;
                        if (usedLocale.has(locale)) {
                            errors.push(error_factory_1.ValidationErrorFactory.DuplicateLocale({
                                expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                                attributes: {
                                    locale,
                                    variationItem: usedLocale.get(locale),
                                },
                            }));
                        }
                        else {
                            usedLocale.set(locale, (_b = (_a = item.item) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name);
                        }
                    });
                }
            }
        });
    }
    return errors;
};
exports.validateVariations = validateVariations;
/**
 * Validate that a call to a User Defined API or Dialog is not contained within another call.
 *
 * Validate that this Call is allowed in this Context.
 *
 * @param call
 * @param checker
 * @returns
 */
const validateCallContext = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply !== undefined) {
        const callType = apply.isUserDefinedApi()
            ? `user defined API '${apply.getName()}'`
            : apply.isDialog()
                ? "a dialog"
                : apply.isBuiltin()
                    ? `'${apply.getShortName()}'`
                    : "an action";
        return walkCallContext(call.context);
        function walkCallContext(context) {
            if (context === undefined || ask.isDialogDeclaration(context)) {
                return [];
            }
            if (context.kind === "InteractionDeclaration" || context.kind === "Correction") {
                // TODO: add validation checks - https://github.com/alexa/ask-ac/issues/869
                return [];
            }
            if (ask.isModule(context)) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidCallContextInModule({
                        expr: call,
                        attributes: {
                            callType,
                        },
                    }),
                ];
            }
            if (context.kind === "When") {
                if (!(apply.isOperator() || apply.isNativeAction())) {
                    return [
                        error_factory_1.ValidationErrorFactory.InvalidCallContextInCondition({
                            expr: call,
                            attributes: {
                                callType,
                            },
                        }),
                    ];
                }
            }
            else if (context.kind === "Call") {
                const contextApply = checker.getApply(context);
                if ((contextApply === null || contextApply === void 0 ? void 0 : contextApply.isUserDefinedApi()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isDialog()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isType())) {
                    const contextType = contextApply.isType() ? (contextApply.isList() ? "a list item" : "a property") : "an argument";
                    const errorArguments = {
                        expr: call,
                        attributes: {
                            callType,
                            contextType,
                        },
                    };
                    if (apply.isOperator()) {
                        return [error_factory_1.ValidationErrorFactory.InvalidCallContextComparison(errorArguments)];
                    }
                    if (apply.isNativeAction()) {
                        return [error_factory_1.ValidationErrorFactory.InvalidCallContextType(errorArguments)];
                    }
                    return [error_factory_1.ValidationErrorFactory.InvalidCallContextTypeInline(errorArguments)];
                }
            }
            return walkCallContext(context.context);
        }
    }
    return [];
};
exports.validateCallContext = validateCallContext;
/**
 * Validates that a `validateArg` annotation matches the following rules:
 * 1. action must have at least one argument
 * 2. condition must reference at least one of those arguments in its boolean expression
 * 3. at least one argument must be referenced
 * 4. that argument must be from the same action that this validateArg annotation is attached to.
 *
 * @param apply Apply instance for the validateArg annotation call.
 * @param checker static TypeChecker instance
 * @returns validation errors
 * @see https://github.com/alexa/ask-ac/issues/690
 */
const validateValidateArgAnnotation = (apply, checker) => {
    var _a;
    if (!apply.isValidateArg()) {
        return [];
    }
    const action = (_a = apply.checker.getThing(apply.call.context.context)) === null || _a === void 0 ? void 0 : _a.asAction();
    if (action === undefined) {
        // we don't need to error here - validateArg's annotation targets restricts it to an Action
        return [];
    }
    if (action.origin.arguments === undefined || action.origin.arguments.length === 0) {
        return [
            error_factory_1.ValidationErrorFactory.InvalidAnnotationValidateArg({
                expr: apply.call,
            }),
        ];
    }
    const argumentsNode = apply.getArgumentValue("arguments");
    const conditionNode = apply.getArgumentValue("condition");
    const condition = apply.getArgumentValueThing("condition");
    const args = apply.getArgumentValueThing("arguments");
    const argsNode = apply.getArgumentValue("arguments");
    const requestPromptNode = apply.getArgumentValue("requestPrompt");
    const requestPrompt = apply.getArgumentValueThing("requestPrompt");
    return [
        ...validateArguments(),
        ...validateConditionReferencesAtLeastOneArgument(),
        ...validateConditionOperations(conditionNode, undefined),
        ...validateRequestPrompt(),
    ];
    function validateConditionReferencesAtLeastOneArgument() {
        var _a;
        if (conditionNode === undefined) {
            // type error
            return [];
        }
        if (condition === null || condition === void 0 ? void 0 : condition.isNothing()) {
            return [
                error_factory_1.ValidationErrorFactory.IllegalNothingValueBoolean({
                    expr: (0, error_factory_1.getExpressionIfLocField)(conditionNode, apply.call),
                }),
            ];
        }
        if (!hasAtLeastOneArgumentNameReference(conditionNode)) {
            return [
                error_factory_1.ValidationErrorFactory.InvalidAnnotationValidateArgCondition({
                    expr: conditionNode,
                    attributes: {
                        actionArguments: (_a = action === null || action === void 0 ? void 0 : action.origin.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => { var _a; return `'${(_a = arg.name) === null || _a === void 0 ? void 0 : _a.name}'`; }).join(","),
                        actionName: action.actionName,
                    },
                }),
            ];
        }
        return [];
    }
    function hasAtLeastOneArgumentNameReference(node) {
        if (node.kind === "NameReference") {
            const referencedNode = checker.resolveNameReference(node);
            if ((referencedNode === null || referencedNode === void 0 ? void 0 : referencedNode.kind) === "ArgumentDeclaration") {
                return true;
            }
        }
        return (0, visit_1.collect)(node, hasAtLeastOneArgumentNameReference, (a, b) => a || b, false);
    }
    function validateConditionOperations(node, errorExpr) {
        if (node === undefined) {
            return [];
        }
        if (node.kind === "NameReference") {
            return validateConditionOperations(checker.resolveNameReference(node), (0, error_factory_1.getExpressionIfLocField)(errorExpr, node));
        }
        if (node.kind === "PropertyReference") {
            return validateConditionOperations(checker.resolveNameReferenceToCall(node), (0, error_factory_1.getExpressionIfLocField)(errorExpr, node));
        }
        if (node.kind === "Call") {
            const apply = checker.getApply(node);
            if (apply === undefined) {
                // type error
                return [];
            }
            if (apply.isType()) {
                if (node.arguments === null ||
                    typeof node.arguments === "string" ||
                    typeof node.arguments === "number" ||
                    typeof node.arguments === "boolean" ||
                    ask.isListLiteral(node.arguments)) {
                    if (ask.isListLiteral(node.arguments)) {
                        // check that each of the values in the list are also valid
                        return node.arguments.items.map((item) => validateConditionOperations(item.item, errorExpr)).flat();
                    }
                    // literal value comparisons are allowed
                    return [];
                }
                return [
                    error_factory_1.ValidationErrorFactory.InvalidBooleanExpressionTypeLiteral({
                        expr: (0, error_factory_1.getExpressionIfLocField)(errorExpr, node, conditionNode),
                        attributes: {
                            typeName: apply.getName(),
                        },
                    }),
                ];
            }
            if (apply.isBinaryOperator()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("left"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("right"), errorExpr),
                ];
            }
            if (apply.isNot() || apply.isIs() || apply.isExists()) {
                return validateConditionOperations(apply.getArgumentValue("right"), errorExpr);
            }
            if (apply.isSize()) {
                return validateConditionOperations(apply.getArgumentValue("list"), errorExpr);
            }
            if (apply.isGetListItem()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("list"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("index"), errorExpr),
                ];
            }
            if (apply.isLength()) {
                return validateConditionOperations(apply.getArgumentValue("s"), errorExpr);
            }
            return [
                error_factory_1.ValidationErrorFactory.InvalidBooleanExpressionAction({
                    expr: (0, error_factory_1.getExpressionIfLocField)(errorExpr, node, conditionNode),
                    attributes: {
                        actionName: apply.getName(),
                    },
                }),
            ];
        }
        return [];
    }
    function validateRequestPrompt() {
        if (requestPromptNode === undefined) {
            // type error
            return [];
        }
        if (requestPrompt === null || requestPrompt === void 0 ? void 0 : requestPrompt.isNothing()) {
            return [
                error_factory_1.ValidationErrorFactory.IllegalNothingValueResponsePrompt({
                    expr: (0, error_factory_1.getExpressionIfLocField)(requestPromptNode, apply.call),
                }),
            ];
        }
        return [];
    }
    function validateArguments() {
        var _a, _b;
        if (argumentsNode === undefined || (args === null || args === void 0 ? void 0 : args.isNothing())) {
            return [
                error_factory_1.ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: apply.call,
                    attributes: {
                        actionName: (_a = action.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ];
        }
        if (!(args === null || args === void 0 ? void 0 : args.isLiteral())) {
            return [
                error_factory_1.ValidationErrorFactory.ExpectedLiteralValue({
                    expr: (0, error_factory_1.getExpressionIfLocField)(argumentsNode, apply.call),
                }),
            ];
        }
        if (!args.isList()) {
            return [];
        }
        const items = args.getItems();
        if (!(items === null || items === void 0 ? void 0 : items.length)) {
            return [
                error_factory_1.ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: (0, error_factory_1.getExpressionIfLocField)(argumentsNode, apply.call),
                    attributes: {
                        actionName: (_b = action.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
            ];
        }
        return items.flatMap((arg, i) => {
            var _a;
            // if this arguments is an inline literal list, we will place the error on the specific item in the list
            const argsExpr = (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)
                ? (_a = argsNode.arguments.items[i]) === null || _a === void 0 ? void 0 : _a.item
                : (0, error_factory_1.getExpressionIfLocField)(argumentsNode, apply.call);
            if (arg === undefined) {
                return []; // type error;
            }
            if (arg.isNothing()) {
                return [
                    error_factory_1.ValidationErrorFactory.IllegalNothingValueActionArgument({
                        expr: argsExpr,
                        attributes: {
                            actionName: action === null || action === void 0 ? void 0 : action.actionName,
                        },
                    }),
                ];
            }
            if (arg.isArgument() && arg.action && !arg.action.equals(action)) {
                return [
                    error_factory_1.ValidationErrorFactory.MismatchedActionArgumentsValidateArguments({
                        expr: argsExpr,
                        attributes: {
                            argumentName: arg.argumentName,
                            actualActionName: arg.action.actionName,
                            expectedActionName: action.actionName,
                        },
                    }),
                ];
            }
            return [];
        });
    }
};
exports.validateValidateArgAnnotation = validateValidateArgAnnotation;
/**
 * Validate a call to `require` - an internal action to reference a file from disk.
 */
const validateRequireCall = (apply, checker) => {
    var _a, _b;
    const name = apply.getName();
    if (name === ast_1.AlexaConversations.apl || name === ast_1.AlexaConversations.apla) {
        const pathArg = (_a = apply.getArguments()) === null || _a === void 0 ? void 0 : _a.path;
        if (((_b = pathArg === null || pathArg === void 0 ? void 0 : pathArg.value) === null || _b === void 0 ? void 0 : _b.kind) === "Call") {
            const filePath = ask.isUtterance(pathArg.value.arguments)
                ? pathArg.value.arguments.text
                : typeof pathArg.value.arguments === "string"
                    ? pathArg.value.arguments
                    : undefined;
            if (filePath !== undefined) {
                const uri = checker.getUri(apply.call);
                if (uri !== undefined) {
                    let absolutePath;
                    if (path_1.default.isAbsolute(filePath)) {
                        absolutePath = filePath;
                    }
                    else {
                        absolutePath = path_1.default.join(uri, "..", filePath);
                    }
                    if (!fs_extra_1.default.existsSync(absolutePath)) {
                        // TODO: don't use synchronous IO in the validators
                        // see: https://github.com/alexa/ask-ac/issues/504
                        return [
                            error_factory_1.ValidationErrorFactory.PathNotAccessible({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // developer could provide folder name only
                    // auto fill the 'document.json' in path
                    const status = fs_extra_1.default.statSync(absolutePath);
                    let documentPath;
                    if (status.isFile()) {
                        documentPath = absolutePath;
                    }
                    else {
                        documentPath = path_1.default.join(absolutePath, constants_1.Constants.APLADocumentFileName);
                    }
                    // The document can only use the name 'document.json'
                    if (path_1.default.basename(documentPath) !== constants_1.Constants.APLADocumentFileName) {
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                documentName: path_1.default.basename(documentPath),
                            },
                        };
                        return [
                            name === ast_1.AlexaConversations.apl
                                ? error_factory_1.ValidationErrorFactory.InvalidAplDocumentName(errorArguments)
                                : error_factory_1.ValidationErrorFactory.InvalidAplaDocumentName(errorArguments),
                        ];
                    }
                    // if no document.json found
                    if (!fs_extra_1.default.existsSync(documentPath)) {
                        return [
                            error_factory_1.ValidationErrorFactory.FileNotFound({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // Type check to make sure apla action point to APLA document
                    // and apl action point to APL document
                    try {
                        const json = (0, util_1.readAndParseMandatoryJSONFileSync)(documentPath);
                        const { type } = json;
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                filePath,
                                fileType: type === undefined ? type : `"${type}"`,
                            },
                        };
                        if (name === ast_1.AlexaConversations.apl && type !== constants_1.APLFileType.APL) {
                            return [error_factory_1.ValidationErrorFactory.InvalidFileTypeApl(errorArguments)];
                        }
                        if (name === ast_1.AlexaConversations.apla && !constants_1.APLAFileTypes.includes(type)) {
                            return [error_factory_1.ValidationErrorFactory.InvalidFileTypeApla(errorArguments)];
                        }
                    }
                    catch (err) {
                        return [
                            error_factory_1.ValidationErrorFactory.FileReadError({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                                overrideMessage: err.message,
                            }),
                        ];
                    }
                }
            }
        }
    }
    return [];
};
exports.validateRequireCall = validateRequireCall;
/**
 * Validate the arguments passed to a Call against the target declaration.
 *
 * - Finds missing required arguments.
 * - Detect unknown arguments, whether by name or position. Account for var-args.
 * - Detect when positional arguments are used after named ones.
 * - Check that the types of arguments.
 *
 * @param apply
 * @param checker
 * @param checkType should we type check? default true
 */
const validateNamedArguments = (apply, checker, checkType = true) => {
    var _a, _b, _c;
    if (apply.isType() && ((_a = apply.getReturnType()) === null || _a === void 0 ? void 0 : _a.isPrimitive())) {
        return [];
    }
    const { call } = apply;
    const errors = [];
    let isPositionalAllowed = true;
    let position = 0;
    const seenNamedArgs = new Set();
    if (Array.isArray(call.arguments)) {
        for (const argument of call.arguments) {
            // recursively descend and validate this argument
            errors.push(...(0, exports.validateExpression)(argument, checker));
            if ((_b = argument.name) === null || _b === void 0 ? void 0 : _b.name) {
                isPositionalAllowed = false;
                const decl = apply.argumentDeclIndex[argument.name.name];
                if (decl === undefined) {
                    unknown();
                }
                if (seenNamedArgs.has(argument.name.name)) {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidApiArgumentRedeclare({
                        expr: argument,
                        attributes: {
                            argumentName: argument.name.name,
                        },
                    }));
                }
                else {
                    seenNamedArgs.add(argument.name.name);
                }
            }
            else if (isPositionalAllowed) {
                const decl = (_c = apply.argumentDeclarations) === null || _c === void 0 ? void 0 : _c[position];
                const env = apply.getGenericEnvironment();
                const declType = (decl === null || decl === void 0 ? void 0 : decl.kind) === "ArgumentDeclaration" ? checker.instantiateTypeReference(decl.type, env) : decl === null || decl === void 0 ? void 0 : decl.type;
                if (declType === undefined) {
                    unknown();
                }
                if ((declType === null || declType === void 0 ? void 0 : declType.isArgs()) !== true) {
                    // if this is not var args, increment the declaration position
                    // otherwise, subsequent arguments are considered an item in the var-args list
                    position += 1;
                }
            }
            else {
                errors.push(error_factory_1.ValidationErrorFactory.PositionalArgumentAfterName({
                    expr: argument,
                }));
                // If positional arguments are used after a named argument, skip the rest validation
                return errors;
            }
            function unknown() {
                var _a, _b, _c;
                let error;
                const expr = (0, error_factory_1.getExpressionIfLocField)(argument.name, argument);
                if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                    error = apply.isType()
                        ? error_factory_1.ValidationErrorFactory.UnknownProperty({
                            expr,
                            attributes: {
                                propertyName: argument.name.name,
                                typeName: (_c = (_b = apply.getReturnType()) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        })
                        : error_factory_1.ValidationErrorFactory.UnknownArgument({
                            expr,
                            attributes: {
                                argumentName: argument.name.name,
                                callName: apply.getName(),
                            },
                        });
                }
                else {
                    const errorArguments = {
                        expr,
                        attributes: {
                            index: argument.index,
                        },
                    };
                    error = apply.isType()
                        ? error_factory_1.ValidationErrorFactory.UnknownPropertyIndex(errorArguments)
                        : error_factory_1.ValidationErrorFactory.UnknownArgumentIndex(errorArguments);
                }
                errors.push(error);
            }
        }
    }
    const missing = new Set(apply.requiredArguments);
    const sanitizedArguments = apply.getArguments();
    if (sanitizedArguments !== undefined) {
        // arguments are grouped by name and var-args are assembled into a List.
        // now go through each argument and type check it.
        for (const [name, argument] of Object.entries(sanitizedArguments || {})) {
            missing.delete(name);
            if (checkType) {
                // special case: when property of an event result is of type optional, and there's request prompt available for that property
                // Then we should treat this property as not optional
                let actualType = checker.getType(argument.value);
                if (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                    // for backwards compatibility
                    // Temporarily make Optional<T> assignable to T
                    // TODO: get argumentEnsured condition back once we are ready to ship breaking changes
                    // if (checker.isArgumentEnsured(call, apply.decl, name)) {
                    while (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                        actualType = actualType.getOptionalType();
                    }
                }
                const expectedType = apply === null || apply === void 0 ? void 0 : apply.getType(argument);
                if (actualType && expectedType) {
                    if (!actualType.extends(expectedType)) {
                        errors.push((0, error_1.typeError)(actualType, expectedType, apply.call, argument));
                    }
                }
            }
        }
    }
    if (missing.size > 0) {
        errors.push(apply.isType()
            ? error_factory_1.ValidationErrorFactory.MissingProperties({
                expr: call,
                attributes: { properties: Array.from(missing.values()).join(",") },
            })
            : error_factory_1.ValidationErrorFactory.MissingArguments({
                expr: call,
                attributes: { args: Array.from(missing.values()).join(",") },
            }));
    }
    errors.push(...validateBinaryOperator(apply));
    return errors;
};
exports.validateNamedArguments = validateNamedArguments;
function validateBinaryOperator(apply) {
    var _a, _b;
    if (apply.isBinaryOperator()) {
        // special-case logic for binary operators - the types must match
        // for example, if we have `1 == "hello"`, then it will be inferred as
        // `equals<Thing>(1, "hello")` // there is no type error here
        // for these cases, we will explicitly check that either:
        // 1. left extends right
        // 2. right extends left
        const left = (_a = apply.getArgumentValueThing("left")) === null || _a === void 0 ? void 0 : _a.type;
        const right = (_b = apply.getArgumentValueThing("right")) === null || _b === void 0 ? void 0 : _b.type;
        if (left && right) {
            if (!left.extends(right) && !right.extends(left)) {
                return [
                    error_factory_1.ValidationErrorFactory.TypeErrorIncomparableExpr({
                        expr: apply.call,
                        attributes: {
                            leftExpr: left.toString(apply.call),
                            rightExpr: right.toString(apply.call),
                        },
                    }),
                ];
            }
        }
    }
    return [];
}
exports.validateBinaryOperator = validateBinaryOperator;
/**
 * Validates the utterance in expr
 * @param expr expression containing the utterance to validate
 * @param utteranceType type for utterance
 * @param getPropertyMap memoized type's getPropertyMap
 * @returns
 */
const validateUtterance = (expr, utteranceType, getPropertyMap) => {
    var _a;
    let errors = [];
    // throw error if the item in a list is not literal string
    if (expr.kind !== "Call" || (!(typeof expr.arguments === "string") && !ask.isUtterance(expr.arguments))) {
        return [error_factory_1.ValidationErrorFactory.InvalidUtteranceItem({ expr })];
    }
    let utterance;
    if (ask.isUtterance(expr.arguments)) {
        utterance = expr.arguments.text;
    }
    else {
        utterance = expr.arguments;
    }
    // Validate the utterance text here. Currently only validating it's not an empty string
    if (utterance.trim().length === 0) {
        return [error_factory_1.ValidationErrorFactory.EmptyUtteranceString({ expr })];
    }
    if (!utteranceType) {
        return errors;
    }
    const utteranceTypeRequiredProperties = utteranceType.getRequiredProperties();
    if (typeof expr.arguments === "string" && utteranceTypeRequiredProperties.size > 0) {
        errors.push(error_factory_1.ValidationErrorFactory.MissingPropertiesOnType({
            expr,
            attributes: {
                requiredProperties: Array.from(utteranceTypeRequiredProperties.values())
                    .map((p) => `${p.name}`)
                    .join(", "),
                typeName: utteranceType.toString(expr),
            },
        }));
    }
    else if (ask.isUtterance(expr.arguments)) {
        const propertyPaths = [];
        const pathsSeen = new Set();
        for (const name of expr.arguments.names || []) {
            if (!name.name) {
                continue;
            }
            if (pathsSeen.has(name.name)) {
                errors.push(error_factory_1.ValidationErrorFactory.DuplicateProperty({
                    expr: name,
                    attributes: {
                        propertyName: name.name,
                    },
                }));
            }
            pathsSeen.add(name.name);
            propertyPaths.push(name.name);
        }
        const { errors: propertyTreeErrors, root: propertyTreeRoot } = property_node_1.PropertyNode.buildPropertyTree(expr.arguments.names || [], utteranceType, expr, getPropertyMap);
        errors = [...errors, ...propertyTreeErrors];
        // Verify required properties at each tree level.
        // The tree traversal algorithm is the standard queue breadth first
        // (level by level) logic where we quee the root and while the queue
        // is not empty we unqueue element and queue its children.
        const queue = [propertyTreeRoot];
        while (queue.length !== 0) {
            const propertyNode = queue.shift();
            const requiredProperties = propertyNode === null || propertyNode === void 0 ? void 0 : propertyNode.propertyType.getRequiredProperties();
            for (const child of propertyNode.children.values()) {
                // mark this child as present by removing from requiredProperties
                requiredProperties.delete(child.property.name);
                // queue child which is a part of standard queue traversal
                queue.push(child);
            }
            for (const requiredProperty of requiredProperties.values()) {
                // if it's a list, then it's allowed to be omitted - omitted means empty list?
                if (!((_a = requiredProperty.type) === null || _a === void 0 ? void 0 : _a.isList())) {
                    errors.push(error_factory_1.ValidationErrorFactory.MissingPropertiesOnUtteranceType({
                        expr,
                        attributes: {
                            utterance: expr.arguments.text,
                            propertyName: requiredProperty.name,
                            typeName: utteranceType.toString(expr),
                        },
                    }));
                }
            }
        }
    }
    return errors;
};
exports.validateUtterance = validateUtterance;
const validateCondition = (condition, checker) => {
    const errors = [];
    if (condition.when !== undefined) {
        errors.push(...(0, exports.validateExpression)(condition.when, checker));
    }
    if (condition.then === undefined) {
        console.warn("undefined then");
    }
    else {
        errors.push(...(0, exports.validateConditionBlock)(condition.then, checker));
        errors.push(...(0, exports.validateBlock)(condition.then, checker));
    }
    if (condition.else) {
        errors.push(...(0, exports.validateConditionBlock)(condition.else, checker));
        errors.push(...(0, exports.validateBlock)(condition.else, checker));
    }
    const whenType = checker.getType(condition.when);
    if ((whenType === null || whenType === void 0 ? void 0 : whenType.isBoolean()) === false) {
        errors.push(error_factory_1.ValidationErrorFactory.TypeErrorWhenBoolean({
            expr: (0, error_factory_1.getExpressionIfLocField)(condition.when, condition),
            attributes: {
                whenType: whenType.toString(condition.when),
                whenCondition: checker.boolean.toString(condition.when),
            },
        }));
    }
    return errors;
};
exports.validateCondition = validateCondition;
/**
 * Validate that a Condition Block has expressions.
 */
const validateConditionBlock = (scope) => {
    var _a;
    return scope.expressions === undefined || ((_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.length) === 0
        ? [
            error_factory_1.ValidationErrorFactory.EmptyConditionBlock({
                expr: scope,
            }),
        ]
        : [];
};
exports.validateConditionBlock = validateConditionBlock;
/**
 * Validate EnsureOrder action call
 * 1. All the args in the list should from same api
 * 2. All the args in the list should be required args
 *
 * Related Github feature request:
 * https://github.com/alexa/ask-ac/issues/553
 */
const validateEnsureArgOrder = (apply, checker) => {
    const errors = [];
    if (apply.isEnsureArgOrder()) {
        const argumentsValue = apply.getArgumentValue("arguments");
        const argumentsValueThing = checker.getThing(argumentsValue);
        // all the arguments in the list should be required args
        errors.push(...(0, evaluate_1.validateArgumentListThing)(argumentsValueThing, argumentsValue));
        if ((argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.isLiteral()) && argumentsValueThing.isList()) {
            const items = argumentsValueThing.getItems();
            items === null || items === void 0 ? void 0 : items.forEach((item) => {
                var _a, _b, _c;
                if (item === null || item === void 0 ? void 0 : item.isArgument()) {
                    const referencedArgumentDeclaration = item.getReferencedActionArgumentDeclaration();
                    const type = checker.getType(referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.type);
                    if (type === null || type === void 0 ? void 0 : type.isOptional()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidEnsureArgOptional({
                            expr: item,
                            attributes: {
                                argumentName: (_a = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.name) === null || _a === void 0 ? void 0 : _a.name,
                                actionName: (_c = (_b = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.context) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }));
                    }
                }
            });
        }
    }
    return errors;
};
exports.validateEnsureArgOrder = validateEnsureArgOrder;
/**
 * Validates that calls to catalog actions like `extendCatalog` or `builtInCatalog` are only allowed
 * at the module scope and not within a dialog sample.
 */
const validateCatalogCallContext = (apply, checker) => {
    if (!apply.isCatalogDecl()) {
        return [];
    }
    let context = apply.call.context;
    while (context && context.kind !== "Module") {
        if (context.kind === "Sample" || context.kind === "DialogDeclaration") {
            return [
                error_factory_1.ValidationErrorFactory.InvalidCatalogCallContext({
                    expr: apply.call,
                    attributes: {
                        callName: apply.getShortName(),
                    },
                }),
            ];
        }
        context = context.context;
    }
    return [];
};
exports.validateCatalogCallContext = validateCatalogCallContext;
/**
 * Validates the argument provided to builtinCatalog is a valid built in type and
 * the type parameter is of type String.
 */
const validateBuiltinCatalogAction = (apply, checker) => {
    var _a;
    if (!apply.isBuiltinCatalogAction()) {
        return [];
    }
    const errors = [];
    const builtInTypes = new Set(Object.values(ast_1.BuiltIns).map((builtIn) => builtIn.replace(ast_1.BuiltinsNamespace + ".", "")));
    const genericType = (_a = apply.getGenericArguments()) === null || _a === void 0 ? void 0 : _a[0];
    const argValueThing = apply.getArgumentValueThing("name");
    // Validate type parameter is of type String
    if (genericType && !(genericType.isPrimitive() || genericType.isThing())) {
        errors.push(error_factory_1.ValidationErrorFactory.InvalidCatalogTypeParameter({
            expr: apply.call,
            attributes: {
                typeName: genericType.shortName,
            },
        }));
    }
    // Validate string argument is a built in type
    if (argValueThing === null || argValueThing === void 0 ? void 0 : argValueThing.isLiteral()) {
        // Get the string value of the argument
        let argString = argValueThing.apply.call.arguments;
        if (typeof argString === "string") {
            // Remove the AMAZON portion. "AMAZON.Actor" -> "Actor"
            let argValue = argString.replace("AMAZON.", "");
            if (!builtInTypes.has(argValue)) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidBuiltinCatalog({
                    expr: (0, error_factory_1.getExpressionIfLocField)(argValueThing, apply.call),
                    attributes: {
                        argName: argString,
                    },
                }));
            }
        }
    }
    return errors;
};
exports.validateBuiltinCatalogAction = validateBuiltinCatalogAction;
const validateInteractionDeclaration = (action, checker) => {
    return [...(0, exports.validateAnnotations)(action, checker), ...(0, exports.validateExpression)(action.scope, checker)];
};
exports.validateInteractionDeclaration = validateInteractionDeclaration;
const validateCorrection = (action, checker) => [
    ...(0, exports.validateExpression)(action.actual, checker),
    ...(0, exports.validateExpression)(action.expected, checker),
];
exports.validateCorrection = validateCorrection;
/**
 * Validates that the call to getAllNames.
 *
 * 1. Verify the namespaces provided exist.
 */
const validateGetAllNamesAction = (apply, checker) => {
    if (!apply.isGetAllNamesAction()) {
        return [];
    }
    const errors = [];
    const namespaces = (0, get_all_names_1.getNamespacesFromGetAllNames)(apply, checker);
    const missingNamespaces = namespaces.filter((namespace) => !checker.global.namespaces.has(namespace));
    if ((missingNamespaces === null || missingNamespaces === void 0 ? void 0 : missingNamespaces.length) > 0) {
        errors.push(error_factory_1.ValidationErrorFactory.InvalidNamespacesProvidedToGetAllNames({
            expr: apply.call,
            attributes: {
                namespaces: missingNamespaces.map((ns) => `"${ns}"`).join(", "),
            },
        }));
    }
    return errors;
};
exports.validateGetAllNamesAction = validateGetAllNamesAction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdmFsaWRhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx3REFBMEI7QUFDMUIsZ0RBQXdCO0FBQ3hCLDJDQUE2QjtBQUU3QixtQ0FBNkc7QUFNN0csK0JBQWdJO0FBQ2hJLGlDQUFxRTtBQUNyRSwyQ0FBa0U7QUFFbEUseUNBQTZIO0FBQzdILGlDQUE0QjtBQUM1QixxREFBeUU7QUFDekUseURBQW1EO0FBQ25ELG1DQUFnQztBQUNoQyxtREFBNkg7QUFFN0gsbURBQTZDO0FBQzdDLGlDQUErQjtBQUMvQixtREFBNkQ7QUFJN0Q7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxPQUFnQixFQUFFLE9BQWlCLEVBQUUsdUJBQWlDOztJQUNwRyxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDekMsTUFBTSxNQUFNLEdBQWlCLEVBQUUsQ0FBQztJQUVoQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBRTVDLE1BQU0sQ0FBQyxJQUFJLENBQ1QsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFOztRQUFDLE9BQUE7WUFDOUMsbUNBQW1DO1lBQ25DLEdBQUcsQ0FBQyxNQUFBLFNBQVMsQ0FBQyxNQUFNLG1DQUFJLEVBQUUsQ0FBQztZQUMzQiw2Q0FBNkM7WUFDN0MsR0FBRyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNqRixzQ0FBc0M7WUFDdEMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxPQUFPLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFD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