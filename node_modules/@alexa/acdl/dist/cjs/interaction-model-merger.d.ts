import { Intent, InteractionModel, SlotDefinition, SlotType, TypeValue } from "./interaction-model";
export interface ItemMerger<T> {
    keySelector(item: T): string;
    merge(first: T, second: T): T;
    handleError(first: T, second: T, err: unknown): void;
}
export declare function mergeArrays<T>(first: T[], second: T[], itemMerger: ItemMerger<T>): T[];
/**
 * Merges intents.
 */
declare class IntentMerger implements ItemMerger<Intent> {
    private readonly intentSlotMerger;
    constructor(intentSlotMerger: IntentSlotMerger);
    keySelector(item: Intent): string;
    merge(first: Intent, second: Intent): Intent;
    handleError(first: Intent, _second: Intent, err: Error): void;
}
/**
 * Merges intent slots.
 */
export declare class IntentSlotMerger implements ItemMerger<SlotDefinition> {
    keySelector(item: SlotDefinition): string;
    merge(first: SlotDefinition, second: SlotDefinition): SlotDefinition;
    handleError(first: SlotDefinition, _second: SlotDefinition, err: Error): void;
}
/**
 * Merges slot type values.
 */
export declare class SlotTypeValueMerger implements ItemMerger<TypeValue> {
    keySelector(item: TypeValue): string;
    merge(first: TypeValue, second: TypeValue): TypeValue;
    handleError(first: TypeValue, _second: TypeValue, err: Error): void;
}
/**
 * Merges slot types.
 */
export declare class SlotTypeMerger implements ItemMerger<SlotType> {
    private readonly slotTypeValueMerger;
    static INSTANCE: SlotTypeMerger;
    constructor(slotTypeValueMerger: SlotTypeValueMerger);
    keySelector(item: SlotType): string;
    merge(first: SlotType, second: SlotType): SlotType;
    handleError(first: SlotType, _second: SlotType, err: Error): void;
}
/**
 * Merges two interaction models into one (the second one into the first one).
 *
 * Takes all fields from the first interaction model, except for these which are combined together
 * - `intents`
 *   - `slots` - fails if they differ in `type`
 *     - `samples` - union of both samples
 *   - `samples` - union of both samples
 * - `types` - fails if they differ in `valueSupplier`
 *   - `values` - fails if they differ in `id`
 *     - `synonyms` - union of both synonyms
 *
 * ~~~
 * {
 *   interactionModel: {
 *     languageModel: {
 *       intents: [
 *         {
 *           name: 'intentName',
 *           slots: [
 *             {
 *               name: 'slotName',
 *               samples: [...]
 *             }
 *           ]
 *           samples: [...]
 *         }, ...
 *       ]
 *       types: [
 *         {
 *           name: 'typeName'
 *           values: [
 *             {
 *               name: {
 *                 value: 'valueName',
 *                 synonyms: [...]
 *               }
 *             }
 *           ]
 *         }, ...
 *       ]
 *     }
 *   }
 * }
 * ~~~
 *
 * Intents are merged from both models. If same intent is defined in both models, their slots and samples are merged.
 * If the intent slot types do not match, an error will be raised.
 *
 * Slot types are merged from both models. If same slot type is defined in both models, an error will be raised.
 *
 * Note: The code should be written in a way that when new fields are added, they are preserved.
 */
export declare class InteractionModelMerger {
    private readonly intentMerger;
    private readonly slotTypeMerger;
    static INSTANCE: InteractionModelMerger;
    constructor(intentMerger: IntentMerger, slotTypeMerger: SlotTypeMerger);
    /**
     * Merges two interaction models into one (the second one into the first one).
     *
     * @param first First interaction model data.
     * @param second Second interaction model data.
     * @returns The merged interaction model.
     */
    mergeInteractionModels(first: InteractionModel, second: InteractionModel): InteractionModel;
    private mergeInteractionModelSchemas;
    private mergeLanguageModels;
}
export {};
//# sourceMappingURL=interaction-model-merger.d.ts.map