"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformModule = exports.transformProject = void 0;
const ask = __importStar(require("./ast"));
const visit_1 = require("./visit");
const project_1 = require("./project");
const ast_1 = require("./ast");
const validate_1 = require("./validate");
const get_all_names_1 = require("./get-all-names");
/**
 * Takes in a parsed ACDL {@link Project} and returns a new project with
 * constant expressions transformed into the equivalent {@link ask.Node}.
 *
 * Current transformations are:
 *
 * - `getAllNames<T>(Args<String> namespaces)`
 *
 *
 * Transformations should only be placed here if they need to be completed after
 * parsing the acdl files.
 */
function transformProject(project) {
    const modules = project.source.modules.map((mod) => {
        var _a;
        const transformedModule = mod.content ? transformModule(mod.content, project.getTypeChecker()) : undefined;
        const content = transformedModule === null || transformedModule === void 0 ? void 0 : transformedModule.module;
        const errors = mod.errors ? mod.errors.concat((_a = transformedModule === null || transformedModule === void 0 ? void 0 : transformedModule.errors) !== null && _a !== void 0 ? _a : []) : transformedModule === null || transformedModule === void 0 ? void 0 : transformedModule.errors;
        return {
            ...mod,
            content,
            errors,
        };
    });
    return new project_1.Project({
        config: project.config,
        external: project.external,
        source: {
            ...project.source,
            modules: modules,
        },
    });
}
exports.transformProject = transformProject;
function transformModule(module, checker) {
    var _a;
    const errors = [];
    const expressions = (_a = module.expressions) === null || _a === void 0 ? void 0 : _a.map((expr) => transformNode(expr, checker, errors));
    const exports = expressions === null || expressions === void 0 ? void 0 : expressions.map((e) => { var _a; return e.kind !== "InteractionDeclaration" && ((_a = e === null || e === void 0 ? void 0 : e.name) === null || _a === void 0 ? void 0 : _a.name); }).filter((n) => n !== undefined);
    const mod = new ask.Module(module.uri, module.schema, module.namespace, module.imports, exports, expressions);
    return {
        module: mod,
        errors: errors,
    };
}
exports.transformModule = transformModule;
/**
 * Converts a node into an equivalent {@link ask.Expression}.
 */
function transformNode(node, checker, errors) {
    if (ask.isCall(node)) {
        const apply = checker.getApply(node);
        if (apply === null || apply === void 0 ? void 0 : apply.isGetAllNamesAction()) {
            return transformGetAllNames(node, apply, checker, errors);
        }
    }
    return (0, visit_1.transformEachChild)(node, (child) => transformNode(child, checker, errors));
}
/**
 * Converts a getAllNames action into a {@link ask.ListLiteral}. It searches the namespaces
 * for global name declarations and creates a list of name references that match the
 * generic type of the action.
 *
 * ```
 * namespace company
 *
 * locale1 = Locale.en_US
 * locale2 = Locale.fr_FR
 *
 * getAllNames<Locale>("company")
 *
 * // Will be transformed into:
 * ask.Call(
 *  ask.Name(AlexaSchema.List),
 *  ask.ListLiteral([
 *    ask.ListItem(ask.NameReference("company.locale1")),
 *    ask.ListItem(ask.NameReference("company.locale2")),
 * ]))
 * ```
 */
function transformGetAllNames(node, apply, checker, errors) {
    // Manually validate the getAllNames action
    errors.push(...(0, validate_1.validateCall)(node, checker));
    const nameDecls = (0, get_all_names_1.getAllNames)(apply, checker);
    // nameDecls is undefined when there was a problem with the type system, let this
    // fall through and get caught by later validations.
    if (nameDecls === undefined) {
        return node;
    }
    const items = nameDecls.map((decl, idx) => {
        const nameRef = new ask.NameReference(decl.name);
        return new ask.ListItem(nameRef, idx);
    });
    const list = new ask.ListLiteral(items, node.loc);
    return new ask.Call(new ask.Name(ast_1.AlexaSchema.List), list, node.genericArguments, node.annotations, node.loc);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtLXByb2plY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdHJhbnNmb3JtLXByb2plY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFHN0IsbUNBQTJDO0FBRTNDLHVDQUFrQztBQUNsQywrQkFBa0M7QUFFbEMseUNBQXdDO0FBQ3hDLG1EQUE0QztBQUU1Qzs7Ozs7Ozs7Ozs7R0FXRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLE9BQWdCO0lBQy9DLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFOztRQUNqRCxNQUFNLGlCQUFpQixHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFFM0csTUFBTSxPQUFPLEdBQUcsaUJBQWlCLGFBQWpCLGlCQUFpQix1QkFBakIsaUJBQWlCLENBQUUsTUFBTSxDQUFDO1FBQzFDLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQUEsaUJBQWlCLGFBQWpCLGlCQUFpQix1QkFBakIsaUJBQWlCLENBQUUsTUFBTSxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLGFBQWpCLGlCQUFpQix1QkFBakIsaUJBQWlCLENBQUUsTUFBTSxDQUFDO1FBRTNHLE9BQU87WUFDTCxHQUFHLEdBQUc7WUFDTixPQUFPO1lBQ1AsTUFBTTtTQUNQLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sSUFBSSxpQkFBTyxDQUFDO1FBQ2pCLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtRQUN0QixRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVE7UUFDMUIsTUFBTSxFQUFFO1lBQ04sR0FBRyxPQUFPLENBQUMsTUFBTTtZQUNqQixPQUFPLEVBQUUsT0FBTztTQUNqQjtLQUNGLENBQUMsQ0FBQztBQUNMLENBQUM7QUF0QkQsNENBc0JDO0FBRUQsU0FBZ0IsZUFBZSxDQUM3QixNQUFrQixFQUNsQixPQUFvQjs7SUFLcEIsTUFBTSxNQUFNLEdBQWlCLEVBQUUsQ0FBQztJQUNoQyxNQUFNLFdBQVcsR0FBRyxNQUFBLE1BQU0sQ0FBQyxXQUFXLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM1RixNQUFNLE9BQU8sR0FBRyxXQUFXLGFBQVgsV0FBVyx1QkFBWCxXQUFXLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsV0FBQyxPQUFBLENBQUMsQ0FBQyxJQUFJLEtBQUssd0JBQXdCLEtBQUksTUFBQSxDQUFDLGFBQUQsQ0FBQyx1QkFBRCxDQUFDLENBQUUsSUFBSSwwQ0FBRSxJQUFJLENBQUEsQ0FBQSxFQUFBLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFhLENBQUM7SUFDekksTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzlHLE9BQU87UUFDTCxNQUFNLEVBQUUsR0FBRztRQUNYLE1BQU0sRUFBRSxNQUFNO0tBQ2YsQ0FBQztBQUNKLENBQUM7QUFmRCwwQ0FlQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxhQUFhLENBQXFCLElBQU8sRUFBRSxPQUFvQixFQUFFLE1BQW9CO0lBQzVGLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNwQixNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJDLElBQUksS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLG1CQUFtQixFQUFFLEVBQUU7WUFDaEMsT0FBTyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQU0sQ0FBQztTQUNoRTtLQUNGO0lBRUQsT0FBTyxJQUFBLDBCQUFrQixFQUFDLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwRixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNILFNBQVMsb0JBQW9CLENBQUMsSUFBYyxFQUFFLEtBQVksRUFBRSxPQUFvQixFQUFFLE1BQW9CO0lBQ3BHLDJDQUEyQztJQUMzQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBQSx1QkFBWSxFQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBRTVDLE1BQU0sU0FBUyxHQUFHLElBQUEsMkJBQVcsRUFBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFOUMsaUZBQWlGO0lBQ2pGLG9EQUFvRDtJQUNwRCxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7UUFDM0IsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE1BQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDeEMsTUFBTSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqRCxPQUFPLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDeEMsQ0FBQyxDQUFDLENBQUM7SUFDSCxNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsRCxPQUFPLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQy9HLENBQUMifQ==