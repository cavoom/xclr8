"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSkillCallContext = exports.validateTrackActions = exports.validateSaveContextAction = exports.validateLoadContextAction = exports.validateSkillLocale = exports.validateEnsureArgOrder = exports.validateSkillPolicy = exports.validateSkill = void 0;
const path = __importStar(require("path"));
const immutable = __importStar(require("immutable"));
const checker_1 = require("./checker");
const evaluate_1 = require("./evaluate");
const flow_1 = require("./flow");
const skill_context_1 = require("./skill-context");
const evaluation_state_1 = require("./evaluation-state");
const visit_1 = require("./visit");
const error_factory_1 = require("./error-factory");
/**
 * Validates a com.amazon.alexa.ask.conversations.skill data structure.
 *
 * 1. It must contain a list of Dialogs with at least one item.
 * 2. If taskContextProjectionInfo is specified, then its contents must be valid. (see validateSki)
 */
function validateSkill(skill, checker) {
    const errors = [];
    const skillContext = (0, skill_context_1.loadSkillContext)(skill);
    errors.push(...validateLoadContextAction(skillContext), ...validateSaveContextAction(skillContext), ...validateTrackActions(skillContext));
    const dialogs = checker.project.getRootDialogs();
    if (dialogs === undefined || dialogs.length === 0) {
        const dialogsArray = skill.getArgumentValueThing("dialogs");
        if (dialogsArray !== undefined) {
            // if dialogs array exist, report this error on dialog array loc
            errors.push(error_factory_1.ValidationErrorFactory.NoDialogsInSkill({
                expr: dialogsArray.origin,
            }));
        }
        else {
            errors.push(error_factory_1.ValidationErrorFactory.NoDialogsInSkill());
        }
    }
    else {
        for (const rootDialog of dialogs) {
            const flow = new flow_1.Flow(new checker_1.TypeChecker(skill.checker.project), rootDialog, undefined, []);
            errors.push(...(0, evaluate_1.evaluateDialogFlow)(flow, new evaluation_state_1.EvaluationState(skillContext)));
        }
    }
    // validate skill locales
    errors.push(...validateSkillLocale(skill, checker));
    // validate skill policies
    errors.push(...validateSkillPolicy(skill, checker));
    return errors;
}
exports.validateSkill = validateSkill;
/**
 * validate the policy info in the skill action
 * 1. make sure there's no ResetArguments and ResetAllArguments point to the same api
 * 2. make sure the EnsureArgOrder policy not conflict
 * @param skill
 * @param checker
 * @returns
 */
function validateSkillPolicy(skill, checker) {
    const errors = [];
    const policies = skill.getArgumentValueThing("policies");
    const policyItems = (policies === null || policies === void 0 ? void 0 : policies.isList()) && policies.isLiteral() ? policies.getListItems() : [];
    const actionsUsedInResetAllArguments = new Map();
    // first loop: record action names used in ResetAllArguments policies
    policyItems === null || policyItems === void 0 ? void 0 : policyItems.forEach((item) => {
        var _a, _b, _c, _d, _e;
        const itemThing = checker.getThing(item);
        if ((_a = itemThing === null || itemThing === void 0 ? void 0 : itemThing.apply) === null || _a === void 0 ? void 0 : _a.isResetAllArguments()) {
            const actionThing = itemThing.getProperty("action");
            if (actionThing === null || actionThing === void 0 ? void 0 : actionThing.isAction()) {
                if (checker.isNameReference(item === null || item === void 0 ? void 0 : item.item)) {
                    // if the item is a nameReference, record the nameReference's name for better error message
                    actionsUsedInResetAllArguments.set((_b = actionThing.name) === null || _b === void 0 ? void 0 : _b.name, (_d = (_c = item === null || item === void 0 ? void 0 : item.item) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name);
                }
                else {
                    actionsUsedInResetAllArguments.set((_e = actionThing.name) === null || _e === void 0 ? void 0 : _e.name, undefined);
                }
            }
        }
    });
    // second loop: check all ResetArguments type policy doesn't use action which already use ResetAllArguments policy
    policyItems === null || policyItems === void 0 ? void 0 : policyItems.forEach((item) => {
        var _a, _b, _c, _d, _e;
        const itemThing = checker.getThing(item);
        if ((_a = itemThing === null || itemThing === void 0 ? void 0 : itemThing.apply) === null || _a === void 0 ? void 0 : _a.isResetArguments()) {
            const argumentsValueThing = itemThing.getProperty("arguments");
            if ((argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.isLiteral()) && argumentsValueThing.isList()) {
                const items = argumentsValueThing.getItems();
                if (items && items.length >= 1 && ((_d = (_c = (_b = items[0]) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.isAction())) {
                    const actionName = (_e = items[0].parent.parent.name) === null || _e === void 0 ? void 0 : _e.name;
                    if (actionsUsedInResetAllArguments.has(actionName)) {
                        const policyName = actionsUsedInResetAllArguments.get(actionName);
                        const errorArguments = {
                            expr: item === null || item === void 0 ? void 0 : item.item,
                            attributes: {
                                actionName,
                                policyName,
                            },
                        };
                        errors.push(policyName !== undefined
                            ? error_factory_1.ValidationErrorFactory.InvalidPolicyWithPolicyName(errorArguments)
                            : error_factory_1.ValidationErrorFactory.InvalidPolicy(errorArguments));
                    }
                }
            }
        }
    });
    errors.push(...validateEnsureArgOrder(policies, checker));
    return errors;
}
exports.validateSkillPolicy = validateSkillPolicy;
/**
 * validate the EnsureArgOrder policies are not conflict
 *
 * E.G. Below is a invalid case where we can't figure out the order of 'cityName' and 'date'
 * ```
 * EnsureArgOrder(getWeather.arguments.cityName, getWeather.arguments.date)
 * EnsureArgOrder(getWeather.arguments.date, getWeather.arguments.cityName)
 * ```
 *
 * Feature request link: https://github.com/alexa/ask-ac/issues/554
 * @param policyItems
 * @param checker
 * @returns
 */
function validateEnsureArgOrder(policies, checker) {
    var _a, _b, _c, _d, _e, _f;
    const errors = [];
    const policyItems = (_b = (_a = policies === null || policies === void 0 ? void 0 : policies.asLiteralList()) === null || _a === void 0 ? void 0 : _a.getItems()) !== null && _b !== void 0 ? _b : [];
    if (policyItems === undefined || policyItems.length === 0) {
        return errors;
    }
    // go through all the EnsureArgOrder policy and build the order graph
    const parentToChild = new Map();
    // record the token to Argument Thing, this map is used to provide better error message
    const tokenToArgumentThing = new Map();
    for (const policyItem of policyItems) {
        if ((_c = policyItem === null || policyItem === void 0 ? void 0 : policyItem.apply) === null || _c === void 0 ? void 0 : _c.isEnsureArgOrder()) {
            const argumentsValueThing = policyItem.getProperty("arguments");
            const items = (_e = (_d = argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.asLiteralList()) === null || _d === void 0 ? void 0 : _d.getItems()) !== null && _e !== void 0 ? _e : [];
            if (items && items.length >= 2) {
                for (let i = 0; i < items.length - 1; i++) {
                    const curItem = items[i];
                    const nextItem = items[i + 1];
                    if (curItem === undefined || nextItem === undefined || !curItem.isArgument() || !nextItem.isArgument()) {
                        // If the item in the array is not valid, skip this validation
                        return errors;
                    }
                    if (!parentToChild.has(curItem.token)) {
                        parentToChild.set(curItem.token, [nextItem]);
                        tokenToArgumentThing.set(curItem.token, curItem);
                    }
                    else {
                        (_f = parentToChild.get(curItem.token)) === null || _f === void 0 ? void 0 : _f.push(nextItem);
                    }
                }
            }
        }
    }
    // check each node in the graph to make sure there's no circular reference
    // memo is used to record visited node's circular reference info thus we could avoid revisit same node again
    const memo = new Map();
    for (const token of parentToChild.keys()) {
        if (!memo.has(token)) {
            const circularReference = findCircularReference(token, immutable.Set());
            const circularReferenceArgsFlow = circularReference === null || circularReference === void 0 ? void 0 : circularReference.map((token) => {
                var _a;
                const argThing = tokenToArgumentThing.get(token);
                return `'${(_a = argThing === null || argThing === void 0 ? void 0 : argThing.action) === null || _a === void 0 ? void 0 : _a.actionName}.arguments.${argThing === null || argThing === void 0 ? void 0 : argThing.argumentName}'`;
            });
            if (circularReferenceArgsFlow !== undefined && circularReferenceArgsFlow.length > 0) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidEnsureArgOrder({
                    expr: policies,
                    attributes: {
                        firstArgument: circularReferenceArgsFlow[0],
                        argumentsFlow: circularReferenceArgsFlow.join("-->"),
                    },
                }));
            }
        }
    }
    return errors;
    // DFS to find circular reference for a node
    function findCircularReference(start, seen) {
        if (seen.has(start)) {
            memo.set(start, true);
            return generateCircularReferenceFlow(seen, start);
        }
        seen = seen.add(start);
        const children = parentToChild.get(start);
        if (children === undefined || children.length === 0) {
            seen = seen.delete(start);
            memo.set(start, false);
            return undefined;
        }
        for (const child of children) {
            // we don't want to report same circle again, thus no matter this token has circularReference or not,
            // if we have handled the token already, we could skip
            if (!memo.has(child.token)) {
                const circularReference = findCircularReference(child.token, seen);
                if (circularReference !== undefined) {
                    memo.set(start, true);
                    return circularReference;
                }
            }
        }
        seen = seen.delete(start);
        memo.set(start, false);
        return undefined;
    }
}
exports.validateEnsureArgOrder = validateEnsureArgOrder;
function generateCircularReferenceFlow(seen, duplicateToken) {
    const circularReferenceFlow = [];
    let findDuplicate = false;
    seen.forEach((token) => {
        if (!findDuplicate) {
            if (token === duplicateToken) {
                findDuplicate = true;
                circularReferenceFlow.push(token);
            }
        }
        else {
            circularReferenceFlow.push(token);
        }
    });
    circularReferenceFlow.push(duplicateToken);
    return circularReferenceFlow;
}
/**
 * validate the locale info in the skill action
 * 1. There must exist deployable dialog for all specified locales
 * 2. There must exist InteractionModel for all specified locales
 * 3. At least one locale need to be specified for a skill
 * 4. The samples in a dialog must have all required locales for the dialog
 * 5. All the nameRef used in a sample must support all the locales the sample use
 * @param skill
 * @param checker
 * @returns
 */
function validateSkillLocale(skill, checker) {
    var _a;
    const errors = [];
    const dialogs = skill.getArgumentValueThing("dialogs");
    const locales = skill.getArgumentValueThing("locales");
    const skillResponses = skill.getArgumentValueThing("skillLevelResponses");
    const dialogItems = (_a = checker.project.getRootDialogs()) === null || _a === void 0 ? void 0 : _a.map((dialogDecl) => checker.getThing(dialogDecl));
    const localeItems = (locales === null || locales === void 0 ? void 0 : locales.isList()) && locales.isLiteral() ? locales.getItems() : [];
    if (localeItems !== undefined && localeItems.length > 0) {
        // record required locales set by reading the all the localeItems in the locale list
        const requiredLocales = new Set(localeItems
            .map((locale) => {
            var _a;
            if (((_a = locale === null || locale === void 0 ? void 0 : locale.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name" && locale.origin.name) {
                return locale.origin.name;
            }
            return undefined;
        })
            .filter((s) => s !== undefined));
        errors.push(...validateDialogLocale(requiredLocales, dialogItems));
        errors.push(...validateSkillResponseLocale(requiredLocales, skillResponses, checker));
        errors.push(...validateInteractionModelLocale(requiredLocales, checker));
        errors.push(...validateModuleScopeNameDeclarationsLocale(requiredLocales, checker));
    }
    else {
        errors.push(error_factory_1.ValidationErrorFactory.MissingLocale({
            expr: locales === null || locales === void 0 ? void 0 : locales.origin,
        }));
    }
    return errors;
    /**
     * validate all nameDecls' locale info under module scope
     * make sure the slotType used in nameDecl is consistent with locale annotations
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM
     * ```
     * @locale(Locale.en_US)
     * a = apla<deOnlySlot>("./apla")
     *
     * This is invalid because deOnlySlot not exist in en_US IM, but the locale annotation include en_US
     * ```
     *
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     *
     * @locale(Locale.en_US)
     * a = utterances<myType>([
     *   "hello world"
     * ])
     *
     * This is invalid because myType use slotType deOnlySlot which does not exist in en_US IM, but the locale annotation include en_US
     * ```
     */
    function validateModuleScopeNameDeclarationsLocale(defaultLocales, checker) {
        const errors = [];
        const nameDecls = checker.getAllModuleScopeNameDeclarations();
        for (const nameDecl of nameDecls) {
            const annotatedLocales = checker.collectLocaleInfo(nameDecl);
            if (annotatedLocales.length === 0) {
                // if no locale annotation, default to skill action's locale config
                defaultLocales.forEach((locale) => annotatedLocales.push(locale));
            }
            (0, visit_1.visitEachChild)(nameDecl, function visit(node) {
                if (node.kind === "TypeReference") {
                    const thing = checker.getThing(node);
                    errors.push(...validateTypeAgainstRequiredLocales(thing === null || thing === void 0 ? void 0 : thing.type, annotatedLocales, node));
                }
                (0, visit_1.visitEachChild)(node, visit);
            });
        }
        return errors;
    }
    /**
     * check whether the type depends on any slotType which not exist in the IM for required locales
     * E.G.
     * ```
     * type myType {
     *  optional deOnlySlot german
     * }
     *
     * validateTypeAgainstRequiredLocales(myType) will check deOnlySlot exist in all the required locales' IM
     * ```
     *
     * ```
     * type myType2 {
     *  myType name
     * }
     *
     * validateTypeAgainstRequiredLocales(myType2) will check deOnlySlot exist in all the required locales' IM
     * ```
     * @param type The type which we want to check whether it contains invalid slotType
     * @param requiredLocales The Array lof all required locales, a used slotType must exist in all corresponding IMs
     * @param node The origin node where depends on this type, thus we could use it's loc to report error
     * @returns
     */
    function validateTypeAgainstRequiredLocales(type, requiredLocales, node) {
        var _a, _b, _c;
        const errors = [];
        const seen = new Set();
        if (type === null || type === void 0 ? void 0 : type.isSlotType()) {
            errors.push(...validateSlotTypeAgainstRequiredLocales(type.declaration, requiredLocales, node));
        }
        else if (type === null || type === void 0 ? void 0 : type.properties) {
            for (const property of type.properties) {
                if (((_b = (_a = property.type) === null || _a === void 0 ? void 0 : _a.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "SlotType") {
                    errors.push(...validateSlotTypeAgainstRequiredLocales((_c = property.type) === null || _c === void 0 ? void 0 : _c.declaration, requiredLocales, node));
                }
                else {
                    (0, visit_1.visitEachChildType)(property.type, function checkSlotType(type) {
                        if (type.declaration && !seen.has(type.declaration)) {
                            if (!(type.isOptional() || type.isList())) {
                                seen.add(type.declaration);
                            }
                            if (type.declaration.kind === "SlotType") {
                                errors.push(...validateSlotTypeAgainstRequiredLocales(type === null || type === void 0 ? void 0 : type.declaration, requiredLocales, node));
                            }
                            (0, visit_1.visitEachChildType)(type, checkSlotType);
                        }
                    });
                }
            }
        }
        return errors;
    }
    /**
     * check whether the SlotType exist in the IM for required locales
     * @param slotType
     * @param requiredLocales
     * @param node
     * @returns
     */
    function validateSlotTypeAgainstRequiredLocales(slotType, requiredLocales, node) {
        var _a, _b, _c, _d;
        const errors = [];
        const thing = checker.getThing(node);
        const availableLocales = slotType.locales;
        for (const requiredLocale of requiredLocales) {
            if (!availableLocales.includes(requiredLocale) && node.inferred !== true) {
                ((_a = thing === null || thing === void 0 ? void 0 : thing.type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType"
                    ? errors.push(error_factory_1.ValidationErrorFactory.MissingSlotTypeForLocale({
                        expr: node,
                        attributes: {
                            slotTypeName: (_b = slotType.name) === null || _b === void 0 ? void 0 : _b.name,
                            locale: requiredLocale,
                        },
                    }))
                    : errors.push(error_factory_1.ValidationErrorFactory.MissingSlotTypeForLocaleTypeDependency({
                        expr: node,
                        attributes: {
                            typeName: (_c = node.name) === null || _c === void 0 ? void 0 : _c.name,
                            slotTypeName: (_d = slotType.name) === null || _d === void 0 ? void 0 : _d.name,
                            locale: requiredLocale,
                        },
                    }));
            }
        }
        return errors;
    }
    function validateSkillResponseLocale(requiredLocales, skillResponses, checker) {
        const errors = [];
        if (skillResponses === null || skillResponses === void 0 ? void 0 : skillResponses.isLiteral()) {
            const args = skillResponses.apply.getArguments();
            if (args !== undefined) {
                Object.entries(args).map(([name, arg]) => {
                    var _a, _b;
                    if (((_a = arg.value) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = arg.value) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                        const locales = checker.collectLocaleInfo(arg.value);
                        // if there's no locale info, assume this prompt will be applied to all specified locales
                        // if locale info exist, make sure all required locales exist
                        if (locales.length > 0) {
                            const localesSet = new Set(locales);
                            requiredLocales.forEach((requiredLocale) => {
                                if (requiredLocale && !localesSet.has(requiredLocale)) {
                                    errors.push(error_factory_1.ValidationErrorFactory.MissingSkillResponseForLocale({
                                        expr: arg === null || arg === void 0 ? void 0 : arg.value,
                                        attributes: {
                                            skillResponseName: name,
                                            locale: requiredLocale,
                                        },
                                    }));
                                }
                            });
                        }
                    }
                });
            }
        }
        return errors;
    }
    /**
     * validate all of required locales has corresponding IM
     */
    function validateInteractionModelLocale(requiredLocales, checker) {
        var _a;
        const errors = [];
        const interactionModelsPath = checker.project.source.interactionModels;
        // parse the locales from the file names
        const availableLocales = new Set((_a = interactionModelsPath === null || interactionModelsPath === void 0 ? void 0 : interactionModelsPath.map((interactionModel) => path.parse(interactionModel.file).name.replace("-", "_"))) !== null && _a !== void 0 ? _a : []);
        for (const requiredLocale of requiredLocales) {
            if (requiredLocale && !availableLocales.has(requiredLocale)) {
                errors.push(error_factory_1.ValidationErrorFactory.MissingInteractionModelForLocale({
                    expr: locales === null || locales === void 0 ? void 0 : locales.origin,
                    attributes: {
                        locale: requiredLocale,
                    },
                }));
            }
        }
        return errors;
    }
    /**
     * all the required locales must have at least one dialog in the skill
     * @param requiredLocales A set which record all required locales (the locales used in skill action)
     * @param dialogItems dialog Thing array
     * @returns
     */
    function validateDialogLocale(requiredLocales, dialogItems) {
        const errors = [];
        const availableLocales = new Set();
        // record available locales set by go through all the deployable dialogs and read from locale annotations
        dialogItems === null || dialogItems === void 0 ? void 0 : dialogItems.forEach((dialog) => {
            if (dialog === null || dialog === void 0 ? void 0 : dialog.isDialog()) {
                const dialogLocales = new Set();
                const locales = recordLocalesFromAnnotations(dialog.origin.annotations, requiredLocales);
                locales.forEach((locale) => dialogLocales.add(locale));
                // go through all the samples and make sure all the dialogLocales exist
                errors.push(...validateSampleLocale(dialogLocales, dialog));
                dialogLocales.forEach((locale) => availableLocales.add(locale));
            }
        });
        // loop each required locale, and check if any deployable dialog use the locale
        requiredLocales.forEach((locale) => {
            if (!availableLocales.has(locale)) {
                errors.push(error_factory_1.ValidationErrorFactory.NoDeployableDialogForLocale({
                    expr: dialogs === null || dialogs === void 0 ? void 0 : dialogs.origin,
                    attributes: {
                        locale,
                    },
                }));
            }
        });
        return errors;
    }
    /**
     * for all the locales used for the dialog, there must exist at least one sample in the dialog use that locale
     * @param dialogLocales A set which record all the locales for the dialog
     * @param dialog dialog Thing
     * @returns
     */
    function validateSampleLocale(dialogLocales, dialog) {
        var _a;
        const errors = [];
        const sampleLocales = new Set();
        (_a = dialog.origin.samples) === null || _a === void 0 ? void 0 : _a.forEach((sample) => {
            const locales = recordLocalesFromAnnotations(sample.annotations, dialogLocales);
            errors.push(...validateSampleExprLocale(locales, sample));
            locales.forEach((locale) => sampleLocales.add(locale));
        });
        // loop each required locale, and check if any deployable dialog use the locale
        dialogLocales.forEach((locale) => {
            var _a;
            if (!sampleLocales.has(locale)) {
                errors.push(error_factory_1.ValidationErrorFactory.MissingSampleForLocale({
                    expr: dialog === null || dialog === void 0 ? void 0 : dialog.origin,
                    attributes: {
                        dialogName: (_a = dialog.origin.name) === null || _a === void 0 ? void 0 : _a.name,
                        locale,
                    },
                }));
            }
        });
        return errors;
    }
    /**
     * validate all nameReference used in a sample must support all the locales the sample support
     * E.G.
     * ```
     * @locale(Locale.en_US)
     * getWeatherEventUS = utterances<CityAndDate>(["xxx"])
     *
     * @locale(Locale.en_GB)
     * dialog Nothing WeatherInGerman {
     *     @locale(Locale.en_GB)
     *     sample {
     *         // This is invalid as getWeatherEventUS only support en_US without en_GB
     *         result = expect(Invoke, getWeatherEventUS)
     *     }
     * }
     * ```
     * @param sampleLocales The locales sample support
     * @param sample
     * @returns
     */
    function validateSampleExprLocale(sampleLocales, sample) {
        var _a, _b;
        const errors = [];
        (_b = (_a = sample.scope) === null || _a === void 0 ? void 0 : _a.expressions) === null || _b === void 0 ? void 0 : _b.forEach((expr) => {
            errors.push(...validateNodeAgainstRequiredLocales(expr, sampleLocales));
            (0, visit_1.visitEachChild)(expr, function visit(node) {
                errors.push(...validateNodeAgainstRequiredLocales(node, sampleLocales));
                (0, visit_1.visitEachChild)(node, visit);
            });
        });
        return errors;
    }
    /**
     * Validate all the node against all the required locales,
     * make sure the node doesn't depend on slotTypes which can't be used in the required locales
     *
     * @param node
     * @param requiredLocales
     * @returns
     */
    function validateNodeAgainstRequiredLocales(node, requiredLocales) {
        var _a;
        const errors = [];
        if (node.kind === "NameReference" || node.kind === "PropertyReference") {
            const locales = checker.collectLocaleInfo(node);
            // if locales is empty, then the locale will be default to skill actions' locale array
            // which means this name support all the locales we want to deploy, and thus no need to do the validations
            if (locales.length > 0) {
                requiredLocales.forEach((requiredLocale) => {
                    var _a;
                    if (requiredLocale && !locales.includes(requiredLocale)) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidLocaleInSampleNameOrProperty({
                            expr: node,
                            attributes: {
                                name: (_a = node.name) === null || _a === void 0 ? void 0 : _a.name,
                                locale: requiredLocale,
                            },
                        }));
                    }
                });
            }
        }
        else if (node.kind === "Call") {
            const apply = checker.getApply(node);
            const decl = apply === null || apply === void 0 ? void 0 : apply.decl;
            if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration" || (decl === null || decl === void 0 ? void 0 : decl.kind) === "DialogDeclaration") {
                const thing = checker.getThing(decl);
                if (((thing === null || thing === void 0 ? void 0 : thing.isAction()) && (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi())) || (thing === null || thing === void 0 ? void 0 : thing.isDialog())) {
                    const locales = thing.getLocales();
                    if (locales) {
                        requiredLocales.forEach((requiredLocale) => {
                            var _a;
                            if (requiredLocale && !locales.includes(requiredLocale)) {
                                const name = (_a = thing.name) === null || _a === void 0 ? void 0 : _a.name;
                                if (thing.isDialog()) {
                                    errors.push(error_factory_1.ValidationErrorFactory.InvalidLocaleInSampleDialog({
                                        expr: node,
                                        attributes: {
                                            dialogName: name,
                                            locale: requiredLocale,
                                        },
                                    }));
                                }
                                else {
                                    errors.push(error_factory_1.ValidationErrorFactory.InvalidLocaleInSampleAction({
                                        expr: node,
                                        attributes: {
                                            actionName: name,
                                            locale: requiredLocale,
                                        },
                                    }));
                                }
                            }
                        });
                    }
                }
            }
            else if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "Type") {
                const locales = decl.getLocales();
                if (locales) {
                    requiredLocales.forEach((requiredLocale) => {
                        var _a;
                        if (requiredLocale && !locales.includes(requiredLocale)) {
                            errors.push(error_factory_1.ValidationErrorFactory.InvalidLocaleInSampleType({
                                expr: node,
                                attributes: {
                                    typeName: (_a = decl.name) === null || _a === void 0 ? void 0 : _a.name,
                                    locale: requiredLocale,
                                },
                            }));
                        }
                    });
                }
            }
        }
        else if (node.kind === "TypeReference") {
            const locales = (_a = checker.getType(node)) === null || _a === void 0 ? void 0 : _a.getLocales();
            if (locales) {
                requiredLocales.forEach((requiredLocale) => {
                    var _a;
                    if (requiredLocale && !locales.includes(requiredLocale)) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidLocaleInSampleType({
                            expr: node,
                            attributes: {
                                typeName: (_a = node.name) === null || _a === void 0 ? void 0 : _a.name,
                                locale: requiredLocale,
                            },
                        }));
                    }
                });
            }
        }
        return errors;
    }
    /**
     * Update the locale set based on the annotations
     * @param locales locale set which need to be updated based on locale annotation
     * @param annotations annotations array
     * @param defaultLocales the default locale set, which will be used when there's no locale annotation available
     */
    function recordLocalesFromAnnotations(annotations, defaultLocales) {
        let localeAnnotationExist = false;
        const locales = new Set();
        annotations === null || annotations === void 0 ? void 0 : annotations.forEach((ann) => {
            if (ann.kind === "Annotation" && ann.call.kind === "Call") {
                const apply = checker.getApply(ann.call);
                if (apply === null || apply === void 0 ? void 0 : apply.isLocaleAction()) {
                    localeAnnotationExist = true;
                    const annLocales = apply.getArgumentValueThing("locales");
                    if ((annLocales === null || annLocales === void 0 ? void 0 : annLocales.isList()) && annLocales.isLiteral()) {
                        const annLocaleItems = annLocales.getItems();
                        if (annLocaleItems !== undefined && annLocaleItems.length > 0) {
                            annLocaleItems.forEach((locale) => {
                                var _a;
                                if (((_a = locale === null || locale === void 0 ? void 0 : locale.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name") {
                                    locales.add(locale.origin.name);
                                }
                            });
                        }
                    }
                }
            }
        });
        if (!localeAnnotationExist) {
            // if there no locale annotation
            // fill the locales with default locales
            defaultLocales.forEach((locale) => locales.add(locale));
        }
        return locales;
    }
}
exports.validateSkillLocale = validateSkillLocale;
/**
 * Validate the `loadContext` action configured in a TaskContextProjectionInfo.
 *
 * 1. it cannot accept any arguments
 * 2. it cannot have any generic arguments
 * 3. the return type must be `com.amazon.alexa.ask.conversations.TaskContextProjection`.
 * 4. it must be a user-defined action and not a built-in action.
 */
function validateLoadContextAction(context) {
    var _a, _b, _c, _d, _e;
    const errors = [];
    const expr = ((_a = context === null || context === void 0 ? void 0 : context.loadContextDeclaration) === null || _a === void 0 ? void 0 : _a.loc) ? context === null || context === void 0 ? void 0 : context.loadContextDeclaration : context === null || context === void 0 ? void 0 : context.skill.call;
    if (context === null || context === void 0 ? void 0 : context.loadContext) {
        const actionName = (_b = context.loadContext.name) === null || _b === void 0 ? void 0 : _b.name;
        if ((_c = context.loadContext.arguments) === null || _c === void 0 ? void 0 : _c.length) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidLoadContextActionArguments({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        if ((_d = context.loadContext.genericArguments) === null || _d === void 0 ? void 0 : _d.length) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidLoadContextActionGenericArguments({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        const returnType = context.loadContext.returnType
            ? context.skill.checker.getType(context.loadContext.returnType)
            : context.skill.checker.void;
        if (returnType && !returnType.isTaskContextProjection()) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidLoadContextActionReturnType({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
    }
    else if ((_e = context === null || context === void 0 ? void 0 : context.loadContextThing) === null || _e === void 0 ? void 0 : _e.isNothing()) {
        errors.push(error_factory_1.ValidationErrorFactory.InvalidLoadContextActionNoActionReference({
            expr,
        }));
    }
    return errors;
}
exports.validateLoadContextAction = validateLoadContextAction;
/**
 * Validate the `saveContext` action configured in a TaskContextProjectionInfo.
 *
 * 1. it cannot have any generic arguments.
 * 2. the return type must be `Nothing` or `Void`.
 * 3. it must have exactly one argument of type `TaskContextProjection`.
 * 4. it must be a user-defined action and not a built-in.
 */
function validateSaveContextAction(context) {
    var _a, _b, _c, _d, _e;
    const errors = [];
    const expr = ((_a = context === null || context === void 0 ? void 0 : context.saveContextDeclaration) === null || _a === void 0 ? void 0 : _a.loc) ? context === null || context === void 0 ? void 0 : context.saveContextDeclaration : context === null || context === void 0 ? void 0 : context.skill.call;
    if (context === null || context === void 0 ? void 0 : context.saveContext) {
        const actionName = (_b = context.saveContext.name) === null || _b === void 0 ? void 0 : _b.name;
        if ((_c = context.saveContext.genericArguments) === null || _c === void 0 ? void 0 : _c.length) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidSaveContextActionGenericArguments({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        const returnType = (_d = context.skill.checker.getType(context.saveContext)) === null || _d === void 0 ? void 0 : _d.getTypeType();
        if (returnType && !((returnType === null || returnType === void 0 ? void 0 : returnType.isVoid()) || (returnType === null || returnType === void 0 ? void 0 : returnType.isNothing()))) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidSaveContextActionReturnType({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        if (context.saveContext.arguments === undefined ||
            context.saveContext.arguments.length === 0 ||
            context.saveContext.arguments.length > 1) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidSaveContextActionArgumentType({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        else {
            const argType = context.skill.checker.getType(context.saveContext.arguments[0]);
            if (argType && !argType.isTaskContextProjection()) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidSaveContextActionArgumentType({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
        }
    }
    else if ((_e = context === null || context === void 0 ? void 0 : context.saveContextThing) === null || _e === void 0 ? void 0 : _e.isNothing()) {
        errors.push(error_factory_1.ValidationErrorFactory.InvalidSaveContextActionNoActionReference({
            expr,
        }));
    }
    return errors;
}
exports.validateSaveContextAction = validateSaveContextAction;
/**
 * Validates the `trackActions` field configured in `TaskContextProjectionInfo`.
 *
 * 1. the list cannot be empty
 * 2. an action in the list cannot be the `loadContext` or the `saveContext` action.
 * 3. it must be a user-defined API and not a built-in action.
 */
function validateTrackActions(context) {
    var _a, _b;
    const errors = [];
    if (context) {
        const { checker } = context.skill;
        const expr = context.trackActionsDeclaration ? context.trackActionsDeclaration : context.skill.call;
        if (((_a = context.trackActions) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidTrackActionsEmptyList({
                expr,
            }));
        }
        (_b = context.trackActions) === null || _b === void 0 ? void 0 : _b.forEach((action) => {
            var _a, _b, _c, _d, _e, _f;
            const actionFqn = checker.qualifyName(action, (_a = action.name) === null || _a === void 0 ? void 0 : _a.name);
            const actionName = (_b = action.name) === null || _b === void 0 ? void 0 : _b.name;
            if (actionFqn === ((_d = (_c = context.loadContext) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name)) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidTrackActionsLoadContext({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
            else if (actionFqn === ((_f = (_e = context.saveContext) === null || _e === void 0 ? void 0 : _e.name) === null || _f === void 0 ? void 0 : _f.name)) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidTrackActionsSaveContext({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
            const actionType = context.skill.checker.getType(action);
            if (actionType && !actionType.isCustom()) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidTrackActionsBuiltIn({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
        });
    }
    return errors;
}
exports.validateTrackActions = validateTrackActions;
/**
 * Validates the context of a call to `com.amazon.alexa.ask.conversations.skill`.
 *
 * 1. the result of the call must be assigned to a name, e.g. `name = skill(..)`.
 * 2. the call can only exist at the module scope, it cannot be within a dialog sample.
 */
function validateSkillCallContext(skill) {
    if (skill.isSkillAction()) {
        if (skill.call.context.kind !== "NameDeclaration") {
            return [
                error_factory_1.ValidationErrorFactory.InvalidSkillCallContextNameDeclaration({
                    expr: skill.call,
                }),
            ];
        }
        if (skill.call.context.context.kind !== "Module") {
            return [
                error_factory_1.ValidationErrorFactory.InvalidSkillCallContextModuleScope({
                    expr: skill.call,
                }),
            ];
        }
    }
    return [];
}
exports.validateSkillCallContext = validateSkillCallContext;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtc2tpbGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdmFsaWRhdGUtc2tpbGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFDN0IscURBQXVDO0FBS3ZDLHVDQUFzQztBQUV0Qyx5Q0FBOEM7QUFDOUMsaUNBQTRCO0FBQzVCLG1EQUErRDtBQUUvRCx5REFBbUQ7QUFDbkQsbUNBQTJEO0FBRTNELG1EQUFvRjtBQUVwRjs7Ozs7R0FLRztBQUNILFNBQWdCLGFBQWEsQ0FBQyxLQUFZLEVBQUUsT0FBb0I7SUFDOUQsTUFBTSxNQUFNLEdBQWlCLEVBQUUsQ0FBQztJQUVoQyxNQUFNLFlBQVksR0FBRyxJQUFBLGdDQUFnQixFQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTdDLE1BQU0sQ0FBQyxJQUFJLENBQ1QsR0FBRyx5QkFBeUIsQ0FBQyxZQUFZLENBQUMsRUFDMUMsR0FBRyx5QkFBeUIsQ0FBQyxZQUFZLENBQUMsRUFDMUMsR0FBRyxvQkFBb0IsQ0FBQyxZQUFZLENBQUMsQ0FDdEMsQ0FBQztJQUVGLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7SUFFakQsSUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2pELE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM1RCxJQUFJLFlBQVksS0FBSyxTQUFTLEVBQUU7WUFDOUIsZ0VBQWdFO1lBQ2hFLE1BQU0sQ0FBQyxJQUFJLENBQ1Qsc0NBQXNCLENBQUMsZ0JBQWdCLENBQUM7Z0JBQ3RDLElBQUksRUFBRSxZQUFZLENBQUMsTUFBTTthQUMxQixDQUFDLENBQ0gsQ0FBQztTQUNIO2FBQU07WUFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLHNDQUFzQixDQUFDLGdC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