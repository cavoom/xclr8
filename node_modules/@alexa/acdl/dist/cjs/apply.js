"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Apply = void 0;
const immutable_1 = __importDefault(require("immutable"));
const ask = __importStar(require("./ast"));
const ast_1 = require("./ast");
const constants_1 = require("./constants");
const type_1 = require("./type");
const responseInfo_1 = require("./responseInfo");
const util_1 = require("./util");
/**
 * An Apply represents a Call to an Action, Dialog or Type.
 *
 * This class provides a lazily-evaluated API for querying this call's AST
 * for type checking and type inference.
 */
class Apply {
    constructor(checker, call, decl, prev, returnType, argumentIndex, genericEnvironment, genericArguments) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "call", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: call
        });
        Object.defineProperty(this, "decl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: decl
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Apply"
        });
        Object.defineProperty(this, "argumentDeclarations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "argumentDeclIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "requiredArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "returnType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "arguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "genericEnvironment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (prev) {
            this.argumentDeclarations = prev.argumentDeclarations;
            this.argumentDeclIndex = prev.argumentDeclIndex;
            this.requiredArguments = prev.requiredArguments;
            this.returnType = returnType;
            this.arguments = argumentIndex;
            this.genericEnvironment = genericEnvironment;
            this.genericArguments = genericArguments;
        }
        else {
            if (decl.kind === "Type") {
                if (decl.isFunction()) {
                    this.argumentDeclarations = decl.getFunctionArgumentDeclarations();
                }
                else {
                    this.argumentDeclarations = decl.properties;
                }
            }
            else if (decl.kind === "TypeDeclaration") {
                this.argumentDeclarations = (_b = (_a = this.checker.instantiateTypeDeclaration(decl)) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.map((prop) => {
                    var _a, _b, _c;
                    const arg = new ask.ArgumentDeclaration(new ask.Name(prop.name), (_a = prop.type) === null || _a === void 0 ? void 0 : _a.toTypeReference(), undefined, (_c = (_b = prop.declaration) === null || _b === void 0 ? void 0 : _b.annotations) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), undefined);
                    decl.setAsParentOn(arg);
                    return arg;
                });
            }
            else {
                this.argumentDeclarations = decl.arguments;
            }
            if (this.argumentDeclarations) {
                (_c = this.argumentDeclarations) === null || _c === void 0 ? void 0 : _c.map((argDecl, index) => {
                    var _a;
                    const argName = typeof (argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === "string" ? argDecl.name : (_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name;
                    if (argName) {
                        this.argumentDeclIndex[argName] = argDecl;
                        this.argumentDeclIndex[index] = argDecl;
                    }
                });
            }
            const required = [];
            if (this.argumentDeclarations) {
                for (const arg of this.argumentDeclarations) {
                    const argName = typeof arg.name === "string" ? arg.name : (_d = arg.name) === null || _d === void 0 ? void 0 : _d.name;
                    if (argName && arg.type) {
                        if (arg.kind === "Property" &&
                            !arg.type.isOptional() &&
                            !arg.type.isArgs() &&
                            ((_e = arg.declaration) === null || _e === void 0 ? void 0 : _e.kind) === "TypeProperty" &&
                            ((_f = arg.declaration) === null || _f === void 0 ? void 0 : _f.optional) !== true) {
                            required.push(argName);
                        }
                        else if (arg.kind === "ArgumentDeclaration" &&
                            checker.qualifyName(arg, (_g = arg.type.name) === null || _g === void 0 ? void 0 : _g.name) !== ast_1.AlexaSchema.Optional &&
                            checker.qualifyName(arg, (_h = arg.type.name) === null || _h === void 0 ? void 0 : _h.name) !== ast_1.AlexaConversations.Args &&
                            arg.defaultExpression === undefined) {
                            required.push(argName);
                        }
                    }
                }
            }
            this.requiredArguments = [...required];
        }
    }
    /**
     * Instantiate this static Apply instance within a local TypeChecker environment.
     *
     * @param localChecker the new environment in which to instantiate the Apply.
     */
    instantiate(localChecker) {
        var _a, _b, _c;
        if (this.isList()) {
            return (_a = resolveType(this.getReturnType())) === null || _a === void 0 ? void 0 : _a.apply(this.call, localChecker);
        }
        const actionLocal = localChecker.getThing(this.checker.lookupCallDeclaration(this.call));
        if (actionLocal === undefined || actionLocal.origin === undefined || actionLocal.origin.kind === "ArgumentDeclaration") {
            // we only support instantiating actions for concrete Action/Dialog Declaration expressions.
            return undefined;
        }
        return new Apply(localChecker, this.call, actionLocal.origin, this, resolveType(this.getReturnType()), this.getArguments(), undefined, // this.getGenericEnvironment(),
        (_c = (_b = this.getGenericArguments()) === null || _b === void 0 ? void 0 : _b.map((t) => resolveType(t))) !== null && _c !== void 0 ? _c : null);
        // resolve type parameters
        function resolveType(type, hasTypeParameters = type === null || type === void 0 ? void 0 : type.hasTypeParameters()) {
            var _a, _b, _c, _d;
            if (type === undefined) {
                return undefined;
            }
            if (hasTypeParameters === false) {
                return type;
            }
            if (((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
                return (_c = (_b = localChecker.types) === null || _b === void 0 ? void 0 : _b.get(type.declaration)) !== null && _c !== void 0 ? _c : type;
            }
            return new type_1.Type(type.checker, type.declaration, (_d = type.genericArguments) === null || _d === void 0 ? void 0 : _d.map((t) => resolveType(t, hasTypeParameters)), type.functionArgumentNames);
        }
    }
    isList() {
        return this.decl.kind === "Type" && this.decl.isList();
    }
    getListItems() {
        if (this.isList() && ask.isListLiteral(this.call.arguments)) {
            return this.call.arguments.items.map((item) => item.item);
        }
        return undefined;
    }
    isArgs() {
        return this.decl.kind === "Type" && this.decl.isArgs();
    }
    isType() {
        return (this.decl.kind === "Type" && !this.decl.isFunction()) || this.decl.kind === "TypeDeclaration";
    }
    isIs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.is;
    }
    isIsInCatalog() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.isInCatalog;
    }
    isIn() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.in;
    }
    isWhen() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.when;
    }
    isEq() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Eq;
    }
    isNeq() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Neq;
    }
    isAnd() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.And;
    }
    isOr() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Or;
    }
    isNot() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Not;
    }
    isGt() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Gt;
    }
    isGte() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Gte;
    }
    isLt() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Lt;
    }
    isLte() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Lte;
    }
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.skill` action.
     */
    isSkillAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.skill;
    }
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.Skill` type.
     */
    isSkillType() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Skill;
    }
    /**
     * Checks if this apply is targeting the core `annotation` action.
     */
    isAnnotationAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.annotation;
    }
    /**
     * Checks if the target of this Apply is an action annotated with the `@annotation` meta-annotation?
     */
    isAnnotation() {
        var _a;
        return (this.isAction() &&
            this.decl.kind === "ActionDeclaration" &&
            ((_a = this.decl.annotations) === null || _a === void 0 ? void 0 : _a.find((a) => this.checker.qualifyName(this.decl, a.call.name) === ast_1.AlexaConversations.annotation)) !== undefined);
    }
    /**
     * Get the `allowMultiple` field from an instance of the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * @returns true/false if this is an instance of `Annotation`, otherwise `undefined.
     */
    getAnnotationAllowMultiple() {
        if (this.isAnnotationAction()) {
            const allowMultiple = this.getArgumentValueAndResolveToCallIfNameRef("allowMultiple");
            if ((allowMultiple === null || allowMultiple === void 0 ? void 0 : allowMultiple.kind) === "Call" && typeof allowMultiple.arguments === "boolean") {
                return allowMultiple.arguments;
            }
            return false;
        }
        return undefined;
    }
    /**
     * Get the `targets` field if this is a call to the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * Ex.
     * ```
     * // returns [AnnotationTarget.Type]
     * @Annotation(targets = [AnnotationTarget.Type])
     * ..
     * ```
     */
    getAnnotationTargets() {
        if (this.isAnnotationAction()) {
            const annotationTargets = this.getArgumentValueAndResolveToCallIfNameRef("targets");
            if ((annotationTargets === null || annotationTargets === void 0 ? void 0 : annotationTargets.kind) === "Call" && ask.isListLiteral(annotationTargets.arguments)) {
                return annotationTargets.arguments.items
                    .map((item) => {
                    var _a, _b, _c, _d;
                    if (((_a = item.item) === null || _a === void 0 ? void 0 : _a.kind) === "PropertyReference") {
                        const name = (_b = item.item.name) === null || _b === void 0 ? void 0 : _b.name;
                        const exprType = this.checker.getType(item.item.expression);
                        // if this is a reference to `enum AnnotationTarget`, then its type should be `Type<AnnotationTarget>`.
                        const isAnnotationTargetEnum = (exprType === null || exprType === void 0 ? void 0 : exprType.isType()) && ((_c = exprType.getTypeType()) === null || _c === void 0 ? void 0 : _c.isAnnotationTarget()); // getTypeType() => AnnotationTarget type
                        if (isAnnotationTargetEnum && (0, ast_1.isAnnotationTarget)(name)) {
                            // ex. AnnotationTarget.Dialog
                            // name => Dialog
                            // exprType => Type<AnnotationTarget>
                            // yields AnnotationTarget.Dialog
                            return name;
                        }
                    }
                    else if (((_d = item.item) === null || _d === void 0 ? void 0 : _d.kind) === "NameReference") {
                    }
                    return undefined;
                })
                    .filter((t) => t !== undefined);
            }
        }
        return undefined;
    }
    isAction() {
        return this.decl.kind === "ActionDeclaration" || (this.decl.kind === "Type" && this.decl.isAction());
    }
    isBuiltin() {
        var _a, _b;
        return ((_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.AlexaConversationsNamespace)) || false;
    }
    isUserDefinedApi() {
        var _a;
        return (this.isAction() || (this.decl.kind === "Type" && ((_a = this.decl.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration")) && !this.isBuiltin();
    }
    isDialog() {
        return this.decl.kind === "DialogDeclaration" || (this.decl.kind === "Type" && this.decl.isDialog());
    }
    isBinaryOperator() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && constants_1.Constants.BINARY_OPERATOR_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    isOperator() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && constants_1.Constants.OPERATOR_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    // This method tracks the legal data binding function calls in ACDL syntax. Might need a more precise name for this function..
    isNativeAction() {
        return this.isSize() || this.isLength() || this.isExists() || this.isGetListItem() || this.isIs();
    }
    isFileAccessAction() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && constants_1.Constants.FILE_ACCESS_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    isGetListItem() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.getListItem;
    }
    isEnsure() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ensure;
    }
    isExpect() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.expect;
    }
    isConfirmAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.confirmAction;
    }
    isConfirmActionAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmAction;
    }
    /**
     * Checks if this is a call to the `confirmArgs` action.
     */
    isConfirmArgs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.confirmArgs;
    }
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArgsAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArgs;
    }
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArguments;
    }
    isUtterances() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.utterances;
    }
    isTouch() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.touch;
    }
    isMultiModalEvent() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.multiModalEvent;
    }
    isEventDecl() {
        return this.isUtterances() || this.isTouch() || this.isMultiModalEvent() || this.isIntent();
    }
    isCatalogDecl() {
        return this.isListBasedCatalogAction() || this.isExtendCatalogAction() || this.isBuiltinCatalogAction();
    }
    isUtterance() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Utterance;
    }
    isIntent() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.intent;
    }
    isAlexaLine() {
        return this.isResponse() || this.isConfirmAction();
    }
    isResponse() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.response;
    }
    isDelegateToIntent() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.delegateToIntent;
    }
    isIntentRequest() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.IntentRequest;
    }
    isDelegateRequest() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.delegateRequest;
    }
    isReceived() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.received;
    }
    isRequestArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.RequestArguments;
    }
    isResetAllArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ResetAllArguments;
    }
    isResetArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ResetArguments;
    }
    isEnsureArgOrder() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.EnsureArgOrder;
    }
    isRequestAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Request;
    }
    isLength() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.length;
    }
    isAlexaSchemaNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.AlexaSchemaNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isAlexaConversationsNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.AlexaConversationsNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isAlexaBuiltinsNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.BuiltinsNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isSize() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.size;
    }
    isUserSays() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.userSays;
    }
    isExists() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.exists;
    }
    isEvents() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.events;
    }
    isWelcome() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.welcome;
    }
    isLocaleAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.locale;
    }
    isVarArgs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Args;
    }
    isValidateArg() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.validateArg;
    }
    isVariations() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.variations;
    }
    isAplaAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.apla;
    }
    isAplAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.apl;
    }
    isReferableAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.referable;
    }
    isCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.catalog;
    }
    isCatalogType() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Catalog;
    }
    isListBasedCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.listBasedCatalog;
    }
    isExtendCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.extendCatalog;
    }
    isBuiltinCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.builtinCatalog;
    }
    isGeneratedAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.generated;
    }
    isGetAllNamesAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.getAllNames;
    }
    getName() {
        var _a;
        return (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name;
    }
    getShortName() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) ? (0, util_1.getName)(this.decl.name.name) : undefined;
    }
    /**
     * Gets a Thing representing an Argument Value.
     *
     * @param name name of the argument value.
     * @returns a Thing representing the value (if it can be determined) or `undefined`.
     */
    getArgumentValueThing(name) {
        return this.checker.getThing(this.getArgumentValue(name));
    }
    /**
     * Gets a List of Thing representing all the argument values
     * @returns a List of Thing representing all the argument values
     */
    getArgumentValueThingList() {
        return this.getArgumentsList().map((argument) => this.checker.getThing(argument.value));
    }
    /**
     * Get the specific argument value by name
     * @param name name string or ask.Name
     */
    getArgumentValue(name) {
        var _a;
        return (_a = this.getArgument(name)) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Get the specific argument by name
     * @param name name string or ask.Name
     */
    getArgument(name) {
        var _a, _b, _c, _d;
        const args = this.getArguments();
        const nameStr = name === undefined
            ? undefined
            : typeof name === "string"
                ? name
                : name.kind === "Name"
                    ? name.name
                    : ((_b = (_a = name.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction()) && name.argumentName
                        ? (_d = (_c = name.parent.parent.concreteToAbstractArgumentNames) === null || _c === void 0 ? void 0 : _c[name.argumentName]) !== null && _d !== void 0 ? _d : name.argumentName
                        : name.argumentName;
        if (args !== undefined && nameStr !== undefined) {
            // return args[this.argumentNameMappings?.[nameStr] ?? nameStr];
            return args[nameStr];
        }
        return undefined;
    }
    /**
     * Get the specific argument value by name, if it's a nameReference, resolve it
     * @param name name string or ask.Name
     * @returns
     */
    getArgumentValueAndResolveIfNameRef(name) {
        const value = this.getArgumentValue(name);
        if (this.checker.isNameReference(value)) {
            return this.checker.resolveNameReference(value);
        }
        return value;
    }
    /**
     * Get the specific argument value by name, if the value kind is nameReference, resolve it to the call
     *
     * E.G.
     * ```
     * apla = APLA {}
     * temp = apla
     * response(temp, Bye {})
     *
     * if we have the response apply
     * apply.getArgumentValueAndResolveToCallIfNameRef('response') => APLA {}
     * ```
     * @param name name string or ask.Name
     */
    getArgumentValueAndResolveToCallIfNameRef(name) {
        const value = this.getArgumentValue(name);
        if (this.checker.isNameReference(value)) {
            return this.checker.resolveNameReferenceToCall(value);
        }
        return value;
    }
    getArgumentsList() {
        var _a;
        return Object.values((_a = this.getArguments()) !== null && _a !== void 0 ? _a : {});
    }
    getArgumentsThing() {
        var _a;
        return Object.entries((_a = this.getArguments()) !== null && _a !== void 0 ? _a : {})
            .map(([name, arg]) => ({
            [name]: this.checker.getThing(arg),
        }))
            .reduce((a, b) => ({ ...a, ...b }), {});
    }
    /**
     * Get a map or argument name to the ArgumentValue node passed to this call.
     */
    getArguments() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.arguments === undefined) {
            this.arguments = {};
            if (this.call.arguments === undefined || Array.isArray(this.call.arguments)) {
                let isPositionalAllowed = true;
                let i = 0;
                let loc;
                for (const argument of this.call.arguments || []) {
                    if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                        isPositionalAllowed = false;
                        this.arguments[argument.name.name] = argument;
                    }
                    else if (argument.index !== undefined) {
                        if (isPositionalAllowed) {
                            const argDecl = (_b = this.argumentDeclarations) === null || _b === void 0 ? void 0 : _b[i];
                            const isVarArgs = argDecl !== undefined &&
                                ((_c = argDecl.type) === null || _c === void 0 ? void 0 : _c.name) &&
                                this.checker.qualifyName(argDecl.type.name, argDecl.type.name.name) === ast_1.AlexaConversations.Args;
                            const argName = typeof (argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === "string" ? argDecl.name : (_d = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _d === void 0 ? void 0 : _d.name;
                            // argName = argName ? this.argumentNameMappings?.[argName] ?? argName : argName;
                            if (argName) {
                                if (isVarArgs) {
                                    // if this is a var-args, construct a list literal call
                                    let arg = this.arguments[argName];
                                    let listCall = arg === null || arg === void 0 ? void 0 : arg.value;
                                    let list = listCall === null || listCall === void 0 ? void 0 : listCall.arguments;
                                    if (list === undefined) {
                                        list = new ask.ListLiteral([]);
                                        listCall = new ask.Call(new ask.Name(ast_1.AlexaConversations.Args), list, undefined);
                                        arg = new ask.Argument(undefined, argument.index, listCall);
                                        this.call.setAsParentOn(arg);
                                        this.arguments[argName] = arg;
                                    }
                                    const item = new ask.ListItem((_e = argument === null || argument === void 0 ? void 0 : argument.value) === null || _e === void 0 ? void 0 : _e.clone(), list.items.length);
                                    list.setAsParentOn(item);
                                    list.items.push(item);
                                    if (loc && ((_f = argument.loc) === null || _f === void 0 ? void 0 : _f.end)) {
                                        loc.end = (_g = argument === null || argument === void 0 ? void 0 : argument.loc) === null || _g === void 0 ? void 0 : _g.end;
                                    }
                                    else {
                                        loc = argument.loc;
                                    }
                                    listCall.loc = loc;
                                }
                                else {
                                    this.arguments[argName] = argument;
                                    i += 1; // increment the declaration index only if we're not var-args
                                }
                            }
                        }
                    }
                }
            }
        }
        return this.arguments || undefined;
    }
    /**
     * Get the return type of this call.
     *
     * Infers generic arguments and computing generic return type if necessary
     *
     * @returns the return type if it is known, otherwise `undefined`.
     */
    getReturnType(seen) {
        var _a, _b;
        if (this.returnType === undefined) {
            this.returnType = (_a = this.resolveReturnType(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.returnType) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveReturnType(seen) {
        if (this.decl.kind === "Type") {
            if (this.decl.isFunctionN()) {
                return this.decl.getFunctionReturnType();
            }
            if (this.decl.isFunction()) {
                return this.checker.thing;
            }
            return this.decl;
        }
        if (this.decl.genericArguments === undefined) {
            if (this.decl.kind === "TypeDeclaration") {
                return this.checker.instantiateTypeDeclaration(this.decl);
            }
            return this.checker.instantiateTypeReference(this.decl.returnType);
        }
        if (this.decl.kind === "TypeDeclaration") {
            const args = this.getGenericArguments(seen);
            if (args !== undefined) {
                return this.checker.instantiateTypeDeclaration(this.decl, args);
            }
        }
        else {
            // ActionDeclaration and DialogDeclaration
            const env = this.getGenericEnvironment(seen);
            if (env !== undefined) {
                return this.checker.instantiateTypeReference(this.decl.returnType, env);
            }
        }
        return undefined;
    }
    /**
     * Get the type of an argument or property
     */
    getType(arg, context) {
        var _a, _b, _c;
        if (arg === undefined) {
            // `undefined` refers to a primitive expression's arguments, e.g. `null`, `string`, `[]`.
            if (this.decl.kind === "Type") {
                return this.decl;
            }
        }
        else if (arg.kind === "Argument") {
            const argDecl = ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) ? this.argumentDeclIndex[arg.name.name] : (_b = this.argumentDeclarations) === null || _b === void 0 ? void 0 : _b[arg.index];
            if (argDecl) {
                return this.getType(argDecl, context);
            }
        }
        else {
            const name = typeof arg.name === "string" ? arg.name : (_c = arg.name) === null || _c === void 0 ? void 0 : _c.name;
            const decl = this.argumentDeclIndex[name];
            if (decl.kind === "ArgumentDeclaration") {
                return this.checker.instantiateTypeReference(decl.type, this.getGenericEnvironment());
            }
            return decl.type;
        }
        return undefined;
    }
    /**
     * Retuns a mapping of generic argument names to their inferred type. For instance consider the action declaration:
     *
     *    action Nothing getWeather<T,K>(T something, K somethingElse)
     *
     * For the call/apply below:
     *    sample {
     *      ...
     *      getWeather('x', 1)
     *      ...
     *    }
     * The return value will be: { "T" : <Type object refering to string>, "K": <Type object refering to number>}
     *
     * For anonymous functions the generic arguments are also types as opposed to something like T or K above.
     * For instance consider the reusable dialog declaration containing an anonymous function receiving Optional<T>
     * and returning Nothing:
     *     dialog Nothing reusableDialog<T>( Action1<Optional<T>, Nothing> anonAction, T value) {
     *        sample {
     *            ...
     *            anonAction(value);
     *            ...
     *        }
     *     }
     * for the call/apply inside the sample the generic arguments are the types Optional<T> and Nothing
     * seen in Action1<Optional<T>, Nothing> anonAction
     * The return value for this call is {"T": <Type object refering to T>, "Nothing": <Type object refering to Nothing>}
     * @param seen used  to prevent infinite recursion in type lookups
     */
    getGenericEnvironment(seen) {
        var _a, _b;
        if (this.genericEnvironment === undefined) {
            this.genericEnvironment = this.genericEnvironment = (_a = this.resolveGetGenericEnvironment(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.genericEnvironment) !== null && _b !== void 0 ? _b : undefined;
    }
    /**
     * Does the actual work in getGenericEnvironment.
     * @param seen used  to prevent infinite recursion in type lookups
     */
    resolveGetGenericEnvironment(seen) {
        var _a;
        const genericArgumentTypes = this.getGenericArguments(seen);
        return (_a = this.decl.genericArguments) === null || _a === void 0 ? void 0 : _a.map((declGenericArgument, i) => {
            var _a;
            if ((declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.kind) === "TypeParameter") {
                const type = genericArgumentTypes === null || genericArgumentTypes === void 0 ? void 0 : genericArgumentTypes[i];
                return type ? { [(_a = declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.name) === null || _a === void 0 ? void 0 : _a.name]: type } : {};
            }
            else if ((declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.kind) === "Type") {
                // The generic argument here might look like Apply<Optional<T>,K>. We need to find nested generic arguments T and K.
                // Because of that, one generic argument like Apply<Optional<T>,K> might turn into many: [T,K]. The map below will
                // add a nested dimension to the array that will be flatened below.
                const nestedGenericArguments = declGenericArgument.getNestedGenericArguments();
                return nestedGenericArguments.map((nestedGenericArgument) => {
                    var _a;
                    return { [(_a = nestedGenericArgument === null || nestedGenericArgument === void 0 ? void 0 : nestedGenericArgument.name) === null || _a === void 0 ? void 0 : _a.name]: nestedGenericArgument };
                });
            }
            else {
                return {};
            }
        }).flat().reduce((a, b) => ({ ...a, ...b }), {});
    }
    getGenericArguments(seen) {
        var _a, _b;
        if (this.genericArguments === undefined) {
            this.genericArguments = (_a = this.resolveGenericArguments(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.genericArguments) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveGenericArguments(seen) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.decl.kind === "Type" && this.decl.genericArguments !== undefined) {
            // TODO: infer
            return this.decl.genericArguments;
        }
        if (this.decl.genericArguments === undefined) {
            return undefined;
        }
        if (((_a = this.call.genericArguments) === null || _a === void 0 ? void 0 : _a.length) === this.decl.genericArguments.length) {
            return this.call.genericArguments.map((a) => { var _a; return (_a = this.checker.instantiateTypeReference(a)) !== null && _a !== void 0 ? _a : this.checker.thing; });
        }
        if (this.call.genericArguments === undefined) {
            // infer the arguments from the values
            if (ask.isListLiteral(this.call.arguments) && this.decl.kind === "TypeDeclaration") {
                // we're instantiating a List declaration
                const listValueType = this.checker.getType(this.call.arguments, false, seen);
                const listDeclType = this.checker.instantiateTypeDeclaration(this.decl, this.decl.genericArguments.map((arg) => this.checker.instantiateTypeParameter(arg)));
                if (listValueType && listDeclType) {
                    // the list could be a complex sub type
                    // e.g. type MyList<A> : List<List<A>>
                    // e.g. type MyList2<A> : MyList<List<A>> : List<List<List<A>>
                    // ... so we first reduce it to the value's type
                    return this.decl.genericArguments.map((genericArg) => { var _a, _b; return (_b = inferTypeParameter((_a = genericArg.name) === null || _a === void 0 ? void 0 : _a.name, listDeclType, listValueType)) !== null && _b !== void 0 ? _b : this.checker.thing; });
                }
            }
            else {
                const declarations = this.decl.kind === "Type" ? this.decl.properties : this.argumentDeclarations;
                const args = this.getArguments();
                // store a mapping of Type Parameter to:
                // 1. `string` - another type parameter in the parameter list
                // 2. Type - a type inferred from the values
                const inferredTypes = {};
                // first pass over the generic arguments, infer what we can from the values
                for (const genericArg of this.decl.genericArguments) {
                    let inferredType;
                    if (args !== undefined && declarations !== undefined) {
                        for (const argDecl of declarations) {
                            const argName = typeof argDecl.name === "string" ? argDecl.name : (_b = argDecl.name) === null || _b === void 0 ? void 0 : _b.name;
                            const arg = args[argName];
                            if (arg === undefined || argDecl.type === undefined) {
                                continue;
                            }
                            const argType = this.checker.getType(arg.value, false, seen);
                            if (argType === undefined) {
                                continue;
                            }
                            const argDeclType = argDecl.kind === "ArgumentDeclaration" ? this.checker.instantiateTypeReference(argDecl.type) : argDecl.type;
                            if (argDeclType) {
                                const inferred = inferTypeParameter((_c = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _c === void 0 ? void 0 : _c.name, argDeclType, argType);
                                inferredType = (_d = inferredType === null || inferredType === void 0 ? void 0 : inferredType.union(inferred)) !== null && _d !== void 0 ? _d : inferred;
                            }
                        }
                    }
                    if (inferredType) {
                        // we found a value in the arguments that informs this generic argument
                        inferredTypes[(_e = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _e === void 0 ? void 0 : _e.name] = inferredType;
                    }
                    else if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) === "TypeParameter") {
                        // we did not find a value for the argument, let's see if there are default types
                        if (genericArg.constraints === undefined || genericArg.constraints.length === 0) {
                            // this parameter has no constraints, default to Thing.
                            inferredTypes[(_f = genericArg.name) === null || _f === void 0 ? void 0 : _f.name] = this.checker.thing;
                        }
                        else if (genericArg.constraints.length > 1) {
                            // this generic arg has multiple constraints, e.g. T : A : B
                            // we don't yet support this case, for now we will default it to Thing.
                            inferredTypes[(_g = genericArg.name) === null || _g === void 0 ? void 0 : _g.name] = this.checker.thing;
                        }
                        else if (genericArg.constraints.length === 1) {
                            // this generic arg has a single constrain, e.g. T : V
                            // default to that type
                            const defaultType = this.checker.getType(genericArg.constraints[0], undefined, seen);
                            if (((_h = defaultType === null || defaultType === void 0 ? void 0 : defaultType.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "TypeParameter") {
                                // if the constraint is another type parameter, e.g. <T : V, V>
                                // then use that name as a place-holder and attempt to resolve it in the final pass.
                                inferredTypes[(_j = genericArg.name) === null || _j === void 0 ? void 0 : _j.name] = (_k = defaultType.declaration.name) === null || _k === void 0 ? void 0 : _k.name;
                            }
                            else if (defaultType !== undefined) {
                                // this is a concrete type
                                inferredTypes[(_l = genericArg.name) === null || _l === void 0 ? void 0 : _l.name] = defaultType;
                            }
                        }
                    }
                }
                // second pass over generic arguments where we resolve the inference results
                return this.decl.genericArguments.map((genericArg) => { var _a, _b; return (_b = resolveInferredArg((_a = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _a === void 0 ? void 0 : _a.name)) !== null && _b !== void 0 ? _b : this.checker.thing; });
                /**
                 * Resolves a named argument from the results of the first pass.
                 */
                function resolveInferredArg(name, seen = immutable_1.default.Set()) {
                    if (name === undefined) {
                        return undefined;
                    }
                    const inferred = inferredTypes[name];
                    if (inferred === undefined) {
                        return undefined;
                    }
                    if (typeof inferred === "string") {
                        // the type is a place-holder referring to the inferred type of another generic argument
                        if (seen.has(inferred)) {
                            // encountered a loop, so the type is undefined.
                            return undefined;
                        }
                        // try and resolve the place-holder
                        return resolveInferredArg(inferred, seen.add(inferred));
                    }
                    if (inferred.genericArguments === undefined || inferred.genericArguments.length === 0) {
                        // this is a concrete type, terminate inference
                        return inferred;
                    }
                    // this is a generic type, we need to recursively resolve generic arguments that may be
                    // referencing other inferred generic arguments
                    // e.g foo<T : List<V>, V>(V value)
                    // foo("string")
                    // once we have inferred V => String
                    // we must then resolve T => List<V> => List<String>
                    return (function resolveType(type) {
                        if (type === undefined) {
                            return undefined;
                        }
                        if (type.genericArguments === undefined || type.genericArguments.length === 0) {
                            return type;
                        }
                        return new type_1.Type(type.checker, type.declaration, type.genericArguments.map((arg) => {
                            var _a, _b;
                            if (((_a = arg === null || arg === void 0 ? void 0 : arg.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
                                const resolvedType = resolveInferredArg((_b = arg.declaration.name) === null || _b === void 0 ? void 0 : _b.name, seen);
                                if (resolvedType !== undefined) {
                                    return resolvedType;
                                }
                            }
                            return resolveType(arg);
                        }));
                    })(inferred);
                }
            }
        }
        return undefined;
    }
    /**
     * a util function help retrieve payload argumentDeclarations
     * @param apply
     */
    getPayloadValue() {
        if (this.isResponse() || this.isConfirmAction()) {
            let payloadValue = this.getArgumentValue("payload");
            if (payloadValue !== undefined) {
                payloadValue = this.checker.isNameReference(payloadValue)
                    ? this.checker.resolveNameReferenceToCall(payloadValue)
                    : payloadValue;
                return payloadValue;
            }
        }
        return undefined;
    }
    /**
     * get detailed response info for an Alexa response
     *
     * In current acdl, there's four response actions and eight response acts, it's hard to retrieve property in different kind of responses
     * This function try to collect all info an Alexa Response may have and represent them as ResponseInfo interface,
     * this new layer make it easier to get a specific property in an Alexa response
     *
     * E.G.
     * ```
     * ensure(
     *      RequestArguments {arguments = [getPerson.arguments.name], response = greeting_apla},
     *      RequestArguments {arguments = [getPerson.arguments.age], response = bye_apla}
     * )
     *
     * =>
     *
     * [
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.name],
     *     prompt: greeting_apla
     *   },
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.age],
     *     prompt: bye_apla
     *   }
     * ]
     * ```
     *
     * @returns
     */
    getResponseInfo() {
        const responseInfo = [];
        if (this.isConfirmAction()) {
            responseInfo.push({
                purpose: responseInfo_1.ResponsePurpose.ConfirmAction,
                actionName: this.getArgument("actionName"),
                prompt: this.getArgument("response"),
                payload: this.getArgument("payload"),
            });
        }
        else if (this.isConfirmArgs() || this.isEnsure()) {
            const argsValue = this.isConfirmArgs()
                ? this.getArgumentValueAndResolveToCallIfNameRef("confirmArgs")
                : this.getArgumentValueAndResolveToCallIfNameRef("requestArgs");
            if ((argsValue === null || argsValue === void 0 ? void 0 : argsValue.kind) === "Call" && ask.isListLiteral(argsValue.arguments)) {
                for (const confirmArguments of argsValue.arguments.items) {
                    let itemValue = confirmArguments.item;
                    if (this.checker.isNameReference(itemValue)) {
                        itemValue = this.checker.resolveNameReferenceToCall(itemValue);
                    }
                    // The expected value is ConfirmArguments Object Literal or RequestArguments Object Literal
                    if ((itemValue === null || itemValue === void 0 ? void 0 : itemValue.kind) === "Call") {
                        const argsApply = this.checker.getApply(itemValue, undefined);
                        responseInfo.push({
                            purpose: this.isConfirmArgs() ? responseInfo_1.ResponsePurpose.ConfirmArgs : responseInfo_1.ResponsePurpose.Request,
                            arguments: argsApply === null || argsApply === void 0 ? void 0 : argsApply.getArgument("arguments"),
                            prompt: argsApply === null || argsApply === void 0 ? void 0 : argsApply.getArgument("response"),
                        });
                    }
                }
            }
        }
        else if (this.isResponse()) {
            const sourceActValue = this.getArgumentValue("act");
            const actValue = this.checker.isNameReference(sourceActValue)
                ? this.checker.resolveNameReferenceToCall(sourceActValue)
                : sourceActValue;
            const actType = this.checker.getType(actValue);
            if ((actValue === null || actValue === void 0 ? void 0 : actValue.kind) === "Call") {
                const actApply = this.checker.getApply(actValue, undefined);
                responseInfo.push({
                    purpose: (actType === null || actType === void 0 ? void 0 : actType.isRequest())
                        ? responseInfo_1.ResponsePurpose.Request
                        : (actType === null || actType === void 0 ? void 0 : actType.isConfirmArgs())
                            ? responseInfo_1.ResponsePurpose.ConfirmArgs
                            : (actType === null || actType === void 0 ? void 0 : actType.isConfirmAction())
                                ? responseInfo_1.ResponsePurpose.ConfirmAction
                                : (actType === null || actType === void 0 ? void 0 : actType.isNotify())
                                    ? responseInfo_1.ResponsePurpose.Notify
                                    : (actType === null || actType === void 0 ? void 0 : actType.isOffer())
                                        ? responseInfo_1.ResponsePurpose.Offer
                                        : (actType === null || actType === void 0 ? void 0 : actType.isReqAlt())
                                            ? responseInfo_1.ResponsePurpose.ReqAlt
                                            : (actType === null || actType === void 0 ? void 0 : actType.isReqMore())
                                                ? responseInfo_1.ResponsePurpose.ReqMore
                                                : (actType === null || actType === void 0 ? void 0 : actType.isBye())
                                                    ? responseInfo_1.ResponsePurpose.Bye
                                                    : undefined,
                    arguments: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("arguments"),
                    actionName: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("actionName"),
                    carryOverArguments: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("carryOverArguments"),
                    success: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("success"),
                    prompt: this.getArgument("response"),
                    payload: this.getArgument("payload"),
                });
            }
        }
        return responseInfo;
    }
}
exports.Apply = Apply;
/**
 * Infer a TypeParameter's type by searching for it within an instantiated type.
 *
 * e.g. inferring T from passed in arguments.
 * ```
 * action T myAction(List<T> list)
 * List<String> list
 *
 * t = myAction(list)
 *
 * // declarationType: List<T>
 * // instantiatedType: List<String>
 * ```
 *
 * The declarationType is `List<T>` and the instantiatedType is List<String>. Searching
 * for `T` will find `String`.
 *
 * `T` is inferred as `String` from the passed in `List<String>`.
 *
 * @param parameter  type parameter to infer
 * @param declarationType  declaration signature of this type, e.g. List<T>
 * @param valueType  type of the value e.g. List<String>
 */
function inferTypeParameter(parameter, declaration, valueType) {
    var _a, _b, _c;
    if (valueType === undefined || declaration === undefined) {
        return undefined;
    }
    if (parameter === ((_a = declaration === null || declaration === void 0 ? void 0 : declaration.name) === null || _a === void 0 ? void 0 : _a.name)) {
        return valueType;
    }
    if (((_b = valueType.name) === null || _b === void 0 ? void 0 : _b.name) === ((_c = declaration.name) === null || _c === void 0 ? void 0 : _c.name)) {
        if (declaration.genericArguments !== undefined && valueType.genericArguments !== undefined) {
            for (let i = 0; i < declaration.genericArguments.length; i++) {
                const argumentDeclaration = declaration.genericArguments[i];
                const instantiated = valueType.genericArguments[i];
                if (instantiated !== undefined) {
                    const found = inferTypeParameter(parameter, argumentDeclaration, instantiated);
                    if (found) {
                        return found;
                    }
                }
            }
        }
    }
    else if (valueType.isOptional()) {
        // we currently have the problem where Optional<T> must be assignable to T
        // for this case, we will reduce an Optional<T> value to T and infer from that.
        return inferTypeParameter(parameter, declaration, valueType.getOptionalType());
    }
    else if (declaration.isOptional()) {
        // Optional<T> is effectively a union type, we want to traverse its type parameters (the items in its set) and not its extensions
        return inferTypeParameter(parameter, declaration.getOptionalType(), valueType);
    }
    else if (valueType.extensions) {
        for (const extension of valueType.extensions) {
            const found = inferTypeParameter(parameter, declaration, extension);
            if (found) {
                return found;
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBwbHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwREFBa0M7QUFDbEMsMkNBQTZCO0FBRTdCLCtCQVNlO0FBQ2YsMkNBQXNDO0FBRXRDLGlDQUE0QjtBQUc1QixpREFBNkQ7QUFFN0QsaUNBQStCO0FBTS9COzs7OztHQUtHO0FBQ0gsTUFBYSxLQUFLO0lBOEJoQixZQUNXLE9BQW9CLEVBQ3BCLElBQWMsRUFDZCxJQUFnRixFQUN6RixJQUFZLEVBQ1osVUFBb0MsRUFDcEMsYUFBK0QsRUFDL0Qsa0JBQW1ELEVBQ25ELGdCQUE0Qzs7Ozs7O21CQVBuQzs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7O1FBaENYOzs7O21CQUF5QixPQUFPO1dBQUM7UUFFakM7Ozs7O1dBQWtGO1FBRWxGOzs7O21CQUFpRixFQUFFO1dBQUM7UUFFcEY7Ozs7O1dBQThDO1FBRTlDOzs7OztXQUE0QztRQUU1Qzs7Ozs7V0FBbUU7UUFFbkU7Ozs7O1dBQTJEO1FBRTNEOzs7OztXQUFrRTtRQXlCaEUsSUFBSSxJQUFJLEVBQUU7WUFDUixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQ3RELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFDaEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUNoRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztZQUM3QixJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQztZQUMvQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7WUFDN0MsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO1NBQzFDO2FBQU07WUFDTCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssTUFB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QUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLElBQUksQ0FBQztJQUMxRCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FB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