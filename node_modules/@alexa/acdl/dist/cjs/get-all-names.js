"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNamespacesFromGetAllNames = exports.getAllNames = void 0;
const ask = __importStar(require("./ast"));
/**
 *
 * Gets the namespaces from the getAllNames<T>(Args<String> namespaces) action and returns
 * all nodes in the matching namespaces that are a subtype of type T.
 *
 * In the following example, the name declaration nodes for john and jane are returned:
 *
 * ```
 * namespace test.namespace
 *
 * john = Person {
 *   firstName = "John",
 *   lastName = "Doe",
 * }
 *
 * jane = Person {
 *   firstName = "Jane",
 *   lastName = "Doe",
 * }
 *
 * people = getAllNames<Person>("test.namespace")
 * ```
 * Calling this function with the getAllNames apply will return
 * the name declaration nodes for john and jane.
 *
 * ```
 * const nodes = getAllNames(getAllNamesApply, typeChecker) -> [john, jane]
 * ```
 */
function getAllNames(apply, checker) {
    var _a;
    if (apply.isGetAllNamesAction()) {
        const global = checker.global;
        const genericType = (_a = apply.getGenericArguments()) === null || _a === void 0 ? void 0 : _a[0];
        const returnNodes = new Set();
        const namespaces = getNamespacesFromGetAllNames(apply, checker);
        const foundNamespaces = namespaces.filter((namespace) => checker.global.namespaces.has(namespace));
        for (const namespace of foundNamespaces) {
            const scope = global.namespaces.get(namespace);
            if (scope) {
                for (const node of scope.values()) {
                    const nameDeclNode = Array.isArray(node) ? node === null || node === void 0 ? void 0 : node[0] : node;
                    if ((nameDeclNode && ask.isNameDeclaration(nameDeclNode)) || ask.isDialogDeclaration(nameDeclNode)) {
                        // Check if the declaration is of type of T from getAllNames<T>
                        const type = checker.getType(nameDeclNode);
                        if (type === null || type === void 0 ? void 0 : type.extends(genericType)) {
                            returnNodes.add(nameDeclNode);
                        }
                    }
                }
            }
        }
        return Array.from(returnNodes);
    }
    return [];
}
exports.getAllNames = getAllNames;
/**
 * Returns the unique namespaces provided to the getAllNames action.
 */
function getNamespacesFromGetAllNames(apply, checker) {
    var _a, _b, _c;
    if (!apply.isGetAllNamesAction()) {
        return [];
    }
    const items = (_c = (_b = (_a = apply.getArgumentValueThing("namespaces")) === null || _a === void 0 ? void 0 : _a.asList()) === null || _b === void 0 ? void 0 : _b.getListItems()) !== null && _c !== void 0 ? _c : [];
    const namespaces = new Set();
    for (const item of items) {
        const node = item === null || item === void 0 ? void 0 : item.item;
        const type = checker.getType(node);
        if (!ask.isCall(node) || !(type === null || type === void 0 ? void 0 : type.isString()) || typeof node.arguments !== "string") {
            continue;
        }
        namespaces.add(node.arguments);
    }
    return Array.from(namespaces);
}
exports.getNamespacesFromGetAllNames = getNamespacesFromGetAllNames;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWFsbC1uYW1lcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9nZXQtYWxsLW5hbWVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBSzdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJHO0FBQ0gsU0FBZ0IsV0FBVyxDQUFDLEtBQVksRUFBRSxPQUFvQjs7SUFDNUQsSUFBSSxLQUFLLENBQUMsbUJBQW1CLEVBQUUsRUFBRTtRQUMvQixNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQzlCLE1BQU0sV0FBVyxHQUFHLE1BQUEsS0FBSyxDQUFDLG1CQUFtQixFQUFFLDBDQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxFQUErQyxDQUFDO1FBRTNFLE1BQU0sVUFBVSxHQUFHLDRCQUE0QixDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNoRSxNQUFNLGVBQWUsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUVuRyxLQUFLLE1BQU0sU0FBUyxJQUFJLGVBQWUsRUFBRTtZQUN2QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMvQyxJQUFJLEtBQUssRUFBRTtnQkFDVCxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUUsRUFBRTtvQkFDakMsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7b0JBQzVELElBQUksQ0FBQyxZQUFZLElBQUksR0FBRyxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxFQUFFO3dCQUNsRywrREFBK0Q7d0JBQy9ELE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7d0JBQzNDLElBQUksSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTs0QkFDOUIsV0FBVyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQzt5QkFDL0I7cUJBQ0Y7aUJBQ0Y7YUFDRjtTQUNGO1FBQ0QsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQ2hDO0lBRUQsT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBNUJELGtDQTRCQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsNEJBQTRCLENBQUMsS0FBWSxFQUFFLE9BQW9COztJQUM3RSxJQUFJLENBQUMsS0FBSyxDQUFDLG1CQUFtQixFQUFFLEVBQUU7UUFDaEMsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELE1BQU0sS0FBSyxHQUFHLE1BQUEsTUFBQSxNQUFBLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsMENBQUUsTUFBTSxFQUFFLDBDQUFFLFlBQVksRUFBRSxtQ0FBSSxFQUFFLENBQUM7SUFFeEYsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztJQUVyQyxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtRQUN4QixNQUFNLElBQUksR0FBRyxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsSUFBSSxDQUFDO1FBQ3hCLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFbkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxRQUFRLEVBQUUsQ0FBQSxJQUFJLE9BQU8sSUFBSSxDQUFDLFNBQVMsS0FBSyxRQUFRLEVBQUU7WUFDaEYsU0FBUztTQUNWO1FBRUQsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDaEM7SUFFRCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDaEMsQ0FBQztBQXJCRCxvRUFxQkMifQ==