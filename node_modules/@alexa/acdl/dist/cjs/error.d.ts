import * as ask from "./ast";
import { Error as ACError, LocationObject } from "./error-factory";
import { Type } from "./type";
/**
 * Error encountered while Parsing source code.
 */
export interface ParseError<Code extends ACError = ACError, Message extends string = string> {
    uri?: string | undefined;
    loc?: ask.SourceLocation;
    code: Code;
    message: Message;
    attributes?: Record<string, string | number>;
}
/**
 * Used for errors in non ACDL files, most likely JSON files
 */
export declare class FileError extends Error {
    message: string;
    uri: string;
    constructor(message: string, uri: string);
}
export type ProjectError = ParseError;
export declare function logProjectErrors(errors: ProjectError[]): void;
export declare function logProjectWarnings(errors?: ProjectError[]): void;
export declare function logProjectError(error: ProjectError): void;
/**
 * Gets a string out of an error if it is a ProjectError or a regular Javascript Error
 */
export declare function stringifyError(error: Error): string;
export declare function stringifyProjectError(error: ProjectError): string;
export declare function stringifyLocation(errorUri: string, loc: ask.SourceLocation | undefined): string;
export declare function filterDuplicateErrors(errors: ParseError[]): ParseError[];
/**
 * Sort error array based on uri and loc
 * error without uri directly compare the loc
 * error with uri first compare uri then compare the loc
 * when loc are identical, compare the error message
 * @param errors
 * @returns
 */
export declare function sortErrors(errors: ParseError[]): ParseError[];
export declare function typeError(actual: Type, expected: Type, scope: ask.Node | undefined, errorExpr?: LocationObject): ParseError<ACError, string>;
export declare function nameNotFound(name: ask.Name, loc?: ask.SourceLocation, node?: ask.NameReference | ask.TypeReference): ParseError<ACError, string>;
export declare function hasTerminalErrors(errors: ProjectError[]): boolean;
//# sourceMappingURL=error.d.ts.map