/// <reference types="node" />
import fs from "fs-extra";
import * as ask from "./ast";
import { Type } from "./type";
export declare function time<T>(description: string, f: () => Promise<T>): Promise<T>;
export declare function time<T>(description: string, f: () => T): T;
export declare function trimScheme(uri: string): string;
/**
 * Asynchronously check if a file exists
 */
export declare function existsSync(file: string): boolean;
/**
 * Asynchronously check if a file exists
 */
export declare function exists(file: string): Promise<boolean>;
export declare function readdir(dir: string): Promise<string[]>;
/**
 * Parses JSON throwing an error that includes the path if the JSON is invalid
 * @param jsonText text to be parsed
 * @param path path the text came from
 */
export declare function parseJSON(jsonText: string, path: string): any;
/**
 * Reads a file and parses the JSON throwing an error that includes the path if
 * cannot read file or if the JSON is invalid
 * @param path path of file to read
 * @returns the JSON object read from the file
 */
export declare function readAndParseMandatoryJSONFileSync(path: string): any;
export declare function readJsonFileSync<T = unknown>(filePath: string): T | undefined;
export declare function readJsonFile<T = unknown>(filePath: string): Promise<T | undefined>;
export declare function readFileSync(path: string): string | undefined;
export declare function readFile(path: string): Promise<string | undefined>;
export declare function isFileSync(path: string): boolean | undefined;
export declare function isFile(path: string): Promise<boolean | undefined>;
export declare function isDirSync(path: string): boolean;
export declare function isDir(path: string): Promise<boolean>;
export declare function statSync(path: string): fs.Stats | undefined;
export declare function stat(path: string): Promise<fs.Stats | undefined>;
export declare function lstat(path: string): Promise<fs.Stats | undefined>;
export declare function safeFsSync<T>(f: () => T): T | undefined;
export declare function safeFs<T>(f: () => T | Promise<T>): Promise<T | undefined>;
export declare function getNamespace(fqn: string): string;
export declare function getName(fqn: string): string;
export declare function isQualifiedNamePattern(name: string | undefined): boolean;
export declare function stringifyTypeReference(ref: ask.TypeReference | undefined): string;
export declare function stringifyTypeParameter(param: ask.TypeParameter): string;
export declare function sanitize<T>(a: T | undefined): T | undefined;
export declare function log(a?: any, keepLoc?: boolean): void;
export declare function zipDirectory(source: string, out: string): Promise<unknown>;
export declare function isBuiltinSlotType(slotName: string): boolean;
export declare function isNotUndefined<T>(value: T | undefined): value is T;
/**
 * Stringifies a type array to their short type names
 */
export declare function typesToNameString(types: Type[]): string;
/**
 * Returns if this file is generated ASKIR module.
 */
export declare function isGeneratedFile(fileName: string): boolean;
/**
 * returns if the string starts with AMAZON.
 */
export declare function isAmazonBuiltin(name: string): boolean;
/**
 * gets all directories recursively under parentDirectoryPath
 * @param parentDirectoryPath path of parentDirectory
 * @returns an array of all directories recursively under parentDirectoryPath
 */
export declare function getDirectories(parentDirectoryPath: any): Promise<any[]>;
/**
 * gets all directories recursively under parentDirectoryPath
 * @param parentDirectoryPath path of parentDirectory
 * @returns an array of all directories recursively under parentDirectoryPath
 */
export declare function getDirectoriesSync(parentDirectoryPath: any): any[];
//# sourceMappingURL=util.d.ts.map