import immutable from "immutable";
import * as ask from "./ast";
import { TypeChecker } from "./checker";
import { Thing } from "./thing";
import { Expression } from "./expression";
import { Type } from "./type";
/**
 * An Interpreter can return two types:
 * 1. an object, `T`, representing the final result of the interpretation.
 * 2. a continuation function `(expr: Expression) => InterpretResult<T>`, which will be called back with the subsequent {@link Expression}.
 */
export type InterpretResult<T extends object> = T | ((expr: Expression) => InterpretResult<T>);
export declare class Flow<N extends ask.Node | undefined = ask.Node | undefined> {
    /**
     * Type Checker environment for this branch.
     */
    readonly checker: TypeChecker;
    /**
     * The next expression in this branch sequence.
     */
    readonly expression: N;
    /**
     * Branch before this node.
     */
    readonly prev: Flow | undefined;
    /**
     * Node to continue the branch from
     */
    readonly stack: (ask.Call | ask.Condition)[];
    /**
     * Map of node to resolved Thing at this point in the branch.
     */
    readonly things: immutable.Map<ask.Node, Thing | null>;
    /**
     * Maps a TypeParameter to its concrete Type.
     */
    readonly types: immutable.Map<ask.TypeParameter, Type | null>;
    constructor(
    /**
     * Type Checker environment for this branch.
     */
    checker: TypeChecker, 
    /**
     * The next expression in this branch sequence.
     */
    expression: N, 
    /**
     * Branch before this node.
     */
    prev: Flow | undefined, 
    /**
     * Node to continue the branch from
     */
    stack: (ask.Call | ask.Condition)[], 
    /**
     * Map of node to resolved Thing at this point in the branch.
     */
    things?: immutable.Map<ask.Node, Thing | null>, 
    /**
     * Maps a TypeParameter to its concrete Type.
     */
    types?: immutable.Map<ask.TypeParameter, Type | null>);
    /**
     * This function will walk over each dialog flow, parse each ASKIR {@link ask.Expression} into a
     * high-level {@link Expression} class and call the provided call back.
     *
     * Those Expressions represent concepts like {@link Expect}, {@link InvokeApi}, {@link ConditionalBranch}, {@link DialogExpansion}, etc.
     *
     * The most basic usage:
     * ```
     * flow.interpret(function interpret(expr): InterpretResult<boolean> {
     *   // process this expression in the stream
     *   const result = process(expr);
     *   if (result !== undefined) {
     *      // terminate the interpreter and end with this result
     *      return result;
     *   }
     *   // return a callback to handle the next expression after this one in the stream.
     *   return interpret;
     * })
     * ``
     *
     * Usually, you want to track some state. Do this with recursive closures. Below,
     * we track a variable, `seenEvent`, which we'll set to true if we come across an Expect event.
     *
     * At the end of the Dialog Flow stream, we'll return this value.
     * ```
     * get a list of booleans indicating if each branch in this Dialog Flow contains an Expect event.
     * const seenEvents = flow.interpret(function interpret(expr, seenEvent = false) {
     *   if (expr.isExpect()) {
     *     // if we receive an Expect event, we'll return a closure that sets the seenEvent variable to `true`.
     *     return (nextExpr) => interpret(nextExpr, true)
     *   } else if (expr.isEnd()) {
     *     // at the end, we'll return the result
     *     return seenEvent;
     *   } else {
     *     // otherwise, recursively process the next expression and pass along the `seenEvent` state.
     *     return (nextExpr) => interpret(nextExpr, seenEvent);
     *   }
     * })
     *
     * if (seenEvents.find(seenEvent => seenEvent === true) {
     *   // all
     * }
     * ```
     *
     * @param interpreter callback function to interpret the next Expression and return a
     * @param prev the previous Expression seen in this interpreter stream.
     * @returns a list of {@link State} objects, one for each branch in the Dialog Flow stream.
     */
    interpret<State extends object>(interpreter: (expr: Expression) => InterpretResult<State>, prev?: Expression | undefined): State[];
    /**
     * Push a Call or Condition node onto the Call Stack.
     *
     * @param node Call or Condition node to push onto the STack.
     * @returns a new Dialog Flow representing the environment within the Call or Condition
     */
    push(node: ask.Call | ask.Condition): Flow;
    /**
     * Steps to the next {@link expr} in the Dialog Flow.
     *
     * @param expr next expression in the flow
     * @returns a new Flow starting from the next {@link expr}
     */
    step<T extends ask.Node | undefined>(expr: T): Flow<T>;
    /**
     * Walks back up the Stack to create a Flow continuing with the return value and next expression.
     *
     * @param returnValue the value returned from this Frame
     * @return Flow a new Data Flow reprsenting the continuation of this Flow after returning the value.
     */
    pop(returnValue: Thing): Flow;
    /**
     * Fork this Dialog Flow into a new dialog flow, starting from this {@link expr}.
     * @param expr expression from which we need to fork the dialog, e.g. a Call to a Dialog or Condition branch.
     * @returns a new Flow starting with the first expression in the forked Dialog Flow.
     */
    fork(expr: ask.Node): Flow;
    visitPrevious<T>(hook: (branch: Flow | undefined) => T[]): T[];
    private walkEachBranch;
    /**
     * Returns true if the resetArgumentsAction resets the argument with value argValueThing. Returns false otherwise.
     * Example of false return:
     * ```
     * policies = [ResetArguments{arguments = [getWeather.arguments.cityName]}] //only reset cityName
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   getWeather(weatherRequest.cityName) // weatherRequest.cityName is reset
     * }
     * ```
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   people = expect(Invoke, getPeopleEvent)
     *   getWeather(weatherRequest.cityName, weatherRequest.date)
     *
     *   getWeather(weatherRequest.cityName, weatherRequest.date) // invalid since weatherRequest.cityName has been reset
     * }
     * ```
     * @param argValueThing 'Thing' object for the argument value we are validating
     * @param argumentActionName action name for the argument being validated
     * @param resetArgumentsAction {@link Apply} object for a an {@link Action} that has a corresponding ResetArguments policy
     * @param resetArgumentsPolicy the ResetArgumentsPolicy for the resetArgumentsAction
     * @param actionChecker checker for resetArgumentsAction
     * @returns true if the resetArgumentsAction resets the argument with value argValueThing which means:
     * 1) argumentActionName and resetArgumentsAction refer to the same action
     * 2) resetArgumentsAction is passed argValueThing
     * 3) resetArgumentsPolicy mentions the argument to which argValueThing is passed in resetArgumentsAction
     */
    private doesResetArgumentsResetArgument;
    /**
     * check whether the input argValue has been reset
     * @param argValueThing argValue to check whether it has been reset
     * @param argumentActionDecl The action declaration of the action which use the input argValue
     * @returns
     */
    isArgumentReset(argValueThing: Thing, argumentActionDecl: ask.ActionDeclaration): boolean;
}
//# sourceMappingURL=flow.d.ts.map