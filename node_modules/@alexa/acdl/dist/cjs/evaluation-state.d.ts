import { Map as ImmutableMap, Set as ImmutableSet } from "immutable";
import * as ask from "./ast";
import { ArgumentThing, Thing } from "./thing";
import { ProjectError } from "./error";
import { SkillContext } from "./skill-context";
import { ConfirmAction, Expect, Expression, Response, InvokeApi, Ensure, ConfirmArgs, DialogExpansion } from "./expression";
/**
 * The EvaluationState is an immutable class that tracks information observed while processing an
 * {@link Expression} stream with {@link Flow.interpret}. As the Dialog Flow forks on {@link DialogExpansion}
 * expansions and {@link ConditionalBranch}
 */
export declare class EvaluationState {
    readonly skillContext: SkillContext | undefined;
    /**
     * Arguments that have been requested. The string is the argument name.
     */
    readonly requestedArguments: ImmutableMap<ask.ActionDeclaration, ImmutableSet<string>>;
    readonly pendingConfirmations: ImmutableSet<ConfirmAction | Response>;
    readonly errors: ProjectError[];
    /**
     * A LIFO queue (Stack) of all expressions seen in the Flow until this time.
     */
    readonly expressionStack: Expression[];
    /**
     * The most recent received Event.
     */
    readonly previousEvent: Expect | undefined;
    /**
     * The most recent API invocation.
     */
    readonly previousApi: InvokeApi | undefined;
    /**
     * Most recent offer that has been affirmed but not invoked
     */ readonly pendingOffer: string | undefined;
    /**
     * API invocations that we have not yet ensured has a request prompt for each required argument.
     */
    readonly pendingRequestPromptValidation: ImmutableMap<Ensure | InvokeApi | Response | ConfirmArgs, ImmutableMap<ArgumentThing, ImmutableSet<string>>>;
    /**
     * Set of Dialogs that have been expanded so far in this dialog flow. We use this to detect
     * circular references to dialogs.
     */
    readonly expandedDialogs: ImmutableSet<ask.DialogDeclaration>;
    /**
     * Flag to indicate if a circular refrence has been detected.
     */
    readonly isCircular: boolean;
    constructor(skillContext: SkillContext | undefined, 
    /**
     * Arguments that have been requested. The string is the argument name.
     */
    requestedArguments?: ImmutableMap<ask.ActionDeclaration, ImmutableSet<string>>, pendingConfirmations?: ImmutableSet<ConfirmAction | Response>, errors?: ProjectError[], 
    /**
     * A LIFO queue (Stack) of all expressions seen in the Flow until this time.
     */
    expressionStack?: Expression[], 
    /**
     * The most recent received Event.
     */
    previousEvent?: Expect | undefined, 
    /**
     * The most recent API invocation.
     */
    previousApi?: InvokeApi | undefined, 
    /**
     * Most recent offer that has been affirmed but not invoked
     */ pendingOffer?: string | undefined, 
    /**
     * API invocations that we have not yet ensured has a request prompt for each required argument.
     */
    pendingRequestPromptValidation?: ImmutableMap<Ensure | InvokeApi | Response | ConfirmArgs, ImmutableMap<ArgumentThing, ImmutableSet<string>>>, 
    /**
     * Set of Dialogs that have been expanded so far in this dialog flow. We use this to detect
     * circular references to dialogs.
     */
    expandedDialogs?: ImmutableSet<ask.DialogDeclaration>, 
    /**
     * Flag to indicate if a circular refrence has been detected.
     */
    isCircular?: boolean);
    /**
     * Push an Expression onto the `expressionStack` and update `previousEvent` and `previousApi` accordingly.
     *
     * @param expression the next expression seen in the dialog flow.
     * @returns a new EvaluationState with the updated `expressionStack`, previousEvent` and `previousApi`.
     */
    pushExpr<Expr extends Expression>(expression: Expr): EvaluationState;
    hasExpandedDialog(dialog: DialogExpansion): boolean;
    /**
     * For a given API argument, if the argument is a built in or slot type, only the argument needs to be requested.
     * If the argument type is built in or slot this will return [`person`] assuming argument.argumentName is 'person'
     * If the argument is an object type, then we need to get to all paths leading to built in and slot types.
     * If the argument type looks like:
     *
     * type Person {
     *    PersonName name
     *    Number age
     *    Car car
     *    optional Number friendCount;
     * }
     *
     *
     * type Car {
     *   CarModel model;
     * }
     *
     * Where CarModel and PersonName are slot types.
     *
     * This method will return [`person.properties.name`, `person.properties.age`, `person.properties.car.properties.model`]
     *
     * @param argument argument to retrieve property paths that should be requested from
     * @returns The properties paths that should be requested put of argument
     */
    private getArgumentPaths;
    /**
     * Keep track of this API invocation and check later if it has all necessary request prompts.
     * Called for mandatory arguments of an invoked API originated from an event in evaluateInvokeApi or
     * for arguments to ensure/confirmArgs/response with more than one value in validateRequestPromptInArgsList
     * to add to pendingRequestPromptValidation
     * @param api api invocation
     * @param argName the name of the argument
     * @returns
     */
    withPendingRequestPromptValidation(api: InvokeApi | Response | Ensure | ConfirmArgs, arg: ArgumentThing): this;
    /**
     * Checks if this State has any outstanding/pending Confirmation Expressions such as
     * ConfirmAction and ConfirmArguments.
     */
    hasPendingConfirmation(): boolean;
    /**
     * Track a ConfirmAction or ConfirmArgs Response that is pending Confirmation.
     *
     * @param confirmation the response asking for confirmation from the user.
     */
    withPendingConfirmation(confirmation: ConfirmAction | Response): EvaluationState;
    withCircular(isCircular: boolean): EvaluationState;
    withPendingOffer(pendingOffer: string): EvaluationState;
    clearPendingOffer(): EvaluationState;
    /**
     * Add new discovered errors to the state.
     *
     * @param errors new errors
     */
    withError(...errors: ProjectError[]): EvaluationState;
    /**
     * @returns `true` if this state contains errors, `false` otherwise.
     */
    hasErrors(): boolean;
    /**
     * Register some {@link ArgumentThing}s as individually requested and are guarnateed to exist.
     *
     * @param ambient whether this argument request is ambient (meaning order of expression does not matter). Only the `ensure` block counts as an ambient request.
     * @param requestedArgs list of arguments that have been individually requested from the user.
     */
    withRequestedArguments(ambient: boolean, ...requestedArgs: ArgumentThing[]): EvaluationState;
    /**
     * Checks if an Action's argument is requested via previous Expressions.
     *
     * Case 1: `ensure` as a previous expression in this flow.
     * ```
     * ensure(
     *   RequestArguments {arguments = [foo.arguments.arg], response = apla }
     * )
     * // arg is requested by `ensure` above
     * foo(arg = argValue)
     * ```
     *
     * Case 2: a `response` with `Request` act.
     * ```
     * response(apla, Request { arguments = [foo.arguments.arg] })
     * // arg is requested by `response` above
     * foo(arg = argValue)
     * ```
     *
     * Case 3: same value passed to a previously requested argument.
     * ```
     * response(apla, Request { arguments = [foo.arguments.arg] })
     * foo(arg = argValue)
     * // because foo.arguments.arg is requested, argValue is considered requested for other actions also.
     * bar(arg = argValue)
     * ```
     *
     * TODO: this function does not cover the case where `ensure` is located AFTER an Expression. Implementing
     * this logic is accomplished by {@link Flow.isArgumentRequested} but is computationally expensive. Our
     * goal is to change that behavior and instead use {@link EvaluationState} to keep track of this until
     * the {@link End} of the Dialog Flow and then validate all actions lacking requested arguments then. That
     * way the validation will be constant time.
     *
     * @param arg the argument we are looking up a request prompt for
     * @param argValueThing the value of the argument
     * @returns true if the argument has been requested, false otherwise.
     */
    isArgumentRequested(arg: ArgumentThing | undefined, argValueThing?: Thing): boolean;
}
//# sourceMappingURL=evaluation-state.d.ts.map