"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyNode = void 0;
const _1 = require(".");
/**
 * Node in a tree useful to validate property paths in an utterance. See buildPropertyTree for details.
 */
class PropertyNode {
    /**
     *
     * @param property a Property in a type
     * @param propertyType the corresponding propertyType
     * @param children nodes corresponding to propertyType.Properties
     */
    constructor(property, propertyType, children = new Map()) {
        Object.defineProperty(this, "property", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: property
        });
        Object.defineProperty(this, "propertyType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: propertyType
        });
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: children
        });
    }
    /**
     * Out of a string in Utterances<MealOrderType> like:
     *  'I want a {pizzaOrder.size} {pizzaOrder.pizzaType} pizza and a {drinkOrder.size} {drinkOrder.drinkType} drink'
     * This will build a tree like seen below where each Parenthesis is a Property with the given name and type:
     *
     *                                                    ('', MealOrderType)
     *
     *                 ('pizzaOrder', PizzaOrderType)                                      ('drinkOrder', DrinkOrderType)
     *
     *     ('pizzaType' ,PizzaType)          ('size', PizzaSizeType)             ('drinkType', DrinkType)        ('size', DrinkSizeType)
     *
     * In the process of building the tree 'no such property' errors can be produced.
     * With the tree, at each node, we can verify if the required properties have been specified
     * @param propertyPaths each ask.Name contains dot separate property path like 'pizzaOrder.size' plus its location for error messages.
     * @param type the type where all the first segments in propertyPaths are supposed to belong to.
     * @param context used for type's toString
     * @param getPropertyMap memoized type's getPropertyMap
     * @returns errors and the root of the tree
     */
    static buildPropertyTree(propertyPaths, type, context, getPropertyMap) {
        var _a, _b;
        const errors = [];
        const root = new PropertyNode({ name: "", type, kind: "Property", index: 0 }, type);
        for (const propertyPath of propertyPaths) {
            const segments = ((_a = propertyPath.name) !== null && _a !== void 0 ? _a : "").split(".");
            let currentType = type;
            let currentNode = root;
            let propertyFound = true;
            for (const segment of segments) {
                const propertyToTypes = getPropertyMap(currentType);
                const segmentProperty = propertyToTypes.get(segment);
                const segmentType = segmentProperty === null || segmentProperty === void 0 ? void 0 : segmentProperty.type;
                if (!segmentProperty) {
                    propertyFound = false;
                    // ignore if slot value is empty between braces as this will be caught later on during validation
                    if (segment.replace(/\s*/g, "").length > 0) {
                        errors.push(_1.ValidationErrorFactory.UnknownProperty({
                            expr: propertyPath,
                            attributes: {
                                propertyName: segment,
                                typeName: currentType.toString(context),
                            },
                        }));
                    }
                    continue;
                }
                if (!segmentType) {
                    propertyFound = false;
                    errors.push(_1.ValidationErrorFactory.NameNotFoundInUtteranceValue({
                        expr: propertyPath,
                        attributes: {
                            value: segment,
                        },
                    }));
                    continue;
                }
                let segmentNode = currentNode.children.get(segment);
                if (!segmentNode) {
                    segmentNode = new PropertyNode(segmentProperty, segmentType);
                    currentNode.children.set(segment, segmentNode);
                }
                currentType = segmentType.getNonOptionalType();
                currentNode = segmentNode;
            }
            const elementType = currentType.isList()
                ? currentType.getListItemType()
                : currentType.isOptional()
                    ? currentType.getNonOptionalType()
                    : currentType;
            const isTypeValid = (elementType === null || elementType === void 0 ? void 0 : elementType.isBuiltIn()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isCoreType()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isAlexaSchema()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isSlotType());
            if (propertyFound && !(elementType === null || elementType === void 0 ? void 0 : elementType.isValidForUtterance())) {
                errors.push(_1.ValidationErrorFactory.UndefinedCatalogCustomType({
                    expr: propertyPath,
                    attributes: {
                        propertyName: (_b = propertyPath.name) !== null && _b !== void 0 ? _b : "",
                        propertyType: elementType === null || elementType === void 0 ? void 0 : elementType.toString(propertyPath),
                    },
                }));
            }
        }
        return { errors, root };
    }
}
exports.PropertyNode = PropertyNode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydHktbm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9wZXJ0eS1ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHdCQUFxRDtBQUtyRDs7R0FFRztBQUNILE1BQWEsWUFBWTtJQUN2Qjs7Ozs7T0FLRztJQUNILFlBQXFCLFFBQWtCLEVBQVcsWUFBa0IsRUFBVyxXQUFXLElBQUksR0FBRyxFQUF3Qjs7Ozs7bUJBQXBHOzs7Ozs7bUJBQTZCOzs7Ozs7bUJBQTZCOztJQUE2QyxDQUFDO0lBRTdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7SUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQzdCLGFBQXlCLEVBQ3pCLElBQVUsRUFDVixPQUE2QixFQUM3QixjQUFxRDs7UUFFckQsTUFBTSxNQUFNLEdBQWlCLEVBQUUsQ0FBQztRQUNoQyxNQUFNLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xGLEtBQUssTUFBTSxZQUFZLElBQUksYUFBYSxFQUFFO1lBQ3hDLE1BQU0sUUFBUSxHQUFHLENBQUMsTUFBQSxZQUFZLENBQUMsSUFBSSxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEQsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3ZCLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQztZQUN2QixJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDekIsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7Z0JBQzlCLE1BQU0sZUFBZSxHQUFHLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsTUFBTSxlQUFlLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztn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