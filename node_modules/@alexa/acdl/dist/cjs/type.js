"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Type_environment, _Type_extensions, _Type_properties, _Type_propertiesIndex, _Type_locales, _Type_leafTypes;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.isType = void 0;
const ask = __importStar(require("./ast"));
const apply_1 = require("./apply");
const ast_1 = require("./ast");
const util_1 = require("./util");
const thing_1 = require("./thing");
const visit_1 = require("./visit");
function isType(obj) {
    return (obj === null || obj === void 0 ? void 0 : obj.kind) === "Type";
}
exports.isType = isType;
/**
 * A Type represents an instantiated Type in some context.
 *
 * Any `genericArguments` are either explicitly substituted or inferred from the surrounding context.
 *
 * This class provides a lazily-evaluated API for querying properties of the type.
 */
class Type {
    constructor(checker, 
    /**
     * Declaration of the instantiated type.
     */
    declaration, 
    /**
     * Instantiated type arguments.
     */
    genericArguments, 
    /**
     * Source node of this Type.
     */
    // readonly source?: ask.Node,
    functionArgumentNames, 
    /**
     * Name of the function (if this is an abstract function signature)
     */
    functionName) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "declaration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: declaration
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: genericArguments
        });
        Object.defineProperty(this, "functionArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionArgumentNames
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionName
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Type"
        });
        // cache lazily evaluated environment - use `null` to indicate "cached, but empty".
        _Type_environment.set(this, void 0);
        // cache lazily evaluated list of base types - use `null` to indicate "cached, but empty".
        _Type_extensions.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_properties.set(this, void 0);
        // cache lazily evaluated property index - use `null` to indicate "cached, but empty".
        _Type_propertiesIndex.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_locales.set(this, void 0);
        /**
         * Cached lazily evaluated set of all the leaf types (including this) in this type.
         *
         * Note: We could store this as a Map<string, Type> if we want to include the full type path to the leaf type.
         */
        _Type_leafTypes.set(this, void 0);
    }
    /**
     * String representation of this Type.
     */
    toString(context) {
        var _a, _b, _c, _d;
        const inScope = context ? this.checker.lookupName(context, this.shortName) : undefined;
        const name = (inScope === null || inScope === void 0 ? void 0 : inScope.kind) === "TypeDeclaration" && ((_a = inScope.name) === null || _a === void 0 ? void 0 : _a.name) && inScope.name.name === ((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) ? this.shortName : (_c = this.name) === null || _c === void 0 ? void 0 : _c.name;
        if (this.isFunctionN() && this.functionArgumentNames !== undefined) {
            const prefix = this.isAction() ? "action" : this.isDialog() ? "dialog" : "function";
            return `${prefix} ${(_d = this.getFunctionReturnType()) === null || _d === void 0 ? void 0 : _d.toString()}${this.functionName ? ` ${this.functionName}` : ""}(${this.functionArgumentNames
                .map((name, i) => {
                let argType = this.getFunctionArgumentType(i);
                const isOptional = (argType === null || argType === void 0 ? void 0 : argType.isOptional()) === true;
                if (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                    while (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                        argType = argType.getOptionalType();
                    }
                }
                return `${isOptional ? "optional " : ""}${argType === null || argType === void 0 ? void 0 : argType.toString()} ${name}`;
            })
                .join(", ")})`;
        }
        return `${name}${this.genericArguments ? `<${this.genericArguments.map((a) => a === null || a === void 0 ? void 0 : a.toString(context)).join(", ")}>` : ""}`;
    }
    toTypeReference(context) {
        var _a;
        const ref = new ask.TypeReference(this.name, (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a.map((arg) => arg === null || arg === void 0 ? void 0 : arg.toTypeReference()), undefined, undefined);
        if (context) {
            ref.context = context;
        }
        return ref;
    }
    get shortName() {
        var _a, _b, _c;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) ? (0, util_1.getName)((_c = this.declaration.name) === null || _c === void 0 ? void 0 : _c.name) : undefined;
    }
    /**
     * Name of this Type.
     */
    get name() {
        var _a;
        return (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name;
    }
    get namespace() {
        var _a, _b;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) ? (0, util_1.getNamespace)((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : undefined;
    }
    /**
     * The type environment of this Type.
     *
     * Maps type aliases for Type Parameters to instantiated Types.
     */
    get environment() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_environment, "f") === undefined) {
            if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeDeclaration") {
                const genericArguments = this.declaration.genericArguments || [];
                __classPrivateFieldSet(this, _Type_environment, ((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.map((arg, i) => {
                    var _a, _b;
                    const name = (_b = (_a = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i]) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
                    return name === undefined
                        ? {}
                        : {
                            [name]: arg,
                        };
                }).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
            }
        }
        return __classPrivateFieldGet(this, _Type_environment, "f") || undefined;
    }
    /**
     * Ordered list of this Type's base types (the types it "extends").
     */
    get extensions() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_extensions, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_extensions, (_a = this.resolveExtensions()) !== null && _a !== void 0 ? _a : null, "f");
        }
        return (_b = __classPrivateFieldGet(this, _Type_extensions, "f")) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveExtensions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // instantiate the base types
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
            // Beta 1 loads Slot Types from the interaction model - they always extend string.
            return [this.checker.string];
        }
        if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration") {
            const actionArity = (_e = (_d = this.declaration.arguments) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0;
            const typeArgs = [
                ...((_g = (_f = this.declaration.arguments) === null || _f === void 0 ? void 0 : _f.map((arg) => this.checker.getType(arg.type))) !== null && _g !== void 0 ? _g : []),
                this.checker.getType(this.declaration.returnType),
            ];
            const actionType = this.checker.instantiateTypeDeclaration(this.checker.lookupTypeDeclaration(((_h = this.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "ActionDeclaration" ? (0, ast_1.ActionTypeName)(actionArity) : (0, ast_1.DialogTypeName)(actionArity)), typeArgs);
            if (actionType) {
                return [actionType];
            }
            return [this.checker.nothing];
        }
        if (((_j = this.declaration) === null || _j === void 0 ? void 0 : _j.kind) === "EnumDeclaration") {
            return [this.checker.enumeration()];
        }
        if (((_k = this.declaration) === null || _k === void 0 ? void 0 : _k.kind) === "EnumItemDeclaration") {
            const enumType = this.checker.getType(this.declaration.context);
            if (enumType) {
                return [enumType];
            }
        }
        else if (((_l = this.declaration) === null || _l === void 0 ? void 0 : _l.kind) === "TypeDeclaration" || ((_m = this.declaration) === null || _m === void 0 ? void 0 : _m.kind) === "TypeParameter") {
            const extensions = this.declaration.kind === "TypeDeclaration"
                ? this.declaration.extensions
                : this.declaration.kind === "TypeParameter"
                    ? this.declaration.constraints
                    : undefined;
            if (extensions) {
                return extensions
                    .map((extension) => {
                    var _a;
                    // map the input typeArgs to the base-type's arguments
                    const extEnv = ((_a = extension.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => {
                        var _a;
                        return ({
                            [(_a = arg === null || arg === void 0 ? void 0 : arg.name) === null || _a === void 0 ? void 0 : _a.name]: this.checker.instantiateTypeReference(arg, this.environment),
                        });
                    }).reduce((a, b) => ({ ...a, ...b }), {})) || undefined;
                    return this.checker.instantiateTypeReference(extension, extEnv);
                })
                    .filter(util_1.isNotUndefined);
            }
            if (((_o = this.declaration.name) === null || _o === void 0 ? void 0 : _o.name) !== ast_1.AlexaSchema.Nothing && ((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) !== ast_1.AlexaSchema.Thing) {
                return [this.checker.thing];
            }
        }
        else {
            return [this.checker.nothing];
        }
        return undefined;
    }
    /**
     * Ordered list of all Properties in this Type.
     *
     * @returns list of properties if any, `null` otherwise.
     */
    get properties() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        if (__classPrivateFieldGet(this, _Type_properties, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_properties, "f");
        }
        const properties = [];
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration") {
            // enum item has no properties, this will change when we support values https://github.com/alexa/ask-ac/issues/198
        }
        else if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" || this.isFunctionN()) {
            const typeType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Type);
            const actionType = this.checker.lookupTypeDeclaration(ast_1.AlexaConversations.Action);
            const argumentsType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Arguments);
            const returnType = (_d = this.getFunctionReturnType()) !== null && _d !== void 0 ? _d : this.checker.thing;
            if (actionType && typeType && returnType) {
                properties.push({
                    kind: "Property",
                    index: 0,
                    name: "arguments",
                    type: new Type(this.checker, argumentsType, [this]),
                }, {
                    kind: "Property",
                    index: 1,
                    name: "returnType",
                    type: this.checker.instantiateTypeDeclaration(typeType, [returnType]),
                });
            }
        }
        else if (((_e = this.declaration) === null || _e === void 0 ? void 0 : _e.kind) === "TypeDeclaration") {
            if (((_f = this.declaration.name) === null || _f === void 0 ? void 0 : _f.name) === ast_1.AlexaSchema.Type) {
                // this is the intrinsic `Type<T>` type that has varying behavior based on what type it references.
                const type = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g[0];
                if (type) {
                    if (((_h = type.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "EnumDeclaration") {
                        (_j = type.declaration.items) === null || _j === void 0 ? void 0 : _j.forEach((item, index) => {
                            var _a, _b;
                            if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
                                properties.push({
                                    kind: "Property",
                                    index,
                                    name: (_b = item.name) === null || _b === void 0 ? void 0 : _b.name,
                                    declaration: item,
                                    type: this.checker.getType(item),
                                });
                            }
                        });
                    }
                    else {
                        const propertiesType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Properties);
                        if (propertiesType) {
                            properties.push({
                                kind: "Property",
                                index: 0,
                                name: "properties",
                                type: new Type(this.checker, propertiesType, [type]),
                            });
                        }
                    }
                }
            }
            else if (((_k = this.declaration.name) === null || _k === void 0 ? void 0 : _k.name) === ast_1.AlexaSchema.Properties || ((_l = this.declaration.name) === null || _l === void 0 ? void 0 : _l.name) === ast_1.AlexaSchema.ArgumentProperties) {
                const property = ((_m = this.declaration.name) === null || _m === void 0 ? void 0 : _m.name) === ast_1.AlexaSchema.Properties ? ast_1.AlexaSchema.Property : ast_1.AlexaSchema.ArgumentProperty;
                const typeType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Type);
                const propType = this.checker.lookupTypeDeclaration(property);
                const type = (_o = this.genericArguments) === null || _o === void 0 ? void 0 : _o[0];
                if (typeType && propType && (type === null || type === void 0 ? void 0 : type.properties) !== undefined) {
                    properties.push(...type.properties.map((prop) => ({
                        ...prop,
                        type: this.checker.instantiateTypeDeclaration(propType, [prop.type]),
                        declaration: undefined,
                    })));
                }
            }
            else if (((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) === ast_1.AlexaConversations.ActionContextValues ||
                ((_q = this.declaration.name) === null || _q === void 0 ? void 0 : _q.name) === ast_1.AlexaSchema.ArgumentValues ||
                ((_r = this.declaration.name) === null || _r === void 0 ? void 0 : _r.name) === ast_1.AlexaSchema.Arguments) {
                // Arguments<F>, ArgumentValues<F> and ActionContextValues<A> all compute a type based on the arguments
                const targetType = (_s = this.genericArguments) === null || _s === void 0 ? void 0 : _s[0];
                const containerType = ((_t = this.declaration.name) === null || _t === void 0 ? void 0 : _t.name) === ast_1.AlexaConversations.ActionContextValues
                    ? this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional)
                    : this.declaration.name.name === ast_1.AlexaSchema.Arguments
                        ? this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Argument)
                        : undefined;
                properties.push(...((_v = (_u = targetType === null || targetType === void 0 ? void 0 : targetType.getFunctionArgumentDeclarations()) === null || _u === void 0 ? void 0 : _u.map((arg, index) => {
                    var _a, _b, _c, _d;
                    const innerType = this.checker.instantiateTypeReference(arg.type);
                    const prop = {
                        kind: "Property",
                        index,
                        name: (_a = arg.name) === null || _a === void 0 ? void 0 : _a.name,
                        type: ((_b = containerType === null || containerType === void 0 ? void 0 : containerType.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaSchema.Optional && (innerType === null || innerType === void 0 ? void 0 : innerType.isOptional())
                            ? innerType
                            : containerType
                                ? this.checker.instantiateTypeDeclaration(containerType, [innerType])
                                : ((_d = (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) === ast_1.AlexaSchema.ArgumentValues
                                    ? innerType
                                    : undefined,
                        declaration: arg,
                    };
                    return prop;
                })) !== null && _v !== void 0 ? _v : []));
            }
            else if (((_w = this.declaration.name) === null || _w === void 0 ? void 0 : _w.name) === ast_1.AlexaSchema.Optional) {
                // Optional<T> type would contain all the properties of `T`.
                const argumentType = (_x = this.genericArguments) === null || _x === void 0 ? void 0 : _x[0];
                if (argumentType && argumentType.properties) {
                    properties.push(...argumentType.properties);
                }
            }
            else {
                properties.push(...(((_z = (_y = this.declaration) === null || _y === void 0 ? void 0 : _y.properties) === null || _z === void 0 ? void 0 : _z.map((prop, index) => {
                    var _a;
                    let type = prop.type !== undefined ? this.checker.instantiateTypeReference(prop.type, this.environment) : undefined;
                    if (prop.optional === true && (type === null || type === void 0 ? void 0 : type.isOptional()) === false) {
                        const optionalType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional);
                        if (optionalType) {
                            type = this.checker.instantiateTypeDeclaration(optionalType, [type]);
                        }
                    }
                    return {
                        kind: "Property",
                        declaration: prop,
                        index,
                        name: (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name,
                        type,
                    };
                })) || []));
            }
        }
        const seen = new Set();
        const _properties = [];
        addProperties(properties);
        if (this.extensions) {
            for (const ext of this.extensions) {
                if (ext.properties) {
                    addProperties(ext.properties);
                }
            }
        }
        __classPrivateFieldSet(this, _Type_properties, _properties || null, "f");
        return __classPrivateFieldGet(this, _Type_properties, "f") || undefined;
        function addProperties(properties) {
            if (properties) {
                for (const property of properties) {
                    if (!seen.has(property.name)) {
                        _properties.push(property);
                        seen.add(property.name);
                    }
                }
            }
        }
    }
    /**
     * Index of all Properties by name.
     */
    get propertiesIndex() {
        var _a;
        if (__classPrivateFieldGet(this, _Type_propertiesIndex, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_propertiesIndex, ((_a = this.properties) === null || _a === void 0 ? void 0 : _a.map((p) => ({
                [p.name]: p,
            })).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
        }
        return __classPrivateFieldGet(this, _Type_propertiesIndex, "f") || undefined;
    }
    /**
     * Apply a Call to this Type.
     *
     *
     * @param call expression of input to the Action.
     */
    apply(call, checker = this.checker) {
        return new apply_1.Apply(checker, call, this);
    }
    /**
     * Instantiate a new Thing of this Type.
     *
     * @param node AST node this Thing value originates from.
     * @returns a Thing instance representing this distinct Thing
     */
    getThing(token, origin, parent, apply) {
        var _a;
        // use the environment of the Application or default to this environment
        const checker = (_a = apply === null || apply === void 0 ? void 0 : apply.checker) !== null && _a !== void 0 ? _a : this.checker;
        if (this.isPrimitive()) {
            if (this.isStringLike()) {
                return new thing_1.StringThing(checker, token, this, apply, origin, parent);
            }
            if (this.isBoolean()) {
                return new thing_1.BooleanThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNumber()) {
                return new thing_1.NumberThing(checker, token, this, apply, origin, parent);
            }
            if (this.isVoid()) {
                return new thing_1.VoidThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNothing()) {
                return new thing_1.NothingThing(checker, token, this, apply, origin, parent);
            }
        }
        else if (this.isAction()) {
            return new thing_1.ActionThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isDialog()) {
            return new thing_1.DialogThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isFunction()) {
            return new thing_1.FunctionThing(checker, token, this, (origin === null || origin === void 0 ? void 0 : origin.kind) === "ArgumentDeclaration" ? origin : undefined);
        }
        else if (this.isList()) {
            return new thing_1.ListThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArgument()) {
            return new thing_1.ArgumentThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArguments()) {
            return new thing_1.ArgumentsThing(checker, token, this, origin, parent === null || parent === void 0 ? void 0 : parent.asFunction());
        }
        else if (this.isObject()) {
            return new thing_1.ObjectThing(checker, token, this, apply, origin, parent);
        }
        return new thing_1.AnyThing(checker, token, this, apply, origin, parent);
    }
    /**
     * Get the type of a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getPropertyType(argument) {
        var _a;
        return (_a = this.getProperty(argument)) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Get a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getProperty(argument) {
        var _a, _b, _c;
        if (argument === undefined) {
            return undefined;
        }
        if (ask.isArgument(argument)) {
            if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                return this.getProperty(argument.name.name);
            }
            if (typeof argument.index === "number") {
                return this.getProperty(argument.index);
            }
        }
        else if (typeof argument === "number") {
            return (_b = this.properties) === null || _b === void 0 ? void 0 : _b[argument];
        }
        else {
            const prop = (_c = this.propertiesIndex) === null || _c === void 0 ? void 0 : _c[argument];
            if (prop) {
                return prop;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const prop = ext.getProperty(argument);
                    if (prop) {
                        return prop;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Get the Nodes referenced by this Type.
     */
    getReferences() {
        var _a;
        const references = new Set();
        (_a = this.properties) === null || _a === void 0 ? void 0 : _a.forEach((prop) => {
            var _a, _b;
            if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                findReferences(prop.type);
            }
        });
        return references;
        function findReferences(type) {
            var _a, _b, _c;
            if ((type === null || type === void 0 ? void 0 : type.declaration) !== undefined && !references.has(type.declaration)) {
                references.add(type.declaration);
                (_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.forEach(findReferences);
                (_b = type.extensions) === null || _b === void 0 ? void 0 : _b.forEach(findReferences);
                (_c = type.properties) === null || _c === void 0 ? void 0 : _c.forEach((prop) => {
                    var _a, _b;
                    if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                        findReferences(prop.type);
                    }
                });
            }
        }
    }
    /**
     * Scan this type for any type arguments or super-types that consist of TypeParameters.
     */
    hasTypeParameters() {
        var _a, _b, _c;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return true;
        }
        return (((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.find((t) => t === null || t === void 0 ? void 0 : t.hasTypeParameters())) !== undefined ||
            ((_c = this.extensions) === null || _c === void 0 ? void 0 : _c.find((e) => e.hasTypeParameters())) !== undefined);
    }
    /**
     * A type has a catalog if it is:
     * - a built-in slot type
     * - a custom slot type found in the interaction model
     * - has an association with a catalog using `@catalog` annotation
     */
    hasCatalog() {
        var _a, _b, _c;
        return ((_c = (((_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.BuiltinsNamespace)) || ((_b = this.namespace) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.SlotTypesNamespace)) || this.hasCatalogAnnotation())) !== null && _c !== void 0 ? _c : false);
    }
    hasCatalogAnnotation() {
        var _a, _b;
        return (ask.isTypeDeclaration(this.declaration) &&
            ((_b = (_a = this.declaration.annotations) === null || _a === void 0 ? void 0 : _a.filter((annotation) => { var _a; return (_a = this.checker.getApply(annotation.call)) === null || _a === void 0 ? void 0 : _a.isCatalogAction(); }).length) !== null && _b !== void 0 ? _b : 0) > 0);
    }
    /**
     * A custom type is one that is not defined in:
     * 1. com.amazon.alexa.schema
     * 2. com.amazon.alexa.ask.conversations
     * 3. com.amazon.ask.types.builtins.AMAZON
     *
     * TODO: validate that users can't use these namespaces: https://github.com/alexa/ask-ac/issues/3
     */
    isCustom() {
        return !(this.isBuiltIn() || this.isAlexaSchema() || this.isCoreType());
    }
    /**
     * Checks if this is a built in type provided by the platform.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     *
     * TODO: should we also consider Alexa Schema as built-in?
     */
    isBuiltIn() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.BuiltinsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * @returns true if the type can be used as the result type of an utterance
     */
    isValidForUtterance() {
        return this.isBuiltIn() || this.isCoreType() || this.isAlexaSchema() || this.isSlotType() || this.hasCatalog();
    }
    /**
     * Checks if this is a valid UtteranceEvent wrapper type
     */
    isValidUtteranceWrapper() {
        return (!this.isPrimitive() || this.isNothing()) && !this.isBuiltIn();
    }
    /**
     * Checks if this type is defined in an interaction model.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     */
    isSlotType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.SlotTypesNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in the AC core library.
     *
     * Namespace:
     * `com.amazon.alexa.ask.conversations`
     */
    isCoreType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.AlexaConversationsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in Alexa Schema.
     *
     * Namespace:
     * `com.amazon.alexa.schema`
     */
    isAlexaSchema() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.AlexaSchemaNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Check if this type is the top-level Skill type.
     */
    isSkill() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaConversations.Skill;
    }
    /**
     * Check if this type is the SkillLevelResponses type.
     */
    isSkillLevelResponses() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaConversations.SkillLevelResponses;
    }
    /**
     * Check if this type is the InvocationName type.
     */
    isInvocationName() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaConversations.InvocationName;
    }
    /**
     * A complex type is one with at least one property.
     */
    isObject() {
        var _a, _b;
        return ((_b = (_a = this.properties) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0;
    }
    /**
     * Check if a name is (inclusively) found in this type's hierarchy.
     *
     * @param name name of type to find
     */
    isNameInHierarchy(name) {
        return this.findNameInHierarchy(name) !== undefined;
    }
    /**
     * Find a type by name in this type's hierarchy.
     *
     * E.g.
     * ```
     * looking for UtteranceEvent<T>
     *
     * // type is the one we're looking for
     * UtteranceEvent<T> => UtteranceEvent<T>
     *
     * // search the type's hierarchy.
     * type A : UtteranceEvent<String> => UtteranceEvent<String>
     *
     * // type does not exist
     * type B => undefined
     * ```
     *
     *
     * @param name name of the type to find
     */
    findNameInHierarchy(name) {
        var _a, _b, _c;
        if (name !== undefined) {
            if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && typeof name === "function" ? name((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : ((_c = this.name) === null || _c === void 0 ? void 0 : _c.name) === name) {
                return this;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const found = ext.findNameInHierarchy(name);
                    if (found) {
                        return found;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Check if this is the intrinsic `Properties<T>` type that computes the properties of some type, `T`.
     */
    isProperties() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Properties;
    }
    /**
     * Check if this is the intrinsic `Property<T>`.
     */
    isProperty() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Property;
    }
    /**
     * If this is a type `Property<T>`, return the inner type, `T`.
     */
    getPropertyTypeType() {
        var _a;
        if (this.isProperty()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * Check if this is the `Type<T>` type.
     *
     * ```
     * type Person {
     *   String name
     * }
     *
     * // Type<Person>
     * person = Person
     * ```
     */
    isType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Type;
    }
    /**
     * Get the type of the `Type<T>` type - in this case, `T`.
     *
     * ```
     * Type<Person> => Person
     * ```
     */
    getTypeType() {
        var _a, _b;
        if (this.isType()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return (_b = this.findNameInHierarchy(ast_1.AlexaSchema.Type)) === null || _b === void 0 ? void 0 : _b.getTypeType();
    }
    /**
     * Is the `ReturnValue<T>` intrinsic type.
     */
    isReturnValue() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.ReturnValue;
    }
    /**
     * Get the type parameter of the `ReturnValue<T>`.
     */
    getReturnValueType() {
        var _a;
        return this.isReturnValue() ? (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0] : undefined;
    }
    /**
     * Is this Type `alexa.schema.Nothing` (the Bottom Type)?
     */
    isNothing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Nothing;
    }
    /**
     * Is this Type `alexa.schema.Thing` (the Bottom Type)?
     */
    isThing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Thing;
    }
    /**
     * Is this type `Nothing`, `Void`, `Boolean`, `Number`, `String`, `Date` or `Time`.
     */
    isPrimitive() {
        return this.isNothing() || this.isVoid() || this.isBoolean() || this.isNumber() || this.isStringLike();
    }
    /**
     * Is this type one of 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'.
     */
    isResponseAct() {
        return (this.isRequest() ||
            this.isConfirmArgs() ||
            this.isConfirmAction() ||
            this.isNotify() ||
            this.isOffer() ||
            this.isReqAlt() ||
            this.isBye() ||
            this.isReqMore());
    }
    /**
     * Is this the Void type, `com.amazon.alexa.schema.Void`?
     *
     * @version 1.0.0-beta2
     */
    isVoid() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Void;
    }
    /**
     * Is this type, `Optional<T>`?
     *
     * Also known as a union, `T | Void`.
     */
    isOptional() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Optional;
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isBoolean() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Boolean);
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isNumber() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Number);
    }
    /**
     * Is this a String-like Type?
     *
     * TODO: should Date and Time really be considered String-like?
     */
    isStringLike() {
        return this.isString() || this.isUtterance();
    }
    /**
     * is this type String or a sub-type of String.
     */
    isString() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.String);
    }
    /**
     * Is this the core `com.amazon.alexa.ask.conversations.UtteranceEvent` type?
     */
    isUtteranceEvent() {
        return this.isNameInHierarchy(ast_1.AlexaConversations.UtteranceEvent);
    }
    /**
     * Get the UtteranceEvent's inner type.
     *
     * E.g.
     *
     * ```
     * UtteranceEvent<Person> => Person
     * ```
     */
    getUtteranceEventType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaConversations.UtteranceEvent)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Get the IntentEvent's inner type.
     *
     * E.g.
     *
     * ```
     * IntentEvent<Person> => Person
     * ```
     */
    getIntentEventType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaConversations.IntentEvent)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic `Utterance` type, representing a type-safe sample utterance string.
     *
     * ```
     * // UtteranceEvent<Person>
     * u = utterances<Person>(
     *   // List<Utterance<Person>>
     *   [
     *     // Utterance<Person>
     *     "i am {name}"
     *   ]
     * )
     * ```
     */
    isUtterance() {
        return this.isNameInHierarchy(ast_1.AlexaConversations.Utterance);
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Argument type representing an argument on some action.
     *
     * ```
     * action A(String arg)
     *
     * // Argument<String>
     * a = A.arguments.arg
     * ```
     */
    isArgument() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Argument);
    }
    /**
     * @returns the type `T` in `Argument<T>`.
     */
    getArgumentType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaSchema.Argument)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Arguments type representing the arguments of some Action.
     *
     * ```
     * action A(String arg)
     *
     * // Arguments<A>
     * a = A.arguments
     * ```
     */
    isArguments() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Arguments);
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * Utterance<Person> => (type) Person
     * utterances<Person>([
     *   "hello" => (type) Person
     * ])
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getUtteranceType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaConversations.Utterance)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Get the type of an Optional.
     *
     * ```
     * Optional<String> => (type) String
     * Optional<T> => (type parameter) T
     * ```
     */
    getOptionalType() {
        var _a;
        if (this.isOptional()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * If this is Optional<T> returns T else returns this
     * @returns
     */
    getNonOptionalType() {
        var _a;
        return this.isOptional() && ((_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0]) ? this.genericArguments[0] : this;
    }
    /**
     * Checks if this type is the `Locale` enum type.
     */
    isLocale() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Locale;
    }
    /**
     * Checks if this type is the `AnnotationTarget` enum type.
     */
    isAnnotationTarget() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.AnnotationTarget;
    }
    /**
     * Checks if this is a type that extends the base Function type.
     *
     * Both Action and Dialog types extend Function.
     *
     * @returns
     */
    isFunction() {
        return this.findNameInHierarchy(ast_1.AlexaSchema.Function) !== undefined;
    }
    /**
     * Checks if this Type extends one of `FunctionN` functions where `N` is a numerical value representing
     * the number of arguments in the Function.
     */
    isFunctionN() {
        return this.getFunctionN() !== undefined;
    }
    /**
     * Gets the `FunctionN` type in this Type's hierarchy if this is of type `FunctionN` where `N` is a
     * numerical value representing the number of arguments in the Function.
     */
    getFunctionN() {
        return this.findNameInHierarchy((s) => s.startsWith(ast_1.AlexaSchema.Function) && s !== ast_1.AlexaSchema.Function);
    }
    /**
     * If this Type is a Function (Dialog or Action) then
     * @returns
     */
    getFunctionReturnType() {
        var _a, _b, _c, _d;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.checker.instantiateTypeReference(this.declaration.returnType);
        }
        if (this.isFunctionN()) {
            const functionN = this.getFunctionN();
            return (_c = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _c === void 0 ? void 0 : _c[((_d = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _d === void 0 ? void 0 : _d.length) - 1];
        }
        return undefined;
    }
    getFunctionArgumentType(index) {
        var _a, _b;
        return (_b = (_a = this.getFunctionN()) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[index];
    }
    getFunctionArgumentTypes() {
        var _a, _b, _c, _d, _e;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return (_c = this.declaration.arguments) === null || _c === void 0 ? void 0 : _c.map((arg) => this.checker.getType(arg));
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => { var _a; return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]; });
            }
            // parse the value of N in a FunctionN/ActionN/DialogN.
            const nStr = (_d = this.shortName) === null || _d === void 0 ? void 0 : _d.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    args.push((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e[i]);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Get the ArgumentDeclarations for this Type if the Type is a Function.
     */
    getFunctionArgumentDeclarations() {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.declaration.arguments;
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => {
                    var _a, _b, _c;
                    const decl = new ask.ArgumentDeclaration(new ask.Name(name), (_b = (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.toTypeReference());
                    (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.setAsParentOn(decl);
                    return decl;
                });
            }
            const nStr = (_c = this.shortName) === null || _c === void 0 ? void 0 : _c.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    // BUG: we are moving the TypeReference to the TypeDeclaration so it has the wrong lexical scope.
                    const decl = new ask.ArgumentDeclaration(new ask.Name(`arg${i}`), (_e = (_d = this.genericArguments) === null || _d === void 0 ? void 0 : _d[i]) === null || _e === void 0 ? void 0 : _e.toTypeReference());
                    (_f = this.declaration) === null || _f === void 0 ? void 0 : _f.setAsParentOn(decl);
                    args.push(decl);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Takes two Function types and creates a mapping between their respective argument names based on position.
     *
     * This is the foundation on which we allow functions passed around as arguments to be compatible even
     * when they don't have the same argument names. We do not wish for argument names to be relevant for
     * the compatibility of functions.
     *
     * Ex. `foo.getFunctionArgumentDeclarationMappings(Foo)`:
     * ```
     * action String Foo(String arg)
     *
     * dialog Bar(
     *   action String foo(String str)
     * ) {
     *   sample {
     *     // here, foo's `str` will be mapped to Foo's `arg`.
     *     foo(str = "hello")
     *   }
     * }
     * ```
     *
     * @param other the other type we are mapping this argument's names to.
     * @returns resulting mappings will map from `this`'s argument names to `other`'s argument names.
     */
    getFunctionArgumentDeclarationMappings(other) {
        var _a;
        if (other === undefined || !(other.isFunction() && this.isFunction())) {
            return undefined;
        }
        const thisArgs = this.getFunctionArgumentDeclarations();
        if (thisArgs === undefined) {
            return undefined;
        }
        return (_a = other
            .getFunctionArgumentDeclarations()) === null || _a === void 0 ? void 0 : _a.map((arg, i) => {
            var _a, _b;
            const argDecl = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs[i];
            if (((_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name) && ((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name)) {
                return {
                    [argDecl.name.name]: arg.name.name,
                };
            }
            return {};
        }).reduce((a, b) => ({ ...a, ...b }), {});
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialogDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "DialogDeclaration";
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialog() {
        return this.findNameInHierarchy(ast_1.AlexaConversations.Dialog) !== undefined;
    }
    /**
     * Checks if this type is a fully qualified TypeDeclaration.
     */
    isTypeDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeDeclaration";
    }
    /**
     * Checks if this type is a fully qualified ActionDeclaration.
     */
    isActionDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration";
    }
    isAction() {
        return this.findNameInHierarchy(ast_1.AlexaConversations.Action) !== undefined;
    }
    /**
     * Checks if this is a type
     * @returns
     */
    isEnum() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumDeclaration";
    }
    /**
     * Checks if this is a Type representing an item in an `enum`.
     * @returns
     */
    isEnumItem() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration";
    }
    /**
     * Is this `com.amazon.alexa.ask.conversations.Args` or a sub-type.
     *
     * This type represents var args in an Action.
     *
     * ```
     * action void A(Args<String>)
     *
     * a = A(
     *   "no need",
     *   "to surround these with",
     *   "[ and ]"
     * )
     * ```
     */
    isArgs() {
        return this.isNameInHierarchy(ast_1.AlexaConversations.Args);
    }
    /**
     * Does this Type extend `alexa.schema.List`.
     */
    isList() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.List);
    }
    isTaskContextProjection() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.TaskContextProjection;
    }
    isTaskContextProjectionType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.TaskContextProjectionType;
    }
    isTaskContextProjectionAnnotation() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.taskContextProjection;
    }
    isTaskContextProjectionInfo() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.TaskContextProjectionInfo;
    }
    /**
     * Is this type one of 'Invoke', 'Inform', 'Affirm', 'Deny', 'RequestAct'.
     */
    isRequestAct() {
        var _a;
        return this.isInvoke() || this.isInform() || this.isAffirm() || this.isDeny() || ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.RequestAct;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Invoke"
     */
    isInvoke() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Invoke;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Inform"
     */
    isInform() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Inform;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Affirm"
     */
    isAffirm() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Affirm;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Deny"
     */
    isDeny() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Deny;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Offer"
     */
    isOffer() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Offer;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqAlt"
     */
    isReqAlt() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ReqAlt;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isReqMore() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ReqMore;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Request"
     */
    isRequest() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Request;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.RequestArguments"
     */
    isRequestArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.RequestArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmAction"
     */
    isConfirmAction() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmAction;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmArgs"
     */
    isConfirmArgs() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArgs;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmArguments"
     */
    isConfirmArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Bye"
     */
    isBye() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Bye;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Notify"
     */
    isNotify() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Notify;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APLA"
     */
    isApla() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.APLA;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.MultiModalResponse"
     */
    isMultiModalResponse() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.MultiModalResponse;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APL"
     */
    isApl() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.APL;
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * List<String> => (type) String
     * List<T> => (type parameter) T
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getListItemType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaSchema.List)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Check if this type is a sub-type (or same type) as a `baseType`.
     *
     * A type, `A` extends another type, `B` if `A & B == B`.
     *
     * In other words, the intersection of A and B should be exactly B.
     *
     * @param baseType base type
     */
    extends(baseType) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (baseType === undefined) {
            return false;
        }
        if (this.isNothing()) {
            // Nothing is a sub type of all Things
            return true;
        }
        if (baseType.isThing()) {
            // Thing is the base type of all Things.
            return true;
        }
        if (this.isVoid() && baseType.isOptional()) {
            return true;
        }
        if (this.isVoid() && baseType.isNothing()) {
            // for backwards compatibility, we will equate `Nothing` and `Void`.
            return true;
        }
        if ((((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" && ((_b = baseType.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration") ||
            (((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" && ((_d = baseType.declaration) === null || _d === void 0 ? void 0 : _d.kind) === "DialogDeclaration")) {
            // if we are comparing literal actions/dialogs, then their name must be identical regardless of compatibility
            // we still uphold nominal rules when comparing static references.
            return ((_e = this.declaration.name) === null || _e === void 0 ? void 0 : _e.name) === ((_f = baseType.declaration.name) === null || _f === void 0 ? void 0 : _f.name);
        }
        if (this.isFunctionN() && baseType.isFunctionN()) {
            if (baseType.isAction() && !this.isAction()) {
                return false;
            }
            if (baseType.isDialog() && !this.isDialog()) {
                return false;
            }
            const thisArgs = (_g = this.getFunctionN()) === null || _g === void 0 ? void 0 : _g.getFunctionArgumentTypes();
            const baseTypeArgs = (_h = baseType.getFunctionN()) === null || _h === void 0 ? void 0 : _h.getFunctionArgumentTypes();
            if (!((_k = (_j = this.getFunctionReturnType()) === null || _j === void 0 ? void 0 : _j.extends(baseType.getFunctionReturnType())) !== null && _k !== void 0 ? _k : false)) {
                // return types are co-variant, this function's return type must extend the base function's return type
                return false;
            }
            // Lengths are different, lets check the extraneous arguments in baseType and ensure they're optional
            if ((thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length) && (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length)) {
                const startArgPos = (_l = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== null && _l !== void 0 ? _l : 0;
                for (let i = startArgPos; i < baseTypeArgs.length; i++) {
                    if (!baseTypeArgs[i].isOptional() || !baseTypeArgs[i].isArgs()) {
                        return false;
                    }
                }
            }
            return ((_m = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.map((thisArg, i) => {
                const otherArg = baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs[i];
                if (otherArg === undefined) {
                    return thisArg.isOptional() || thisArg.isArgs();
                }
                // arguments are contra-variant, the base type's argument must be a super-type of this function's argument.
                return otherArg.extends(thisArg);
            }).reduce((a, b) => a && b, true)) !== null && _m !== void 0 ? _m : false);
        }
        if (((_o = this.name) === null || _o === void 0 ? void 0 : _o.name) === ((_p = baseType.name) === null || _p === void 0 ? void 0 : _p.name)) {
            if (this.genericArguments) {
                if (this.genericArguments.length === ((_q = baseType.genericArguments) === null || _q === void 0 ? void 0 : _q.length)) {
                    return this.genericArguments.find((genericArg, i) => (genericArg === null || genericArg === void 0 ? void 0 : genericArg.extends(baseType === null || baseType === void 0 ? void 0 : baseType.genericArguments[i])) !== true) === undefined;
                }
                return false;
            }
            return true;
        }
        // Check optional types, we currently allow Optional<T> as assignable to T.
        if (baseType.isOptional()) {
            return this.extends(baseType.getOptionalType());
        }
        else if (this.isOptional()) {
            return (_s = (_r = this.getOptionalType()) === null || _r === void 0 ? void 0 : _r.extends(baseType)) !== null && _s !== void 0 ? _s : false;
        }
        return ((_t = this.extensions) === null || _t === void 0 ? void 0 : _t.find((extension) => (extension === null || extension === void 0 ? void 0 : extension.extends(baseType)) === true)) !== undefined;
    }
    /**
     * Check if two instantiated types are identical.
     *
     * @param other
     */
    equals(other) {
        var _a;
        if (this.name !== undefined && this.name === other.name) {
            if (this.genericArguments !== undefined && this.genericArguments.length === ((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                for (let i = 0; i < this.genericArguments.length; i++) {
                    const _this = this.genericArguments[i];
                    const _other = other.genericArguments[i];
                    if (_this === undefined || _other === undefined) {
                        return false;
                    }
                    if (!_this.equals(_other)) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Get the union of this type and another. We only have limited support for unions at this time.
     *
     * Rules:
     * 1. Void | Void = Void
     * 2. Nothing | T = T
     * 3. Void | T = Optional<T>
     * 4. Optional<T> | T = Optional<T>
     * 5. A | B = A & B
     *
     * RE: Rule #5 - when two non-Optional or Void types are unioned, we take their intersection. I.e. we
     * reduce their type to their most common denominator. We will change this once we add full support for
     * union types.
     *
     * @param other other type to union this type with
     * @returns the unioned type.
     */
    union(other) {
        var _a, _b;
        if (other === undefined) {
            return this;
        }
        if (this.equals(other)) {
            return this;
        }
        if (this.isNothing()) {
            return other;
        }
        if (other === null || other === void 0 ? void 0 : other.isNothing()) {
            return this;
        }
        if (this.isVoid() && (other === null || other === void 0 ? void 0 : other.isVoid())) {
            return this;
        }
        if (this.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional), [other]);
        }
        if (other.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional), [this]);
        }
        if (this.isOptional()) {
            return this.checker.void.union((_a = this.getOptionalType()) === null || _a === void 0 ? void 0 : _a.union(other));
        }
        if (other.isOptional()) {
            return this.checker.void.union((_b = other.getOptionalType()) === null || _b === void 0 ? void 0 : _b.union(this));
        }
        return this.intersect(other);
        // return this.getIntersection(other);
    }
    intersect(other) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.isNothing() || (other === null || other === void 0 ? void 0 : other.isNothing())) {
            return this.checker.nothing;
        }
        if (other === undefined) {
            return undefined;
        }
        if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ((_b = other.name) === null || _b === void 0 ? void 0 : _b.name)) {
            if (((_c = this.genericArguments) === null || _c === void 0 ? void 0 : _c.length) === 0 && ((_d = other.genericArguments) === null || _d === void 0 ? void 0 : _d.length) === 0) {
                return this;
            }
            if (((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e.length) === ((_f = other.genericArguments) === null || _f === void 0 ? void 0 : _f.length)) {
                const genericArguments = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g.map((genericArg, i) => { var _a, _b; return (_b = genericArg === null || genericArg === void 0 ? void 0 : genericArg.intersect((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a[i])) !== null && _b !== void 0 ? _b : this.checker.thing; });
                return new Type(this.checker, this.declaration, genericArguments);
            }
        }
        else if (this.extends(other)) {
            for (const ext of (_h = this.extensions) !== null && _h !== void 0 ? _h : []) {
                if (ext.extends(other)) {
                    return ext.intersect(other);
                }
            }
        }
        else if (other.extends(this)) {
            for (const ext of (_j = other.extensions) !== null && _j !== void 0 ? _j : []) {
                if (ext.extends(this)) {
                    return ext.intersect(this);
                }
            }
        }
        else {
            for (const thisExt of (_k = this.extensions) !== null && _k !== void 0 ? _k : []) {
                for (const otherExt of (_l = other.extensions) !== null && _l !== void 0 ? _l : []) {
                    if (thisExt.extends(otherExt)) {
                        return thisExt.intersect(otherExt);
                    }
                }
            }
        }
        return this.checker.thing;
    }
    narrow(other) {
        if (other === undefined) {
            return this;
        }
        if (other.extends(this)) {
            // if the other type is more narrow, choose it
            return other;
        }
        if (this.extends(other)) {
            // if this type is more general, choose the other
            return this;
        }
        // these types have no intersection, this case is impossible.
        return this.checker.nothing;
    }
    /**
     * Find all locales this type support
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales() {
        if (__classPrivateFieldGet(this, _Type_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_locales, "f");
        }
        const slotTypes = new Set();
        const seen = new Set();
        // Find all slotTypes this type depends on
        if (this.isSlotType()) {
            slotTypes.add(this.declaration);
        }
        else {
            // recursively look up the child types
            (0, visit_1.visitEachChildType)(this, function collectSlotType(type) {
                var _a;
                if (type.declaration && !seen.has(type.toString())) {
                    seen.add(type.toString());
                    if (((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
                        slotTypes.add(type.declaration);
                    }
                    (0, visit_1.visitEachChildType)(type, collectSlotType);
                }
            });
        }
        // calculate the overlap locales that all slotTypes support
        let locales;
        for (const slotType of slotTypes.values()) {
            if (!locales) {
                locales = [...slotType.locales];
            }
            else {
                locales = locales.filter((locale) => slotType.locales.includes(locale));
            }
        }
        __classPrivateFieldSet(this, _Type_locales, locales, "f");
        return __classPrivateFieldGet(this, _Type_locales, "f");
    }
    /**
     * Gets a map of required property names to properties in this.properties
     * @returns a map of required property names to properties in this.properties
     */
    getRequiredProperties() {
        var _a;
        return new Map((_a = this.properties) === null || _a === void 0 ? void 0 : _a.reduce((acc, property) => {
            var _a, _b, _c;
            if (((_a = property.type) === null || _a === void 0 ? void 0 : _a.isOptional()) || (((_b = property.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "TypeProperty" && ((_c = property.declaration) === null || _c === void 0 ? void 0 : _c.optional) === true)) {
                return acc;
            }
            acc.push([property.name, property]);
            return acc;
        }, []));
    }
    /**
     * Gets a map of property names to corresponding properties
     * @returns a map of property names to corresponding properties
     */
    getPropertyMap() {
        var _a;
        return new Map(((_a = this.properties) !== null && _a !== void 0 ? _a : []).map((property) => [property.name, property]));
    }
    /**
     * Retrieves generic arguments nested in a Type declaration of the form Apply<Optional<T>,K>.
     * For such type this will return an array with two elements, a type object corresponding to T
     * and a type object corresponding to K.
     */
    getNestedGenericArguments() {
        var _a, _b;
        // This is the recursion termination case for when we reach T in  Action1<Optional<T>, Nothing>
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return [this];
        }
        const typeGenericArguments = (_b = this.genericArguments) !== null && _b !== void 0 ? _b : [];
        if (typeGenericArguments.length === 0) {
            // This is a special case found in Action1<Optional<T>, Nothing>. Nothing has no
            // nested generic arguments so we just return a type object corresponding to Nothing
            return [this];
        }
        // Call getNestedGenericArguments recursively on each of this.genericArguents
        const returnValue = [];
        for (const typeGenericArgument of typeGenericArguments) {
            if (!typeGenericArgument) {
                continue;
            }
            returnValue.push(...typeGenericArgument.getNestedGenericArguments());
        }
        return returnValue;
    }
    /**
     * Leaf types of a type are the types that have no properties.
     *
     * This method recursively searches all of the properties of this type (extensions included)
     * until is finds all of leaf type.
     *
     * i.e.
     *
     * ```acdl
     * type NestedEmptyType {}
     *
     * type NestedType {
     *  String name
     *  NestedEmptyType empty
     * }
     *
     * type Weather {
     *   Number temperature
     * }
     *
     * type Example {
     *  String str
     *  NestedType nestedProp
     *  Weather weather
     * }
     * ```
     *
     * Processing the type `Example` would return the following array of types: `[String, Number, NestedEmptyType]`
     *
     * @param seen - the types that have been processed so far.
     * @returns Array of unique leaf types.
     */
    getLeafTypes(seen = new Set()) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (__classPrivateFieldGet(this, _Type_leafTypes, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_leafTypes, "f");
        }
        // We've already processed this type
        if (seen === null || seen === void 0 ? void 0 : seen.has(this.toString())) {
            return [];
        }
        if (this.isOptional()) {
            return (_b = (_a = this.getOptionalType()) === null || _a === void 0 ? void 0 : _a.getLeafTypes(seen)) !== null && _b !== void 0 ? _b : [];
        }
        if (this.isList()) {
            return (_d = (_c = this.getListItemType()) === null || _c === void 0 ? void 0 : _c.getLeafTypes(seen)) !== null && _d !== void 0 ? _d : [];
        }
        seen.add(this.toString());
        // Base case: A non optional Type with no properties
        if (!((_e = this.properties) === null || _e === void 0 ? void 0 : _e.length)) {
            return [this];
        }
        const seenLeafTypes = new Set();
        const leafTypes = [];
        // Recursive case: Get the leaf types by searching through properties
        for (const property of (_f = this.properties) !== null && _f !== void 0 ? _f : []) {
            const leafs = (_h = (_g = property.type) === null || _g === void 0 ? void 0 : _g.getLeafTypes(seen)) !== null && _h !== void 0 ? _h : [];
            for (const leaf of leafs) {
                const typeName = (_j = leaf === null || leaf === void 0 ? void 0 : leaf.name) === null || _j === void 0 ? void 0 : _j.name;
                if (typeName && !seenLeafTypes.has(typeName)) {
                    leafTypes.push(leaf);
                    seenLeafTypes.add(typeName);
                }
            }
        }
        __classPrivateFieldSet(this, _Type_leafTypes, leafTypes, "f");
        return __classPrivateFieldGet(this, _Type_leafTypes, "f");
    }
    /**
     *
     * Searches a type for either an empty base type or for all empty leaf types.
     *
     * An empty type is defined as a type that has no properties and is neither a primitive or a catalog.
     *
     * @param type - the type to search for empty types.
     * @returns The empty subtypes in this type, or this if it's an empty base type.
     */
    getEmptyLeafTypes() {
        // The TaskContextProjection types are used with the loadContext and saveContext() api calls
        // and are allowed to have empty types. i.e (ReturnType, Action, ActionContextValues)
        if (this.isTaskContextProjection() || this.isTaskContextProjectionInfo()) {
            return [];
        }
        const genericEnvironment = this.environment || {};
        // we are currently unable to retrieve properties for generic types in some resuable dialog scenarios
        // hence the condition about the leaf type not being a generic type.
        // See https://github.com/alexa/ask-ac/issues/1357
        return this.getLeafTypes().filter((leafType) => { var _a; return !leafType.isPrimitive() && !leafType.hasCatalog() && !genericEnvironment[((_a = leafType.name) === null || _a === void 0 ? void 0 : _a.name) || ""]; });
    }
}
exports.Type = Type;
_Type_environment = new WeakMap(), _Type_extensions = new WeakMap(), _Type_properties = new WeakMap(), _Type_propertiesIndex = new WeakMap(), _Type_locales = new WeakMap(), _Type_leafTypes = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBRTdCLG1DQUE4QjtBQUM5QiwrQkFTZTtBQUdmLGlDQUE2RDtBQUU3RCxtQ0FlaUI7QUFFakIsbUNBQTJDO0FBRTNDLFNBQWdCLE1BQU0sQ0FBQyxHQUFRO0lBQzdCLE9BQU8sQ0FBQSxHQUFHLGFBQUgsR0FBRyx1QkFBSCxHQUFHLENBQUUsSUFBSSxNQUFLLE1BQU0sQ0FBQztBQUM5QixDQUFDO0FBRkQsd0JBRUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFhLElBQUk7SUFHZixZQUNXLE9BQW9CO0lBQzdCOztPQUVHO0lBQ00sV0FRWTtJQUNyQjs7T0FFRztJQUNNLGdCQUF1QztJQUNoRDs7T0FFRztJQUNILDhCQUE4QjtJQUNyQixxQkFBZ0M7SUFDekM7O09BRUc7SUFDTSxZQUFxQjs7Ozs7bUJBekJyQjs7Ozs7O21CQUlBOzs7Ozs7bUJBWUE7Ozs7OzttQkFLQTs7Ozs7O21CQUlBOztRQTVCWDs7OzttQkFBd0IsTUFBTTtXQUFDO1FBd0YvQixtRkFBbUY7UUFDbkYsb0NBQWlDO1FBMkJqQywwRkFBMEY7UUFDMUYsbUNBQXVDO1FBMkV2QyxrRkFBa0Y7UUFDbEYsbUNBQWdDO1FBNktoQyxzRkFBc0Y7UUFDdEYsd0NBQThEO1FBc3NDOUQsa0ZBQWtGO1FBQ2xGLGdDQUFvQztRQXFIcEM7Ozs7V0FJRztRQUNILGtDQUFtQjtJQW5wRGhCLENBQUM7SUFFSjs7T0FFRztJQUNJLFFBQVEsQ0FBQyxPQUE4Qjs7UUFDNUMsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDdkYsTUFBTSxJQUFJLEdBQ1IsQ0FBQSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsSUFBSSxNQUFLLGlCQUFpQixLQUFJLE1BQUEsT0FBTyxDQUFDLElBQUksMENBQUUsSUFBSSxDQUFBLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLE1BQUssTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLENBQUEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLENBQUM7UUFFeEksSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksSUFBSSxDQUFDLHFCQUFxQixLQUFLLFNBQVMsRUFBRTtZQUNsRSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUNwRixPQUFPLEdBQUcsTUFBTSxJQUFJLE1BQUEsSUFBSSxDQUFDLHFCQUFxQixFQUFFLDBDQUFFLFFBQVEsRUFBRSxHQUMxRCxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDaEQsSUFBSSxJQUFJLENBQUMscUJBQXFCO2lCQUMzQixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2YsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5QyxNQUFNLFVBQVUsR0FBRyxDQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxVQUFVLEVBQUUsTUFBSyxJQUFJLENBQUM7Z0JBQ2xELElBQUksT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFVBQVUsRUFBRSxFQUFFO29CQUN6QixPQUFPLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxVQUFVLEVBQUUsRUFBRTt3QkFDNUIsT0FBTyxHQUFHLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQztxQkFDckM7aUJBQ0Y7Z0JBQ0QsT0FBTyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDO1lBQzFFLENBQUMsQ0FBQztpQkFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUNsQjtRQUVELE9BQU8sR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsYUFBRCxDQUFDLHVCQUFELENBQUMsQ0FBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDM0gsQ0FBQztJQUVNLGVBQWUsQ0FBQyxPQUFzQzs7UUFDM0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsYUFBYSxDQUMvQixJQUFJLENBQUMsSUFBSSxFQUNULE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxlQUFlLEVBQUUsQ0FBQyxFQUMzRCxTQUFTLEVBQ1QsU0FBUyxDQUNWLENBQUM7UUFDRixJQUFJLE9BQU8sRUFBRTtZQUNYLEdBQUcsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1NBQ3ZCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQsSUFBSSxTQUFTOztRQUNYLE9BQU8sQ0FBQSxNQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSwwQ0FBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDLElBQUEsY0FBTyxFQUFDLE1BQUEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLDBDQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDekYsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxJQUFJOztRQUNOLE9BQU8sTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELElBQUksU0FBUzs7UUFDWCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDLElBQUEsbUJBQVksRUFBQyxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDckUsQ0FBQztJQUtEOzs7O09BSUc7SUFDSCxJQUFXLFdBQVc7O1FBQ3BCLElBQUksdUJBQUEsSUFBSSx5QkFBYSxLQUFLLFNBQVMsRUFBRTtZQUNuQyxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssaUJBQWlCLEVBQUU7Z0JBQ2hELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsSUFBSSxFQUFFLENBQUM7Z0JBQ2pFLHVCQUFBLElBQUkscUJBQ0YsQ0FBQSxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsMENBQ2pCLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTs7b0JBQ2YsTUFBTSxJQUFJLEdBQUcsTUFBQSxNQUFBLGdCQUFnQixhQUFoQixnQkFBZ0IsdUJBQWhCLGdCQUFnQixDQUFHLENBQUMsQ0FBQywwQ0FBRSxJQUFJLDBDQUFFLElBQUksQ0FBQztvQkFDL0MsT0FBTyxJQUFJLEtBQUssU0FBUzt3QkFDdkIsQ0FBQyxDQUFDLEVBQUU7d0JBQ0osQ0FBQyxDQUFDOzRCQUNFLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRzt5QkFDWixDQUFDO2dCQUNSLENBQUMsRUFDQSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFJLElBQUksTUFBQSxDQUFDO2FBQ25EO1NBQ0Y7UUFDRCxPQUFPLHVCQUFBLElBQUkseUJBQWEsSUFBSSxTQUFTLENBQUM7SUFDeEMsQ0FBQztJQUtEOztPQUVHO0lBQ0gsSUFBSSxVQUFVOztRQUNaLElBQUksdUJBQUEsSUFBSSx3QkFBWSxLQUFLLFNBQVMsRUFBRTtZQUNsQyx1QkFBQSxJQUFJLG9CQUFlLE1BQUEsSUFBSSxDQUFDLGlCQUFpQixFQUFFLG1DQUFJLElBQUksTUFBQSxDQUFDO1NBQ3JEO1FBRUQsT0FBTyxNQUFBLHVCQUFBLElBQUksd0JBQVksbUNBQUksU0FBUyxDQUFDO0lBQ3ZDLENBQUM7SUFFTyxpQkFBaUI7O1FBQ3ZCLDZCQUE2QjtRQUM3QixJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssVUFBVSxFQUFFO1lBQ3pDLGtGQUFrRjtZQUNsRixPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUM5QjtRQUNELElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxtQkFBbUIsSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLG1CQUFtQixFQUFFO1lBQ3BHLE1BQU0sV0FBVyxHQUFHLE1BQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsMENBQUUsTUFBTSxtQ0FBSSxDQUFDLENBQUM7WUFDNUQsTUFBTSxRQUFRLEdBQUc7Z0JBQ2YsR0FBRyxDQUFDLE1BQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsMENBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFFLENBQUMsbUNBQUksRUFBRSxDQUFDO2dCQUNwRixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBRTthQUNuRCxDQUFDO1lBQ0YsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FDeEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FDaEMsQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsSUFBQSxvQkFBYyxFQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFBLG9CQUFjLEVBQUMsV0FBVyxDQUFDLENBQzFHLEVBQ0YsUUFBUSxDQUNULENBQUM7WUFDRixJQUFJLFVBQVUsRUFBRTtnQkFDZCxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDckI7WUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMvQjtRQUNELElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxpQkFBaUIsRUFBRTtZQUNoRCxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1NBQ3JDO1FBQ0QsSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLHFCQUFxQixFQUFFO1lBQ3BELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDaEUsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ25CO1NBQ0Y7YUFBTSxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssaUJBQWlCLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxlQUFlLEVBQUU7WUFDckcsTUFBTSxVQUFVLEdBQ2QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssaUJBQWlCO2dCQUN6QyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVO2dCQUM3QixDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssZUFBZTtvQkFDM0MsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVztvQkFDOUIsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUNoQixJQUFJLFVBQVUsRUFBRTtnQkFDZCxPQUFPLFVBQVU7cUJBQ2QsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7O29CQUNqQixzREFBc0Q7b0JBQ3RELE1BQU0sTUFBTSxHQUNWLENBQUEsTUFBQSxTQUFTLENBQUMsU0FBUywwQ0FDZixHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTs7d0JBQUMsT0FBQSxDQUFDOzRCQUNkLENBQUMsTUFBQSxHQUFHLGFBQUgsR0FBRyx1QkFBSCxHQUFHLENBQUUsSUFBSSwwQ0FBRSxJQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDO3lCQUNqRixDQUFDLENBQUE7cUJBQUEsRUFDRCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFJLFNBQVMsQ0FBQztvQkFFdkQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUUsQ0FBQztnQkFDbkUsQ0FBQyxDQUFDO3FCQUNELE1BQU0sQ0FBQyxxQkFBYyxDQUFDLENBQUM7YUFDM0I7WUFDRCxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsT0FBTyxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsS0FBSyxFQUFFO2dCQUM1RyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUM3QjtTQUNGO2FBQU07WUFDTCxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMvQjtRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFLRDs7OztPQUlHO0lBQ0gsSUFBSSxVQUFVOztRQUNaLElBQUksdUJBQUEsSUFBSSx3QkFBWSxLQUFLLFNBQVMsRUFBRTtZQUNsQyxPQUFPLHVCQUFBLElBQUksd0JBQWEsQ0FBQztTQUMxQjtRQUNELE1BQU0sVUFBVSxHQUFlLEVBQUUsQ0FBQztRQUVsQyxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUsscUJBQXFCLEVBQUU7WUFDcEQsa0hBQWtIO1NBQ25IO2FBQU0sSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLG1CQUFtQixJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssbUJBQW1CLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQ2pJLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsaUJBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0RSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLHdCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pGLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsaUJBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUVoRixNQUFNLFVBQVUsR0FBRyxNQUFBLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxtQ0FBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztZQUN0RSxJQUFJLFVBQVUsSUFBSSxRQUFRLElBQUksVUFBVSxFQUFFO2dCQUN4QyxVQUFVLENBQUMsSUFBSSxDQUNiO29CQUNFLElBQUksRUFBRSxVQUFVO29CQUNoQixLQUFLLEVBQUUsQ0FBQztvQkFDUixJQUFJLEVBQUUsV0FBVztvQkFDakIsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3BELEVBQ0Q7b0JBQ0UsSUFBSSxFQUFFLFVBQVU7b0JBQ2hCLEtBQUssRUFBRSxDQUFDO29CQUNSLElBQUksRUFBRSxZQUFZO29CQUNsQixJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDdEUsQ0FDRixDQUFDO2FBQ0g7U0FDRjthQUFNLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxpQkFBaUIsRUFBRTtZQUN2RCxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsSUFBSSxFQUFFO2dCQUNwRCxtR0FBbUc7Z0JBQ25HLE1BQU0sSUFBSSxHQUFHLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDeEMsSUFBSSxJQUFJLEVBQUU7b0JBQ1IsSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLGlCQUFpQixFQUFFO3dCQUNoRCxNQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSywwQ0FBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7OzRCQUM5QyxJQUFJLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxFQUFFO2dDQUNuQixVQUFVLENBQUMsSUFBSSxDQUFDO29DQUNkLElBQUksRUFBRSxVQUFtQjtvQ0FDekIsS0FBSztvQ0FDTCxJQUFJLEVBQUUsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFLO29DQUN0QixXQUFXLEVBQUUsSUFBSTtvQ0FDakIsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztpQ0FDakMsQ0FBQyxDQUFDOzZCQUNKO3dCQUNILENBQUMsQ0FBQyxDQUFDO3FCQUNKO3lCQUFNO3dCQUNMLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsaUJBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQzt3QkFDbEYsSUFBSSxjQUFjLEVBQUU7NEJBQ2xCLFVBQVUsQ0FBQyxJQUFJLENBQUM7Z0NBQ2QsSUFBSSxFQUFFLFVBQW1CO2dDQUN6QixLQUFLLEVBQUUsQ0FBQztnQ0FDUixJQUFJLEVBQUUsWUFBWTtnQ0FDbEIsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsY0FBYyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7NkJBQ3JELENBQUMsQ0FBQzt5QkFDSjtxQkFDRjtpQkFDRjthQUNGO2lCQUFNLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxVQUFVLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxrQkFBa0IsRUFBRTtnQkFDbkksTUFBTSxRQUFRLEdBQUcsQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGlCQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxpQkFBVyxDQUFDLGdCQUFnQixDQUFDO2dCQUM5SCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLGlCQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3RFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQzlELE1BQU0sSUFBSSxHQUFHLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDeEMsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLENBQUEsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLFVBQVUsTUFBSyxTQUFTLEVBQUU7b0JBQzFELFVBQVUsQ0FBQyxJQUFJLENBQ2IsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FDcEIsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUNQLENBQUM7d0JBQ0MsR0FBRyxJQUFJO3dCQUNQLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLDBCQUEwQixDQUFDLFFBQVEsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFLLENBQUMsQ0FBQzt3QkFDckUsV0FBVyxFQUFFLFNBQVM7cUJBQ1YsQ0FBQSxDQUNqQixDQUNGLENBQUM7aUJBQ0g7YUFDRjtpQkFBTSxJQUNMLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLG1CQUFtQjtnQkFDdEUsQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxjQUFjO2dCQUMxRCxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyxpQkFBVyxDQUFDLFNBQVMsRUFDckQ7Z0JBQ0EsdUdBQXVHO2dCQUN2RyxNQUFNLFVBQVUsR0FBRyxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsMENBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLE1BQU0sYUFBYSxHQUNqQixDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyx3QkFBa0IsQ0FBQyxtQkFBbUI7b0JBQ3BFLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLGlCQUFXLENBQUMsUUFBUSxDQUFDO29CQUMxRCxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLGlCQUFXLENBQUMsU0FBUzt3QkFDdEQsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsaUJBQVcsQ0FBQyxRQUFRLENBQUM7d0JBQzFELENBQUMsQ0FBQyxTQUFTLENBQUM7Z0JBRWhCLFVBQVUsQ0FBQyxJQUFJLENBQ2IsR0FBRyxDQUFDLE1BQUEsTUFBQSxVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsK0JBQStCLEVBQUUsMENBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFOztvQkFDcEUsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ2xFLE1BQU0sSUFBSSxHQUFhO3dCQUNyQixJQUFJLEVBQUUsVUFBbUI7d0JBQ3pCLEtBQUs7d0JBQ0wsSUFBSSxFQUFFLE1BQUEsR0FBRyxDQUFDLElBQUksMENBQUUsSUFBSzt3QkFDckIsSUFBSSxFQUNGLENBQUEsTUFBQSxhQUFhLGFBQWIsYUFBYSx1QkFBYixhQUFhLENBQUUsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxRQUFRLEtBQUksU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLFVBQVUsRUFBRSxDQUFBOzRCQUMzRSxDQUFDLENBQUMsU0FBUzs0QkFDWCxDQUFDLENBQUMsYUFBYTtnQ0FDZixDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxTQUFVLENBQUMsQ0FBQztnQ0FDdEUsQ0FBQyxDQUFDLENBQUEsTUFBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsY0FBYztvQ0FDN0QsQ0FBQyxDQUFDLFNBQVM7b0NBQ1gsQ0FBQyxDQUFDLFNBQVM7d0JBQ2YsV0FBVyxFQUFFLEdBQUc7cUJBQ2pCLENBQUM7b0JBQ0YsT0FBTyxJQUFJLENBQUM7Z0JBQ2QsQ0FBQyxDQUFDLG1DQUFJLEVBQUUsQ0FBQyxDQUNWLENBQUM7YUFDSDtpQkFBTSxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsUUFBUSxFQUFFO2dCQUMvRCw0REFBNEQ7Z0JBQzVELE1BQU0sWUFBWSxHQUFHLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDaEQsSUFBSSxZQUFZLElBQUksWUFBWSxDQUFDLFVBQVUsRUFBRTtvQkFDM0MsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDN0M7YUFDRjtpQkFBTTtnQkFDTCxVQUFVLENBQUMsSUFBSSxDQUNiLEdBQUcsQ0FBQyxDQUFBLE1BQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxVQUFVLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRTs7b0JBQ3BELElBQUksSUFBSSxHQUNOLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7b0JBRTNHLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksQ0FBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsVUFBVSxFQUFFLE1BQUssS0FBSyxFQUFFO3dCQUMxRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLGlCQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBQzlFLElBQUksWUFBWSxFQUFFOzRCQUNoQixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO3lCQUN0RTtxQkFDRjtvQkFDRCxPQUFPO3dCQUNMLElBQUksRUFBRSxVQUFVO3dCQUNoQixXQUFXLEVBQUUsSUFBSTt3QkFDakIsS0FBSzt3QkFDTCxJQUFJLEVBQUUsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJO3dCQUNyQixJQUFJO3FCQUNPLENBQUM7Z0JBQ2hCLENBQUMsQ0FBQyxLQUFJLEVBQUUsQ0FBQyxDQUNWLENBQUM7YUFDSDtTQUNGO1FBQ0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUMvQixNQUFNLFdBQVcsR0FBZSxFQUFFLENBQUM7UUFFbkMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTFCLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2pDLElBQUksR0FBRyxDQUFDLFVBQVUsRUFBRTtvQkFDbEIsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDL0I7YUFDRjtTQUNGO1FBQ0QsdUJBQUEsSUFBSSxvQkFBZSxXQUFXLElBQUksSUFBSSxNQUFBLENBQUM7UUFDdkMsT0FBTyx1QkFBQSxJQUFJLHdCQUFZLElBQUksU0FBUyxDQUFDO1FBRXJDLFNBQVMsYUFBYSxDQUFDLFVBQXVCO1lBQzVDLElBQUksVUFBVSxFQUFFO2dCQUNkLEtBQUssTUFBTSxRQUFRLElBQUksVUFBVSxFQUFFO29CQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSyxDQUFDLEVBQUU7d0JBQzdCLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBQzNCLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUssQ0FBQyxDQUFDO3FCQUMxQjtpQkFDRjthQUNGO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFLRDs7T0FFRztJQUNILElBQUksZUFBZTs7UUFDakIsSUFBSSx1QkFBQSxJQUFJLDZCQUFpQixLQUFLLFNBQVMsRUFBRTtZQUN2Qyx1QkFBQSxJQUFJLHlCQUNGLENBQUEsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FDWCxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ1osQ0FBQyxDQUFDLENBQUMsSUFBSyxDQUFDLEVBQUUsQ0FBQzthQUNiLENBQUMsRUFDRCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFJLElBQUksTUFBQSxDQUFDO1NBQ25EO1FBQ0QsT0FBTyx1QkFBQSxJQUFJLDZCQUFpQixJQUFJLFNBQVMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsSUFBYyxFQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTztRQUNqRCxPQUFPLElBQUksYUFBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksUUFBUSxDQUFDLEtBQVksRUFBRSxNQUE0QixFQUFFLE1BQWMsRUFBRSxLQUFhOztRQUN2Rix3RUFBd0U7UUFDeEUsTUFBTSxPQUFPLEdBQUcsTUFBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsT0FBTyxtQ0FBSSxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQy9DLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQ3RCLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFO2dCQUN2QixPQUFPLElBQUksbUJBQVcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ3JFO1lBQ0QsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUU7Z0JBQ3BCLE9BQU8sSUFBSSxvQkFBWSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDdEU7WUFDRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRTtnQkFDbkIsT0FBTyxJQUFJLG1CQUFXLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQzthQUNyRTtZQUNELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFO2dCQUNqQixPQUFPLElBQUksaUJBQVMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ25FO1lBQ0QsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUU7Z0JBQ3BCLE9BQU8sSUFBSSxvQkFBWSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDdEU7U0FDRjthQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQzFCLE9BQU8sSUFBSSxtQkFBVyxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFrQixDQUFDLENBQUMsQ0FBQyxPQUFPO1NBQy9FO2FBQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDMUIsT0FBTyxJQUFJLG1CQUFXLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQWtCLENBQUMsQ0FBQyxDQUFDLE9BQU87U0FDL0U7YUFBTSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUM1QixPQUFPLElBQUkscUJBQWEsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFBLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxJQUFJLE1BQUsscUJBQXFCLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDN0c7YUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUN4QixPQUFPLElBQUksaUJBQVMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ25FO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDNUIsT0FBTyxJQUFJLHFCQUFhLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztTQUN2RTthQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQzdCLE9BQU8sSUFBSSxzQkFBYyxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztTQUMvRTthQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQzFCLE9BQU8sSUFBSSxtQkFBVyxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDckU7UUFDRCxPQUFPLElBQUksZ0JBQVEsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksZUFBZSxDQUFDLFFBQXdDOztRQUM3RCxPQUFPLE1BQUEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsMENBQUUsSUFBSSxDQUFDO0lBQzFDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksV0FBVyxDQUFDLFFBQXlDOztRQUMxRCxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDMUIsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFDRCxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDNUIsSUFBSSxNQUFBLFFBQVEsQ0FBQyxJQUFJLDBDQUFFLElBQUksRUFBRTtnQkFDdkIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDN0M7WUFDRCxJQUFJLE9BQU8sUUFBUSxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7Z0JBQ3RDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDekM7U0FDRjthQUFNLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFO1lBQ3ZDLE9BQU8sTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRyxRQUFRLENBQUMsQ0FBQztTQUNwQzthQUFNO1lBQ0wsTUFBTSxJQUFJLEdBQUcsTUFBQSxJQUFJLENBQUMsZUFBZSwwQ0FBRyxRQUFRLENBQUMsQ0FBQztZQUM5QyxJQUFJLElBQUksRUFBRTtnQkFDUixPQUFPLElBQUksQ0FBQzthQUNiO1lBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNuQixLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQ2pDLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQ3ZDLElBQUksSUFBSSxFQUFFO3dCQUNSLE9BQU8sSUFBSSxDQUFDO3FCQUNiO2lCQUNGO2FBQ0Y7U0FDRjtRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWE7O1FBQ2xCLE1BQU0sVUFBVSxHQUFHLElBQUksR0FBRyxFQUFZLENBQUM7UUFDdkMsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTs7WUFDaEMsSUFBSSxDQUFDLENBQUMsQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLE1BQU0sRUFBRSxNQUFJLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsVUFBVSxFQUFFLENBQUEsQ0FBQyxFQUFFO2dCQUNyRCxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzNCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLFVBQVUsQ0FBQztRQUVsQixTQUFTLGNBQWMsQ0FBQyxJQUFzQjs7WUFDNUMsSUFBSSxDQUFBLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxXQUFXLE1BQUssU0FBUyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBWSxDQUFDLEVBQUU7Z0JBQ3pFLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNqQyxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsMENBQUUsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUMvQyxNQUFBLElBQUksQ0FBQyxVQUFVLDBDQUFFLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDekMsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTs7b0JBQ2hDLElBQUksQ0FBQyxDQUFDLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxNQUFNLEVBQUUsTUFBSSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLFVBQVUsRUFBRSxDQUFBLENBQUMsRUFBRTt3QkFDckQsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDM0I7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7YUFDSjtRQUNILENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxpQkFBaUI7O1FBQ3RCLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxlQUFlLEVBQUU7WUFDOUMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE9BQU8sQ0FDTCxDQUFBLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsYUFBRCxDQUFDLHVCQUFELENBQUMsQ0FBRSxpQkFBaUIsRUFBRSxDQUFDLE1BQUssU0FBUztZQUN4RSxDQUFBLE1BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxNQUFLLFNBQVMsQ0FDbEUsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLFVBQVU7O1FBQ2YsT0FBTyxDQUNMLE1BQUEsQ0FBQyxDQUFBLE1BQUEsSUFBSSxDQUFDLFNBQVMsMENBQUUsVUFBVSxDQUFDLHVCQUFpQixDQUFDLE1BQUksTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxVQUFVLENBQUMsd0JBQWtCLENBQUMsQ0FBQSxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLG1DQUNoSSxLQUFLLENBQ04sQ0FBQztJQUNKLENBQUM7SUFFTyxvQkFBb0I7O1FBQzFCLE9BQU8sQ0FDTCxHQUFHLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUN2QyxDQUFDLE1BQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsMENBQUUsTUFBTSxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsV0FBQyxPQUFBLE1BQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQywwQ0FBRSxlQUFlLEVBQUUsQ0FBQSxFQUFBLEVBQUUsTUFBTSxtQ0FBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ2xJLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLFFBQVE7UUFDYixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksU0FBUzs7UUFDZCxPQUFPLE1BQUEsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxVQUFVLENBQUMsdUJBQWlCLENBQUMsbUNBQUksS0FBSyxDQUFDO0lBQ2hFLENBQUM7SUFFRDs7T0FFRztJQUNJLG1CQUFtQjtRQUN4QixPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDakgsQ0FBQztJQUVEOztPQUVHO0lBQ0ksdUJBQXVCO1FBQzVCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUN4RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxVQUFVOztRQUNmLE9BQU8sTUFBQSxNQUFBLElBQUksQ0FBQyxTQUFTLDBDQUFFLFVBQVUsQ0FBQyx3QkFBa0IsQ0FBQyxtQ0FBSSxLQUFLLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksVUFBVTs7UUFDZixPQUFPLE1BQUEsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxVQUFVLENBQUMsaUNBQTJCLENBQUMsbUNBQUksS0FBSyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLGFBQWE7O1FBQ2xCLE9BQU8sTUFBQSxNQUFBLElBQUksQ0FBQyxTQUFTLDBDQUFFLFVBQVUsQ0FBQywwQkFBb0IsQ0FBQyxtQ0FBSSxLQUFLLENBQUM7SUFDbkUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTzs7UUFDWixPQUFPLENBQUEsTUFBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEtBQUssQ0FBQztJQUNuRSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxxQkFBcUI7O1FBQzFCLE9BQU8sQ0FBQSxNQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsbUJBQW1CLENBQUM7SUFDakYsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZ0JBQWdCOztRQUNyQixPQUFPLENBQUEsTUFBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLGNBQWMsQ0FBQztJQUM1RSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFROztRQUtiLE9BQU8sQ0FBQyxNQUFBLE1BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsTUFBTSxtQ0FBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxpQkFBaUIsQ0FBQyxJQUFhO1FBQ3BDLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLFNBQVMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkc7SUFDSSxtQkFBbUIsQ0FBQyxJQUEyQzs7UUFDcEUsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ3RCLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyxTQUFTLElBQUksT0FBTyxJQUFJLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyxJQUFJLEVBQUU7Z0JBQ2xILE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFDRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ25CLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtvQkFDakMsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO29CQUM1QyxJQUFJLEtBQUssRUFBRTt3QkFDVCxPQUFPLEtBQUssQ0FBQztxQkFDZDtpQkFDRjthQUNGO1NBQ0Y7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxZQUFZOztRQUNqQixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxVQUFVLENBQUM7SUFDcEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVTs7UUFDZixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxRQUFRLENBQUM7SUFDbEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksbUJBQW1COztRQUN4QixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUNyQixPQUFPLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztTQUNuQztRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNJLE1BQU07O1FBQ1gsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsSUFBSSxDQUFDO0lBQzlDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxXQUFXOztRQUNoQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNqQixPQUFPLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztTQUNuQztRQUNELE9BQU8sTUFBQSxJQUFJLENBQUMsbUJBQW1CLENBQUMsaUJBQVcsQ0FBQyxJQUFJLENBQUMsMENBQUUsV0FBVyxFQUFFLENBQUM7SUFDbkUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYTs7UUFDbEIsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsV0FBVyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7T0FFRztJQUNJLGtCQUFrQjs7UUFDdkIsT0FBTyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7T0FFRztJQUNJLFNBQVM7O1FBQ2QsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsT0FBTyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7T0FFRztJQUNJLE9BQU87O1FBQ1osT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsS0FBSyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7T0FFRztJQUNJLFdBQVc7UUFDaEIsT0FBTyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3pHLENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWE7UUFDbEIsT0FBTyxDQUNMLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDaEIsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDZixJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2QsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNmLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDWixJQUFJLENBQUMsU0FBUyxFQUFFLENBQ2pCLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU07O1FBQ1gsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLGlCQUFXLENBQUMsSUFBSSxDQUFDO0lBQzlDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksVUFBVTs7UUFDZixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssaUJBQVcsQ0FBQyxRQUFRLENBQUM7SUFDbEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksU0FBUztRQUNkLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUTtRQUNiLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxZQUFZO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRO1FBQ2IsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsaUJBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxnQkFBZ0I7UUFDckIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsd0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0kscUJBQXFCOztRQUMxQixPQUFPLE1BQUEsTUFBQSxJQUFJLENBQUMsbUJBQW1CLENBQUMsd0JBQWtCLENBQUMsY0FBYyxDQUFDLDBDQUFFLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxrQkFBa0I7O1FBQ3ZCLE9BQU8sTUFBQSxNQUFBLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyx3QkFBa0IsQ0FBQyxXQUFXLENBQUMsMENBQUUsZ0JBQWdCLDBDQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksV0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyx3QkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksVUFBVTtRQUNmLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZTs7UUFDcEIsT0FBTyxNQUFBLE1BQUEsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFXLENBQUMsUUFBUSxDQUFDLDBDQUFFLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksV0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNJLGdCQUFnQjs7UUFDckIsT0FBTyxNQUFBLE1BQUEsSUFBSSxDQUFDLG1CQUFtQixDQUFDLHdCQUFrQixDQUFDLFNBQVMsQ0FBQywwQ0FBRSxnQkFBZ0IsMENBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdkYsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxlQUFlOztRQUNwQixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUNyQixPQUFPLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztTQUNuQztRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSSxrQkFBa0I7O1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxLQUFJLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUMzRixDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFROztRQUNiLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyx3QkFBa0IsQ0FBQyxNQUFNLENBQUM7SUFDdkQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksa0JBQWtCOztRQUN2QixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsZ0JBQWdCLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFVBQVU7UUFDZixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxpQkFBVyxDQUFDLFFBQVEsQ0FBQyxLQUFLLFNBQVMsQ0FBQztJQUN0RSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksV0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxTQUFTLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFlBQVk7UUFDakIsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsaUJBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssaUJBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMzRyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0kscUJBQXFCOztRQUMxQixJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssbUJBQW1CLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxtQkFBbUIsRUFBRTtZQUNwRyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUMzRTtRQUNELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQ3RCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN0QyxPQUFPLE1BQUEsU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLGdCQUFnQiwwQ0FBRyxDQUFBLE1BQUEsU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLGdCQUFnQiwwQ0FBRSxNQUFNLElBQUcsQ0FBQyxDQUFDLENBQUM7U0FDL0U7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRU0sdUJBQXVCLENBQUMsS0FBYTs7UUFDMUMsT0FBTyxNQUFBLE1BQUEsSUFBSSxDQUFDLFlBQVksRUFBRSwwQ0FBRSxnQkFBZ0IsMENBQUcsS0FBSyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVNLHdCQUF3Qjs7UUFDN0IsSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLG1CQUFtQixJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssbUJBQW1CLEVBQUU7WUFDcEcsT0FBTyxNQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUywwQ0FBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBRSxDQUFDLENBQUM7U0FDN0U7UUFDRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUNyQixJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtnQkFDOUIsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLFdBQUMsT0FBQSxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsMENBQUcsQ0FBQyxDQUFFLENBQUEsRUFBQSxDQUFDLENBQUM7YUFDakY7WUFDRCx1REFBdUQ7WUFDdkQsTUFBTSxJQUFJLEdBQUcsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3BELElBQUksSUFBSSxFQUFFO2dCQUNSLE1BQU0sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQzdCLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsMENBQUcsQ0FBQyxDQUFFLENBQUMsQ0FBQztpQkFDeEM7Z0JBQ0QsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksK0JBQStCOztRQUNwQyxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssbUJBQW1CLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxtQkFBbUIsRUFBRTtZQUNwRyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDO1NBQ25DO1FBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDckIsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7Z0JBQzlCLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTs7b0JBQ2hELE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLG1CQUFtQixDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFBLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsMENBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztvQkFDNUcsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ3RDLE9BQU8sSUFBSSxDQUFDO2dCQUNkLENBQUMsQ0FBQyxDQUFDO2FBQ0o7WUFDRCxNQUFNLElBQUksR0FBRyxNQUFBLElBQUksQ0FBQyxTQUFTLDBDQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDcEQsSUFBSSxJQUFJLEVBQUU7Z0JBQ1IsTUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDN0IsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUMxQixpR0FBaUc7b0JBQ2pHLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLG1CQUFtQixDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBQSxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsMENBQUcsQ0FBQyxDQUFDLDBDQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7b0JBQ2pILE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNqQjtnQkFDRCxPQUFPLElBQUksQ0FBQzthQUNiO1NBQ0Y7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJHO0lBQ0ksc0NBQXNDLENBQUMsS0FBdUI7O1FBQ25FLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFO1lBQ3JFLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLCtCQUErQixFQUFFLENBQUM7UUFDeEQsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQzFCLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxNQUFBLEtBQUs7YUFDVCwrQkFBK0IsRUFBRSwwQ0FDaEMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFOztZQUNmLE1BQU0sT0FBTyxHQUFHLFFBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FBRyxDQUFDLENBQUMsQ0FBQztZQUU5QixJQUFJLENBQUEsTUFBQSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsSUFBSSwwQ0FBRSxJQUFJLE1BQUksTUFBQSxHQUFHLENBQUMsSUFBSSwwQ0FBRSxJQUFJLENBQUEsRUFBRTtnQkFDekMsT0FBTztvQkFDTCxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJO2lCQUNuQyxDQUFDO2FBQ0g7WUFDRCxPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUMsRUFDQSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNJLG1CQUFtQjs7UUFHeEIsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLG1CQUFtQixDQUFDO0lBQ3hELENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7UUFDYixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyx3QkFBa0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxTQUFTLENBQUM7SUFDM0UsQ0FBQztJQUVEOztPQUVHO0lBQ0ksaUJBQWlCOztRQUd0QixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssaUJBQWlCLENBQUM7SUFDdEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksbUJBQW1COztRQUd4QixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssbUJBQW1CLENBQUM7SUFDeEQsQ0FBQztJQUVNLFFBQVE7UUFDYixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyx3QkFBa0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxTQUFTLENBQUM7SUFDM0UsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU07O1FBR1gsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLGlCQUFpQixDQUFDO0lBQ3RELENBQUM7SUFFRDs7O09BR0c7SUFDSSxVQUFVOztRQUdmLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxxQkFBcUIsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7O09BY0c7SUFDSSxNQUFNO1FBQ1gsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsd0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTTtRQUNYLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVNLHVCQUF1Qjs7UUFDNUIsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLHFCQUFxQixDQUFDO0lBQ3RFLENBQUM7SUFFTSwyQkFBMkI7O1FBQ2hDLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyx3QkFBa0IsQ0FBQyx5QkFBeUIsQ0FBQztJQUMxRSxDQUFDO0lBRU0saUNBQWlDOztRQUN0QyxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMscUJBQXFCLENBQUM7SUFDdEUsQ0FBQztJQUVNLDJCQUEyQjs7UUFDaEMsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLHlCQUF5QixDQUFDO0lBQzFFLENBQUM7SUFFRDs7T0FFRztJQUNJLFlBQVk7O1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsVUFBVSxDQUFDO0lBQ3JJLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7O1FBQ2IsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLE1BQU0sQ0FBQztJQUN2RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFROztRQUNiLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyx3QkFBa0IsQ0FBQyxNQUFNLENBQUM7SUFDdkQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUTs7UUFDYixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsTUFBTSxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU07O1FBQ1gsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLElBQUksQ0FBQztJQUNyRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPOztRQUNaLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyx3QkFBa0IsQ0FBQyxLQUFLLENBQUM7SUFDdEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUTs7UUFDYixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsTUFBTSxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNJLFNBQVM7O1FBQ2QsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLE9BQU8sQ0FBQztJQUN4RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxTQUFTOztRQUNkLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyx3QkFBa0IsQ0FBQyxPQUFPLENBQUM7SUFDeEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksa0JBQWtCOztRQUN2QixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsZ0JBQWdCLENBQUM7SUFDakUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZTs7UUFDcEIsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLGFBQWEsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxhQUFhOztRQUNsQixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsV0FBVyxDQUFDO0lBQzVELENBQUM7SUFFRDs7T0FFRztJQUNJLGtCQUFrQjs7UUFDdkIsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLGdCQUFnQixDQUFDO0lBQ2pFLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUs7O1FBQ1YsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFROztRQUNiLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSyx3QkFBa0IsQ0FBQyxNQUFNLENBQUM7SUFDdkQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTTs7UUFDWCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssd0JBQWtCLENBQUMsSUFBSSxDQUFDO0lBQ3JELENBQUM7SUFFRDs7T0FFRztJQUNJLG9CQUFvQjs7UUFDekIsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLGtCQUFrQixDQUFDO0lBQ25FLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUs7O1FBQ1YsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksZUFBZTs7UUFDcEIsT0FBTyxNQUFBLE1BQUEsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFXLENBQUMsSUFBSSxDQUFDLDBDQUFFLGdCQUFnQiwwQ0FBRyxDQUFDLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxPQUFPLENBQUMsUUFBZTs7UUFDNUIsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQzFCLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRTtZQUNwQixzQ0FBc0M7WUFDdEMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ3RCLHdDQUF3QztZQUN4QyxPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQzFDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDekMsb0VBQW9FO1lBQ3BFLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUNFLENBQUMsQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxtQkFBbUIsSUFBSSxDQUFBLE1BQUEsUUFBUSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLG1CQUFtQixDQUFDO1lBQ3RHLENBQUMsQ0FBQSxNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxtQkFBbUIsSUFBSSxDQUFBLE1BQUEsUUFBUSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLG1CQUFtQixDQUFDLEVBQ3RHO1lBQ0EsNkdBQTZHO1lBQzdHLGtFQUFrRTtZQUNsRSxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksMENBQUUsSUFBSSxPQUFLLE1BQUEsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLDBDQUFFLElBQUksQ0FBQSxDQUFDO1NBQ3hFO1FBQ0QsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksUUFBUSxDQUFDLFdBQVcsRUFBRSxFQUFFO1lBQ2hELElBQUksUUFBUSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO2dCQUMzQyxPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsSUFBSSxRQUFRLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUU7Z0JBQzNDLE9BQU8sS0FBSyxDQUFDO2FBQ2Q7WUFDRCxNQUFNLFFBQVEsR0FBRyxNQUFBLElBQUksQ0FBQyxZQUFZLEVBQUUsMENBQUUsd0JBQXdCLEVBQUUsQ0FBQztZQUNqRSxNQUFNLFlBQVksR0FBRyxNQUFBLFFBQVEsQ0FBQyxZQUFZLEVBQUUsMENBQUUsd0JBQXdCLEVBQUUsQ0FBQztZQUV6RSxJQUFJLENBQUMsQ0FBQyxNQUFBLE1BQUEsSUFBSSxDQUFDLHFCQUFxQixFQUFFLDBDQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxtQ0FBSSxLQUFLLENBQUMsRUFBRTtnQkFDdkYsdUdBQXVHO2dCQUN2RyxPQUFPLEtBQUssQ0FBQzthQUNkO1lBRUQscUdBQXFHO1lBQ3JHLElBQUksQ0FBQSxRQUFRLGFBQVIsUUFBUSx1QkFBUixRQUFRLENBQUUsTUFBTSxPQUFLLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRSxNQUFNLENBQUEsS0FBSSxZQUFZLGFBQVosWUFBWSx1QkFBWixZQUFZLENBQUUsTUFBTSxDQUFBLEVBQUU7Z0JBQ3JFLE1BQU0sV0FBVyxHQUFHLE1BQUEsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLE1BQU0sbUNBQUksQ0FBQyxDQUFDO2dCQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLFdBQVcsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDdEQsSUFBSSxDQUFDLFlBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFlBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTt3QkFDaEUsT0FBTyxLQUFLLENBQUM7cUJBQ2Q7aUJBQ0Y7YUFDRjtZQUVELE9BQU8sQ0FDTCxNQUFBLFFBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FDSixHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ25CLE1BQU0sUUFBUSxHQUFHLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDbkMsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO29CQUMxQixPQUFPLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7aUJBQ2pEO2dCQUNELDJHQUEyRztnQkFDM0csT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ25DLENBQUMsRUFDQSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxtQ0FBSSxLQUFLLENBQzNDLENBQUM7U0FDSDtRQUNELElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksT0FBSyxNQUFBLFFBQVEsQ0FBQyxJQUFJLDBDQUFFLElBQUksQ0FBQSxFQUFFO1lBQzNDLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO2dCQUN6QixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLE1BQUssTUFBQSxRQUFRLENBQUMsZ0JBQWdCLDBDQUFFLE1BQU0sQ0FBQSxFQUFFO29CQUN0RSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxPQUFPLENBQUMsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLGdCQUFnQixDQUFFLENBQUMsQ0FBQyxDQUFDLE1BQUssSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDO2lCQUNsSTtnQkFDRCxPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELDJFQUEyRTtRQUMzRSxJQUFJLFFBQVEsQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUN6QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7U0FDakQ7YUFBTSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUM1QixPQUFPLE1BQUEsTUFBQSxJQUFJLENBQUMsZUFBZSxFQUFFLDBDQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsbUNBQUksS0FBSyxDQUFDO1NBQzNEO1FBRUQsT0FBTyxDQUFBLE1BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFBLFNBQVMsYUFBVCxTQUFTLHVCQUFULFNBQVMsQ0FBRSxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQUssSUFBSSxDQUFDLE1BQUssU0FBUyxDQUFDO0lBQ25HLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLEtBQVc7O1FBQ3ZCLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsSUFBSSxFQUFFO1lBQ3ZELElBQUksSUFBSSxDQUFDLGdCQUFnQixLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxNQUFLLE1BQUEsS0FBSyxDQUFDLGdCQUFnQiwwQ0FBRSxNQUFNLENBQUEsRUFBRTtnQkFDMUcsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3JELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDdkMsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUV6QyxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTt3QkFDL0MsT0FBTyxLQUFLLENBQUM7cUJBQ2Q7b0JBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7d0JBQ3pCLE9BQU8sS0FBSyxDQUFDO3FCQUNkO2lCQUNGO2FBQ0Y7WUFDRCxPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSSxLQUFLLENBQUMsS0FBdUI7O1FBQ2xDLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRTtZQUNwQixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsSUFBSSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsU0FBUyxFQUFFLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFJLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxNQUFNLEVBQUUsQ0FBQSxFQUFFO1lBQ3BDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNqQixPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxpQkFBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNsRztRQUNELElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2xCLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLGlCQUFXLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ2pHO1FBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDckIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBQSxJQUFJLENBQUMsZUFBZSxFQUFFLDBDQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ3RFO1FBQ0QsSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBQSxLQUFLLENBQUMsZUFBZSxFQUFFLDBDQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3RFO1FBQ0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLHNDQUFzQztJQUN4QyxDQUFDO0lBRU0sU0FBUyxDQUFDLEtBQXVCOztRQUN0QyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsU0FBUyxFQUFFLENBQUEsRUFBRTtZQUMxQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO1NBQzdCO1FBQ0QsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxPQUFLLE1BQUEsS0FBSyxDQUFDLElBQUksMENBQUUsSUFBSSxDQUFBLEVBQUU7WUFDeEMsSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRSxNQUFNLE1BQUssQ0FBQyxJQUFJLENBQUEsTUFBQSxLQUFLLENBQUMsZ0JBQWdCLDBDQUFFLE1BQU0sTUFBSyxDQUFDLEVBQUU7Z0JBQy9FLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFDRCxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsZ0JBQWdCLDBDQUFFLE1BQU0sT0FBSyxNQUFBLEtBQUssQ0FBQyxnQkFBZ0IsMENBQUUsTUFBTSxDQUFBLEVBQUU7Z0JBQ3BFLE1BQU0sZ0JBQWdCLEdBQUcsTUFBQSxJQUFJLENBQUMsZ0JBQWdCLDBDQUFFLEdBQUcsQ0FDakQsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsZUFBQyxPQUFBLE1BQUEsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLFNBQVMsQ0FBQyxNQUFBLEtBQUssQ0FBQyxnQkFBZ0IsMENBQUcsQ0FBQyxDQUFDLENBQUMsbUNBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUEsRUFBQSxDQUM1RixDQUFDO2dCQUNGLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLGdCQUFnQixDQUFDLENBQUM7YUFDbkU7U0FDRjthQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM5QixLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQUEsSUFBSSxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUFFO2dCQUN2QyxJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ3RCLE9BQU8sR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDN0I7YUFDRjtTQUNGO2FBQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzlCLEtBQUssTUFBTSxHQUFHLElBQUksTUFBQSxLQUFLLENBQUMsVUFBVSxtQ0FBSSxFQUFFLEVBQUU7Z0JBQ3hDLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDckIsT0FBTyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUM1QjthQUNGO1NBQ0Y7YUFBTTtZQUNMLEtBQUssTUFBTSxPQUFPLElBQUksTUFBQSxJQUFJLENBQUMsVUFBVSxtQ0FBSSxFQUFFLEVBQUU7Z0JBQzNDLEtBQUssTUFBTSxRQUFRLElBQUksTUFBQSxLQUFLLENBQUMsVUFBVSxtQ0FBSSxFQUFFLEVBQUU7b0JBQzdDLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTt3QkFDN0IsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUNwQztpQkFDRjthQUNGO1NBQ0Y7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO0lBQzVCLENBQUM7SUFFTSxNQUFNLENBQUMsS0FBdUI7UUFDbkMsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdkIsOENBQThDO1lBQzlDLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdkIsaURBQWlEO1lBQ2pELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCw2REFBNkQ7UUFDN0QsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUM5QixDQUFDO0lBS0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJHO0lBQ0gsVUFBVTtRQUNSLElBQUksdUJBQUEsSUFBSSxxQkFBUyxLQUFLLFNBQVMsRUFBRTtZQUMvQixPQUFPLHVCQUFBLElBQUkscUJBQVMsQ0FBQztTQUN0QjtRQUNELE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxFQUFnQixDQUFDO1FBQzFDLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFDL0IsMENBQTBDO1FBQzFDLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ3JCLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQTJCLENBQUMsQ0FBQztTQUNqRDthQUFNO1lBQ0wsc0NBQXNDO1lBQ3RDLElBQUEsMEJBQWtCLEVBQUMsSUFBSSxFQUFFLFNBQVMsZUFBZSxDQUFDLElBQUk7O2dCQUNwRCxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFO29CQUNsRCxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO29CQUMxQixJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssVUFBVSxFQUFFO3dCQUN6QyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztxQkFDakM7b0JBRUQsSUFBQSwwQkFBa0IsRUFBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7aUJBQzNDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUNELDJEQUEyRDtRQUMzRCxJQUFJLE9BQWlDLENBQUM7UUFDdEMsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDekMsSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDWixPQUFPLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNqQztpQkFBTTtnQkFDTCxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzthQUN6RTtTQUNGO1FBRUQsdUJBQUEsSUFBSSxpQkFBWSxPQUFPLE1BQUEsQ0FBQztRQUV4QixPQUFPLHVCQUFBLElBQUkscUJBQVMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0kscUJBQXFCOztRQUMxQixPQUFPLElBQUksR0FBRyxDQUNaLE1BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsTUFBTSxDQUFDLENBQUMsR0FBOEIsRUFBRSxRQUFRLEVBQUUsRUFBRTs7WUFDbkUsSUFBSSxDQUFBLE1BQUEsUUFBUSxDQUFDLElBQUksMENBQUUsVUFBVSxFQUFFLEtBQUksQ0FBQyxDQUFBLE1BQUEsUUFBUSxDQUFDLFdBQVcsMENBQUUsSUFBSSxNQUFLLGNBQWMsSUFBSSxDQUFBLE1BQUEsUUFBUSxDQUFDLFdBQVcsMENBQUUsUUFBUSxNQUFLLElBQUksQ0FBQyxFQUFFO2dCQUM3SCxPQUFPLEdBQUcsQ0FBQzthQUNaO1lBQ0QsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNwQyxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FDUCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNJLGNBQWM7O1FBQ25CLE9BQU8sSUFBSSxHQUFHLENBQW1CLENBQUMsTUFBQSxJQUFJLENBQUMsVUFBVSxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekcsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSx5QkFBeUI7O1FBQzlCLCtGQUErRjtRQUMvRixJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsV0FBVywwQ0FBRSxJQUFJLE1BQUssZUFBZSxFQUFFO1lBQzlDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNmO1FBRUQsTUFBTSxvQkFBb0IsR0FBRyxNQUFBLElBQUksQ0FBQyxnQkFBZ0IsbUNBQUksRUFBRSxDQUFDO1FBQ3pELElBQUksb0JBQW9CLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNyQyxnRkFBZ0Y7WUFDaEYsb0ZBQW9GO1lBQ3BGLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNmO1FBRUQsNkVBQTZFO1FBQzdFLE1BQU0sV0FBVyxHQUFXLEVBQUUsQ0FBQztRQUMvQixLQUFLLE1BQU0sbUJBQW1CLElBQUksb0JBQW9CLEVBQUU7WUFDdEQsSUFBSSxDQUFDLG1CQUFtQixFQUFFO2dCQUN4QixTQUFTO2FBQ1Y7WUFFRCxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsbUJBQW1CLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxDQUFDO1NBQ3RFO1FBQ0QsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQztJQVNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0JHO0lBQ0ksWUFBWSxDQUFDLE9BQU8sSUFBSSxHQUFHLEVBQVU7O1FBQzFDLElBQUksdUJBQUEsSUFBSSx1QkFBVyxLQUFLLFNBQVMsRUFBRTtZQUNqQyxPQUFPLHVCQUFBLElBQUksdUJBQVcsQ0FBQztTQUN4QjtRQUVELG9DQUFvQztRQUNwQyxJQUFJLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUU7WUFDOUIsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sTUFBQSxNQUFBLElBQUksQ0FBQyxlQUFlLEVBQUUsMENBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxtQ0FBSSxFQUFFLENBQUM7U0FDekQ7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNqQixPQUFPLE1BQUEsTUFBQSxJQUFJLENBQUMsZUFBZSxFQUFFLDBDQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsbUNBQUksRUFBRSxDQUFDO1NBQ3pEO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUUxQixvREFBb0Q7UUFDcEQsSUFBSSxDQUFDLENBQUEsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxNQUFNLENBQUEsRUFBRTtZQUM1QixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDZjtRQUVELE1BQU0sYUFBYSxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFDeEMsTUFBTSxTQUFTLEdBQVcsRUFBRSxDQUFDO1FBRTdCLHFFQUFxRTtRQUNyRSxLQUFLLE1BQU0sUUFBUSxJQUFJLE1BQUEsSUFBSSxDQUFDLFVBQVUsbUNBQUksRUFBRSxFQUFFO1lBQzVDLE1BQU0sS0FBSyxHQUFHLE1BQUEsTUFBQSxRQUFRLENBQUMsSUFBSSwwQ0FBRSxZQUFZLENBQUMsSUFBSSxDQUFDLG1DQUFJLEVBQUUsQ0FBQztZQUV0RCxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtnQkFDeEIsTUFBTSxRQUFRLEdBQUcsTUFBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsSUFBSSwwQ0FBRSxJQUFJLENBQUM7Z0JBQ2xDLElBQUksUUFBUSxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRTtvQkFDNUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDckIsYUFBYSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDN0I7YUFDRjtTQUNGO1FBRUQsdUJBQUEsSUFBSSxtQkFBYyxTQUFTLE1BQUEsQ0FBQztRQUM1QixPQUFPLHVCQUFBLElBQUksdUJBQVcsQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxpQkFBaUI7UUFDdEIsNEZBQTRGO1FBQzVGLHFGQUFxRjtRQUNyRixJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxJQUFJLElBQUksQ0FBQywyQkFBMkIsRUFBRSxFQUFFO1lBQ3hFLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO1FBQ2xELHFHQUFxRztRQUNyRyxvRUFBb0U7UUFDcEUsa0RBQWtEO1FBQ2xELE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLE1BQU0sQ0FDL0IsQ0FBQyxRQUFRLEVBQUUsRUFBRSxXQUFDLE9BQUEsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBLE1BQUEsUUFBUSxDQUFDLElBQUksMENBQUUsSUFBSSxLQUFJLEVBQUUsQ0FBQyxDQUFBLEVBQUEsQ0FDbEgsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXh4REQsb0JBd3hEQyJ9