import { ActionDeclaration } from "./action";
import { Argument, ArgumentDeclaration } from "./argument";
import { Call } from "./call";
import { Condition, ElseScope, ThenScope, When } from "./condition";
import { DialogDeclaration } from "./dialog";
import { ListItem, ListLiteral } from "./list-literal";
import { Module, ModuleSchema } from "./module";
import { Name } from "./name";
import { NameDeclaration } from "./name-declaration";
import { NameReference } from "./name-reference";
import { PropertyReference } from "./property-reference";
import { Sample } from "./sample";
import { Block } from "./block";
import { TypeDeclaration, TypeParameter, TypeProperty, TypeReference } from "./type";
import { parseUtteranceSlotNames, Utterance } from "./utterance";
import { validateModuleSchema } from "./validate";
import { EnumDeclaration, EnumItem } from "./enum";
import { Annotation } from "./annotation";
import { AlexaConversations, AlexaSchema, OPERATOR_ACTIONS_SET } from "./prelude";
import { InteractionDeclaration } from "./interaction";
import { Correction, CorrectionScope } from "./correction";
import { parseJSON } from "../util";
/**
 * Parse a JSON form of ASK Module to the in-memory representation.
 *
 * @param data JSON string data
 * @param uri optional URI for the source of the ASKIR JSON
 */
export function fromASKModuleJson(data, uri) {
    return fromASKModule(parseJSON(data, uri), uri);
}
/**
 * Parse a serialized form of ASK Module to the in-memory representation.
 *
 * @param data parsed JSON data
 * @param uri optional URI for the source of the ASKIR JSON
 */
export function fromASKModule(data, uri) {
    var _a, _b;
    cleanStructure(data);
    validateModuleSchema(data, uri);
    return new Module(uri, ModuleSchema, undefined, undefined, (_a = data.exports) !== null && _a !== void 0 ? _a : [], (_b = data.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => readAsk(expr)));
}
/**
 * Clean a parsed ASKIR JSON file that does not exactly comply with the JSON schema.
 */
export function cleanStructure(data) {
    if (typeof data === "object") {
        Object.entries(data).forEach(([name, value]) => {
            if ((name === "type" || name === "annotations") && value === null) {
                // UI exporter is incorrectly writing `"type": null`
                delete data[name];
            }
            else if (value && typeof value === "object") {
                cleanStructure(value);
            }
            else if (Array.isArray(value)) {
                value.forEach(cleanStructure);
            }
        });
    }
}
function readAsk(expr) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (expr === undefined) {
        return undefined;
    }
    if (Array.isArray(expr)) {
        return expr.map((d) => readAsk(d));
    }
    if (typeof expr === "string") {
        return new Name(expr);
    }
    if (typeof expr === "object") {
        if (expr.kind === "ActionDeclaration") {
            const action = new ActionDeclaration(new Name(expr.name), (_a = expr.arguments) === null || _a === void 0 ? void 0 : _a.map((a) => {
                const arg = new ArgumentDeclaration(new Name(a.name), readAsk(a.type), readAsk(a.defaultExpression), readAnnotations(a.annotations));
                return arg;
            }), readAsk(expr.returnType), (_b = expr.genericArguments) === null || _b === void 0 ? void 0 : _b.map((a) => {
                var _a;
                const p = new TypeParameter(new Name(a.name), (_a = a.constraints) === null || _a === void 0 ? void 0 : _a.map((c) => readAsk(c)));
                return p;
            }), readAnnotations(expr.annotations), undefined);
            return action;
        }
        if (expr.kind === "Call") {
            let args = expr.arguments;
            if (Array.isArray(expr.arguments)) {
                if (expr.name === AlexaSchema.List &&
                    ((_d = (_c = expr.genericArguments) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.name) === AlexaConversations.Argument &&
                    expr.genericArguments[0].genericArguments === undefined) {
                    // List<Argument> - this is the old version of the core library, we will instead let the compiler infer the type
                    expr.name = undefined;
                    expr.genericArguments = undefined;
                }
                // list literal arguments, wrap them in a ListLiteral type
                args = new ListLiteral(expr.arguments.map((arg, i) => new ListItem(readAsk(arg), i)));
            }
            else if (expr.arguments && typeof expr.arguments === "object") {
                if (expr.name === AlexaConversations.utterances || expr.name === AlexaConversations.intent) {
                    if (Array.isArray(expr.genericArguments) && expr.genericArguments.length === 0) {
                        // empty array should be undefined
                        expr.genericArguments = undefined;
                    }
                    const { samples } = expr.arguments;
                    if (samples &&
                        samples.kind === "Call" &&
                        samples.name === AlexaSchema.List &&
                        ((_f = (_e = samples.genericArguments) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.name) === AlexaSchema.String) {
                        // List<String> instead of List<Utterance<T>>
                        // remove the types and let the compiler infer them.
                        samples.name = undefined;
                        samples.genericArguments = undefined;
                    }
                }
                args = Object.entries(expr.arguments).map(([name, arg], i) => new Argument(new Name(name), i, readAsk(arg)));
            }
            else if (typeof expr.arguments === "string") {
                const names = parseUtteranceSlotNames(expr.arguments);
                if (names) {
                    args = new Utterance(expr.arguments, names.map((name) => new Name(name)));
                }
            }
            // The exported IR use 'lhs' and 'rhs' for operator arguments
            // convert it to 'left' and 'right'
            if (OPERATOR_ACTIONS_SET.has(expr.name)) {
                for (const arg of args) {
                    if (arg.name.name === "lhs") {
                        arg.name = "left";
                    }
                    else if (arg.name.name === "rhs") {
                        arg.name = "right";
                    }
                }
            }
            return new Call(new Name(expr.name), args, readAsk(expr.genericArguments), readAnnotations(expr.annotations));
        }
        if (expr.kind === "Condition") {
            const thenScope = new ThenScope(readAsk(expr.then));
            const elseScope = new ElseScope(readAsk(expr.else));
            return new Condition(new When(readAsk(expr.when)), thenScope, elseScope, readAnnotations(expr.annotations));
        }
        if (expr.kind === "Correction") {
            const actualScope = new CorrectionScope(readAsk(expr.actual));
            const expectedScope = new CorrectionScope(readAsk(expr.expected));
            return new Correction(actualScope, expectedScope);
        }
        if (expr.kind === "DialogDeclaration") {
            return new DialogDeclaration(new Name(expr.name), (_g = expr.arguments) === null || _g === void 0 ? void 0 : _g.map((a) => {
                const arg = new ArgumentDeclaration(new Name(a.name), readAsk(a.type), readAsk(a.defaultExpression), readAnnotations(expr.annotations));
                return arg;
            }), readAsk(expr.samples), readAsk(expr.returnType), (_h = expr.genericArguments) === null || _h === void 0 ? void 0 : _h.map((a) => {
                var _a;
                return new TypeParameter(new Name(a.name), (_a = a.constraints) === null || _a === void 0 ? void 0 : _a.map((c) => readAsk(c)));
            }), readAnnotations(expr.annotations));
        }
        if (expr.kind === "InteractionDeclaration") {
            return new InteractionDeclaration(new Block(readAsk(expr.expressions)), readAnnotations(expr.annotations));
        }
        if (expr.kind === "TypeReference") {
            return new TypeReference(new Name(renameType(expr.name)), readAsk(expr.arguments), readAnnotations(expr.annotations));
        }
        if (expr.kind === "TypeDeclaration") {
            return new TypeDeclaration(new Name(expr.name), expr.properties === undefined
                ? undefined
                : expr.properties.map((prop) => {
                    const typeProperty = new TypeProperty(new Name(prop.name), readAsk(prop.type), prop.optional, readAnnotations(expr.annotations));
                    return typeProperty;
                }), (_j = expr.genericArguments) === null || _j === void 0 ? void 0 : _j.map((arg) => {
                const typeParam = new TypeParameter(new Name(arg.name), readAsk(arg.constraints));
                return typeParam;
            }), readAsk(expr.extensions), readAnnotations(expr.annotations));
        }
        if (expr.kind === "NameDeclaration" || expr.kind === "QualifiedNameDeclaration" || expr.kind === "InteractionNameDeclaration") {
            return new NameDeclaration(new Name(expr.name), readAsk(expr.type), readAsk(expr.expression), readAnnotations(expr.annotations));
        }
        if (expr.kind === "NameReference") {
            return new NameReference(new Name(renameType(expr.name)), readAnnotations(expr.annotations));
        }
        if (expr.kind === "PropertyReference") {
            return new PropertyReference(readAsk(expr.name), readAsk(expr.expression), readAnnotations(expr.annotations));
        }
        if (expr.kind === "Sample") {
            return new Sample(new Block(readAsk(expr.expressions)), readAnnotations(expr.annotations));
        }
        if (expr.kind === "Scope") {
        }
        else if (expr.kind === "EnumDeclaration") {
            return new EnumDeclaration(new Name(expr.name), Array.isArray(expr.items) ? readAsk(expr.items) : undefined, readAnnotations(expr.annotations));
        }
        else if (expr.kind === "EnumItemDeclaration") {
            return new EnumItem(readAsk(expr.name), readAnnotations(expr.annotations));
        }
    }
    throw new Error(`unexpected expression: ${JSON.stringify(expr)}`);
}
/**
 * Renames a type from the server-side representation to the client-side representation.
 */
function renameType(name) {
    // Even though we no longer map AlexaSchema.Type to AlexaConversations.Type
    // in compile.ts's compileExpression (from ACDL to ASKIR) we keep this so decompile works
    if (name === AlexaConversations.Type) {
        return AlexaSchema.Type;
    }
    if (name === AlexaConversations.Argument) {
        return AlexaSchema.Argument;
    }
    if (name === AlexaConversations.Arguments) {
        return AlexaSchema.Arguments;
    }
    return name;
}
function readAnnotations(calls) {
    return calls === null || calls === void 0 ? void 0 : calls.map((call) => new Annotation(readAsk(call)));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FzdC9zZXJpYWxpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQzNDLE9BQU8sRUFBQyxRQUFRLEVBQUUsbUJBQW1CLEVBQWdCLE1BQU0sWUFBWSxDQUFDO0FBQ3hFLE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNsRSxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDM0MsT0FBTyxFQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyRCxPQUFPLEVBQUMsTUFBTSxFQUFvQixZQUFZLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDaEUsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUM1QixPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDbkQsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQy9DLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRXZELE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDaEMsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUM5QixPQUFPLEVBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQ25GLE9BQU8sRUFBQyx1QkFBdUIsRUFBRSxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDL0QsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQ2hE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