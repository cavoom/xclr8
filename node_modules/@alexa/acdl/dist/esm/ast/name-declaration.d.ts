import { Condition, ConditionScope } from "./condition";
import { CorrectionScope } from "./correction";
import { NameReference } from "./name-reference";
import { Module } from "./module";
import { SampleScope } from "./sample";
import { Tree } from "./tree";
import { TypeReference } from "./type";
import { Call } from "./call";
import { PropertyReference } from "./property-reference";
import { Name } from "./name";
import { SourceLocation } from "./source-location";
import { Annotation } from "./annotation";
import { InteractionScope } from "./interaction";
export declare const isNameDeclaration: (node: any) => node is NameDeclaration<Named>;
export type NameDeclarationParent = Module | SampleScope | ConditionScope | InteractionScope | CorrectionScope;
/**
 * This class represents name initialization operation in a Block, including Sample, Condtion, Interaction, Correction.
 * Left side of the expression will be an identifier with optional type and right side could be any allowed expression.
 * <code>
 *     String x = "Hello World!"
 *     findParkingRequest = {time = someTime, location = someLocation}
 *     parkingResult = findParkingAPI(findParkingRequest)
 * </code>
 */
export declare class NameDeclaration<Expr extends Named = Named> extends Tree<"NameDeclaration", NameDeclarationParent> {
    /**
     * Name of the variable. If type of this entity is not defined
     * it's type will be derived from return type of expression output.
     */
    readonly name?: Name | undefined;
    /**
     * Optional type annotation for the value of this name.
     */
    readonly type?: TypeReference | undefined;
    /**
     * Right side of the NameExpr. It could any valid expression which produces output.
     */
    readonly expression?: Expr | undefined;
    /**
     * Annotations attached to this Name Declaration.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    readonly comment?: string | undefined;
    constructor(
    /**
     * Name of the variable. If type of this entity is not defined
     * it's type will be derived from return type of expression output.
     */
    name?: Name | undefined, 
    /**
     * Optional type annotation for the value of this name.
     */
    type?: TypeReference | undefined, 
    /**
     * Right side of the NameExpr. It could any valid expression which produces output.
     */
    expression?: Expr | undefined, 
    /**
     * Annotations attached to this Name Declaration.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, comment?: string | undefined, loc?: SourceLocation | undefined);
    clone(): this;
}
/**
 * Expression types that can be Named.
 */
export type Named = Call | NameReference | PropertyReference | Condition;
//# sourceMappingURL=name-declaration.d.ts.map