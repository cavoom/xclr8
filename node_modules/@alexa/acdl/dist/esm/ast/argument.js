import { guard } from "./guard";
import { Tree } from "./tree";
export const isArgumentDeclaration = guard("ArgumentDeclaration");
/**
 * The arguments for action or dialog.
 */
export class ArgumentDeclaration extends Tree {
    constructor(
    /**
     * Name of argument.
     */
    name, 
    /**
     * Type of the argument.
     */
    type, 
    /**
     * Default value for the argument, if value is not passed from caller.
     */
    defaultExpression, 
    /**
     * Annotations attached to this Argument Declaration.
     */
    annotations, comment, loc) {
        super("ArgumentDeclaration", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "defaultExpression", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: defaultExpression
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        Object.defineProperty(this, "comment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: comment
        });
        this.setAsParentOn(name);
        this.setAsParentOn(type);
        this.setAsParentOn(defaultExpression);
        this.setAsParentOn(annotations);
    }
    clone() {
        var _a, _b, _c, _d;
        return new ArgumentDeclaration((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.type) === null || _b === void 0 ? void 0 : _b.clone(), (_c = this.defaultExpression) === null || _c === void 0 ? void 0 : _c.clone(), (_d = this.annotations) === null || _d === void 0 ? void 0 : _d.map((a) => a.clone()), this.comment, this.loc);
    }
}
export const isArgument = guard("Argument");
/**
 * Represents named argument.
 * Left side of the expression is name of the argument and right side of the expression is expression assigned to
 * argument.
 * Example 1:
 * <code>
 *    findParkingAPI(parkingRequest = findParkingRequest)
 * </code>
 * parkingRequest is name and findParkingRequest is NameExpr assigned to parkingRequest argument.
 * Example 2:
 * <code>
 *     action Restaurant findRestaurant(City cityName)
 *
 *     findRestaurant(city)
 * </code>
 * cityName is the name and city is the NameExpr assigned to the cityName argument.
 * Type of the NamedArgumentExpr should be the same as the type of expression assigned to argument.
 */
export class Argument extends Tree {
    constructor(
    /**
     * Name of the Argument.
     */
    name, 
    /**
     * Index of the argument if provided positionally.
     */
    index, 
    /**
     * Expression for the argument value.ÃŸ
     */
    value, loc) {
        super("Argument", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: index
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
        });
        this.setAsParentOn(name);
        this.setAsParentOn(value);
    }
    clone() {
        var _a, _b;
        return new Argument((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), this.index, (_b = this.value) === null || _b === void 0 ? void 0 : _b.clone(), this.loc);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJndW1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXN0L2FyZ3VtZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFJOUIsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQVE1QixNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUVsRTs7R0FFRztBQUNILE1BQU0sT0FBTyxtQkFBb0IsU0FBUSxJQUFrRTtJQUN6RztJQUNFOztPQUVHO0lBQ00sSUFBVztJQUNwQjs7T0FFRztJQUNNLElBQW9CO0lBQzdCOztPQUVHO0lBQ00saUJBQThCO0lBQ3ZDOztPQUVHO0lBQ00sV0FBMEIsRUFDMUIsT0FBZ0IsRUFDekIsR0FBb0I7UUFFcEIsS0FBSyxDQUFDLHFCQUFxQixFQUFFLEdBQUcsQ0FBQyxDQUFDOzs7OzttQkFoQnpCOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBQ0E7O1FBSVQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sSUFBSSxtQkFBbUIsQ0FDNUIsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxLQUFLLEVBQUUsRUFDbEIsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxLQUFLLEVBQUUsRUFDbEIsTUFBQSxJQUFJLENBQUMsaUJBQWlCLDBDQUFFLEtBQUssRUFBRSxFQUMvQixNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQ3ZDLElBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLEdBQUcsQ0FDRCxDQUFDO0lBQ1osQ0FBQztDQUNGO0FBRUQsTUFBTSxDQUFDLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUU1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxNQUFNLE9BQU8sUUFBUyxTQUFRLElBQXNCO0lBQ2xEO0lBQ0U7O09BRUc7SUFDTSxJQUFXO0lBQ3BCOztPQUVHO0lBQ00sS0FBYztJQUN2Qjs7T0FFRztJQUNNLEtBQXFCLEVBQzlCLEdBQW9CO1FBRXBCLEtBQUssQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLENBQUM7Ozs7O21CQVhkOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7UUFJVCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVNLEtBQUs7O1FBQ1YsT0FBTyxJQUFJLFFBQVEsQ0FBQyxNQUFBLElBQUksQ0FBQyxJQUFJLDBDQUFFLEtBQUssRUFBRSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsTUFBQSxJQUFJLENBQUMsS0FBSywwQ0FBRSxLQUFLLEVBQUUsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFTLENBQUM7SUFDN0YsQ0FBQztDQUNGIn0=