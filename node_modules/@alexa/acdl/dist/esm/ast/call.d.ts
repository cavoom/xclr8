import { Argument, ArgumentDeclaration, Arguments } from "./argument";
import { SourceLocation } from "./source-location";
import { Tree } from "./tree";
import { TypeDeclaration, TypeProperty, TypeReference } from "./type";
import { Name } from "./name";
import { Block } from "./block";
import { Condition, When } from "./condition";
import { NameDeclaration } from "./name-declaration";
import { ActionDeclaration } from "./action";
import { DialogDeclaration } from "./dialog";
import { ListItem } from "./list-literal";
import { Module } from "./module";
import { Annotation } from "./annotation";
export declare const isCall: (node: any) => node is Call<CallContext>;
export type CallContext = ActionDeclaration | Annotation | Argument | ArgumentDeclaration | Block | Condition | When | ListItem | Module | NameDeclaration | TypeProperty;
export declare class Call<Context extends CallContext = CallContext> extends Tree<"Call", Context> {
    /**
     * Name of the Action.
     */
    readonly name?: Name | undefined;
    /**
     * Optional type parameters of the call.
     */
    readonly genericArguments?: (TypeReference | undefined)[] | undefined;
    /**
     * Annotations attached to this Call expression.
     */
    readonly annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined;
    readonly arguments: Arguments;
    constructor(
    /**
     * Name of the Action.
     */
    name?: Name | undefined, 
    /**
     * Arguments to the Action.
     */
    args?: Arguments, 
    /**
     * Optional type parameters of the call.
     */
    genericArguments?: (TypeReference | undefined)[] | undefined, 
    /**
     * Annotations attached to this Call expression.
     */
    annotations?: Annotation<import("./annotation").AnnotatedNode>[] | undefined, loc?: SourceLocation);
    clone(): this;
}
export type Applicable = ActionDeclaration | DialogDeclaration | TypeDeclaration;
//# sourceMappingURL=call.d.ts.map