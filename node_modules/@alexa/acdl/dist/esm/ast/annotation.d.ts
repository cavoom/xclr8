import { ActionDeclaration } from "./action";
import { ArgumentDeclaration } from "./argument";
import { Call } from "./call";
import { Condition } from "./condition";
import { DialogDeclaration } from "./dialog";
import { EnumDeclaration, EnumItem } from "./enum";
import { InteractionDeclaration } from "./interaction";
import { NameDeclaration } from "./name-declaration";
import { NameReference } from "./name-reference";
import { PropertyReference } from "./property-reference";
import { Sample } from "./sample";
import { SourceLocation } from "./source-location";
import { Tree } from "./tree";
import { TypeDeclaration, TypeProperty, TypeReference } from "./type";
export declare const isAnnotation: (node: any) => node is Annotation<AnnotatedNode>;
/**
 * This node wraps a Call expression to explicitly identify it as a Call in an Annotation position.
 */
export declare class Annotation<Context extends AnnotatedNode = AnnotatedNode> extends Tree<"Annotation", Context> {
    readonly call: Call;
    constructor(call: Call, loc?: SourceLocation | undefined);
    clone(): this;
}
export type AnnotatedNode = ActionDeclaration | ArgumentDeclaration | Call | Condition | DialogDeclaration | EnumDeclaration | EnumItem | NameDeclaration | NameReference | PropertyReference | Sample | TypeDeclaration | TypeProperty | TypeReference | InteractionDeclaration;
//# sourceMappingURL=annotation.d.ts.map