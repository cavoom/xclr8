import { guard } from "./guard";
import { Tree } from "./tree";
/**
 * Check if an expression is a TypeDeclaration.
 */
export const isTypeDeclaration = guard("TypeDeclaration");
/**
 * Type Declaration Expression.
 */
export class TypeDeclaration extends Tree {
    constructor(
    /**
     * Name of the Type.
     */
    name, 
    /**
     * Type properties.
     */
    properties, 
    /**
     * Optional list of type parameters.
     */
    genericArguments, 
    /**
     * Optional list of super types.
     */
    extensions, 
    /**
     * Annotations attached to this Type Declaration.
     */
    annotations, comment, loc) {
        super("TypeDeclaration", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "properties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: properties
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: genericArguments
        });
        Object.defineProperty(this, "extensions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: extensions
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        Object.defineProperty(this, "comment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: comment
        });
        this.setAsParentOn(name);
        this.setAsParentOn(properties);
        this.setAsParentOn(genericArguments);
        this.setAsParentOn(extensions);
        this.setAsParentOn(annotations);
    }
    clone() {
        var _a, _b, _c, _d, _e;
        return new TypeDeclaration((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.properties) === null || _b === void 0 ? void 0 : _b.map((p) => p.clone()), (_c = this.genericArguments) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), (_d = this.extensions) === null || _d === void 0 ? void 0 : _d.map((e) => e.clone()), (_e = this.annotations) === null || _e === void 0 ? void 0 : _e.map((e) => e.clone()), this.comment, this.loc);
    }
}
/**
 * Check if an expression is a TypeProperty.
 */
export const isTypeProperty = guard("TypeProperty");
/**
 * Defines a property in type declaration.
 */
export class TypeProperty extends Tree {
    constructor(
    /**
     * Name of the property.
     */
    name, 
    /**
     * Type of the property.
     */
    type, 
    /**
     * TODO: can we define this as a union type instead?
     */
    optional, 
    /**
     * Annotations attached to this Type Property.
     */
    annotations, comment, loc) {
        super("TypeProperty", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "optional", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: optional
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        Object.defineProperty(this, "comment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: comment
        });
        this.setAsParentOn(name);
        this.setAsParentOn(type);
        this.setAsParentOn(annotations);
    }
    clone() {
        var _a, _b, _c;
        return new TypeProperty((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.type) === null || _b === void 0 ? void 0 : _b.clone(), this.optional, (_c = this.annotations) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), this.comment, this.loc);
    }
}
export const isTypeReference = guard("TypeReference");
/**
 * Used to define type of variable, return type of an expression, type of event or action declaration.
 * <code> MyType<String> </code>
 * Here MyType is name of type and String is type argument.
 */
export class TypeReference extends Tree {
    constructor(
    /**
     * Name of the type being referenced.
     */
    name, 
    /**
     * Generic Type arguments to this Type Reference.
     */
    typeArgs, 
    /**
     * Annotations attached to this Type Reference.
     */
    annotations, 
    /**
     * If this TypeReference is using Function syntax, this array contains a mapping of position to argument name.
     * ex.
     * ```
     * foo(String str)
     * ```
     *
     * This is of type `Function1<String, Nothing>`.
     *
     * Its functionArgumentNames are `["str"]`, meaning the `String` type of `arg0` should be mapped to `str`.
     *
     * This data only exists when parsing ACDL syntax.
     *
     * TODO: should we create a separate Expression kind for this? We don't have one in ASKIR.
     */
    functionArgumentNames, loc, 
    /**
     * internal flag to indicate this type reference was inferred and should not have errors placed on it
     */
    inferred) {
        super("TypeReference", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        Object.defineProperty(this, "functionArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionArgumentNames
        });
        Object.defineProperty(this, "inferred", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: inferred
        });
        /**
         * Generic Type arguments to this Type Reference.
         */
        Object.defineProperty(this, "arguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.setAsParentOn(name);
        this.setAsParentOn(typeArgs);
        this.setAsParentOn(annotations);
        this.arguments = typeArgs;
    }
    clone() {
        var _a, _b, _c;
        return new TypeReference((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.arguments) === null || _b === void 0 ? void 0 : _b.map((a) => a === null || a === void 0 ? void 0 : a.clone()), (_c = this.annotations) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), this.functionArgumentNames, this.loc, this.inferred);
    }
}
export const isTypeParameter = guard("TypeParameter");
/**
 * Generic type parameter.
 */
export class TypeParameter extends Tree {
    constructor(
    /**
     * Name of the Type Parameter.
     */
    name, 
    /**
     * Optional bound for the Type Parameter.
     */
    constraints, loc) {
        super("TypeParameter", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "constraints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: constraints
        });
        this.setAsParentOn(name);
        this.setAsParentOn(constraints);
    }
    clone() {
        var _a, _b;
        return new TypeParameter((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.constraints) === null || _b === void 0 ? void 0 : _b.map((c) => c.clone()), this.loc);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hc3QvdHlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBSzlCLE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFJNUI7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUUxRDs7R0FFRztBQUNILE1BQU0sT0FBTyxlQUFnQixTQUFRLElBQStCO0lBQ2xFO0lBQ0U7O09BRUc7SUFDTSxJQUFXO0lBQ3BCOztPQUVHO0lBQ00sVUFBMkI7SUFDcEM7O09BRUc7SUFDTSxnQkFBa0M7SUFDM0M7O09BRUc7SUFDTSxVQUE0QjtJQUNyQzs7T0FFRztJQUNNLFdBQTBCLEVBRTFCLE9BQWdCLEVBQ3pCLEdBQW9CO1FBRXBCLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7bUJBckJyQjs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBRUE7O1FBSVQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVNLEtBQUs7O1FBQ1YsT0FBTyxJQUFJLGVBQWUsQ0FDeEIsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxLQUFLLEVBQUUsRUFDbEIsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxHQUFHLENBQUMsQ0FBQyxDQUFD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