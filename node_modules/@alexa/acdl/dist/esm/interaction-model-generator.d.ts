import * as ask from "./ast";
import { Apply } from "./apply";
import { Locale } from "./ast";
import { InteractionModel } from "./interaction-model";
/**
 * Interaction model generator generates interaction model from definitions in ACDL code.
 */
export declare class InteractionModelGenerator {
    /**
     * Gets locales from a `skill` action call.
  
    * ~~~acdl
     * mySkill = skill(
     *   locales = [Locale.en_US, ...],
     *   ...
     * )
     * ~~~
     *
     * @param skill The `skill` action call.
     * @returns The set of locales defined in the `skill` action call.
     */
    private findLocales;
    /**
     * Finds intents in the `skill` action call for specified locale.
     * The `intents` value is a list of name references, which can be:
     *
     * - `intent` action call
     * - `variations` action call with name references
     * - name reference to name declaration of any of above
     *
     * Name declarations can have `@locale` annotation that has to match the specified locale.
     *
     * ~~~acdl
     * mySkill = skill(
     *   intents = [...],
     *   ...
     * )
     * ~~~
     *
     * @param skill Skill action call.
     * @param locale The locale for which to find the intents.
     * @returns The intents found in skill action call for specified locale.
     */
    private findIntents;
    private uniqueValues;
    /**
     * Gets the utterance sample text.
     *
     * @param utterance The value with sample utterance. This can be
     * @returns The text value of the sample utterance.
     */
    private getUtteranceText;
    /**
     * Gets string value from `Thing` representing a string literal.
     *
     * @param value Thing that potentially represents a string literal.
     * @returns String value of the thing, or `undefined` if it does not represent a string.
     */
    private getStringValue;
    /**
     * Gets string array from `Thing` representing a string array literal.
     *
     * @param value Thing that potentially represents a string array literal.
     * @param defaultValue Default value for items that are not string literals.
     * @returns String array value of the thing, or `undefined` if it does not represent a string array.
     */
    private getStringListValue;
    /**
     * Gets fully qualified name of the thing representing a name declaration.
     *
     * @param value Thing.
     * @returns Fully qualified name of the thing.
     */
    private getFullyQualifiedName;
    /**
     * Generates slot type based on the list-based catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myBuiltinCatalog = builtinCatalog<MySlot>("AMAZON.Actor")
     * ~~~
     *
     * @returns The slot type based on the list-based catalog type.
     */
    private generateBuiltinCatalog;
    /**
     * Generates slot type based on the list-based catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myListBasedCatalog = listBasedCatalog<MySlot>(
     *   // itemsThing
     *   CatalogItem<MySlot> {
     *     id = "test",
     *     value = "test value",
     *     synonyms = [
     *       "test synonym 1",
     *       "test synonym 2"
     *     ]
     *   }
     * )
     * ~~~
     *
     * @returns The slot type based on the list-based catalog type.
     */
    private generateListBasedCatalog;
    /**
     * Gets annotation applied on the value having the defined name.
     *
     * @param value Value from which the annotation should be extracted.
     * @param name Name of the annotation.
     * @param checker Type checker.
     * @returns Annotation applied on the value.
     */
    private getAnnotation;
    /**
     * Gets argument value from the annotation.
     *
     * @param annotation Annotation from which to get the argument value.
     * @param argumentName Name of the argument to retrieve.
     * @param checker Type checker.
     * @returns Argument value from the annotation.
     */
    private getAnnotationArgumentValue;
    /**
     * Gets locales from annotated node.
     *
     * @param node Node for which to get locales.
     * @param checker Type checker.
     * @returns Locales as a simple string array.
     */
    private getLocalesFromAnnotatedNode;
    /**
     * Resolves variations to get node for specific locale.
     *
     * @param node Node from which to start resolving the variations.
     * @param locale Locale for which to search the resolved value.
     * @param checker Type checker.
     * @param locales Locales of the node.
     * @returns Node for specific locale.
     */
    private resolveVariations;
    /**
     * Determines whether the node is a name declaration that was generated using `interactionModel` generator.
     *
     * @param node Node to evaluate.
     * @param checker Type checker.
     * @returns Indicates whether the node was generated using `interactionModel` generator.
     */
    private isGeneratedFromInteractionModel;
    /**
     * Generates slot type based on the catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myBuiltinCatalog = builtinCatalog<MySlot>("AMAZON.Actor")
     *
     * // catalogAnnotation
     * @catalog(myListBasedCatalog)
     * type MySlot: String {}
     *
     * type MyIntent {
     *   // property
     *   MySlot mySlot
     * }
     * ~~~
     *
     * @returns The intent slots based on the complex type.
     */
    private generateCatalog;
    /**
     * Generates intent slots based on the complex type.
     *
     * ~~~
     * @catalog(myBuiltinCatalog)
     * type MyBuiltinSlot: String {}
     *
     * @catalog(myListBasedCatalog)
     * type MyListBasedSlot: String {}
     *
     * // intentType
     * type MyIntent {
     *   MyBuiltinSlot myBuiltinSlot
     *   MyListBasedSlot myListBasedSlot
     * }
     * ~~~
     *
     * @returns The intent slots based on the complex type.
     */
    private generateSlots;
    /**
     * Creates intents in interaction model from them. Samples from `intent<T>` actions are used for sample utterances,
     * and the type is used to generate slots.
     *
     * ~~~
     * // intent.declaration
     * invocationUtterances =
     *   // intent.apply
     *   intent
     *     // generic argument 0
     *     <MyIntent>
     *     (
     *       // argument: samples
     *       [
     *         "hello world",
     *         "hello {myBuiltinSlot}",
     *         "{myListBasedSlot} world"
     *       ]
     *     )
     * ~~~
     *
     * @returns The intent defined by the `intent` action.
     */
    private generateIntent;
    /**
     * Generates interaction model from ACDL constructs. Gets `intents` defined in `skill` action call and creates
     * intents in interaction model from them. Samples from `intent<T>` actions are used for sample utterances, and
     * the type is used to generate slots.
     * Also, `extendCatalog` calls are collected to find slot type definitions for built-in types.
     *
     * // interactionModels/custom/en-US.json
     * {
     *  "languageModel": {
     *   "intents": [
     *    {
     *     "generated": "acdl",
     *     "name": "getTravelTimeIntentEn",
     *     "slots": [
     *      {
     *       "name": "DepartingPlanet",
     *       "type": "planetCatalogEn"
     *      },
     *      ...
     *     ],
     *     "samples": [
     *      "calculate travel time",
     *      ...
     *     ]
     *    }
     *   ],
     *   "types": [
     *    {
     *     "generated": "acdl",
     *     "name": "planetCatalogEn",
     *     "values": [
     *      {
     *       "name": {
     *        "value": "Mercury"
     *       },
     *       ...
     *      }
     *     ]
     *    }
     *   ]
     *  }
     * }
     *
     * @returns Interaction model generated from ACDL constructs.
     */
    generateInteractionModels(skills: {
        declaration?: ask.NameDeclaration;
        apply: Apply;
    }[], extendCatalogActions: {
        declaration?: ask.NameDeclaration;
        apply: Apply;
    }[]): Map<Locale, InteractionModel>;
    private getSimpleName;
    private generateSlotTypesFromExtendedCatalogs;
}
//# sourceMappingURL=interaction-model-generator.d.ts.map