import * as ask from "./ast";
import { transformEachChild } from "./visit";
import { Project } from "./project";
import { AlexaSchema } from "./ast";
import { validateCall } from "./validate";
import { getAllNames } from "./get-all-names";
/**
 * Takes in a parsed ACDL {@link Project} and returns a new project with
 * constant expressions transformed into the equivalent {@link ask.Node}.
 *
 * Current transformations are:
 *
 * - `getAllNames<T>(Args<String> namespaces)`
 *
 *
 * Transformations should only be placed here if they need to be completed after
 * parsing the acdl files.
 */
export function transformProject(project) {
    const modules = project.source.modules.map((mod) => {
        var _a;
        const transformedModule = mod.content ? transformModule(mod.content, project.getTypeChecker()) : undefined;
        const content = transformedModule === null || transformedModule === void 0 ? void 0 : transformedModule.module;
        const errors = mod.errors ? mod.errors.concat((_a = transformedModule === null || transformedModule === void 0 ? void 0 : transformedModule.errors) !== null && _a !== void 0 ? _a : []) : transformedModule === null || transformedModule === void 0 ? void 0 : transformedModule.errors;
        return {
            ...mod,
            content,
            errors,
        };
    });
    return new Project({
        config: project.config,
        external: project.external,
        source: {
            ...project.source,
            modules: modules,
        },
    });
}
export function transformModule(module, checker) {
    var _a;
    const errors = [];
    const expressions = (_a = module.expressions) === null || _a === void 0 ? void 0 : _a.map((expr) => transformNode(expr, checker, errors));
    const exports = expressions === null || expressions === void 0 ? void 0 : expressions.map((e) => { var _a; return e.kind !== "InteractionDeclaration" && ((_a = e === null || e === void 0 ? void 0 : e.name) === null || _a === void 0 ? void 0 : _a.name); }).filter((n) => n !== undefined);
    const mod = new ask.Module(module.uri, module.schema, module.namespace, module.imports, exports, expressions);
    return {
        module: mod,
        errors: errors,
    };
}
/**
 * Converts a node into an equivalent {@link ask.Expression}.
 */
function transformNode(node, checker, errors) {
    if (ask.isCall(node)) {
        const apply = checker.getApply(node);
        if (apply === null || apply === void 0 ? void 0 : apply.isGetAllNamesAction()) {
            return transformGetAllNames(node, apply, checker, errors);
        }
    }
    return transformEachChild(node, (child) => transformNode(child, checker, errors));
}
/**
 * Converts a getAllNames action into a {@link ask.ListLiteral}. It searches the namespaces
 * for global name declarations and creates a list of name references that match the
 * generic type of the action.
 *
 * ```
 * namespace company
 *
 * locale1 = Locale.en_US
 * locale2 = Locale.fr_FR
 *
 * getAllNames<Locale>("company")
 *
 * // Will be transformed into:
 * ask.Call(
 *  ask.Name(AlexaSchema.List),
 *  ask.ListLiteral([
 *    ask.ListItem(ask.NameReference("company.locale1")),
 *    ask.ListItem(ask.NameReference("company.locale2")),
 * ]))
 * ```
 */
function transformGetAllNames(node, apply, checker, errors) {
    // Manually validate the getAllNames action
    errors.push(...validateCall(node, checker));
    const nameDecls = getAllNames(apply, checker);
    // nameDecls is undefined when there was a problem with the type system, let this
    // fall through and get caught by later validations.
    if (nameDecls === undefined) {
        return node;
    }
    const items = nameDecls.map((decl, idx) => {
        const nameRef = new ask.NameReference(decl.name);
        return new ask.ListItem(nameRef, idx);
    });
    const list = new ask.ListLiteral(items, node.loc);
    return new ask.Call(new ask.Name(AlexaSchema.List), list, node.genericArguments, node.annotations, node.loc);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtLXByb2plY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdHJhbnNmb3JtLXByb2plY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUM7QUFHN0IsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRTNDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUVsQyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUU1Qzs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxPQUFnQjtJQUMvQyxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTs7UUFDakQsTUFBTSxpQkFBaUIsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBRTNHLE1BQU0sT0FBTyxHQUFHLGlCQUFpQixhQUFqQixpQkFBaUIsdUJBQWpCLGlCQUFpQixDQUFFLE1BQU0sQ0FBQztRQUMxQyxNQUFNLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFBLGlCQUFpQixhQUFqQixpQkFBaUIsdUJBQWpCLGlCQUFpQixDQUFFLE1BQU0sbUNBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixhQUFqQixpQkFBaUIsdUJBQWpCLGlC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