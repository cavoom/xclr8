import * as ask from "./ast";
import { TypeChecker } from "./checker";
import { Project } from "./project";
export interface ACDLBuilderProps {
    project: Project;
    namespace: string;
    initialImports: string[];
    profile: string;
}
export declare enum ACDLBuilderTemplate {
    Interaction = "InteractionTemplate"
}
export declare enum ACDLBuilderTemplateWalker {
    ModuleWalker = "MODULE_WALKER",
    InteractionWalker = "INTERACTION_WALKER",
    CorrectionActualWalker = "CORRECTION_ACTUAL_WALKER",
    CorrectionExpectedWalker = "CORRECTION_EXPECTED_WALKER"
}
/**
 * Builder for a single ask.Module for a single ACDL file
 */
export declare class ACDLBuilder {
    /**
     * Builder should always be instantiated with a project context, with its checker always up to date.
     */
    private readonly project;
    private _checker;
    /**
     * Specify the virtual file for the Project instance to carry the AST over to the building process.
     */
    private readonly virtualFile;
    /**
     * Composer is an array of ask.Expression (or ask.ModuleExpression) writers which also walk through the expressions array.
     */
    private readonly composers;
    /**
     * AST will be tracked while the composers walking through their Block
     */
    private readonly _ast;
    get ast(): ask.Module;
    get checker(): TypeChecker;
    /**
     * Each ACDLBuilder is supposed to be constructed with the project information and the ACDL file information to be built.
     * It's required to set the ACDL file name and the namespace, optional with imports, to build the ACDL file.
     *
     * @param props ACDLBuilderProps
     */
    constructor(props: ACDLBuilderProps);
    /**
     * Factory method to produce ACDLBuilder with jump start.
     * Currently only ACDLBuilderTemplate.Interaction is supported.
     *
     * @param template ACDLBuilderTemplate
     * @param props ACDLBuilderProps
     * @returns ACDLBuilder
     */
    static startAs(template: ACDLBuilderTemplate, props: ACDLBuilderProps): ACDLBuilder;
    getComposer(id: ACDLBuilderTemplateWalker): ACDLBlockWalker | undefined;
    registerComposer(walker: ACDLBlockWalker): void;
    removeComposer(id: ACDLBuilderTemplateWalker): void;
    withLine(id: ACDLBuilderTemplateWalker, line: string): ACDLBlockerWalkerExpression;
    withExpressionNode<T extends ask.Expression | ask.ModuleExpression>(id: ACDLBuilderTemplateWalker, expr: T): void;
    build(): string;
}
export type ACDLBlockerWalkerExpression = ask.Call | ask.NameDeclaration | ask.TypeDeclaration | ask.Correction | ask.ActionDeclaration;
export interface ACDLBlockWalkerProps {
    id: ACDLBuilderTemplateWalker;
    context: ask.Block | ask.Module;
    namespace: string;
    at?: number;
}
/**
 * Walkers of the ACDL file Blocks, to inser Node to AST as well as track the position.
 */
export declare class ACDLBlockWalker {
    /**
     * Where the block walker works on
     */
    private readonly context;
    /**
     * Namespace from the builder
     */
    private readonly namespace;
    /**
     * ID is of enum of ACDLBuilderTemplateWalker, which makes sure there is only one type of walker in each building process.
     */
    readonly id: ACDLBuilderTemplateWalker;
    /**
     * Tracks walker's position in the block
     */
    at: number;
    constructor(props: ACDLBlockWalkerProps);
    /**
     * Insert one line of string into the Block as one Expression
     * @param line
     */
    insert(line: string, checker: TypeChecker): ACDLBlockerWalkerExpression;
    /**
     * Insert the AST Tree Node directly into the Block Expression list
     * @param expr
     */
    insertNode<T extends ask.Expression | ask.ModuleExpression>(expr: T, checker: TypeChecker): void;
    /**
     * Get the last added expression
     */
    peek(): ask.ModuleExpression | ask.Expression | undefined;
    private parseLine;
}
//# sourceMappingURL=builder.d.ts.map