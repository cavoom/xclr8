import * as ask from "./ast";
import { isNotUndefined } from "./util";
import { AlexaConversations } from "./ast";
import { SlotTypeMerger } from "./interaction-model-merger";
const GENERATOR_NAME = "acdl";
class InteractionModelGeneratorContext {
    constructor(allGeneratedSlotTypes) {
        /**
         * Cache generated slot types across all locales, to avoid regenerating if it was already generated.
         */
        Object.defineProperty(this, "allGeneratedSlotTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Generated slot types.
         */
        Object.defineProperty(this, "generatedSlotTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.allGeneratedSlotTypes = allGeneratedSlotTypes;
        this.generatedSlotTypes = new Map();
    }
    addGeneratedSlotType(generatedSlotType) {
        const name = generatedSlotType.slotType.name;
        this.generatedSlotTypes.set(name, generatedSlotType);
        this.allGeneratedSlotTypes.set(name, generatedSlotType);
        return generatedSlotType;
    }
    getGeneratedSlotType(name) {
        return this.generatedSlotTypes.get(name);
    }
    getGeneratedSlotTypes() {
        return [...this.generatedSlotTypes.values()];
    }
    importGeneratedSlotType(name) {
        const generatedSlotType = this.allGeneratedSlotTypes.get(name);
        if (generatedSlotType === undefined) {
            return undefined;
        }
        this.generatedSlotTypes.set(name, generatedSlotType);
        return generatedSlotType;
    }
    clone() {
        const context = new InteractionModelGeneratorContext(new Map());
        context.allGeneratedSlotTypes = new Map(this.allGeneratedSlotTypes);
        context.generatedSlotTypes = new Map(this.generatedSlotTypes);
        return context;
    }
}
/**
 * Interaction model generator generates interaction model from definitions in ACDL code.
 */
export class InteractionModelGenerator {
    /**
     * Gets locales from a `skill` action call.
  
    * ~~~acdl
     * mySkill = skill(
     *   locales = [Locale.en_US, ...],
     *   ...
     * )
     * ~~~
     *
     * @param skill The `skill` action call.
     * @returns The set of locales defined in the `skill` action call.
     */
    findLocales(skill) {
        var _a;
        const locales = skill.getArgumentValueThing("locales");
        const localeItems = (locales === null || locales === void 0 ? void 0 : locales.isList()) && locales.isLiteral() ? (_a = locales.getItems()) !== null && _a !== void 0 ? _a : [] : [];
        return new Set(localeItems
            .map((locale) => { var _a; return (((_a = locale === null || locale === void 0 ? void 0 : locale.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name" && locale.origin.name ? locale.origin.name : undefined); })
            .filter(isNotUndefined));
    }
    /**
     * Finds intents in the `skill` action call for specified locale.
     * The `intents` value is a list of name references, which can be:
     *
     * - `intent` action call
     * - `variations` action call with name references
     * - name reference to name declaration of any of above
     *
     * Name declarations can have `@locale` annotation that has to match the specified locale.
     *
     * ~~~acdl
     * mySkill = skill(
     *   intents = [...],
     *   ...
     * )
     * ~~~
     *
     * @param skill Skill action call.
     * @param locale The locale for which to find the intents.
     * @returns The intents found in skill action call for specified locale.
     */
    findIntents(skill, locale, checker) {
        var _a, _b, _c;
        const intents = skill.getArgumentValueThing("intents");
        return this.uniqueValues((_c = (_b = (_a = intents === null || intents === void 0 ? void 0 : intents.asList()) === null || _a === void 0 ? void 0 : _a.getListItems()) === null || _b === void 0 ? void 0 : _b.map((item) => this.resolveVariations(item === null || item === void 0 ? void 0 : item.item, locale, checker)).filter(isNotUndefined)) !== null && _c !== void 0 ? _c : []);
    }
    uniqueValues(array) {
        return [...new Set(array)];
    }
    /**
     * Gets the utterance sample text.
     *
     * @param utterance The value with sample utterance. This can be
     * @returns The text value of the sample utterance.
     */
    getUtteranceText(utterance) {
        if ((utterance === null || utterance === void 0 ? void 0 : utterance.kind) !== "Call") {
            return undefined;
        }
        if (typeof utterance.arguments === "string") {
            return utterance.arguments;
        }
        if (ask.isUtterance(utterance.arguments)) {
            return utterance.arguments.text;
        }
        return undefined;
    }
    /**
     * Gets string value from `Thing` representing a string literal.
     *
     * @param value Thing that potentially represents a string literal.
     * @returns String value of the thing, or `undefined` if it does not represent a string.
     */
    getStringValue(value) {
        var _a, _b;
        return (value === null || value === void 0 ? void 0 : value.isString()) && typeof ((_a = value.apply) === null || _a === void 0 ? void 0 : _a.call.arguments) === "string" ? (_b = value.apply) === null || _b === void 0 ? void 0 : _b.call.arguments : undefined;
    }
    /**
     * Gets string array from `Thing` representing a string array literal.
     *
     * @param value Thing that potentially represents a string array literal.
     * @param defaultValue Default value for items that are not string literals.
     * @returns String array value of the thing, or `undefined` if it does not represent a string array.
     */
    getStringListValue(value, defaultValue) {
        var _a, _b;
        return (_b = (_a = value === null || value === void 0 ? void 0 : value.asList()) === null || _a === void 0 ? void 0 : _a.getItems()) === null || _b === void 0 ? void 0 : _b.map((item) => { var _a; return (_a = this.getStringValue(item)) !== null && _a !== void 0 ? _a : defaultValue; });
    }
    /**
     * Gets fully qualified name of the thing representing a name declaration.
     *
     * @param value Thing.
     * @returns Fully qualified name of the thing.
     */
    getFullyQualifiedName(value) {
        var _a, _b, _c;
        if (!ask.isNameDeclaration((_a = value.apply) === null || _a === void 0 ? void 0 : _a.call.context)) {
            return undefined;
        }
        return (_c = (_b = value.apply) === null || _b === void 0 ? void 0 : _b.call.context.name) === null || _c === void 0 ? void 0 : _c.name;
    }
    /**
     * Generates slot type based on the list-based catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myBuiltinCatalog = builtinCatalog<MySlot>("AMAZON.Actor")
     * ~~~
     *
     * @returns The slot type based on the list-based catalog type.
     */
    generateBuiltinCatalog(catalogValueThing, context) {
        var _a;
        if (!((_a = catalogValueThing === null || catalogValueThing === void 0 ? void 0 : catalogValueThing.apply) === null || _a === void 0 ? void 0 : _a.isBuiltinCatalogAction())) {
            return undefined;
        }
        // for builtin catalog, use its name as slot type name
        const fullyQualifiedName = this.getStringValue(catalogValueThing.apply.getArgumentValueThing("name"));
        if (!fullyQualifiedName) {
            throw new Error("Builtin catalog name cannot be undefined or empty.");
        }
        const name = fullyQualifiedName;
        const existingSlotType = context.getGeneratedSlotType(name);
        if (existingSlotType) {
            if (existingSlotType.fullyQualifiedName !== fullyQualifiedName) {
                throw new Error(`Slot type '${existingSlotType.fullyQualifiedName}' collides with '${fullyQualifiedName}'.`);
            }
            return existingSlotType;
        }
        const importedSlotType = context.importGeneratedSlotType(name);
        if (importedSlotType) {
            return importedSlotType;
        }
        return context.addGeneratedSlotType({
            fullyQualifiedName,
            slotType: { generatedBy: GENERATOR_NAME, name },
        });
    }
    /**
     * Generates slot type based on the list-based catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myListBasedCatalog = listBasedCatalog<MySlot>(
     *   // itemsThing
     *   CatalogItem<MySlot> {
     *     id = "test",
     *     value = "test value",
     *     synonyms = [
     *       "test synonym 1",
     *       "test synonym 2"
     *     ]
     *   }
     * )
     * ~~~
     *
     * @returns The slot type based on the list-based catalog type.
     */
    generateListBasedCatalog(catalogValueThing, context) {
        var _a, _b, _c, _d;
        if (!((_a = catalogValueThing === null || catalogValueThing === void 0 ? void 0 : catalogValueThing.apply) === null || _a === void 0 ? void 0 : _a.isListBasedCatalogAction())) {
            return undefined;
        }
        // for listBasedCatalog, use fully qualified name of the named reference as its name and define values
        const fullyQualifiedName = this.getFullyQualifiedName(catalogValueThing);
        const name = this.getSimpleName(fullyQualifiedName);
        if (!fullyQualifiedName || !name) {
            throw new Error("List-based catalog name cannot be undefined or empty.");
        }
        const existingSlotType = context.getGeneratedSlotType(name);
        if (existingSlotType) {
            if (existingSlotType.fullyQualifiedName !== fullyQualifiedName) {
                throw new Error(`Slot type '${existingSlotType.fullyQualifiedName}' collides with '${fullyQualifiedName}'.`);
            }
            return existingSlotType;
        }
        const importedSlotType = context.importGeneratedSlotType(name);
        if (importedSlotType) {
            return importedSlotType;
        }
        const items = (_d = (_c = (_b = catalogValueThing.apply.getArgumentValueThing("items")) === null || _b === void 0 ? void 0 : _b.asList()) === null || _c === void 0 ? void 0 : _c.getItems()) !== null && _d !== void 0 ? _d : [];
        const valueSet = new Set();
        const idSet = new Set();
        const values = items.map((item) => {
            var _a, _b;
            const id = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("id"));
            const value = (_a = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("value"))) !== null && _a !== void 0 ? _a : "";
            const synonyms = (_b = this.getStringListValue(item === null || item === void 0 ? void 0 : item.getProperty("synonyms"), "")) !== null && _b !== void 0 ? _b : [];
            if (value === "") {
                throw new Error(`Empty string value found in catalog: ${fullyQualifiedName}.`);
            }
            if (valueSet.has(value)) {
                throw new Error(`Duplicate value "${value}" found in catalog: ${fullyQualifiedName}.`);
            }
            if (id && idSet.has(id)) {
                throw new Error(`Duplicate id "${id}" found in catalog: ${fullyQualifiedName}.`);
            }
            valueSet.add(value);
            idSet.add(id);
            return {
                id,
                name: {
                    value,
                    synonyms,
                },
            };
        });
        return context.addGeneratedSlotType({
            fullyQualifiedName,
            slotType: { generatedBy: GENERATOR_NAME, name, values },
        });
    }
    /**
     * Gets annotation applied on the value having the defined name.
     *
     * @param value Value from which the annotation should be extracted.
     * @param name Name of the annotation.
     * @param checker Type checker.
     * @returns Annotation applied on the value.
     */
    getAnnotation(value, name, checker) {
        var _a, _b;
        return (_b = (_a = value === null || value === void 0 ? void 0 : value.annotations) === null || _a === void 0 ? void 0 : _a.filter((annotation) => { var _a, _b; return ((_b = (_a = checker.getApply(annotation.call)) === null || _a === void 0 ? void 0 : _a.decl.name) === null || _b === void 0 ? void 0 : _b.name) === name; })) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Gets argument value from the annotation.
     *
     * @param annotation Annotation from which to get the argument value.
     * @param argumentName Name of the argument to retrieve.
     * @param checker Type checker.
     * @returns Argument value from the annotation.
     */
    getAnnotationArgumentValue(annotation, argumentName, checker) {
        var _a;
        return ask.isCall(annotation === null || annotation === void 0 ? void 0 : annotation.call) ? (_a = checker.getApply(annotation.call)) === null || _a === void 0 ? void 0 : _a.getArgumentValue(argumentName) : undefined;
    }
    /**
     * Gets locales from annotated node.
     *
     * @param node Node for which to get locales.
     * @param checker Type checker.
     * @returns Locales as a simple string array.
     */
    getLocalesFromAnnotatedNode(node, checker) {
        var _a, _b, _c;
        const localeAnnotation = this.getAnnotation(node, AlexaConversations.locale, checker);
        const localesValue = this.getAnnotationArgumentValue(localeAnnotation, "locales", checker);
        const result = [];
        if (ask.isCall(localesValue) && ask.isListLiteral(localesValue === null || localesValue === void 0 ? void 0 : localesValue.arguments)) {
            for (const localeItem of localesValue.arguments.items) {
                if ((_a = checker.getType(localeItem.item)) === null || _a === void 0 ? void 0 : _a.isLocale()) {
                    if (ask.isPropRef(localeItem.item)) {
                        if ((_b = localeItem.item.name) === null || _b === void 0 ? void 0 : _b.name) {
                            result.push((_c = localeItem.item.name) === null || _c === void 0 ? void 0 : _c.name);
                        }
                    }
                }
            }
        }
        return result;
    }
    /**
     * Resolves variations to get node for specific locale.
     *
     * @param node Node from which to start resolving the variations.
     * @param locale Locale for which to search the resolved value.
     * @param checker Type checker.
     * @param locales Locales of the node.
     * @returns Node for specific locale.
     */
    resolveVariations(node, locale, checker, locales = new Set()) {
        if (node === undefined) {
            return undefined;
        }
        // if this is a declaration, append locales from the declaration into the context
        if (ask.isNameDeclaration(node)) {
            this.getLocalesFromAnnotatedNode(node, checker).forEach((locale) => locales.add(locale));
            // resolve the name value recursively
            return this.resolveVariations(node.expression, locale, checker, locales);
        }
        if (ask.isNameReference(node) || ask.isPropRef(node)) {
            const nodes = new Set();
            // recursively add name references and name declaration into `nodes`
            const declaration = checker.resolveNameReferenceToDecl(node, nodes);
            for (const node of nodes) {
                if (ask.isNameReference(node) || ask.isPropRef(node) || ask.isNameDeclaration(node)) {
                    this.getLocalesFromAnnotatedNode(node, checker).forEach((locale) => locales.add(locale));
                }
            }
            return this.resolveVariations(declaration, locale, checker, locales);
        }
        if (ask.isCall(node)) {
            const apply = checker.getApply(node);
            if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                const variationsValue = apply.getArgumentValue("variations");
                if (ask.isCall(variationsValue) && ask.isListLiteral(variationsValue.arguments)) {
                    for (const item of variationsValue.arguments.items) {
                        const variationLocales = new Set(locales);
                        const variation = this.resolveVariations(item.item, locale, checker, variationLocales);
                        if (variation) {
                            return variation;
                        }
                    }
                    return undefined;
                }
            }
        }
        // return the node only if the locales are not defined or they match the requested locale
        return !locales.size || locales.has(locale) ? node : undefined;
    }
    /**
     * Determines whether the node is a name declaration that was generated using `interactionModel` generator.
     *
     * @param node Node to evaluate.
     * @param checker Type checker.
     * @returns Indicates whether the node was generated using `interactionModel` generator.
     */
    isGeneratedFromInteractionModel(node, checker) {
        if (ask.isNameDeclaration(node)) {
            const intentValueAnnotation = this.getAnnotation(node, AlexaConversations.generated, checker);
            const generatorNameValue = this.getAnnotationArgumentValue(intentValueAnnotation, "generatorName", checker);
            return ask.isCall(generatorNameValue) && generatorNameValue.arguments === "interactionModel";
        }
        return false;
    }
    /**
     * Generates slot type based on the catalog type.
     *
     * ~~~
     * // catalogValueThing
     * myBuiltinCatalog = builtinCatalog<MySlot>("AMAZON.Actor")
     *
     * // catalogAnnotation
     * @catalog(myListBasedCatalog)
     * type MySlot: String {}
     *
     * type MyIntent {
     *   // property
     *   MySlot mySlot
     * }
     * ~~~
     *
     * @returns The intent slots based on the complex type.
     */
    generateCatalog(property, locale, context) {
        var _a, _b, _c;
        // Unwrap the type from optional and list types
        let type = property.type;
        while ((type === null || type === void 0 ? void 0 : type.isOptional()) || (type === null || type === void 0 ? void 0 : type.isList())) {
            if (type === null || type === void 0 ? void 0 : type.isOptional()) {
                type = type === null || type === void 0 ? void 0 : type.getOptionalType();
            }
            else {
                type = type === null || type === void 0 ? void 0 : type.getListItemType();
            }
        }
        if (!type || ((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) !== "TypeDeclaration") {
            return undefined;
        }
        const typeDeclaration = type === null || type === void 0 ? void 0 : type.declaration;
        const { checker } = type;
        const catalogAnnotation = this.getAnnotation(typeDeclaration, AlexaConversations.catalog, checker);
        const catalogAnnotationArgumentValue = this.getAnnotationArgumentValue(catalogAnnotation, "catalog", checker);
        const catalogValue = this.resolveVariations(catalogAnnotationArgumentValue, locale, checker);
        const catalogThing = checker.getThing(catalogValue);
        if (this.isGeneratedFromInteractionModel((_b = catalogThing === null || catalogThing === void 0 ? void 0 : catalogThing.apply) === null || _b === void 0 ? void 0 : _b.call.context, checker)) {
            context = context.clone();
        }
        return (_c = this.generateBuiltinCatalog(catalogThing, context)) !== null && _c !== void 0 ? _c : this.generateListBasedCatalog(catalogThing, context);
    }
    /**
     * Generates intent slots based on the complex type.
     *
     * ~~~
     * @catalog(myBuiltinCatalog)
     * type MyBuiltinSlot: String {}
     *
     * @catalog(myListBasedCatalog)
     * type MyListBasedSlot: String {}
     *
     * // intentType
     * type MyIntent {
     *   MyBuiltinSlot myBuiltinSlot
     *   MyListBasedSlot myListBasedSlot
     * }
     * ~~~
     *
     * @returns The intent slots based on the complex type.
     */
    generateSlots(intentType, locale, context) {
        var _a, _b;
        return ((_b = (_a = intentType === null || intentType === void 0 ? void 0 : intentType.properties) === null || _a === void 0 ? void 0 : _a.map((property) => {
            var _a, _b, _c;
            const propertyType = (_b = (_a = property.type) === null || _a === void 0 ? void 0 : _a.getOptionalType()) !== null && _b !== void 0 ? _b : property.type;
            const slotType = (_c = this.generateCatalog(property, locale, context)) === null || _c === void 0 ? void 0 : _c.slotType.name;
            if (!slotType) {
                throw new Error(`The catalog for property "${property.name}" in "${intentType}" for locale "${locale}" could not be found.`);
            }
            const multipleValues = (propertyType === null || propertyType === void 0 ? void 0 : propertyType.isList()) ? { multipleValues: { enabled: true } } : undefined;
            return {
                name: property.name,
                type: slotType,
                ...multipleValues,
            };
        })) !== null && _b !== void 0 ? _b : []);
    }
    /**
     * Creates intents in interaction model from them. Samples from `intent<T>` actions are used for sample utterances,
     * and the type is used to generate slots.
     *
     * ~~~
     * // intent.declaration
     * invocationUtterances =
     *   // intent.apply
     *   intent
     *     // generic argument 0
     *     <MyIntent>
     *     (
     *       // argument: samples
     *       [
     *         "hello world",
     *         "hello {myBuiltinSlot}",
     *         "{myListBasedSlot} world"
     *       ]
     *     )
     * ~~~
     *
     * @returns The intent defined by the `intent` action.
     */
    generateIntent(intent, locale, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!ask.isNameDeclaration((_a = intent === null || intent === void 0 ? void 0 : intent.apply) === null || _a === void 0 ? void 0 : _a.call.context)) {
            return undefined;
        }
        const name = this.getSimpleName((_c = (_b = intent === null || intent === void 0 ? void 0 : intent.apply) === null || _b === void 0 ? void 0 : _b.call.context.name) === null || _c === void 0 ? void 0 : _c.name);
        if (intent === undefined || name === undefined) {
            return undefined;
        }
        if (this.isGeneratedFromInteractionModel((_d = intent.apply) === null || _d === void 0 ? void 0 : _d.call.context, intent.checker)) {
            return undefined;
        }
        const samplesValue = (_f = (_e = intent.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValueThing("samples")) === null || _f === void 0 ? void 0 : _f.origin;
        const samplesItems = ask.isCall(samplesValue) && ask.isListLiteral(samplesValue.arguments) ? samplesValue.arguments.items : [];
        const samples = samplesItems.map((item) => this.getUtteranceText(item.item)).filter(isNotUndefined);
        const intentType = (_h = (_g = intent.apply) === null || _g === void 0 ? void 0 : _g.getGenericArguments()) === null || _h === void 0 ? void 0 : _h[0];
        const slots = this.generateSlots(intentType, locale, context);
        return { generatedBy: GENERATOR_NAME, name, samples, slots };
    }
    /**
     * Generates interaction model from ACDL constructs. Gets `intents` defined in `skill` action call and creates
     * intents in interaction model from them. Samples from `intent<T>` actions are used for sample utterances, and
     * the type is used to generate slots.
     * Also, `extendCatalog` calls are collected to find slot type definitions for built-in types.
     *
     * // interactionModels/custom/en-US.json
     * {
     *  "languageModel": {
     *   "intents": [
     *    {
     *     "generated": "acdl",
     *     "name": "getTravelTimeIntentEn",
     *     "slots": [
     *      {
     *       "name": "DepartingPlanet",
     *       "type": "planetCatalogEn"
     *      },
     *      ...
     *     ],
     *     "samples": [
     *      "calculate travel time",
     *      ...
     *     ]
     *    }
     *   ],
     *   "types": [
     *    {
     *     "generated": "acdl",
     *     "name": "planetCatalogEn",
     *     "values": [
     *      {
     *       "name": {
     *        "value": "Mercury"
     *       },
     *       ...
     *      }
     *     ]
     *    }
     *   ]
     *  }
     * }
     *
     * @returns Interaction model generated from ACDL constructs.
     */
    generateInteractionModels(skills, extendCatalogActions) {
        const result = new Map();
        // intents are taken from the (single) skill definition (following the similar logic in root dialogs)
        if (skills.length !== 1) {
            return result;
        }
        const skill = skills[0].apply;
        const { checker } = skill;
        const locales = this.findLocales(skill);
        const allGeneratedSlotTypes = new Map();
        // the interaction model is generated for each skill's locale
        locales.forEach((locale) => {
            const context = new InteractionModelGeneratorContext(allGeneratedSlotTypes);
            const interactionModel = {
                interactionModel: {
                    languageModel: {
                        invocationName: "",
                        intents: this.findIntents(skill, locale, checker)
                            .map((intent) => this.generateIntent(checker.getThing(intent), locale, context))
                            .filter(isNotUndefined),
                        types: context
                            .getGeneratedSlotTypes()
                            .map((generatedSlotType) => generatedSlotType.slotType)
                            .filter((slotType) => !slotType.name.startsWith("AMAZON."))
                            .concat(this.generateSlotTypesFromExtendedCatalogs(extendCatalogActions)),
                    },
                },
            };
            result.set(locale, interactionModel);
        });
        return result;
    }
    getSimpleName(fullyQualifiedName) {
        if (!fullyQualifiedName) {
            return undefined;
        }
        const lastDotIndex = fullyQualifiedName.lastIndexOf(".");
        if (lastDotIndex === -1) {
            return fullyQualifiedName;
        }
        return fullyQualifiedName.substring(lastDotIndex + 1);
    }
    generateSlotTypesFromExtendedCatalogs(extendCatalogActions) {
        var _a, _b, _c;
        const result = new Map();
        for (const extendCatalogAction of extendCatalogActions) {
            const catalogValueThing = extendCatalogAction.apply.getArgumentValueThing("catalog");
            if (!((_a = catalogValueThing === null || catalogValueThing === void 0 ? void 0 : catalogValueThing.apply) === null || _a === void 0 ? void 0 : _a.isBuiltinCatalogAction())) {
                throw new Error("The 'extendCatalog' call can extend only builtin catalogs.");
            }
            const fullyQualifiedName = this.getStringValue(catalogValueThing.apply.getArgumentValueThing("name"));
            if (!fullyQualifiedName) {
                throw new Error("Extended catalog name cannot be undefined or empty.");
            }
            const itemsThing = extendCatalogAction.apply.getArgumentValueThing("items");
            let values = [];
            if (itemsThing === null || itemsThing === void 0 ? void 0 : itemsThing.isList()) {
                values =
                    (_c = (_b = itemsThing.getItems()) === null || _b === void 0 ? void 0 : _b.map((item) => {
                        var _a, _b;
                        const id = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("id"));
                        const value = (_a = this.getStringValue(item === null || item === void 0 ? void 0 : item.getProperty("value"))) !== null && _a !== void 0 ? _a : "";
                        const synonyms = (_b = this.getStringListValue(item === null || item === void 0 ? void 0 : item.getProperty("synonyms"), "")) !== null && _b !== void 0 ? _b : [];
                        const x = {
                            id,
                            name: {
                                value,
                                synonyms,
                            },
                        };
                        return x;
                    })) !== null && _c !== void 0 ? _c : [];
                let slotType = { name: fullyQualifiedName, values };
                const existingSlotType = result.get(fullyQualifiedName);
                if (existingSlotType) {
                    slotType = SlotTypeMerger.INSTANCE.merge(existingSlotType, slotType);
                }
                result.set(fullyQualifiedName, slotType);
            }
        }
        return [...result.values()];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJhY3Rpb24tbW9kZWwtZ2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVyYWN0aW9uLW1vZGVsLWdlbmVyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQztBQUM3QixPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBS3RDLE9BQU8sRUFBQyxrQkFBa0IsRUFBK0QsTUFBTSxPQUFPLENBQUM7QUFHdkcsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBRTFELE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQztBQW1COUIsTUFBTSxnQ0FBZ0M7SUFXcEMsWUFBWSxxQkFBcUQ7UUFWakU7O1dBRUc7UUFDSDs7Ozs7V0FBOEQ7UUFFOUQ7O1dBRUc7UUFDSDs7Ozs7V0FBMkQ7UUFHekQsSUFBSSxDQUFDLHFCQUFxQixHQUFHLHFCQUFxQixDQUFDO1FBQ25ELElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ3RDLENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxpQkFBb0M7UUFDdkQsTUFBTSxJQUFJLEdBQUcsaUJBQWlCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUM3QyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDeEQsT0FBTyxpQkFBaUIsQ0FBQztJQUMzQixDQUFDO0lBRUQsb0JBQW9CLENBQUMsSUFBWTtRQUMvQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELHFCQUFxQjtRQUNuQixPQUFPLENBQUMsR0FBRyxJQUFJ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