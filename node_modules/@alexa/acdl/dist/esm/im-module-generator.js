import * as ask from "./ast";
import { AlexaConversations, AlexaSchema } from "./ast";
import { GeneratedInteractionModelModule, Namespaces } from "./constants";
import { sourceFile } from "./source-file";
import { isAmazonBuiltin, isNotUndefined, readJsonFile, readJsonFileSync } from "./util";
import { ValidationErrorFactory } from "./error-factory";
/**
 * Generates interaction model ASKIR modules from a projects interaction model files.
 */
export class InteractionModelModuleGenerator {
    constructor(dir, interactionModelFiles) {
        /**
         * Directory that is used when specifying the generated module source files uri.
         */
        Object.defineProperty(this, "dir", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Interaction model file absolute file paths.
         */
        Object.defineProperty(this, "interactionModelFiles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Map from locale to the parsed interaction model content.
         */
        Object.defineProperty(this, "interactionModels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dir = dir;
        this.interactionModelFiles = interactionModelFiles;
    }
    /**
     * Loads the interaction models asyncly.
     */
    loadInteractionModelsSync() {
        if (this.interactionModels === undefined) {
            const map = {};
            for (const interactionModelFile of this.interactionModelFiles) {
                const im = readJsonFileSync(interactionModelFile.file);
                if (im !== undefined) {
                    map[interactionModelFile.locale] = im;
                }
            }
            this.interactionModels = map;
        }
    }
    /**
     * Loads the interaction models syncly.
     */
    async loadInteractionModels() {
        if (this.interactionModels === undefined) {
            const map = {};
            for (const interactionModelFile of this.interactionModelFiles) {
                const im = await readJsonFile(interactionModelFile.file);
                if (im !== undefined) {
                    map[interactionModelFile.locale] = im;
                }
            }
            this.interactionModels = map;
        }
    }
    /**
     * Generates ASKIR Modules that will be compiled and built with a projects source modules.
     *
     * @returns Generated interaction model modules
     */
    async generateInteractionModelModules() {
        if (this.interactionModelFiles.length === 0) {
            return [];
        }
        await this.loadInteractionModels();
        return [...this.generateCatalogModules(), ...this.generateIntentModules()];
    }
    /**
     * Generates ASKIR Modules that will be compiled and built with a projects source modules.
     *
     * @returns Generated interaction model modules
     */
    generateInteractionModelModulesSync() {
        if (this.interactionModelFiles.length === 0) {
            return [];
        }
        this.loadInteractionModelsSync();
        return [...this.generateCatalogModules(), ...this.generateIntentModules()];
    }
    /**
     * Generates the following modules:
     *
     * - `ask.interactionModel.catalogs.{locale}`
     * - `ask.interactionModel.catalogs`
     * - `ask.interactionModel.slotTypes`
     *
     * This function creates a module for each interaction model locale, and will store a variation
     * map that stores a catalog name as the key and locales as the values. The variation map is used
     * to generate the root catalogs module, and is also used for generating the slotTypes module.
     *
     * @returns Generated interaction model catalog and slotTypes modules
     */
    generateCatalogModules() {
        // Map of catalog name to locales. We will use this to create the variations.
        const variations = {};
        const catalogIntentModules = Object.entries(this.interactionModels)
            .map(([locale, im]) => {
            var _a, _b;
            if (((_b = (_a = im === null || im === void 0 ? void 0 : im.interactionModel) === null || _a === void 0 ? void 0 : _a.languageModel) === null || _b === void 0 ? void 0 : _b.types) === undefined) {
                return undefined;
            }
            const namespaceLocale = locale.replace("-", "");
            const namespace = `${Namespaces.catalogs}.${namespaceLocale}`;
            const expressions = im.interactionModel.languageModel.types
                .map((catalog) => {
                if (isAmazonBuiltin(catalog.name)) {
                    return undefined;
                }
                const { name } = catalog;
                const listBastedCatalog = this.generateListBasedCatalog(catalog);
                if (variations[name] === undefined) {
                    variations[name] = [];
                }
                variations[name].push(namespaceLocale);
                return new ask.NameDeclaration(new ask.Name(`${namespace}.${name}`), undefined, listBastedCatalog, [
                    this.generateGeneratedAnnotation("interactionModel"),
                    this.generateLocaleAnnotation(locale.replace("-", "_")),
                ]);
            })
                .filter(isNotUndefined);
            return this.interactionModelSourceModule(`catalog-${namespaceLocale}`, namespace, expressions);
        })
            .filter(isNotUndefined);
        // Now we generate the catalogs and slotTypes modules with the variations.
        return [...catalogIntentModules, this.generateCatalogVariationModules(variations), this.generateSlotTypesModule(variations)];
    }
    /**
     * Generates the `ask.interactionModel.catalogs` module.
     *
     * This module will contain all of the variations of each interaction model catalogs.
     *
     * @param catalogMap map of catalog names to locales it's defined in (MyPlanetSlot -> [enUS, deDE])
     * @returns Generated catalog variation ASKIR module
     */
    generateCatalogVariationModules(catalogMap) {
        return this.generateVariationModule("catalogs", catalogMap, Namespaces.catalogs);
    }
    /**
     * Generates the `ask.interactionModel.slotTypes` module.
     *
     * This module will contain all of the type declarations of the interaction model slot types.
     *
     * @param catalogMap map of catalog names to locales it's defined in (MyPlanetSlot -> [enUS, deDE])
     * @returns Generated slotTypes ASKIR module
     */
    generateSlotTypesModule(catalogMap) {
        const namespace = Namespaces.slotTypes;
        const expressions = Object.keys(catalogMap)
            .map((name) => {
            if (isAmazonBuiltin(name)) {
                return undefined;
            }
            return new ask.TypeDeclaration(new ask.Name(`${namespace}.${name}`), undefined, undefined, [new ask.TypeReference(new ask.Name(AlexaSchema.String))], [this.generateGeneratedAnnotation("interactionModel"), this.generateCatalogAnnotation(`${Namespaces.catalogs}.${name}`)]);
        })
            .filter(isNotUndefined);
        return this.interactionModelSourceModule("slotTypes", namespace, expressions);
    }
    /**
     *
     * Generates the following modules:
     *
     * - `ask.interactionModel.intentTypes`
     * - `ask.interactionModel.intents.{locale}`
     * - `ask.interactionModel.intents`
     *
     * This function creates a module for each interaction model locale, and will store a variation
     * map that stores an intent name as the key and locales as the values. The variation map is used
     * to generate the root intents module.
     *
     * The function first gets the `intentType` module which will also return a set of strings containing
     * the intent names that are identically defined in every interaction model. The function uses the set to generate
     * intents ONLY IF the intent type is defined.
     *
     * @returns The generated ASKIR intent modules.
     */
    generateIntentModules() {
        const variations = {};
        const { validIntents, intentTypeModule } = this.generateIntentTypeModule();
        const intentLocaleModules = Object.entries(this.interactionModels).map(([locale, im]) => {
            var _a, _b, _c, _d;
            const namespaceLocale = locale.replace("-", "");
            const namespace = `${Namespaces.intents}.${namespaceLocale}`;
            const errors = [];
            const expressions = ((_d = (_c = (_b = (_a = im === null || im === void 0 ? void 0 : im.interactionModel) === null || _a === void 0 ? void 0 : _a.languageModel) === null || _b === void 0 ? void 0 : _b.intents) === null || _c === void 0 ? void 0 : _c.map((intent) => {
                var _a, _b, _c;
                if (!validIntents.has(intent.name) || !((_a = intent.samples) === null || _a === void 0 ? void 0 : _a.length) || isAmazonBuiltin(intent.name)) {
                    return undefined;
                }
                // Generate the samples for the intent action
                const samples = new ask.Call(new ask.Name(AlexaSchema.List), new ask.ListLiteral((_c = (_b = intent.samples) === null || _b === void 0 ? void 0 : _b.map((sample, idx) => new ask.ListItem(new ask.Call(new ask.Name(AlexaConversations.Utterance), sample, [
                    new ask.TypeReference(new ask.Name(`${Namespaces.intentTypes}.${intent.name}`)),
                ]), idx))) !== null && _c !== void 0 ? _c : []), [
                    new ask.TypeReference(new ask.Name(AlexaConversations.Utterance), [
                        new ask.TypeReference(new ask.Name(`${Namespaces.intentTypes}.${intent.name}`)),
                    ]),
                ]);
                // Generate the name declaration that will be a call to intent<T>(samples)
                const intentDeclaration = new ask.NameDeclaration(new ask.Name(`${namespace}.${intent.name}`), undefined, new ask.Call(new ask.Name(AlexaConversations.intent), [new ask.Argument(new ask.Name("samples"), 0, samples)], [new ask.TypeReference(new ask.Name(`${Namespaces.intentTypes}.${intent.name}`))]), [this.generateGeneratedAnnotation("interactionModel"), this.generateLocaleAnnotation(locale.replace("-", "_"))]);
                if (variations[intent.name] === undefined) {
                    variations[intent.name] = [];
                }
                variations[intent.name].push(namespaceLocale);
                return intentDeclaration;
            })) !== null && _d !== void 0 ? _d : []).filter((x) => x !== undefined);
            return this.interactionModelSourceModule(`intents-${namespaceLocale}`, namespace, expressions, errors);
        });
        const res = [...intentLocaleModules, intentTypeModule, this.generateIntentVariationModule(variations)];
        return res;
    }
    /**
     *
     * Generates the `ask.interactionModel.intentTypes` module.
     *
     * This module will contain the type declarations for intent types that exist in all
     * interaction models.
     *
     * This function finds the intents that are defined in all models and validates that they
     * have the same structure. If an intent has the same name in another model but has a different
     * structure, it will emit a parse error warning and skip the generation for that intent.
     *
     * Currently this function is three steps:
     *
     * 1. Go through interaction models and gather all intents
     * 2. Validate the remaining intents have the same structure
     * 3. Generate the ASKIR intent type declarations
     *
     *
     * Returns the source module for intentTypes and all of the valid intents. We need to skip
     * intents that don't have a valid intent type.
     *
     * @returns A set of all valid intents and the generated ASKIR intentType module
     */
    generateIntentTypeModule() {
        var _a, _b, _c, _d;
        // Intents that are valid i.e if defined in multiple locales, they have the same structure
        const validIntents = new Set();
        // Map from an intent name to each model's actual intent
        const nameToIntents = new Map();
        // Warnings to emit if intents have different structures in different models
        const errors = [];
        // 1. Gather all intents
        const ims = Object.values(this.interactionModels);
        ims.forEach((im) => {
            var _a, _b, _c;
            (_c = (_b = (_a = im === null || im === void 0 ? void 0 : im.interactionModel) === null || _a === void 0 ? void 0 : _a.languageModel) === null || _b === void 0 ? void 0 : _b.intents) === null || _c === void 0 ? void 0 : _c.forEach((intent) => {
                if (isAmazonBuiltin(intent.name)) {
                    return;
                }
                validIntents.add(intent.name);
                if (nameToIntents.has(intent.name)) {
                    nameToIntents.get(intent.name).push(intent);
                }
                else {
                    nameToIntents.set(intent.name, [intent]);
                }
            });
        });
        // 2. Validate the remaining intents have the same structure
        for (const intentName of nameToIntents.keys()) {
            // The base intent we'll validate against
            const baseIntent = nameToIntents.get(intentName)[0];
            let intentValid = true;
            for (const intentToCheck of nameToIntents.get(intentName)) {
                if (((_a = baseIntent.slots) === null || _a === void 0 ? void 0 : _a.length) !== ((_b = intentToCheck.slots) === null || _b === void 0 ? void 0 : _b.length)) {
                    intentValid = false;
                    break;
                }
                // Validate the slots match
                for (const slotToCheck of (_c = intentToCheck.slots) !== null && _c !== void 0 ? _c : []) {
                    let slotMatch = false;
                    // Looping through incase the slot type is defined in a different position but has same structure
                    for (const slot of (_d = baseIntent.slots) !== null && _d !== void 0 ? _d : []) {
                        if (slot.name === slotToCheck.name && slot.type === slotToCheck.type) {
                            slotMatch = true;
                            break;
                        }
                    }
                    // No matching slot was found, mark intent as invalid
                    if (!slotMatch) {
                        intentValid = false;
                        break;
                    }
                }
            }
            if (!intentValid) {
                // Skip generation of this intent
                errors.push(ValidationErrorFactory.NonMatchingInteractionModelIntents({
                    attributes: {
                        intentName,
                    },
                }));
                validIntents.delete(intentName);
            }
        }
        // 3. Generate the ASKIR type declarations, we need to check if it's a builtin type or a custom type
        const namespace = Namespaces.intentTypes;
        const expressions = Array.from(validIntents).map((intentName) => {
            var _a;
            const intent = nameToIntents.get(intentName)[0];
            // The properties on the generated intent type
            const typeProperties = (_a = intent.slots) === null || _a === void 0 ? void 0 : _a.map((slot) => {
                var _a;
                const type = slot.type ? this.generateSlotTypeReference(slot.type, (_a = slot.multipleValues) === null || _a === void 0 ? void 0 : _a.enabled) : undefined;
                return new ask.TypeProperty(new ask.Name(slot.name), type, true);
            });
            return new ask.TypeDeclaration(new ask.Name(`${namespace}.${intentName}`), typeProperties, undefined, undefined, [
                this.generateGeneratedAnnotation("interactionModel"),
            ]);
        });
        return {
            validIntents: validIntents,
            intentTypeModule: this.interactionModelSourceModule(`intentTypes`, namespace, expressions, errors),
        };
    }
    /**
     *
     * Generates the `ask.interactionModel.intents` module.
     *
     * This module will contain the variations for all intents defined in the interaction model.
     *
     * @param intentMap map of intent name to locales (enUS) using the intent
     * @returns the generated ASKIR intents variation module
     */
    generateIntentVariationModule(intentMap) {
        return this.generateVariationModule("intents", intentMap, Namespaces.intents);
    }
    /**
     * Takes in a object mapping from name declaration to locales and generates
     * a module with variations for each name declaration in the given namespace.
     *
     * It searches namespace.{locale} to get the name reference.
     *
     * @param uri the uri of the source file and ask.Module.
     * @param variations map from name declaration string to locales (enUS, frFR, ...)
     * @param namespace the namespace of the module.
     * @returns a generated ASKIR module with variation calls for each locale name declaration.
     */
    generateVariationModule(uri, variations, namespace) {
        const localeImports = new Set();
        const expressions = Object.entries(variations).map(([name, locales]) => {
            return new ask.NameDeclaration(new ask.Name(`${namespace}.${name}`), undefined, new ask.Call(new ask.Name(AlexaConversations.variations), [
                new ask.Argument(new ask.Name("variations"), 0, new ask.Call(new ask.Name(AlexaConversations.Args), new ask.ListLiteral(locales.map((locale, idx) => {
                    localeImports.add(locale);
                    return new ask.ListItem(new ask.NameReference(new ask.Name(`${namespace}.${locale}.${name}`)), idx);
                })))),
            ], undefined, [this.generateGeneratedAnnotation("interactionModel")]));
        });
        return this.interactionModelSourceModule(uri, namespace, expressions);
    }
    /**
     * Generates a `@generated` annotation with a given name.
     */
    generateGeneratedAnnotation(generatorName) {
        return new ask.Annotation(new ask.Call(new ask.Name(AlexaConversations.generated), [
            new ask.Argument(new ask.Name("generatorName"), 0, new ask.Call(new ask.Name(AlexaSchema.String), generatorName)),
        ]));
    }
    /**
     * Generates a `@catalog` annotation that references the given name.
     */
    generateCatalogAnnotation(nameReference) {
        return new ask.Annotation(new ask.Call(new ask.Name(AlexaConversations.catalog), [
            new ask.Argument(new ask.Name("catalog"), 0, new ask.NameReference(new ask.Name(nameReference))),
        ]));
    }
    /**
     * Generates the ask.Locale annotation for the given locale.
     *
     * @param locale - The locale to generate the annotation for. In the form of `en_US`, `fr_FR`.
     * @returns The ask.Annotation for the given locale.
     */
    generateLocaleAnnotation(locale) {
        return new ask.Annotation(new ask.Call(new ask.Name(AlexaConversations.locale), [
            new ask.Argument(new ask.Name("locales"), 0, new ask.Call(new ask.Name(AlexaConversations.Args), new ask.ListLiteral([
                new ask.ListItem(new ask.PropertyReference(new ask.Name(locale), new ask.NameReference(new ask.Name("Locale"))), 0),
            ]), 
            // TODO: Check this generic works
            [new ask.TypeReference(new ask.Name(AlexaConversations.Locale))])),
        ]));
    }
    /**
     * Generates the ASKIR `ListBasedCatalog<T>` from an interaction model slot type.
     *
     * @param catalog the slot type to use for generating the listBasedCatalog
     * @returns The ask.Call to the listBasedCatalog<T> action
     */
    generateListBasedCatalog(catalog) {
        var _a, _b;
        // Generated list of 'CatalogItem<T> {...}'
        const catalogItems = new ask.ListLiteral((_b = (_a = catalog.values) === null || _a === void 0 ? void 0 : _a.map((value, idx) => {
            var _a, _b, _c;
            return new ask.ListItem(new ask.Call(new ask.Name(AlexaConversations.CatalogItem), [
                new ask.Argument(new ask.Name("value"), undefined, new ask.Call(new ask.Name(AlexaSchema.String), value.name.value)),
                new ask.Argument(new ask.Name("synonyms"), undefined, new ask.Call(new ask.Name(AlexaSchema.List), new ask.ListLiteral((_c = (_b = (_a = value.name) === null || _a === void 0 ? void 0 : _a.synonyms) === null || _b === void 0 ? void 0 : _b.map((synonym, idx) => new ask.ListItem(new ask.Call(new ask.Name(AlexaSchema.String), synonym), idx))) !== null && _c !== void 0 ? _c : []), [new ask.TypeReference(new ask.Name(AlexaSchema.String))])),
            ], [this.generateSlotTypeReference(catalog.name)]), idx);
        })) !== null && _b !== void 0 ? _b : []);
        // Generate the call to 'listBasedCatalog'
        return new ask.Call(new ask.Name(AlexaConversations.listBasedCatalog), [
            new ask.Argument(new ask.Name("items"), undefined, new ask.Call(new ask.Name(AlexaConversations.Args), catalogItems, [
                new ask.TypeReference(new ask.Name(AlexaConversations.CatalogItem), [this.generateSlotTypeReference(catalog.name)]),
            ])),
        ], undefined, [this.generateGeneratedAnnotation("interactionModel")]);
    }
    /**
     * Generates a SourceFile<ask.Module> for generated interaction model modules.
     *
     * The exports will be generated from the given expressions.
     *
     * Module uri will be in the form of `dir/generated-im-{uriSuffix}`.
     *
     * @param uriSuffix the suffix to append to the generated module uri.
     * @param namespace the namespace to give the module.
     * @param expressions the module expressions.
     * @param errors any parse errors to include in the module that will be reported during validations.
     * @return A SourceFile<ask.Module> for the generated interaction model module.
     */
    interactionModelSourceModule(uriSuffix, namespace, expressions, errors) {
        const uri = `${this.dir}/${GeneratedInteractionModelModule.uriPrefix}-${uriSuffix}.acdl`;
        const exports = getExports();
        const module = new ask.Module(uri, "https://amazonalexa.com/ask/2020/12/Module", new ask.Name(`${namespace}`), [
            new ask.Import("ImportNamespace", "com.amazon.alexa.ask.conversations"),
            new ask.Import("ImportNamespace", "com.amazon.alexa.schema"),
        ], exports, expressions);
        return sourceFile(this.dir, uri, module, errors);
        function getExports() {
            return expressions === null || expressions === void 0 ? void 0 : expressions.map((e) => { var _a; return (e.kind === "NameDeclaration" || e.kind === "TypeDeclaration" ? (_a = e.name) === null || _a === void 0 ? void 0 : _a.name : undefined); }).filter((x) => x !== undefined);
        }
    }
    /**
     * Generates a TypeReference to the ask.interactionModels.slotTypes or
     * com.amazon.ask.types.builtins.AMAZON namespace.
     *
     * @param name - Name of the slot type
     * @param multipleValues - Whether this slot has multiple values enabled
     */
    generateSlotTypeReference(name, multipleValues) {
        // Type reference to the slot type or builtin type
        let typeReference = isAmazonBuiltin(name)
            ? new ask.TypeReference(new ask.Name(`${Namespaces.builtinTypes}.${name.substring(7)}`))
            : new ask.TypeReference(new ask.Name(`${Namespaces.slotTypes}.${name}`));
        if (multipleValues) {
            // If multiple values are allowed, then we should return a list
            return new ask.TypeReference(new ask.Name(AlexaSchema.List), [typeReference]);
        }
        return typeReference;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW0tbW9kdWxlLWdlbmVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbS1tb2R1bGUtZ2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDO0FBRTdCLE9BQU8sRUFBQyxrQkFBa0IsRUFBRSxXQUFXLEVBQW9CLE1BQU0sT0FBTyxDQUFDO0FBQ3pFLE9BQU8sRUFBQywrQkFBK0IsRUFBRSxVQUFVLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFHeEUsT0FBTyxFQUFDLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUVyRCxPQUFPLEVBQUMsZUFBZSxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDdkYsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFdkQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sK0JBQStCO0lBYzFDLFlBQVksR0FBVyxFQUFFLHFCQUE2QztRQWJ0RTs7V0FFRztRQUNIOzs7OztXQUE2QjtRQUM3Qjs7V0FFRztRQUNIOzs7OztXQUErRDtRQUMvRDs7V0FFRztRQUNIOzs7OztXQUE0RDtRQUcxRCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxxQkFBcUIsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7O09BRUc7SUFDSyx5QkFBeUI7UUFDL0IsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEtBQUssU0FBUyxFQUFFO1lBQ3hDLE1BQU0sR0FBRyxHQUFxQyxFQUFFLENBQUM7WUFDakQsS0FBSyxNQUFNLG9CQUFvQixJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtnQkFDN0QsTUFBTSxFQUFFLEdBQUcsZ0JBQWdCLENBQW1CLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN6RSxJQUFJLEVBQUUsS0FBSyxTQUFTLEVB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