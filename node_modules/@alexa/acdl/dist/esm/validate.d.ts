import * as ask from "./ast";
import { ParseError } from "./error";
import { Project } from "./project";
import { TypeChecker } from "./checker";
import { Type } from "./type";
import { Property } from "./property";
import { Apply } from "./apply";
import { ListItem } from "./ast";
import { Expression } from "./expression";
export type Validator<T> = (expr: T, checker: TypeChecker) => ParseError[];
/**
 * Validate the entire project for correctness and return and errors.
 *
 * @param project project to validate.
 * @param isSkill whether the project is a skill
 * @param skipSemanticValidations skip semantic validations
 * @returns array of all errors if detected.
 */
export declare function validateProject(project: Project, isSkill?: boolean, skipSemanticValidations?: boolean): ParseError[];
/**
 * Validate all expressions in a module in the context of a Project.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
export declare const validateModule: Validator<ask.Module>;
export declare const validateBlock: Validator<ask.Block | ask.Module>;
export declare const validateNamespace: Validator<ask.Module>;
/**
 * Validate the imports in a module.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
export declare const validateImports: Validator<ask.Module>;
export declare const validateCircularReferences: Validator<ask.DialogDeclaration | ask.TypeDeclaration | ask.TypeReference | ask.NameDeclaration>;
/**
 * Validates all annotations on a node.
 */
export declare const validateAnnotations: Validator<ask.AnnotatedNode>;
/**
 * Validates annotations on name declarations.
 *
 * There are two cases:
 *
 * 1. When the value is a `NameReference`, we should not allow any annotations.
 * 2. When the value is a `variations` call, we should not allow `locale` annotations.
 */
export declare const validateNameDeclarationAnnotations: Validator<ask.Node | undefined>;
/**
 * Validates annotations on type declarations, and the properties of the type.
 *
 * There is one case:
 *
 * 1. We should not allow `referable` annotation on type properties that aren't catalogs.
 */
export declare const validateTypeDeclarationAnnotations: Validator<ask.Node | undefined>;
/**
 * Validates annotations on dialog declarations.
 *
 * There are two cases:
 *
 * 1. When dialog is reusable, we should not allow the dialog to have a `locale` annotation.
 * 2. When dialog is reusable, we should not allow the dialog samples to have a `locale` annotation.
 */
export declare const validateDialogDeclarationAnnotations: Validator<ask.Node | undefined>;
/**
 * Validate an Annotation's Call data structure:
 *
 * 1. the annotation type must also be annotated with the meta-annotation `@com.amazon.alexa.ask.conversations.Annotation`.
 * 2. the list of supported targets for the annotation must include the target this annotation is being applied to,
 */
export declare const validateAnnotation: Validator<ask.Annotation>;
export declare const validateExpression: Validator<ask.Node | undefined>;
export declare const validateDialogDeclaration: Validator<ask.DialogDeclaration>;
export declare const validateSample: Validator<ask.Sample>;
export declare const validateDuplicateNames: Validator<ask.Block | ask.Module>;
/**
 * Validates a name expression.
 *
 * @param checker
 * @param name
 */
export declare const validateNameDeclaration: Validator<ask.NameDeclaration>;
export declare const validateNameReference: Validator<ask.NameReference | ask.Call>;
export declare const validateName: Validator<ask.NameReference | ask.Call | ask.TypeReference>;
export declare const validateActionDeclaration: Validator<ask.ActionDeclaration>;
/**
 * Validates that an ActionDeclaration that is annotated with the `@annotation` meta-annotation has a return type of void.
 */
export declare const validateAnnotatedActionDeclaration: Validator<ask.ActionDeclaration>;
export declare function validateArgumentDeclarations(args: ask.ArgumentDeclaration[], checker: TypeChecker, isDialogArgument: boolean): ParseError[];
export declare function validateArgumentDeclaration(arg: ask.ArgumentDeclaration, checker: TypeChecker, isDialogArgument?: boolean): ParseError[];
/**
 * Validate that an EnumDeclaration has at least one item and no duplicate items.
 *
 * ```acdl
 * enum E {} // invalid
 * enum E { // invalid
 *   A
 *   A
 * }
 * enum E { // valid
 *   A
 *   B
 * }
 * ```
 */
export declare const validateEnumDeclaration: Validator<ask.EnumDeclaration>;
export declare const validateTypeDeclaration: Validator<ask.TypeDeclaration>;
/**
 * validate the properties in typeDecl are not duplicate
 */
export declare const validateTypeDeclarationProperties: Validator<ask.TypeDeclaration>;
export declare const validateTypeParameters: Validator<ask.TypeParameter[] | undefined>;
export declare const validateTypeParameter: Validator<ask.TypeParameter>;
export declare const validateTypeReferences: Validator<(ask.TypeReference | undefined)[] | undefined>;
export declare const validateTypeReference: Validator<ask.TypeReference | undefined>;
/**
 * Validate an `alexa.lang.property` call to access a property on a type.
 *
 * @param ref call expression representing the access of a property on another expression
 */
export declare const validatePropertyReference: Validator<ask.PropertyReference>;
export declare const validateUtteranceTypeWrapper: Validator<Apply>;
/**
 * Validate a Call to a Type or an Action:
 *
 * - Resolve its declaration and throw errors if it cannot be found.
 * - Infer generic arguments if they aren't provided and flag errors if that cannot be achieved.
 * - Validate that all required arguments are provided and that types of arguments match declaration.
 */
export declare const validateCall: (call: ask.Call, checker: TypeChecker) => ParseError<import("./error-factory").Error, string>[];
/**
 * Validate utterance string to check if it contains empty curly braces
 */
export declare function validateUtteranceString(item: ListItem): ParseError[];
/**
 * validate the variations call
 * 1. The argument value can't use duplicate locale info
 * 2. SkillLevelResponses can't be used as an argument of variations call
 * 3. prompts.abc can't be used as an argument of variations call
 *
 * Invalid case example:
 * 1. duplicate locales
 * ```
 *  @locale(Locale.en_US)
 *  promptUS = utterances<Person>([
 *     "hi I am American my name is {name}",
 *     "hi I am American my name is {name} and i am {age} years old"
 *  ])
 *
 *  @locale(Locale.en_US, Locale.en_GB)
 *  promptGB = utterances<Person>([
 *    "hi I am British my name is {name}",
 *    "hi I am British my name is {name} and i am {age} years old"
 *  ])
 *  u = variations(promptUS, promptGB)
 * ```
 *
 * 2. SkillLevelResponses used as argument
 * ```
 * skillLevelResponsesEN = SkillLevelResponses { ... }
 * skillLevelResponsesGB = SkillLevelResponses { ... }
 *
 * skillLevelResponses = variations(skillLevelResponsesEN, skillLevelResponsesGB)
 * ```
 *
 * 3. prompts used as argument
 * ```
 * skillLevelResponses = variations(prompts.AlexaConversationsWelcome, prompts.AlexaConversationsOutOfDomain)
 * ```
 */
export declare const validateVariations: Validator<ask.Call>;
/**
 * Validate that a call to a User Defined API or Dialog is not contained within another call.
 *
 * Validate that this Call is allowed in this Context.
 *
 * @param call
 * @param checker
 * @returns
 */
export declare const validateCallContext: Validator<ask.Call>;
/**
 * Validates that a `validateArg` annotation matches the following rules:
 * 1. action must have at least one argument
 * 2. condition must reference at least one of those arguments in its boolean expression
 * 3. at least one argument must be referenced
 * 4. that argument must be from the same action that this validateArg annotation is attached to.
 *
 * @param apply Apply instance for the validateArg annotation call.
 * @param checker static TypeChecker instance
 * @returns validation errors
 * @see https://github.com/alexa/ask-ac/issues/690
 */
export declare const validateValidateArgAnnotation: Validator<Apply>;
/**
 * Validate a call to `require` - an internal action to reference a file from disk.
 */
export declare const validateRequireCall: Validator<Apply>;
/**
 * Validate the arguments passed to a Call against the target declaration.
 *
 * - Finds missing required arguments.
 * - Detect unknown arguments, whether by name or position. Account for var-args.
 * - Detect when positional arguments are used after named ones.
 * - Check that the types of arguments.
 *
 * @param apply
 * @param checker
 * @param checkType should we type check? default true
 */
export declare const validateNamedArguments: (apply: Apply, checker: TypeChecker, checkType?: boolean) => ParseError[];
export declare function validateBinaryOperator(apply: Apply): ParseError[];
/**
 * Validates the utterance in expr
 * @param expr expression containing the utterance to validate
 * @param utteranceType type for utterance
 * @param getPropertyMap memoized type's getPropertyMap
 * @returns
 */
export declare const validateUtterance: (expr: ask.Expression, utteranceType: Type | undefined, getPropertyMap: (type: Type) => Map<string, Property>) => ParseError[];
export declare const validateCondition: Validator<ask.Condition>;
/**
 * Validate that a Condition Block has expressions.
 */
export declare const validateConditionBlock: Validator<ask.ConditionScope>;
/**
 * Validate EnsureOrder action call
 * 1. All the args in the list should from same api
 * 2. All the args in the list should be required args
 *
 * Related Github feature request:
 * https://github.com/alexa/ask-ac/issues/553
 */
export declare const validateEnsureArgOrder: Validator<Apply>;
/**
 * Validates that calls to catalog actions like `extendCatalog` or `builtInCatalog` are only allowed
 * at the module scope and not within a dialog sample.
 */
export declare const validateCatalogCallContext: Validator<Apply>;
/**
 * Validates the argument provided to builtinCatalog is a valid built in type and
 * the type parameter is of type String.
 */
export declare const validateBuiltinCatalogAction: Validator<Apply>;
export declare const validateInteractionDeclaration: Validator<ask.InteractionDeclaration>;
export declare const validateCorrection: Validator<ask.Correction>;
/**
 * Validates that the call to getAllNames.
 *
 * 1. Verify the namespaces provided exist.
 */
export declare const validateGetAllNamesAction: Validator<Apply>;
//# sourceMappingURL=validate.d.ts.map