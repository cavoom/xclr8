import * as ask from "./ast";
import { Apply } from "./apply";
import { Property } from "./property";
import { TypeChecker } from "./checker";
import { Environment } from "./environment";
import { Thing } from "./thing";
import { Token } from "./token";
export declare function isType(obj: any): obj is Type;
/**
 * A Type represents an instantiated Type in some context.
 *
 * Any `genericArguments` are either explicitly substituted or inferred from the surrounding context.
 *
 * This class provides a lazily-evaluated API for querying properties of the type.
 */
export declare class Type {
    #private;
    readonly checker: TypeChecker;
    /**
     * Declaration of the instantiated type.
     */
    readonly declaration?: ask.ActionDeclaration | ask.DialogDeclaration | ask.EnumDeclaration | ask.TypeDeclaration | ask.EnumItem | ask.TypeParameter | ask.TypeReference | ask.SlotType | undefined;
    /**
     * Instantiated type arguments.
     */
    readonly genericArguments?: (Type | undefined)[] | undefined;
    /**
     * Source node of this Type.
     */
    readonly functionArgumentNames?: string[] | undefined;
    /**
     * Name of the function (if this is an abstract function signature)
     */
    readonly functionName?: string | undefined;
    readonly kind: "Type";
    constructor(checker: TypeChecker, 
    /**
     * Declaration of the instantiated type.
     */
    declaration?: ask.ActionDeclaration | ask.DialogDeclaration | ask.EnumDeclaration | ask.TypeDeclaration | ask.EnumItem | ask.TypeParameter | ask.TypeReference | ask.SlotType | undefined, 
    /**
     * Instantiated type arguments.
     */
    genericArguments?: (Type | undefined)[] | undefined, 
    /**
     * Source node of this Type.
     */
    functionArgumentNames?: string[] | undefined, 
    /**
     * Name of the function (if this is an abstract function signature)
     */
    functionName?: string | undefined);
    /**
     * String representation of this Type.
     */
    toString(context?: ask.Node | undefined): string;
    toTypeReference(context?: ask.TypeReference["context"]): ask.TypeReference;
    get shortName(): string | undefined;
    /**
     * Name of this Type.
     */
    get name(): ask.Name | undefined;
    get namespace(): string | undefined;
    /**
     * The type environment of this Type.
     *
     * Maps type aliases for Type Parameters to instantiated Types.
     */
    get environment(): Environment | undefined;
    /**
     * Ordered list of this Type's base types (the types it "extends").
     */
    get extensions(): Type[] | undefined;
    private resolveExtensions;
    /**
     * Ordered list of all Properties in this Type.
     *
     * @returns list of properties if any, `null` otherwise.
     */
    get properties(): Property[] | undefined;
    /**
     * Index of all Properties by name.
     */
    get propertiesIndex(): Record<string, Property> | undefined;
    /**
     * Apply a Call to this Type.
     *
     *
     * @param call expression of input to the Action.
     */
    apply(call: ask.Call, checker?: TypeChecker): Apply | undefined;
    /**
     * Instantiate a new Thing of this Type.
     *
     * @param node AST node this Thing value originates from.
     * @returns a Thing instance representing this distinct Thing
     */
    getThing(token: Token, origin: ask.Node | undefined, parent?: Thing, apply?: Apply): Thing;
    /**
     * Get the type of a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getPropertyType(argument: string | number | ask.Argument): Type | undefined;
    /**
     * Get a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getProperty(argument?: string | number | ask.Argument): Property | undefined;
    /**
     * Get the Nodes referenced by this Type.
     */
    getReferences(): Set<ask.Node>;
    /**
     * Scan this type for any type arguments or super-types that consist of TypeParameters.
     */
    hasTypeParameters(): boolean;
    /**
     * A type has a catalog if it is:
     * - a built-in slot type
     * - a custom slot type found in the interaction model
     * - has an association with a catalog using `@catalog` annotation
     */
    hasCatalog(): boolean;
    private hasCatalogAnnotation;
    /**
     * A custom type is one that is not defined in:
     * 1. com.amazon.alexa.schema
     * 2. com.amazon.alexa.ask.conversations
     * 3. com.amazon.ask.types.builtins.AMAZON
     *
     * TODO: validate that users can't use these namespaces: https://github.com/alexa/ask-ac/issues/3
     */
    isCustom(): boolean;
    /**
     * Checks if this is a built in type provided by the platform.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     *
     * TODO: should we also consider Alexa Schema as built-in?
     */
    isBuiltIn(): boolean;
    /**
     * @returns true if the type can be used as the result type of an utterance
     */
    isValidForUtterance(): boolean;
    /**
     * Checks if this is a valid UtteranceEvent wrapper type
     */
    isValidUtteranceWrapper(): boolean;
    /**
     * Checks if this type is defined in an interaction model.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     */
    isSlotType(): boolean;
    /**
     * Checks if this type is defined in the AC core library.
     *
     * Namespace:
     * `com.amazon.alexa.ask.conversations`
     */
    isCoreType(): boolean;
    /**
     * Checks if this type is defined in Alexa Schema.
     *
     * Namespace:
     * `com.amazon.alexa.schema`
     */
    isAlexaSchema(): boolean;
    /**
     * Check if this type is the top-level Skill type.
     */
    isSkill(): boolean;
    /**
     * Check if this type is the SkillLevelResponses type.
     */
    isSkillLevelResponses(): boolean;
    /**
     * Check if this type is the InvocationName type.
     */
    isInvocationName(): boolean;
    /**
     * A complex type is one with at least one property.
     */
    isObject(): this is {
        properties: Property[];
    };
    /**
     * Check if a name is (inclusively) found in this type's hierarchy.
     *
     * @param name name of type to find
     */
    isNameInHierarchy(name?: string): boolean;
    /**
     * Find a type by name in this type's hierarchy.
     *
     * E.g.
     * ```
     * looking for UtteranceEvent<T>
     *
     * // type is the one we're looking for
     * UtteranceEvent<T> => UtteranceEvent<T>
     *
     * // search the type's hierarchy.
     * type A : UtteranceEvent<String> => UtteranceEvent<String>
     *
     * // type does not exist
     * type B => undefined
     * ```
     *
     *
     * @param name name of the type to find
     */
    findNameInHierarchy(name?: string | ((name: string) => boolean)): Type | undefined;
    /**
     * Check if this is the intrinsic `Properties<T>` type that computes the properties of some type, `T`.
     */
    isProperties(): boolean;
    /**
     * Check if this is the intrinsic `Property<T>`.
     */
    isProperty(): boolean;
    /**
     * If this is a type `Property<T>`, return the inner type, `T`.
     */
    getPropertyTypeType(): Type | undefined;
    /**
     * Check if this is the `Type<T>` type.
     *
     * ```
     * type Person {
     *   String name
     * }
     *
     * // Type<Person>
     * person = Person
     * ```
     */
    isType(): boolean;
    /**
     * Get the type of the `Type<T>` type - in this case, `T`.
     *
     * ```
     * Type<Person> => Person
     * ```
     */
    getTypeType(): Type | undefined;
    /**
     * Is the `ReturnValue<T>` intrinsic type.
     */
    isReturnValue(): boolean;
    /**
     * Get the type parameter of the `ReturnValue<T>`.
     */
    getReturnValueType(): Type | undefined;
    /**
     * Is this Type `alexa.schema.Nothing` (the Bottom Type)?
     */
    isNothing(): boolean;
    /**
     * Is this Type `alexa.schema.Thing` (the Bottom Type)?
     */
    isThing(): boolean;
    /**
     * Is this type `Nothing`, `Void`, `Boolean`, `Number`, `String`, `Date` or `Time`.
     */
    isPrimitive(): boolean;
    /**
     * Is this type one of 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'.
     */
    isResponseAct(): boolean;
    /**
     * Is this the Void type, `com.amazon.alexa.schema.Void`?
     *
     * @version 1.0.0-beta2
     */
    isVoid(): boolean;
    /**
     * Is this type, `Optional<T>`?
     *
     * Also known as a union, `T | Void`.
     */
    isOptional(): boolean;
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isBoolean(): boolean;
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isNumber(): boolean;
    /**
     * Is this a String-like Type?
     *
     * TODO: should Date and Time really be considered String-like?
     */
    isStringLike(): boolean;
    /**
     * is this type String or a sub-type of String.
     */
    isString(): boolean;
    /**
     * Is this the core `com.amazon.alexa.ask.conversations.UtteranceEvent` type?
     */
    isUtteranceEvent(): boolean;
    /**
     * Get the UtteranceEvent's inner type.
     *
     * E.g.
     *
     * ```
     * UtteranceEvent<Person> => Person
     * ```
     */
    getUtteranceEventType(): Type | undefined;
    /**
     * Get the IntentEvent's inner type.
     *
     * E.g.
     *
     * ```
     * IntentEvent<Person> => Person
     * ```
     */
    getIntentEventType(): Type | undefined;
    /**
     * Is this the intrinsic `Utterance` type, representing a type-safe sample utterance string.
     *
     * ```
     * // UtteranceEvent<Person>
     * u = utterances<Person>(
     *   // List<Utterance<Person>>
     *   [
     *     // Utterance<Person>
     *     "i am {name}"
     *   ]
     * )
     * ```
     */
    isUtterance(): boolean;
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Argument type representing an argument on some action.
     *
     * ```
     * action A(String arg)
     *
     * // Argument<String>
     * a = A.arguments.arg
     * ```
     */
    isArgument(): boolean;
    /**
     * @returns the type `T` in `Argument<T>`.
     */
    getArgumentType(): Type | undefined;
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Arguments type representing the arguments of some Action.
     *
     * ```
     * action A(String arg)
     *
     * // Arguments<A>
     * a = A.arguments
     * ```
     */
    isArguments(): boolean;
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * Utterance<Person> => (type) Person
     * utterances<Person>([
     *   "hello" => (type) Person
     * ])
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getUtteranceType(): Type | undefined;
    /**
     * Get the type of an Optional.
     *
     * ```
     * Optional<String> => (type) String
     * Optional<T> => (type parameter) T
     * ```
     */
    getOptionalType(): Type | undefined;
    /**
     * If this is Optional<T> returns T else returns this
     * @returns
     */
    getNonOptionalType(): Type;
    /**
     * Checks if this type is the `Locale` enum type.
     */
    isLocale(): boolean;
    /**
     * Checks if this type is the `AnnotationTarget` enum type.
     */
    isAnnotationTarget(): boolean;
    /**
     * Checks if this is a type that extends the base Function type.
     *
     * Both Action and Dialog types extend Function.
     *
     * @returns
     */
    isFunction(): boolean;
    /**
     * Checks if this Type extends one of `FunctionN` functions where `N` is a numerical value representing
     * the number of arguments in the Function.
     */
    isFunctionN(): boolean;
    /**
     * Gets the `FunctionN` type in this Type's hierarchy if this is of type `FunctionN` where `N` is a
     * numerical value representing the number of arguments in the Function.
     */
    getFunctionN(): Type | undefined;
    /**
     * If this Type is a Function (Dialog or Action) then
     * @returns
     */
    getFunctionReturnType(): Type | undefined;
    getFunctionArgumentType(index: number): Type | undefined;
    getFunctionArgumentTypes(): Type[] | undefined;
    /**
     * Get the ArgumentDeclarations for this Type if the Type is a Function.
     */
    getFunctionArgumentDeclarations(): ask.ArgumentDeclaration[] | undefined;
    /**
     * Takes two Function types and creates a mapping between their respective argument names based on position.
     *
     * This is the foundation on which we allow functions passed around as arguments to be compatible even
     * when they don't have the same argument names. We do not wish for argument names to be relevant for
     * the compatibility of functions.
     *
     * Ex. `foo.getFunctionArgumentDeclarationMappings(Foo)`:
     * ```
     * action String Foo(String arg)
     *
     * dialog Bar(
     *   action String foo(String str)
     * ) {
     *   sample {
     *     // here, foo's `str` will be mapped to Foo's `arg`.
     *     foo(str = "hello")
     *   }
     * }
     * ```
     *
     * @param other the other type we are mapping this argument's names to.
     * @returns resulting mappings will map from `this`'s argument names to `other`'s argument names.
     */
    getFunctionArgumentDeclarationMappings(other: Type | undefined): Record<string, string> | undefined;
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialogDeclaration(): this is {
        declaration: ask.DialogDeclaration;
    };
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialog(): boolean;
    /**
     * Checks if this type is a fully qualified TypeDeclaration.
     */
    isTypeDeclaration(): this is {
        declaration: ask.TypeDeclaration;
    };
    /**
     * Checks if this type is a fully qualified ActionDeclaration.
     */
    isActionDeclaration(): this is {
        declaration: ask.ActionDeclaration;
    };
    isAction(): boolean;
    /**
     * Checks if this is a type
     * @returns
     */
    isEnum(): this is {
        declaration: ask.EnumDeclaration;
    };
    /**
     * Checks if this is a Type representing an item in an `enum`.
     * @returns
     */
    isEnumItem(): this is {
        declaration: ask.EnumItem;
    };
    /**
     * Is this `com.amazon.alexa.ask.conversations.Args` or a sub-type.
     *
     * This type represents var args in an Action.
     *
     * ```
     * action void A(Args<String>)
     *
     * a = A(
     *   "no need",
     *   "to surround these with",
     *   "[ and ]"
     * )
     * ```
     */
    isArgs(): boolean;
    /**
     * Does this Type extend `alexa.schema.List`.
     */
    isList(): boolean;
    isTaskContextProjection(): boolean;
    isTaskContextProjectionType(): boolean;
    isTaskContextProjectionAnnotation(): boolean;
    isTaskContextProjectionInfo(): boolean;
    /**
     * Is this type one of 'Invoke', 'Inform', 'Affirm', 'Deny', 'RequestAct'.
     */
    isRequestAct(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Invoke"
     */
    isInvoke(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Inform"
     */
    isInform(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Affirm"
     */
    isAffirm(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Deny"
     */
    isDeny(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Offer"
     */
    isOffer(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqAlt"
     */
    isReqAlt(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isReqMore(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Request"
     */
    isRequest(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.RequestArguments"
     */
    isRequestArguments(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmAction"
     */
    isConfirmAction(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmArgs"
     */
    isConfirmArgs(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmArguments"
     */
    isConfirmArguments(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Bye"
     */
    isBye(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Notify"
     */
    isNotify(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APLA"
     */
    isApla(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.MultiModalResponse"
     */
    isMultiModalResponse(): boolean;
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APL"
     */
    isApl(): boolean;
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * List<String> => (type) String
     * List<T> => (type parameter) T
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getListItemType(): Type | undefined;
    /**
     * Check if this type is a sub-type (or same type) as a `baseType`.
     *
     * A type, `A` extends another type, `B` if `A & B == B`.
     *
     * In other words, the intersection of A and B should be exactly B.
     *
     * @param baseType base type
     */
    extends(baseType?: Type): boolean;
    /**
     * Check if two instantiated types are identical.
     *
     * @param other
     */
    equals(other: Type): boolean;
    /**
     * Get the union of this type and another. We only have limited support for unions at this time.
     *
     * Rules:
     * 1. Void | Void = Void
     * 2. Nothing | T = T
     * 3. Void | T = Optional<T>
     * 4. Optional<T> | T = Optional<T>
     * 5. A | B = A & B
     *
     * RE: Rule #5 - when two non-Optional or Void types are unioned, we take their intersection. I.e. we
     * reduce their type to their most common denominator. We will change this once we add full support for
     * union types.
     *
     * @param other other type to union this type with
     * @returns the unioned type.
     */
    union(other: Type | undefined): Type | undefined;
    intersect(other: Type | undefined): Type | undefined;
    narrow(other: Type | undefined): Type;
    /**
     * Find all locales this type support
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales(): ask.Locale[] | undefined;
    /**
     * Gets a map of required property names to properties in this.properties
     * @returns a map of required property names to properties in this.properties
     */
    getRequiredProperties(): Map<string, Property>;
    /**
     * Gets a map of property names to corresponding properties
     * @returns a map of property names to corresponding properties
     */
    getPropertyMap(): Map<string, Property>;
    /**
     * Retrieves generic arguments nested in a Type declaration of the form Apply<Optional<T>,K>.
     * For such type this will return an array with two elements, a type object corresponding to T
     * and a type object corresponding to K.
     */
    getNestedGenericArguments(): Type[];
    /**
     * Leaf types of a type are the types that have no properties.
     *
     * This method recursively searches all of the properties of this type (extensions included)
     * until is finds all of leaf type.
     *
     * i.e.
     *
     * ```acdl
     * type NestedEmptyType {}
     *
     * type NestedType {
     *  String name
     *  NestedEmptyType empty
     * }
     *
     * type Weather {
     *   Number temperature
     * }
     *
     * type Example {
     *  String str
     *  NestedType nestedProp
     *  Weather weather
     * }
     * ```
     *
     * Processing the type `Example` would return the following array of types: `[String, Number, NestedEmptyType]`
     *
     * @param seen - the types that have been processed so far.
     * @returns Array of unique leaf types.
     */
    getLeafTypes(seen?: Set<string>): Type[];
    /**
     *
     * Searches a type for either an empty base type or for all empty leaf types.
     *
     * An empty type is defined as a type that has no properties and is neither a primitive or a catalog.
     *
     * @param type - the type to search for empty types.
     * @returns The empty subtypes in this type, or this if it's an empty base type.
     */
    getEmptyLeafTypes(): Type[];
}
//# sourceMappingURL=type.d.ts.map