import fs from "fs-extra";
import path from "path";
import * as ask from "./ast";
import { filterDuplicateErrors, typeError, nameNotFound, sortErrors } from "./error";
import { AlexaConversations, AnnotationTarget, BuiltinsNamespace, BuiltIns } from "./ast";
import { readAndParseMandatoryJSONFileSync, trimScheme } from "./util";
import { APLAFileTypes, APLFileType, Constants } from "./constants";
import { evaluateDialogFlow, validateGlobalWelcome, validateSkillLevelResponses, validateArgumentListThing } from "./evaluate";
import { Flow } from "./flow";
import { validateSkill, validateSkillCallContext } from "./validate-skill";
import { EvaluationState } from "./evaluation-state";
import { collect } from "./visit";
import { getExpressionIfLocField, ValidationErrorFactory } from "./error-factory";
import { PropertyNode } from "./property-node";
import { memoize } from "./lazy";
import { getNamespacesFromGetAllNames } from "./get-all-names";
/**
 * Validate the entire project for correctness and return and errors.
 *
 * @param project project to validate.
 * @param isSkill whether the project is a skill
 * @param skipSemanticValidations skip semantic validations
 * @returns array of all errors if detected.
 */
export function validateProject(project, isSkill, skipSemanticValidations) {
    var _a, _b, _c;
    const checker = project.getTypeChecker();
    const errors = [];
    const skills = checker.project.findSkills();
    errors.push(...project.sourceModules.flatMap((srcModule) => {
        var _a;
        return [
            // syntax errors from module errors
            ...((_a = srcModule.errors) !== null && _a !== void 0 ? _a : []),
            // syntax errors from validateRootExpressions
            ...(srcModule.content ? validateRootExpressions(srcModule.content, checker) : []),
            // semantic errors from validateModule
            ...(srcModule.content && !skipSemanticValidations ? validateModule(srcModule.content, checker) : []),
        ];
    }));
    if (skipSemanticValidations) {
        return errors;
    }
    errors.push(...validateGlobalWelcome(project, checker));
    // now that type checking has passed, let's pass over the AST and create a tree with all types resolved.
    // project = resolveProject(project);
    // checker = project.getTypeChecker();
    const isParsingSkill = isSkill !== null && isSkill !== void 0 ? isSkill : (project.isSkill() || skills.length > 0);
    if (!isParsingSkill) {
        // if we're not parsing a skill, then we should treat all dialogs as deployable
        // FIXME: this logic is wrong, we should validateDialogFlow of all dialogs and handle cases where the dialog "could be called"
        // e.g don't error when there is no prior expect event for a dialog that may be called.
        // This can be improved as part of our re-usability QA drive.
        (_a = checker.project
            .getRootDialogs()) === null || _a === void 0 ? void 0 : _a.forEach((dialog) => errors.push(...evaluateDialogFlow(new Flow(checker, dialog, undefined, []), new EvaluationState(undefined))));
    }
    else {
        if (skills.length > 1) {
            errors.push(...skills.map((skill) => {
                var _a;
                return ValidationErrorFactory.TooManySkillDeclarations({
                    expr: getExpressionIfLocField((_a = skill.declaration) === null || _a === void 0 ? void 0 : _a.name, skill.declaration, skill.apply.call),
                    attributes: {
                        skillNames: skills
                            .filter((s) => s !== skill)
                            .map((s) => { var _a; return (s.declaration ? `'${(_a = s.declaration.name) === null || _a === void 0 ? void 0 : _a.name}'` : "anonymous"); })
                            .join(", "),
                    },
                });
            }));
        }
        if (project.config.skill === undefined) {
            // no `package.json` or `ask.json` configuration, attempt to derive it from the context
            if (skills.length === 0) {
                // this skill contains no `skill()` declarations, so look for deployable dialogs and global `response/prompts` responses.
                errors.push(...validateDeployableDialogs(checker));
                errors.push(...validateSkillLevelResponses(project));
                (_b = checker.project
                    .getRootDialogs()) === null || _b === void 0 ? void 0 : _b.forEach((dialog) => errors.push(...evaluateDialogFlow(new Flow(checker, dialog, undefined, []), new EvaluationState(undefined))));
            }
            else {
                // skill declarations exist, validate each one.
                skills.forEach((skill) => errors.push(...validateSkill(skill.apply, checker)));
            }
        }
        else {
            // the skill is configured in `package.json` or `ask.json`, let's validate it.
            const skill = checker.lookupQualifiedName(project.config.skill);
            if (skill === undefined) {
                errors.push(ValidationErrorFactory.SkillNotFound({
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
            else if (skill.kind === "NameDeclaration" && ((_c = skill.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
                const apply = checker.getApply(skill.expression);
                if (apply) {
                    if (apply.isSkillAction()) {
                        errors.push(...validateSkill(apply, checker));
                    }
                    else {
                        errors.push(ValidationErrorFactory.InvalidSkillExpression({
                            expr: skill,
                            attributes: {
                                skillName: project.config.skill,
                            },
                        }));
                    }
                }
            }
            else {
                errors.push(ValidationErrorFactory.InvalidSkillExpression({
                    expr: skill,
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
        }
    }
    return sortErrors(filterDuplicateErrors(errors));
}
/**
 * validate the skill has deployable dialog
 * This function should be used when there's no skill action call
 */
function validateDeployableDialogs(checker) {
    const deployableDialogs = checker.project.getRootDialogs();
    if (deployableDialogs === undefined || deployableDialogs.length === 0) {
        return [ValidationErrorFactory.NoDeployableDialog()];
    }
    return [];
}
/**
 * Validate all expressions in a module in the context of a Project.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
export const validateModule = (module, checker) => [
    ...validateImports(module, checker),
    ...validateNamespace(module, checker),
    ...validateBlock(module, checker),
];
/**
 * Returns errors for root expressions (expressions directly at the module level) that are not allowed in the ASKIR schema
 * @param module module we are validating
 * @param checker unused
 * @returns errors for root expressions that are not allowed in the ASKIR schema
 */
const validateRootExpressions = (module, checker) => {
    var _a, _b;
    const errors = [];
    // As seen on https://github.com/alexa/ask-expressions/blob/9a88ebd49ea69dd49ecd2952d2cd6682d41d6b85/packages/%40alexa/ask-expressions-spec/schemas/Module.json#L37
    const validRootExpressions = new Set([
        "ActionDeclaration",
        "DialogDeclaration",
        "InteractionDeclaration",
        "EnumDeclaration",
        "NameDeclaration",
        "TypeDeclaration",
        "Call",
    ]);
    for (const expression of module.expressions || []) {
        if (!validRootExpressions.has(expression.kind)) {
            errors.push(ValidationErrorFactory.DeclarationExpected({
                expr: expression,
                attributes: {
                    text: expression.kind === "InteractionDeclaration" ? "" : ((_a = expression.name) === null || _a === void 0 ? void 0 : _a.name) || "",
                },
            }));
        }
        if (expression.kind === "Call") {
            const apply = checker.getApply(expression);
            if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
                errors.push(ValidationErrorFactory.InvalidDialogCall({
                    expr: expression,
                    attributes: {
                        dialogName: (_b = apply.getName()) !== null && _b !== void 0 ? _b : "",
                    },
                }));
            }
        }
    }
    return errors;
};
export const validateBlock = (scope, checker) => {
    var _a;
    return [
        ...validateDuplicateNames(scope, checker),
        ...((_a = scope.expressions) !== null && _a !== void 0 ? _a : []).map((expr) => validateExpression(expr, checker)).reduce((a, b) => a.concat(b), []),
    ];
};
export const validateNamespace = (module, checker) => {
    var _a;
    const nameSpace = (_a = module.namespace) === null || _a === void 0 ? void 0 : _a.name;
    // make sure the namespace doesn't contain reserved prefix
    const errors = [];
    if (nameSpace !== undefined) {
        Constants.RESERVED_PREFIXES.forEach((prefix) => {
            if (nameSpace.startsWith(prefix)) {
                errors.push(ValidationErrorFactory.InvalidNamespace({
                    expr: module.namespace,
                    attributes: {
                        prefix,
                    },
                }));
            }
        });
    }
    return errors;
};
/**
 * Validate the imports in a module.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
export const validateImports = (module, checker) => {
    var _a;
    return ((_a = module.imports) === null || _a === void 0 ? void 0 : _a.map((imprt) => {
        if (imprt.kind === "ImportName") {
            if (checker.lookupQualifiedName(imprt.name) === undefined) {
                return [
                    ValidationErrorFactory.InvalidImport({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        else {
            const namespace = checker.listNamespace(imprt.name);
            if (namespace === undefined) {
                return [
                    ValidationErrorFactory.InvalidImportNamespace({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        return [];
    }).reduce((a, b) => a.concat(b), [])) || [];
};
export const validateCircularReferences = (source, checker) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (source.kind === "TypeReference" || source.kind === "TypeDeclaration") {
        const type = source.kind === "TypeReference" ? checker.getType(source) : (_a = checker.getType(source)) === null || _a === void 0 ? void 0 : _a.getTypeType();
        if (type !== undefined) {
            if ((type === null || type === void 0 ? void 0 : type.properties) && type.declaration) {
                for (const prop of type.properties) {
                    if (prop.type === undefined || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()) || ((_c = prop.type) === null || _c === void 0 ? void 0 : _c.isList()) || prop.type.isNothing()) {
                        continue;
                    }
                    else if (prop.type.extends(type) || prop.type.getReferences().has(type.declaration)) {
                        return [
                            ValidationErrorFactory.CircularReferenceType({
                                expr: source.name,
                                attributes: {
                                    typeName: (_d = type.toString(source)) !== null && _d !== void 0 ? _d : source.name,
                                },
                            }),
                        ];
                    }
                }
            }
        }
    }
    else if ((_e = checker.getReferences(source)) === null || _e === void 0 ? void 0 : _e.has(source)) {
        const expr = source.name;
        return [
            source.kind === "DialogDeclaration"
                ? ValidationErrorFactory.CircularReferenceDialog({
                    expr,
                    attributes: {
                        dialogName: (_f = source.name) === null || _f === void 0 ? void 0 : _f.name,
                    },
                })
                : ValidationErrorFactory.CircularReferenceName({
                    expr,
                    attributes: {
                        name: (_g = source.name) === null || _g === void 0 ? void 0 : _g.name,
                    },
                }),
        ];
    }
    return [];
};
/**
 * Validates all annotations on a node.
 */
export const validateAnnotations = (node, checker) => {
    var _a, _b;
    return [
        ...validateNameDeclarationAnnotations(node, checker),
        ...validateTypeDeclarationAnnotations(node, checker),
        ...validateDialogDeclarationAnnotations(node, checker),
        ...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.flatMap((ann) => validateAnnotation(ann, checker))) !== null && _b !== void 0 ? _b : []),
    ];
};
/**
 * Validates annotations on name declarations.
 *
 * There are two cases:
 *
 * 1. When the value is a `NameReference`, we should not allow any annotations.
 * 2. When the value is a `variations` call, we should not allow `locale` annotations.
 */
export const validateNameDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (!ask.isNameDeclaration(node)) {
        return errors;
    }
    if (ask.isNameReference(node.expression)) {
        errors.push(...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.map((ann) => ValidationErrorFactory.InvalidAnnotationNameDeclarationNameReference({
            expr: ann,
        }))) !== null && _b !== void 0 ? _b : []));
    }
    if (((_c = node.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
        const apply = checker.getApply(node.expression);
        if ((apply === null || apply === void 0 ? void 0 : apply.isVariations()) && (node === null || node === void 0 ? void 0 : node.annotations)) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(ValidationErrorFactory.InvalidAnnotationNameDeclarationVariations({
                            expr: ann,
                        }));
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * Validates annotations on type declarations, and the properties of the type.
 *
 * There is one case:
 *
 * 1. We should not allow `referable` annotation on type properties that aren't catalogs.
 */
export const validateTypeDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const errors = [];
    if (!ask.isTypeDeclaration(node)) {
        return errors;
    }
    for (const property of (_a = node.properties) !== null && _a !== void 0 ? _a : []) {
        for (const ann of (_b = property.annotations) !== null && _b !== void 0 ? _b : []) {
            const apply = checker.getApply(ann.call);
            if (apply === null || apply === void 0 ? void 0 : apply.isReferableAction()) {
                const type = checker.getType(property.type);
                if (!(type === null || type === void 0 ? void 0 : type.hasCatalog())) {
                    errors.push(ValidationErrorFactory.InvalidReferableAnnotation({
                        expr: ann,
                        attributes: {
                            typeName: (_c = node.name) === null || _c === void 0 ? void 0 : _c.name,
                            propertyName: (_d = property.name) === null || _d === void 0 ? void 0 : _d.name,
                        },
                    }));
                }
            }
        }
    }
    for (const ann of (_e = node === null || node === void 0 ? void 0 : node.annotations) !== null && _e !== void 0 ? _e : []) {
        const annApply = checker.getApply(ann.call);
        if (annApply === null || annApply === void 0 ? void 0 : annApply.isCatalogAction()) {
            const catalog = annApply.getArgumentValue("catalog");
            const catalogType = (_g = (_f = checker.getType(catalog)) === null || _f === void 0 ? void 0 : _f.genericArguments) === null || _g === void 0 ? void 0 : _g[0];
            const declType = (_j = (_h = checker.getType(node)) === null || _h === void 0 ? void 0 : _h.genericArguments) === null || _j === void 0 ? void 0 : _j[0];
            if (!(declType === null || declType === void 0 ? void 0 : declType.extends(catalogType))) {
                errors.push(ValidationErrorFactory.InvalidCatalogSubType({
                    expr: ann,
                    attributes: {
                        typeName: (_k = node.name) === null || _k === void 0 ? void 0 : _k.name,
                        catalogName: (_l = catalog === null || catalog === void 0 ? void 0 : catalog.name) === null || _l === void 0 ? void 0 : _l.name,
                    },
                }));
            }
        }
    }
    return errors;
};
/**
 * Validates annotations on dialog declarations.
 *
 * There are two cases:
 *
 * 1. When dialog is reusable, we should not allow the dialog to have a `locale` annotation.
 * 2. When dialog is reusable, we should not allow the dialog samples to have a `locale` annotation.
 */
export const validateDialogDeclarationAnnotations = (node, checker) => {
    var _a;
    const errors = [];
    if (!ask.isDialogDeclaration(node)) {
        return errors;
    }
    // locale annotation is not allowed on reusable dialog
    if (!checker.project.isRootDialog(node)) {
        if (node.annotations && node.annotations.length > 0) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(ValidationErrorFactory.InvalidAnnotationReusableDialog({
                            expr: ann,
                        }));
                    }
                }
            }
        }
        // locale annotation is not allowed on reusable dialogs' samples
        (_a = node.samples) === null || _a === void 0 ? void 0 : _a.forEach((sample) => {
            if (sample.annotations && sample.annotations.length > 0) {
                for (const ann of sample === null || sample === void 0 ? void 0 : sample.annotations) {
                    if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                        const annApply = checker.getApply(ann.call);
                        if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                            errors.push(ValidationErrorFactory.InvalidAnnotationReusableDialogSample({
                                expr: ann,
                            }));
                        }
                    }
                }
            }
        });
        if (errors.length > 0)
            return errors;
    }
    return errors;
};
/**
 * Validate an Annotation's Call data structure:
 *
 * 1. the annotation type must also be annotated with the meta-annotation `@com.amazon.alexa.ask.conversations.Annotation`.
 * 2. the list of supported targets for the annotation must include the target this annotation is being applied to,
 */
export const validateAnnotation = (annotation, checker) => {
    var _a, _b, _c;
    const errors = validateCall(annotation.call, checker);
    const annotationTarget = AnnotationTarget.from(annotation.context.kind);
    const target = checker.getApply(annotation.call);
    const decl = (target === null || target === void 0 ? void 0 : target.decl.kind) === "Type" ? target.decl.declaration : target === null || target === void 0 ? void 0 : target.decl;
    if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration") {
        const annotationDescription = (_a = decl.annotations) === null || _a === void 0 ? void 0 : _a.map((a) => checker.getApply(a.call)).find((a) => a === null || a === void 0 ? void 0 : a.isAnnotationAction());
        if (annotationDescription) {
            const allowMultiple = annotationDescription.getAnnotationAllowMultiple();
            if (allowMultiple === false) {
                const duplicates = (_b = annotation.context.annotations) === null || _b === void 0 ? void 0 : _b.filter((an) => { var _a, _b, _c, _d; return ((_c = (_b = (_a = checker.getApply(an.call)) === null || _a === void 0 ? void 0 : _a.decl) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === ((_d = decl.name) === null || _d === void 0 ? void 0 : _d.name); });
                if (duplicates && duplicates.length > 1) {
                    errors.push(ValidationErrorFactory.InvalidAnnotationMultiple({
                        expr: annotation,
                        attributes: {
                            annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        },
                    }));
                }
            }
            const targets = annotationDescription.getAnnotationTargets();
            if ((targets === null || targets === void 0 ? void 0 : targets.find((a) => a === annotationTarget)) === undefined) {
                errors.push(ValidationErrorFactory.InvalidAnnotationTarget({
                    expr: annotation,
                    attributes: {
                        annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        annotationTarget,
                        expectedAnnotationTargets: (_c = targets === null || targets === void 0 ? void 0 : targets.map((t) => `'AnnotationTarget.${t}'`).join(", ")) !== null && _c !== void 0 ? _c : "",
                    },
                }));
            }
        }
        else {
            errors.push(ValidationErrorFactory.InvalidAnnotationMetaAnnotation({
                expr: annotation,
                attributes: {
                    annotationType: target === null || target === void 0 ? void 0 : target.getName(),
                },
            }));
        }
    }
    return errors;
};
export const validateExpression = (expr, checker) => {
    if (expr === undefined) {
        return [];
    }
    if (expr.kind === "Module") {
        // return validateModule(expr, checker);
    }
    else if (expr.kind === "InteractionDeclaration") {
        return validateInteractionDeclaration(expr, checker);
    }
    else if (expr.kind === "Correction") {
        return validateCorrection(expr, checker);
    }
    else if (expr.kind === "ActionDeclaration") {
        return validateActionDeclaration(expr, checker);
    }
    else if (expr.kind === "Argument") {
        return validateExpression(expr.value, checker);
    }
    else if (expr.kind === "Call") {
        return validateCall(expr, checker);
    }
    else if (expr.kind === "Condition") {
        return validateCondition(expr, checker);
    }
    else if (expr.kind === "DialogDeclaration") {
        return validateDialogDeclaration(expr, checker);
    }
    else if (expr.kind === "EnumDeclaration") {
        return validateEnumDeclaration(expr, checker);
    }
    else if (expr.kind === "NameDeclaration") {
        return validateNameDeclaration(expr, checker);
    }
    else if (expr.kind === "NameReference") {
        return validateNameReference(expr, checker);
    }
    else if (expr.kind === "Sample") {
        return validateSample(expr, checker);
    }
    else if (expr.kind === "TypeDeclaration") {
        return validateTypeDeclaration(expr, checker);
    }
    else if (expr.kind === "Block") {
        return validateBlock(expr, checker);
    }
    else if (expr.kind === "PropertyReference") {
        return validatePropertyReference(expr, checker);
    }
    else if (expr.kind === "When") {
        return validateExpression(expr.expression, checker);
    }
    console.warn(`can not validate expression kind '${expr.kind}'`);
    return [];
};
export const validateDialogDeclaration = (dialog, checker) => {
    var _a, _b, _c;
    return [
        ...(dialog.samples === undefined || dialog.samples.length === 0
            ? [
                ValidationErrorFactory.EmptyDialog({
                    expr: dialog,
                    attributes: {
                        dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ]
            : []),
        ...validateTypeReference(dialog.returnType, checker),
        ...validateTypeParameters(dialog.genericArguments, checker),
        ...(dialog.arguments ? validateArgumentDeclarations(dialog.arguments, checker, true) : []),
        ...validateAnnotations(dialog, checker),
        ...((_c = (_b = dialog.samples) === null || _b === void 0 ? void 0 : _b.map((sample) => validateSample(sample, checker)).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : []),
        ...validateCircularReferences(dialog, checker),
    ];
};
export const validateSample = (sample, checker) => {
    var _a, _b;
    if (sample.scope === undefined) {
        return [];
    }
    const dialog = sample.context;
    const errors = [...validateBlock(sample.scope, checker), ...validateAnnotations(sample, checker)];
    if (errors.length > 0) {
        return errors; // return if basic parse errors exist for each sample, before checking from entire sample scope
    }
    if (sample.scope.expressions === undefined || sample.scope.expressions.length === 0) {
        errors.push(ValidationErrorFactory.EmptySample({
            expr: sample,
            attributes: {
                dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
            },
        }));
    }
    const expectedType = checker.getType(dialog.returnType) || checker.void;
    const actualType = checker.getType(sample.scope) || checker.void;
    if (!expectedType.isVoid() && !expectedType.isNothing() && !actualType.extends(expectedType)) {
        const last = sample.scope.expressions[sample.scope.expressions.length - 1];
        if (last) {
            errors.push(ValidationErrorFactory.TypeErrorDialogLastExpr({
                expr: last,
                attributes: {
                    dialogName: (_b = dialog.name) === null || _b === void 0 ? void 0 : _b.name,
                    expectedType: expectedType.toString(sample),
                    actualType: actualType.toString(sample),
                },
            }));
        }
    }
    return errors;
};
function hasName(expr) {
    var _a;
    return ((expr.kind === "NameDeclaration" ||
        expr.kind === "TypeDeclaration" ||
        expr.kind === "ActionDeclaration" ||
        expr.kind === "DialogDeclaration") &&
        ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined);
}
export const validateDuplicateNames = (scope, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (scope.kind === "Module") {
        const moduleUri = checker.getUri(scope);
        (_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.forEach((expr) => {
            var _a;
            if (expr.kind !== "InteractionDeclaration" && ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                const declarations = checker.global.scope.get(expr.name.name);
                if (Array.isArray(declarations)) {
                    const files = Array.from(new Set(declarations
                        .map((d) => checker.getUri(d))
                        .filter((uri) => uri !== undefined && uri !== moduleUri)
                        .map((uri) => path.relative(checker.project.config.rootDir, uri))
                        .map((uri) => `'${trimScheme(uri)}'`)));
                    errors.push(ValidationErrorFactory.DuplicateNameDeclarationInModule({
                        expr,
                        attributes: {
                            name: expr.name.name,
                            filesLength: files.length,
                            fileNames: files.join(", "),
                        },
                    }));
                }
            }
        });
    }
    else {
        const seen = new Set();
        const duplicates = new Set();
        const parentScope = checker.getVisibleNames(scope.context, false);
        (_b = scope.expressions) === null || _b === void 0 ? void 0 : _b.forEach((expr) => {
            if (hasName(expr)) {
                const name = expr.name.name;
                if (seen.has(name) || (parentScope === null || parentScope === void 0 ? void 0 : parentScope.has(name)) || checker.global.scope.has(name)) {
                    duplicates.add(name);
                }
                seen.add(name);
            }
        });
        (_c = scope.expressions) === null || _c === void 0 ? void 0 : _c.forEach((expr) => {
            var _a;
            if (hasName(expr) && duplicates.has((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                errors.push(ValidationErrorFactory.DuplicateNameDeclaration({
                    expr: expr.name,
                    attributes: {
                        name: expr.name.name,
                    },
                }));
            }
        });
    }
    return errors;
};
/**
 * Validates a name expression.
 *
 * @param checker
 * @param name
 */
export const validateNameDeclaration = (name, checker) => {
    var _a;
    const errors = name.expression ? [...validateExpression(name.expression, checker)] : [];
    errors.push(...validateCircularReferences(name, checker));
    errors.push(...validateAnnotations(name, checker));
    const valueType = checker.getType(name.expression);
    const explicitType = name.type ? checker.instantiateTypeReference(name.type) : undefined;
    if (name.type !== undefined) {
        errors.push(...validateTypeReference(name.type, checker));
    }
    if (explicitType !== undefined && valueType !== undefined) {
        if (!valueType.extends(explicitType)) {
            errors.push(typeError(valueType, explicitType, name, name.name));
        }
    }
    if (valueType === undefined) {
    }
    // declare a name with an expression of type Nothing is invalid
    const nameType = checker.getType(name.expression);
    if ((nameType === null || nameType === void 0 ? void 0 : nameType.isNothing()) || (nameType === null || nameType === void 0 ? void 0 : nameType.isVoid())) {
        errors.push(ValidationErrorFactory.InvalidNameDeclaration({
            expr: name.name,
            attributes: {
                name: (_a = name.name) === null || _a === void 0 ? void 0 : _a.name,
                nothingTypeName: checker.nothing.toString(name),
                voidTypeName: checker.void.toString(name),
            },
        }));
    }
    return errors;
};
export const validateNameReference = (id, checker) => [...validateName(id, checker)];
export const validateName = (id, checker) => {
    var _a;
    const found = lookupName(id, id.name);
    if (found === undefined) {
        // For Call, it's valid when name is undefined, like listLiteral
        if (id.name !== undefined && id.kind !== "Call") {
            return [nameNotFound(id.name, id.loc, id)];
        }
    }
    else if (Array.isArray(found)) {
        const declares = found
            .map((f) => {
            if (f.kind === "ResponseTemplate") {
                return f.type === ask.ResponseTemplateType.Prompt ? `'prompts.${f.name}'` : `'displays.${f.name}'`;
            }
            return `'${f.name.name}'`;
        })
            .filter((f) => f !== undefined)
            .join(", ");
        return [
            ValidationErrorFactory.AmbiguousNameReference({
                expr: id,
                attributes: {
                    name: (_a = id.name) === null || _a === void 0 ? void 0 : _a.name,
                    possibleName: declares,
                },
            }),
        ];
    }
    return [];
    function lookupName(scope, name) {
        if (name === undefined) {
            return undefined;
        }
        const nameStr = typeof name === "string" ? name : name.name;
        if (checker.global.scope.has(nameStr)) {
            return checker.global.scope.get(nameStr);
        }
        const lexicalScope = checker.getVisibleNames(scope);
        if (lexicalScope === null || lexicalScope === void 0 ? void 0 : lexicalScope.has(nameStr)) {
            return lexicalScope.get(nameStr);
        }
        return undefined;
    }
};
export const validateActionDeclaration = (action, checker) => [
    ...validateTypeReference(action.returnType, checker),
    ...validateTypeParameters(action.genericArguments, checker),
    ...(action.arguments ? validateArgumentDeclarations(action.arguments, checker, false) : []),
    ...validateAnnotations(action, checker),
    ...validateAnnotatedActionDeclaration(action, checker),
];
/**
 * Validates that an ActionDeclaration that is annotated with the `@annotation` meta-annotation has a return type of void.
 */
export const validateAnnotatedActionDeclaration = (action, checker) => {
    var _a, _b, _c;
    if (((_a = action.annotations) === null || _a === void 0 ? void 0 : _a.find((a) => checker.qualifyName(action, a.call.name) === AlexaConversations.annotation)) !== undefined) {
        const actionDeclType = checker.getType(action);
        if ((actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.isAction()) && ((_b = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _b === void 0 ? void 0 : _b.getTypeType())) {
            const returnType = (_c = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _c === void 0 ? void 0 : _c.getTypeType();
            if (returnType && !(returnType.isVoid() || returnType.isNothing())) {
                return [
                    ValidationErrorFactory.InvalidAnnotationMetaAnnotationReturnType({
                        expr: action.name,
                    }),
                ];
            }
        }
    }
    return [];
};
export function validateArgumentDeclarations(args, checker, isDialogArgument) {
    var _a, _b, _c, _d, _e;
    const seen = new Set();
    const duplicates = new Set();
    const errors = [];
    let isRequiredArgAllowed = true;
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (seen.has(arg.name.name)) {
                duplicates.add(arg.name.name);
            }
            seen.add((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name);
        }
        const hasMoreArgs = args[i + 1] !== undefined;
        const type = checker.instantiateTypeReference(arg.type);
        if ((type === null || type === void 0 ? void 0 : type.isArgs()) && hasMoreArgs) {
            errors.push(ValidationErrorFactory.VarArgsMustBeLast({
                expr: arg,
            }));
        }
        if (type === null || type === void 0 ? void 0 : type.isOptional()) {
            isRequiredArgAllowed = false;
        }
        else if (!(type === null || type === void 0 ? void 0 : type.isArgs()) && !isRequiredArgAllowed) {
            errors.push(ValidationErrorFactory.RequiredArgExistAfterOptionalArg({
                expr: arg,
                attributes: {
                    argumentName: (_c = arg.name) === null || _c === void 0 ? void 0 : _c.name,
                },
            }));
        }
        errors.push(...validateArgumentDeclaration(arg, checker, isDialogArgument));
    }
    for (const arg of args) {
        if (((_d = arg.name) === null || _d === void 0 ? void 0 : _d.name) && duplicates.has((_e = arg.name) === null || _e === void 0 ? void 0 : _e.name)) {
            errors.push(ValidationErrorFactory.DuplicateArgument({
                expr: arg.name,
                attributes: {
                    argumentName: arg.name.name,
                },
            }));
        }
    }
    return errors;
}
export function validateArgumentDeclaration(arg, checker, isDialogArgument = false) {
    const errors = [
        ...validateExpression(arg.defaultExpression, checker),
        ...validateTypeReference(arg.type, checker),
        ...validateAnnotations(arg, checker),
    ];
    if (arg.name === undefined) {
        errors.push(ValidationErrorFactory.SyntaxError({
            expr: getExpressionIfLocField(arg.type, arg),
            overrideMessage: "expected name for argument declaration.",
        }));
    }
    if (arg.defaultExpression) {
        const actualType = checker.getType(arg.defaultExpression);
        const expectedType = checker.getType(arg.type);
        if (actualType && expectedType && !actualType.extends(expectedType)) {
            errors.push(typeError(actualType, expectedType, arg.defaultExpression, arg.defaultExpression));
        }
        // Arguments' default value must be nothing except dialogArgument
        if (!isDialogArgument) {
            const thing = checker.getThing(arg.defaultExpression);
            if (!((thing === null || thing === void 0 ? void 0 : thing.isNothing()) && thing.isLiteral())) {
                errors.push(ValidationErrorFactory.InvalidApiArgumentDefaultValue({
                    expr: arg,
                }));
            }
        }
        else {
            // for dialogArgument, the default expression canâ€™t call dialogs, user defined APIs or branch with conditions
        }
    }
    return errors;
}
/**
 * Validate that an EnumDeclaration has at least one item and no duplicate items.
 *
 * ```acdl
 * enum E {} // invalid
 * enum E { // invalid
 *   A
 *   A
 * }
 * enum E { // valid
 *   A
 *   B
 * }
 * ```
 */
export const validateEnumDeclaration = (enumDecl, checker) => {
    var _a, _b, _c, _d;
    if (enumDecl.items === undefined || enumDecl.items.length === 0) {
        return [
            ValidationErrorFactory.EmptyEnumDeclaration({
                expr: enumDecl,
                attributes: {
                    enumName: (_a = enumDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                },
            }),
            ...validateAnnotations(enumDecl, checker),
        ];
    }
    const names = new Set();
    const dups = new Set();
    (_b = enumDecl.items) === null || _b === void 0 ? void 0 : _b.forEach((item) => {
        var _a, _b;
        if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (names.has((_b = item.name) === null || _b === void 0 ? void 0 : _b.name)) {
                dups.add(item.name.name);
            }
            else {
                names.add(item.name.name);
            }
        }
    });
    if (dups.size === 0) {
        return [];
    }
    return [
        ...validateAnnotations(enumDecl, checker),
        ...((_d = (_c = enumDecl.items) === null || _c === void 0 ? void 0 : _c.map((item) => {
            var _a;
            if (((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) && dups.has(item.name.name)) {
                return ValidationErrorFactory.DuplicateEnumItem({
                    expr: item,
                    attributes: {
                        enumItemName: item.name.name,
                    },
                });
            }
            return undefined;
        }).filter((e) => e !== undefined)) !== null && _d !== void 0 ? _d : []),
    ];
};
export const validateTypeDeclaration = (type, checker) => {
    var _a;
    return [
        ...validateTypeReferences((_a = type.properties) === null || _a === void 0 ? void 0 : _a.map((p) => p.type).filter((t) => t !== undefined), checker),
        ...validateTypeReferences(type.extensions, checker),
        ...validateTypeParameters(type.genericArguments, checker),
        ...validateCircularReferences(type, checker),
        ...validateAnnotations(type, checker),
        ...validateTypeDeclarationProperties(type, checker),
    ];
};
/**
 * validate the properties in typeDecl are not duplicate
 */
export const validateTypeDeclarationProperties = (typeDecl, checker) => {
    var _a, _b, _c;
    const seen = new Set((_a = typeDecl.extensions) === null || _a === void 0 ? void 0 : _a.map((ext) => { var _a, _b, _c; return (_c = (_b = (_a = checker.getType(ext)) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.map((p) => p.name)) !== null && _c !== void 0 ? _c : []; }).reduce((a, b) => a.concat(b), []));
    return ((_c = (_b = typeDecl.properties) === null || _b === void 0 ? void 0 : _b.map((prop) => {
        var _a;
        const name = (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name;
        if (name === undefined) {
            return ValidationErrorFactory.SyntaxError({
                expr: getExpressionIfLocField(prop.type, prop),
                overrideMessage: "expected property name.",
            });
        }
        if (seen.has(name)) {
            return ValidationErrorFactory.DuplicatePropertyRedeclared({
                expr: prop,
                attributes: {
                    propertyName: name,
                },
            });
        }
        seen.add(name);
        return undefined;
    }).filter((e) => e !== undefined)) !== null && _c !== void 0 ? _c : []);
};
export const validateTypeParameters = (params, checker) => { var _a; return (_a = params === null || params === void 0 ? void 0 : params.map((param) => validateTypeParameter(param, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
export const validateTypeParameter = (param, checker) => validateTypeReferences(param.constraints, checker);
export const validateTypeReferences = (refs, checker) => { var _a; return (_a = refs === null || refs === void 0 ? void 0 : refs.map((ref) => validateTypeReference(ref, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
export const validateTypeReference = (ref, checker) => {
    var _a, _b;
    const errors = [];
    if (ref) {
        // check if the call name could be resolved, error if fail to resolve call name
        errors.push(...validateName(ref, checker));
        if (errors.length > 0) {
            return errors;
        }
        errors.push(...validateCircularReferences(ref, checker));
        const typeDecl = checker.lookupTypeReference(ref);
        if (typeDecl === undefined) {
            errors.push(nameNotFound(ref.name));
        }
        if (ref.arguments) {
            for (const arg of ref.arguments) {
                errors.push(...validateTypeReference(arg, checker));
            }
        }
        if (typeDecl && errors.length === 0) {
            const type = checker.instantiateTypeReference(ref);
            if (type !== undefined) {
                if (typeDecl.kind === "TypeDeclaration") {
                    if (typeDecl.genericArguments) {
                        if (typeDecl.genericArguments.length !== ((_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                            errors.push(ValidationErrorFactory.TypeErrorRequiredTypeArguments({
                                expr: ref,
                                attributes: {
                                    typeDeclarationName: (_b = typeDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                                    numArguments: typeDecl.genericArguments.length,
                                },
                            }));
                        }
                        else {
                            type.genericArguments.forEach((genericArgument, i) => {
                                var _a, _b;
                                const typeParameter = (_a = typeDecl.genericArguments) === null || _a === void 0 ? void 0 : _a[i];
                                if (typeParameter !== undefined && typeParameter.constraints && genericArgument !== undefined) {
                                    for (const constraint of typeParameter.constraints) {
                                        const constraintType = checker.instantiateTypeReference(constraint, type.environment);
                                        if (constraintType && !genericArgument.extends(constraintType)) {
                                            errors.push(typeError(genericArgument, constraintType, ref, (_b = ref.arguments) === null || _b === void 0 ? void 0 : _b[i]));
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * Validate an `alexa.lang.property` call to access a property on a type.
 *
 * @param ref call expression representing the access of a property on another expression
 */
export const validatePropertyReference = (ref, checker) => {
    // property does not exist
    const { name } = ref;
    const expr = ref.expression;
    const exprType = checker.getType(expr);
    if ((name === null || name === void 0 ? void 0 : name.name) === undefined) {
        return [
            ValidationErrorFactory.IdentifierExpected({
                expr: getExpressionIfLocField(ref.name, ref),
            }),
        ];
    }
    const qualifiedName = ask.PropertyReference.tryResolveQualifiedName(ref);
    if (qualifiedName !== undefined && checker.lookupQualifiedName(qualifiedName) !== undefined) {
        return [];
    }
    if (exprType !== undefined) {
        const prop = exprType.getProperty(name.name);
        if (prop === undefined) {
            return [
                ...validateExpression(expr, checker),
                ValidationErrorFactory.UnknownProperty({
                    expr: getExpressionIfLocField(ref.name, ref),
                    attributes: {
                        propertyName: name.name,
                        typeName: exprType.toString(ref),
                    },
                }),
            ];
        }
    }
    return validateExpression(expr, checker);
};
export const validateUtteranceTypeWrapper = (apply) => {
    const errors = [];
    if (!apply.isUtterances() && !apply.isIntent()) {
        return [];
    }
    const returnType = apply.getReturnType();
    const utteranceType = apply.isUtterances() ? returnType === null || returnType === void 0 ? void 0 : returnType.getUtteranceEventType() : returnType === null || returnType === void 0 ? void 0 : returnType.getIntentEventType();
    if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isValidUtteranceWrapper())) {
        errors.push(ValidationErrorFactory.UtteranceEventTypeMustReferToWrapper({
            expr: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.declaration,
            attributes: {
                typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName,
                action: apply.isUtterances() ? "utterances" : "intent",
            },
        }));
    }
    return errors;
};
/**
 * Validate a Call to a Type or an Action:
 *
 * - Resolve its declaration and throw errors if it cannot be found.
 * - Infer generic arguments if they aren't provided and flag errors if that cannot be achieved.
 * - Validate that all required arguments are provided and that types of arguments match declaration.
 */
export const validateCall = (call, checker) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const errors = [];
    // check if the call name could be resolved, error if fail to resolve call name
    errors.push(...validateName(call, checker));
    const getPropertyMap = memoize((type) => type.getPropertyMap());
    if (errors.length > 0) {
        return errors;
    }
    const apply = checker.getApply(call);
    if (call.genericArguments) {
        errors.push(...validateTypeReferences(call.genericArguments, checker));
    }
    if (apply === undefined) {
        if (((_a = call.name) === null || _a === void 0 ? void 0 : _a.name) === undefined) {
            // could not infer anonymous type
            errors.push(ValidationErrorFactory.CouldNotInferAnonymousType({
                expr: call,
            }));
        }
        else {
            errors.push(nameNotFound(call.name));
        }
    }
    else {
        errors.push(...validateSkillCallContext(apply));
        errors.push(...validateRequireCall(apply, checker));
        errors.push(...validateValidateArgAnnotation(apply, checker));
        if (apply.isAnnotation()) {
            // if this is a call to an Annotation, we must ensure that it is in an Annotation context.
            if (apply.call.context.kind !== "Annotation" && apply.call.getSample() !== undefined) {
                errors.push(ValidationErrorFactory.InvalidAnnotationCall({
                    expr: call,
                    attributes: {
                        annotationTarget: apply.getName(),
                    },
                }));
            }
        }
        else if (apply.isEventDecl() ||
            apply.isIntent() ||
            apply.isFileAccessAction() ||
            apply.isSkillAction() ||
            apply.isWelcome() ||
            apply.isVariations()) {
            if (apply.isSkillAction()) {
                errors.push(...validateSkillCallContext(apply));
            }
            else if (call.context.kind !== "NameDeclaration" || ((_b = call.context.context) === null || _b === void 0 ? void 0 : _b.kind) !== "Module") {
                errors.push(ValidationErrorFactory.InvalidCallContextModuleNameDeclaration({
                    expr: call,
                    attributes: {
                        actionName: checker.qualifyName(call, (_c = call.name) === null || _c === void 0 ? void 0 : _c.name),
                    },
                }));
            }
            if (apply.isWelcome()) {
                const actionValue = apply.getArgumentValue("action");
                const actionType = checker.getType(actionValue);
                if (actionType === null || actionType === void 0 ? void 0 : actionType.isAction()) {
                    if (actionType.isBuiltIn()) {
                        errors.push(ValidationErrorFactory.InvalidWelcomeAction({
                            expr: actionValue,
                        }));
                    }
                    const returnType = (_d = actionType.getPropertyType("returnType")) === null || _d === void 0 ? void 0 : _d.getTypeType();
                    if (returnType) {
                        if (returnType.isVoid() || returnType.isNothing()) {
                            errors.push(ValidationErrorFactory.InvalidWelcomeActionReturnValue({
                                expr: actionValue,
                            }));
                        }
                    }
                }
            }
            else if (apply.isVariations()) {
                errors.push(...validateVariations(call, checker));
            }
        }
        else if (apply.isType() || apply.isGetListItem()) {
            // TODO: should we allow operators and get list item?
            if (apply.isResetArguments() || apply.isResetAllArguments() || apply.isEnsureArgOrder()) {
                const argumentsValue = apply.getArgumentValue("arguments");
                // for ResetArguments, all the arguments in the list should from same api
                if (apply.isResetArguments()) {
                    errors.push(...validateArgumentListThing(checker.getThing(argumentsValue), argumentsValue));
                }
                // for EnsureArgOrder, all the arguments in the list should be required args
                if (apply.isEnsureArgOrder()) {
                    errors.push(...validateEnsureArgOrder(apply, checker));
                }
            }
            else if (apply.isCatalogType()) {
                const catalogType = (_e = apply.getGenericArguments()) === null || _e === void 0 ? void 0 : _e[0];
                if (!(catalogType === null || catalogType === void 0 ? void 0 : catalogType.isString())) {
                    ValidationErrorFactory.CatalogTypeMustBeString({
                        expr: apply.call,
                    });
                }
            }
        }
        else if (apply.isCatalogDecl()) {
            errors.push(...validateCatalogCallContext(apply, checker));
            if (apply.isBuiltinCatalogAction()) {
                errors.push(...validateBuiltinCatalogAction(apply, checker));
            }
        }
        else if (apply.isGetAllNamesAction()) {
            errors.push(...validateGetAllNamesAction(apply, checker));
        }
        else if (call.findInContext(ask.isAnnotation) === undefined) {
            errors.push(...validateCallContext(call, checker));
        }
        if (apply.isUtterances() || apply.isIntent()) {
            errors.push(...validateUtteranceTypeWrapper(apply, checker));
        }
        if ((apply.isUtterances() || apply.isIntent()) && checker.isNameReference((_f = apply.getArguments()) === null || _f === void 0 ? void 0 : _f.samples.value)) {
            errors.push(...validateNamedArguments(apply, checker, false)); // check the arguments but don't type check - we will do this in a custom way
            // special case - we're calling utterances/intent with a name reference to a List.
            // we need to find that list and validate
            const value = (_g = apply.getArguments()) === null || _g === void 0 ? void 0 : _g.samples.value;
            const found = checker.resolveNameReference(value);
            const foundType = checker.getType(value);
            if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                // if empty list, throw error
                if (found.arguments.items.length === 0) {
                    errors.push(ValidationErrorFactory.EmptyUtteranceSet({
                        expr: found.arguments,
                        attributes: {
                            actionName: apply.isUtterances() ? "utterances" : "intent",
                        },
                    }));
                }
                else if ((_h = foundType.getListItemType()) === null || _h === void 0 ? void 0 : _h.isString()) {
                    // yes, we are referencing a List<String> literal
                    const utteranceType = (_j = apply.getGenericArguments()) === null || _j === void 0 ? void 0 : _j[0];
                    for (const item of found.arguments.items) {
                        if (item.item !== undefined) {
                            // TODO: should we change the error message to provide more help? the error is associated with an afar list literal but attached to the name reference
                            errors.push(...validateUtterance(item.item, utteranceType, getPropertyMap).map((e) => {
                                var _a;
                                return ({
                                    ...e,
                                    loc: value.loc,
                                    uri: (_a = e.uri) !== null && _a !== void 0 ? _a : value.uri,
                                });
                            }));
                        }
                    }
                }
            }
            else {
                errors.push(ValidationErrorFactory.InvalidUtteranceArg({
                    expr: value,
                }));
            }
        }
        else {
            if (apply.isUtterances() || apply.isIntent()) {
                const utteranceList = (_l = (_k = apply.getArguments()) === null || _k === void 0 ? void 0 : _k.samples) === null || _l === void 0 ? void 0 : _l.value;
                if ((utteranceList === null || utteranceList === void 0 ? void 0 : utteranceList.kind) === "Call" && ask.isListLiteral(utteranceList.arguments)) {
                    if (utteranceList.arguments.items.length === 0) {
                        errors.push(ValidationErrorFactory.EmptyUtteranceSet({
                            expr: utteranceList.arguments,
                            attributes: {
                                actionName: apply.isUtterances() ? "utterances" : "intent",
                            },
                        }));
                    }
                    else {
                        let utteranceErrors = utteranceList.arguments.items.flatMap((listItem) => validateUtteranceString(listItem));
                        errors.push(...utteranceErrors);
                    }
                }
            }
            errors.push(...validateNamedArguments(apply, checker));
            const genericArguments = apply.getGenericArguments();
            const genericEnvironment = apply.getGenericEnvironment();
            if (apply.decl.genericArguments !== undefined && genericArguments === undefined) {
                errors.push(ValidationErrorFactory.CouldNotInferGenericArguments({
                    expr: call,
                    attributes: {
                        argumentName: (_m = apply.decl.name) === null || _m === void 0 ? void 0 : _m.name,
                    },
                }));
            }
            else if (genericArguments && ((_o = apply.decl.genericArguments) === null || _o === void 0 ? void 0 : _o.length) === (genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments.length)) {
                const decl = apply.decl.kind === "Type" ? apply.decl.declaration : apply.decl;
                if (decl &&
                    decl.kind !== "TypeParameter" &&
                    decl.kind !== "SlotType" &&
                    decl.kind !== "EnumDeclaration" &&
                    decl.kind !== "EnumItemDeclaration" &&
                    decl.kind !== "TypeReference") {
                    (_p = decl.genericArguments) === null || _p === void 0 ? void 0 : _p.forEach((genericArgument, i) => {
                        var _a, _b;
                        const actualType = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i];
                        if (actualType && genericArgument.constraints) {
                            for (const constraint of genericArgument.constraints) {
                                const expectedType = checker.instantiateTypeReference(constraint, genericEnvironment);
                                if (expectedType && !actualType.extends(expectedType)) {
                                    errors.push(typeError(actualType, expectedType, (_b = (_a = call === null || call === void 0 ? void 0 : call.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : call));
                                }
                            }
                        }
                    });
                }
            }
            const returnType = apply.getReturnType();
            if (apply.isType() && returnType) {
                // this is a Type expression, e.g. `Person { name = "sam" }` or `[1, 2]` or `"hello"`
                if (call.arguments === null && !(returnType.isVoid() || returnType.isNothing() || returnType.isOptional())) {
                    errors.push(typeError(returnType, checker.void, call));
                }
                else if (typeof call.arguments === "string" && !returnType.isStringLike()) {
                    errors.push(typeError(returnType, checker.string, call));
                }
                else if (typeof call.arguments === "number" && !returnType.isNumber()) {
                    errors.push(typeError(returnType, checker.number, call));
                }
                else if (typeof call.arguments === "boolean" && !returnType.isBoolean()) {
                    errors.push(typeError(returnType, checker.boolean, call));
                }
                else if (ask.isListLiteral(call.arguments) && !returnType.isList()) {
                    errors.push(ValidationErrorFactory.TypeErrorListType({
                        expr: call,
                    }));
                }
                if (returnType.isUtterance()) {
                    const utteranceType = returnType.getUtteranceType();
                    errors.push(...validateUtterance(call, utteranceType, getPropertyMap));
                }
                if (ask.isListLiteral(call.arguments) && returnType.isList()) {
                    const expectedType = returnType.getListItemType();
                    if (expectedType) {
                        for (const item of call.arguments.items) {
                            errors.push(...validateExpression(item.item, checker));
                            const actualType = checker.getType(item.item);
                            if (actualType) {
                                if (!actualType.extends(expectedType)) {
                                    errors.push(ValidationErrorFactory.TypeErrorListItem({
                                        expr: getExpressionIfLocField(item.item, item),
                                        attributes: {
                                            actualType: actualType.toString(item.item),
                                            expectedType: expectedType.toString(item.item),
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * Validate utterance string to check if it contains empty curly braces
 */
export function validateUtteranceString(item) {
    if (!ask.isCall(item.item))
        return [];
    let errors = [];
    let utterance = ask.isUtterance(item.item.arguments) ? item.item.arguments.text : item.item.arguments;
    if (typeof utterance !== "string")
        return [];
    let emptySlotReEexp = /\{\s*\}/g;
    let validSlotRegExp = /{([- a-zA-Z 0-9 _.|,' \s ]*)}/g;
    let braces = utterance.match(emptySlotReEexp);
    if (braces && (braces === null || braces === void 0 ? void 0 : braces.length) > 0) {
        errors.push(ValidationErrorFactory.EmptyUtteranceBraces({
            expr: { loc: item.item.loc, uri: item.item.uri },
            attributes: {
                utterance,
            },
        }));
    }
    // removes valid '{..}' to check for invalid braces in the utterance
    let utteranceWithoutSlots = utterance.replace(validSlotRegExp, "");
    for (let char of utteranceWithoutSlots) {
        if (char === "}") {
            errors.push(ValidationErrorFactory.MissingUtteranceOpeningBrace({
                expr: { loc: item.item.loc, uri: item.item.uri },
                attributes: {
                    utterance,
                },
            }));
            break;
        }
        else if (char === "{") {
            errors.push(ValidationErrorFactory.MissingUtteranceClosingBrace({
                expr: { loc: item.item.loc, uri: item.item.uri },
                attributes: {
                    utterance,
                },
            }));
            break;
        }
    }
    return errors;
}
/**
 * validate the variations call
 * 1. The argument value can't use duplicate locale info
 * 2. SkillLevelResponses can't be used as an argument of variations call
 * 3. prompts.abc can't be used as an argument of variations call
 *
 * Invalid case example:
 * 1. duplicate locales
 * ```
 *  @locale(Locale.en_US)
 *  promptUS = utterances<Person>([
 *     "hi I am American my name is {name}",
 *     "hi I am American my name is {name} and i am {age} years old"
 *  ])
 *
 *  @locale(Locale.en_US, Locale.en_GB)
 *  promptGB = utterances<Person>([
 *    "hi I am British my name is {name}",
 *    "hi I am British my name is {name} and i am {age} years old"
 *  ])
 *  u = variations(promptUS, promptGB)
 * ```
 *
 * 2. SkillLevelResponses used as argument
 * ```
 * skillLevelResponsesEN = SkillLevelResponses { ... }
 * skillLevelResponsesGB = SkillLevelResponses { ... }
 *
 * skillLevelResponses = variations(skillLevelResponsesEN, skillLevelResponsesGB)
 * ```
 *
 * 3. prompts used as argument
 * ```
 * skillLevelResponses = variations(prompts.AlexaConversationsWelcome, prompts.AlexaConversationsOutOfDomain)
 * ```
 */
export const validateVariations = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply === undefined) {
        return [];
    }
    const errors = [];
    const usedLocale = new Map();
    const argumentValueThing = apply.getArgumentValueThing("variations");
    if (argumentValueThing === null || argumentValueThing === void 0 ? void 0 : argumentValueThing.isList()) {
        const items = argumentValueThing.getListItems();
        items === null || items === void 0 ? void 0 : items.forEach((item) => {
            var _a, _b, _c;
            if (((_a = item === null || item === void 0 ? void 0 : item.item) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = item === null || item === void 0 ? void 0 : item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                // TODO: validate the item is not SkillLevelResponses or prompts
                const thing = checker.getThing(item.item);
                if (thing === null || thing === void 0 ? void 0 : thing.type.isSkillLevelResponses()) {
                    // SkillLevelResponses can't be used as an argument of variations call
                    errors.push(ValidationErrorFactory.InvalidVariationsArgumentSkillLevelResponses({
                        expr: getExpressionIfLocField(item.item, item),
                    }));
                }
                else if (((_c = checker.resolveNameReference(item.item)) === null || _c === void 0 ? void 0 : _c.kind) === "ResponseTemplate") {
                    errors.push(ValidationErrorFactory.InvalidVariationsArgumentResponsePrompts({
                        expr: getExpressionIfLocField(item.item, item),
                    }));
                }
                else {
                    const locales = checker.collectLocaleInfo(item.item);
                    locales.forEach((locale) => {
                        var _a, _b;
                        if (usedLocale.has(locale)) {
                            errors.push(ValidationErrorFactory.DuplicateLocale({
                                expr: getExpressionIfLocField(item.item, item),
                                attributes: {
                                    locale,
                                    variationItem: usedLocale.get(locale),
                                },
                            }));
                        }
                        else {
                            usedLocale.set(locale, (_b = (_a = item.item) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name);
                        }
                    });
                }
            }
        });
    }
    return errors;
};
/**
 * Validate that a call to a User Defined API or Dialog is not contained within another call.
 *
 * Validate that this Call is allowed in this Context.
 *
 * @param call
 * @param checker
 * @returns
 */
export const validateCallContext = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply !== undefined) {
        const callType = apply.isUserDefinedApi()
            ? `user defined API '${apply.getName()}'`
            : apply.isDialog()
                ? "a dialog"
                : apply.isBuiltin()
                    ? `'${apply.getShortName()}'`
                    : "an action";
        return walkCallContext(call.context);
        function walkCallContext(context) {
            if (context === undefined || ask.isDialogDeclaration(context)) {
                return [];
            }
            if (context.kind === "InteractionDeclaration" || context.kind === "Correction") {
                // TODO: add validation checks - https://github.com/alexa/ask-ac/issues/869
                return [];
            }
            if (ask.isModule(context)) {
                return [
                    ValidationErrorFactory.InvalidCallContextInModule({
                        expr: call,
                        attributes: {
                            callType,
                        },
                    }),
                ];
            }
            if (context.kind === "When") {
                if (!(apply.isOperator() || apply.isNativeAction())) {
                    return [
                        ValidationErrorFactory.InvalidCallContextInCondition({
                            expr: call,
                            attributes: {
                                callType,
                            },
                        }),
                    ];
                }
            }
            else if (context.kind === "Call") {
                const contextApply = checker.getApply(context);
                if ((contextApply === null || contextApply === void 0 ? void 0 : contextApply.isUserDefinedApi()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isDialog()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isType())) {
                    const contextType = contextApply.isType() ? (contextApply.isList() ? "a list item" : "a property") : "an argument";
                    const errorArguments = {
                        expr: call,
                        attributes: {
                            callType,
                            contextType,
                        },
                    };
                    if (apply.isOperator()) {
                        return [ValidationErrorFactory.InvalidCallContextComparison(errorArguments)];
                    }
                    if (apply.isNativeAction()) {
                        return [ValidationErrorFactory.InvalidCallContextType(errorArguments)];
                    }
                    return [ValidationErrorFactory.InvalidCallContextTypeInline(errorArguments)];
                }
            }
            return walkCallContext(context.context);
        }
    }
    return [];
};
/**
 * Validates that a `validateArg` annotation matches the following rules:
 * 1. action must have at least one argument
 * 2. condition must reference at least one of those arguments in its boolean expression
 * 3. at least one argument must be referenced
 * 4. that argument must be from the same action that this validateArg annotation is attached to.
 *
 * @param apply Apply instance for the validateArg annotation call.
 * @param checker static TypeChecker instance
 * @returns validation errors
 * @see https://github.com/alexa/ask-ac/issues/690
 */
export const validateValidateArgAnnotation = (apply, checker) => {
    var _a;
    if (!apply.isValidateArg()) {
        return [];
    }
    const action = (_a = apply.checker.getThing(apply.call.context.context)) === null || _a === void 0 ? void 0 : _a.asAction();
    if (action === undefined) {
        // we don't need to error here - validateArg's annotation targets restricts it to an Action
        return [];
    }
    if (action.origin.arguments === undefined || action.origin.arguments.length === 0) {
        return [
            ValidationErrorFactory.InvalidAnnotationValidateArg({
                expr: apply.call,
            }),
        ];
    }
    const argumentsNode = apply.getArgumentValue("arguments");
    const conditionNode = apply.getArgumentValue("condition");
    const condition = apply.getArgumentValueThing("condition");
    const args = apply.getArgumentValueThing("arguments");
    const argsNode = apply.getArgumentValue("arguments");
    const requestPromptNode = apply.getArgumentValue("requestPrompt");
    const requestPrompt = apply.getArgumentValueThing("requestPrompt");
    return [
        ...validateArguments(),
        ...validateConditionReferencesAtLeastOneArgument(),
        ...validateConditionOperations(conditionNode, undefined),
        ...validateRequestPrompt(),
    ];
    function validateConditionReferencesAtLeastOneArgument() {
        var _a;
        if (conditionNode === undefined) {
            // type error
            return [];
        }
        if (condition === null || condition === void 0 ? void 0 : condition.isNothing()) {
            return [
                ValidationErrorFactory.IllegalNothingValueBoolean({
                    expr: getExpressionIfLocField(conditionNode, apply.call),
                }),
            ];
        }
        if (!hasAtLeastOneArgumentNameReference(conditionNode)) {
            return [
                ValidationErrorFactory.InvalidAnnotationValidateArgCondition({
                    expr: conditionNode,
                    attributes: {
                        actionArguments: (_a = action === null || action === void 0 ? void 0 : action.origin.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => { var _a; return `'${(_a = arg.name) === null || _a === void 0 ? void 0 : _a.name}'`; }).join(","),
                        actionName: action.actionName,
                    },
                }),
            ];
        }
        return [];
    }
    function hasAtLeastOneArgumentNameReference(node) {
        if (node.kind === "NameReference") {
            const referencedNode = checker.resolveNameReference(node);
            if ((referencedNode === null || referencedNode === void 0 ? void 0 : referencedNode.kind) === "ArgumentDeclaration") {
                return true;
            }
        }
        return collect(node, hasAtLeastOneArgumentNameReference, (a, b) => a || b, false);
    }
    function validateConditionOperations(node, errorExpr) {
        if (node === undefined) {
            return [];
        }
        if (node.kind === "NameReference") {
            return validateConditionOperations(checker.resolveNameReference(node), getExpressionIfLocField(errorExpr, node));
        }
        if (node.kind === "PropertyReference") {
            return validateConditionOperations(checker.resolveNameReferenceToCall(node), getExpressionIfLocField(errorExpr, node));
        }
        if (node.kind === "Call") {
            const apply = checker.getApply(node);
            if (apply === undefined) {
                // type error
                return [];
            }
            if (apply.isType()) {
                if (node.arguments === null ||
                    typeof node.arguments === "string" ||
                    typeof node.arguments === "number" ||
                    typeof node.arguments === "boolean" ||
                    ask.isListLiteral(node.arguments)) {
                    if (ask.isListLiteral(node.arguments)) {
                        // check that each of the values in the list are also valid
                        return node.arguments.items.map((item) => validateConditionOperations(item.item, errorExpr)).flat();
                    }
                    // literal value comparisons are allowed
                    return [];
                }
                return [
                    ValidationErrorFactory.InvalidBooleanExpressionTypeLiteral({
                        expr: getExpressionIfLocField(errorExpr, node, conditionNode),
                        attributes: {
                            typeName: apply.getName(),
                        },
                    }),
                ];
            }
            if (apply.isBinaryOperator()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("left"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("right"), errorExpr),
                ];
            }
            if (apply.isNot() || apply.isIs() || apply.isExists()) {
                return validateConditionOperations(apply.getArgumentValue("right"), errorExpr);
            }
            if (apply.isSize()) {
                return validateConditionOperations(apply.getArgumentValue("list"), errorExpr);
            }
            if (apply.isGetListItem()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("list"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("index"), errorExpr),
                ];
            }
            if (apply.isLength()) {
                return validateConditionOperations(apply.getArgumentValue("s"), errorExpr);
            }
            return [
                ValidationErrorFactory.InvalidBooleanExpressionAction({
                    expr: getExpressionIfLocField(errorExpr, node, conditionNode),
                    attributes: {
                        actionName: apply.getName(),
                    },
                }),
            ];
        }
        return [];
    }
    function validateRequestPrompt() {
        if (requestPromptNode === undefined) {
            // type error
            return [];
        }
        if (requestPrompt === null || requestPrompt === void 0 ? void 0 : requestPrompt.isNothing()) {
            return [
                ValidationErrorFactory.IllegalNothingValueResponsePrompt({
                    expr: getExpressionIfLocField(requestPromptNode, apply.call),
                }),
            ];
        }
        return [];
    }
    function validateArguments() {
        var _a, _b;
        if (argumentsNode === undefined || (args === null || args === void 0 ? void 0 : args.isNothing())) {
            return [
                ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: apply.call,
                    attributes: {
                        actionName: (_a = action.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ];
        }
        if (!(args === null || args === void 0 ? void 0 : args.isLiteral())) {
            return [
                ValidationErrorFactory.ExpectedLiteralValue({
                    expr: getExpressionIfLocField(argumentsNode, apply.call),
                }),
            ];
        }
        if (!args.isList()) {
            return [];
        }
        const items = args.getItems();
        if (!(items === null || items === void 0 ? void 0 : items.length)) {
            return [
                ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: getExpressionIfLocField(argumentsNode, apply.call),
                    attributes: {
                        actionName: (_b = action.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
            ];
        }
        return items.flatMap((arg, i) => {
            var _a;
            // if this arguments is an inline literal list, we will place the error on the specific item in the list
            const argsExpr = (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)
                ? (_a = argsNode.arguments.items[i]) === null || _a === void 0 ? void 0 : _a.item
                : getExpressionIfLocField(argumentsNode, apply.call);
            if (arg === undefined) {
                return []; // type error;
            }
            if (arg.isNothing()) {
                return [
                    ValidationErrorFactory.IllegalNothingValueActionArgument({
                        expr: argsExpr,
                        attributes: {
                            actionName: action === null || action === void 0 ? void 0 : action.actionName,
                        },
                    }),
                ];
            }
            if (arg.isArgument() && arg.action && !arg.action.equals(action)) {
                return [
                    ValidationErrorFactory.MismatchedActionArgumentsValidateArguments({
                        expr: argsExpr,
                        attributes: {
                            argumentName: arg.argumentName,
                            actualActionName: arg.action.actionName,
                            expectedActionName: action.actionName,
                        },
                    }),
                ];
            }
            return [];
        });
    }
};
/**
 * Validate a call to `require` - an internal action to reference a file from disk.
 */
export const validateRequireCall = (apply, checker) => {
    var _a, _b;
    const name = apply.getName();
    if (name === AlexaConversations.apl || name === AlexaConversations.apla) {
        const pathArg = (_a = apply.getArguments()) === null || _a === void 0 ? void 0 : _a.path;
        if (((_b = pathArg === null || pathArg === void 0 ? void 0 : pathArg.value) === null || _b === void 0 ? void 0 : _b.kind) === "Call") {
            const filePath = ask.isUtterance(pathArg.value.arguments)
                ? pathArg.value.arguments.text
                : typeof pathArg.value.arguments === "string"
                    ? pathArg.value.arguments
                    : undefined;
            if (filePath !== undefined) {
                const uri = checker.getUri(apply.call);
                if (uri !== undefined) {
                    let absolutePath;
                    if (path.isAbsolute(filePath)) {
                        absolutePath = filePath;
                    }
                    else {
                        absolutePath = path.join(uri, "..", filePath);
                    }
                    if (!fs.existsSync(absolutePath)) {
                        // TODO: don't use synchronous IO in the validators
                        // see: https://github.com/alexa/ask-ac/issues/504
                        return [
                            ValidationErrorFactory.PathNotAccessible({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // developer could provide folder name only
                    // auto fill the 'document.json' in path
                    const status = fs.statSync(absolutePath);
                    let documentPath;
                    if (status.isFile()) {
                        documentPath = absolutePath;
                    }
                    else {
                        documentPath = path.join(absolutePath, Constants.APLADocumentFileName);
                    }
                    // The document can only use the name 'document.json'
                    if (path.basename(documentPath) !== Constants.APLADocumentFileName) {
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                documentName: path.basename(documentPath),
                            },
                        };
                        return [
                            name === AlexaConversations.apl
                                ? ValidationErrorFactory.InvalidAplDocumentName(errorArguments)
                                : ValidationErrorFactory.InvalidAplaDocumentName(errorArguments),
                        ];
                    }
                    // if no document.json found
                    if (!fs.existsSync(documentPath)) {
                        return [
                            ValidationErrorFactory.FileNotFound({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // Type check to make sure apla action point to APLA document
                    // and apl action point to APL document
                    try {
                        const json = readAndParseMandatoryJSONFileSync(documentPath);
                        const { type } = json;
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                filePath,
                                fileType: type === undefined ? type : `"${type}"`,
                            },
                        };
                        if (name === AlexaConversations.apl && type !== APLFileType.APL) {
                            return [ValidationErrorFactory.InvalidFileTypeApl(errorArguments)];
                        }
                        if (name === AlexaConversations.apla && !APLAFileTypes.includes(type)) {
                            return [ValidationErrorFactory.InvalidFileTypeApla(errorArguments)];
                        }
                    }
                    catch (err) {
                        return [
                            ValidationErrorFactory.FileReadError({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                                overrideMessage: err.message,
                            }),
                        ];
                    }
                }
            }
        }
    }
    return [];
};
/**
 * Validate the arguments passed to a Call against the target declaration.
 *
 * - Finds missing required arguments.
 * - Detect unknown arguments, whether by name or position. Account for var-args.
 * - Detect when positional arguments are used after named ones.
 * - Check that the types of arguments.
 *
 * @param apply
 * @param checker
 * @param checkType should we type check? default true
 */
export const validateNamedArguments = (apply, checker, checkType = true) => {
    var _a, _b, _c;
    if (apply.isType() && ((_a = apply.getReturnType()) === null || _a === void 0 ? void 0 : _a.isPrimitive())) {
        return [];
    }
    const { call } = apply;
    const errors = [];
    let isPositionalAllowed = true;
    let position = 0;
    const seenNamedArgs = new Set();
    if (Array.isArray(call.arguments)) {
        for (const argument of call.arguments) {
            // recursively descend and validate this argument
            errors.push(...validateExpression(argument, checker));
            if ((_b = argument.name) === null || _b === void 0 ? void 0 : _b.name) {
                isPositionalAllowed = false;
                const decl = apply.argumentDeclIndex[argument.name.name];
                if (decl === undefined) {
                    unknown();
                }
                if (seenNamedArgs.has(argument.name.name)) {
                    errors.push(ValidationErrorFactory.InvalidApiArgumentRedeclare({
                        expr: argument,
                        attributes: {
                            argumentName: argument.name.name,
                        },
                    }));
                }
                else {
                    seenNamedArgs.add(argument.name.name);
                }
            }
            else if (isPositionalAllowed) {
                const decl = (_c = apply.argumentDeclarations) === null || _c === void 0 ? void 0 : _c[position];
                const env = apply.getGenericEnvironment();
                const declType = (decl === null || decl === void 0 ? void 0 : decl.kind) === "ArgumentDeclaration" ? checker.instantiateTypeReference(decl.type, env) : decl === null || decl === void 0 ? void 0 : decl.type;
                if (declType === undefined) {
                    unknown();
                }
                if ((declType === null || declType === void 0 ? void 0 : declType.isArgs()) !== true) {
                    // if this is not var args, increment the declaration position
                    // otherwise, subsequent arguments are considered an item in the var-args list
                    position += 1;
                }
            }
            else {
                errors.push(ValidationErrorFactory.PositionalArgumentAfterName({
                    expr: argument,
                }));
                // If positional arguments are used after a named argument, skip the rest validation
                return errors;
            }
            function unknown() {
                var _a, _b, _c;
                let error;
                const expr = getExpressionIfLocField(argument.name, argument);
                if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                    error = apply.isType()
                        ? ValidationErrorFactory.UnknownProperty({
                            expr,
                            attributes: {
                                propertyName: argument.name.name,
                                typeName: (_c = (_b = apply.getReturnType()) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        })
                        : ValidationErrorFactory.UnknownArgument({
                            expr,
                            attributes: {
                                argumentName: argument.name.name,
                                callName: apply.getName(),
                            },
                        });
                }
                else {
                    const errorArguments = {
                        expr,
                        attributes: {
                            index: argument.index,
                        },
                    };
                    error = apply.isType()
                        ? ValidationErrorFactory.UnknownPropertyIndex(errorArguments)
                        : ValidationErrorFactory.UnknownArgumentIndex(errorArguments);
                }
                errors.push(error);
            }
        }
    }
    const missing = new Set(apply.requiredArguments);
    const sanitizedArguments = apply.getArguments();
    if (sanitizedArguments !== undefined) {
        // arguments are grouped by name and var-args are assembled into a List.
        // now go through each argument and type check it.
        for (const [name, argument] of Object.entries(sanitizedArguments || {})) {
            missing.delete(name);
            if (checkType) {
                // special case: when property of an event result is of type optional, and there's request prompt available for that property
                // Then we should treat this property as not optional
                let actualType = checker.getType(argument.value);
                if (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                    // for backwards compatibility
                    // Temporarily make Optional<T> assignable to T
                    // TODO: get argumentEnsured condition back once we are ready to ship breaking changes
                    // if (checker.isArgumentEnsured(call, apply.decl, name)) {
                    while (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                        actualType = actualType.getOptionalType();
                    }
                }
                const expectedType = apply === null || apply === void 0 ? void 0 : apply.getType(argument);
                if (actualType && expectedType) {
                    if (!actualType.extends(expectedType)) {
                        errors.push(typeError(actualType, expectedType, apply.call, argument));
                    }
                }
            }
        }
    }
    if (missing.size > 0) {
        errors.push(apply.isType()
            ? ValidationErrorFactory.MissingProperties({
                expr: call,
                attributes: { properties: Array.from(missing.values()).join(",") },
            })
            : ValidationErrorFactory.MissingArguments({
                expr: call,
                attributes: { args: Array.from(missing.values()).join(",") },
            }));
    }
    errors.push(...validateBinaryOperator(apply));
    return errors;
};
export function validateBinaryOperator(apply) {
    var _a, _b;
    if (apply.isBinaryOperator()) {
        // special-case logic for binary operators - the types must match
        // for example, if we have `1 == "hello"`, then it will be inferred as
        // `equals<Thing>(1, "hello")` // there is no type error here
        // for these cases, we will explicitly check that either:
        // 1. left extends right
        // 2. right extends left
        const left = (_a = apply.getArgumentValueThing("left")) === null || _a === void 0 ? void 0 : _a.type;
        const right = (_b = apply.getArgumentValueThing("right")) === null || _b === void 0 ? void 0 : _b.type;
        if (left && right) {
            if (!left.extends(right) && !right.extends(left)) {
                return [
                    ValidationErrorFactory.TypeErrorIncomparableExpr({
                        expr: apply.call,
                        attributes: {
                            leftExpr: left.toString(apply.call),
                            rightExpr: right.toString(apply.call),
                        },
                    }),
                ];
            }
        }
    }
    return [];
}
/**
 * Validates the utterance in expr
 * @param expr expression containing the utterance to validate
 * @param utteranceType type for utterance
 * @param getPropertyMap memoized type's getPropertyMap
 * @returns
 */
export const validateUtterance = (expr, utteranceType, getPropertyMap) => {
    var _a;
    let errors = [];
    // throw error if the item in a list is not literal string
    if (expr.kind !== "Call" || (!(typeof expr.arguments === "string") && !ask.isUtterance(expr.arguments))) {
        return [ValidationErrorFactory.InvalidUtteranceItem({ expr })];
    }
    let utterance;
    if (ask.isUtterance(expr.arguments)) {
        utterance = expr.arguments.text;
    }
    else {
        utterance = expr.arguments;
    }
    // Validate the utterance text here. Currently only validating it's not an empty string
    if (utterance.trim().length === 0) {
        return [ValidationErrorFactory.EmptyUtteranceString({ expr })];
    }
    if (!utteranceType) {
        return errors;
    }
    const utteranceTypeRequiredProperties = utteranceType.getRequiredProperties();
    if (typeof expr.arguments === "string" && utteranceTypeRequiredProperties.size > 0) {
        errors.push(ValidationErrorFactory.MissingPropertiesOnType({
            expr,
            attributes: {
                requiredProperties: Array.from(utteranceTypeRequiredProperties.values())
                    .map((p) => `${p.name}`)
                    .join(", "),
                typeName: utteranceType.toString(expr),
            },
        }));
    }
    else if (ask.isUtterance(expr.arguments)) {
        const propertyPaths = [];
        const pathsSeen = new Set();
        for (const name of expr.arguments.names || []) {
            if (!name.name) {
                continue;
            }
            if (pathsSeen.has(name.name)) {
                errors.push(ValidationErrorFactory.DuplicateProperty({
                    expr: name,
                    attributes: {
                        propertyName: name.name,
                    },
                }));
            }
            pathsSeen.add(name.name);
            propertyPaths.push(name.name);
        }
        const { errors: propertyTreeErrors, root: propertyTreeRoot } = PropertyNode.buildPropertyTree(expr.arguments.names || [], utteranceType, expr, getPropertyMap);
        errors = [...errors, ...propertyTreeErrors];
        // Verify required properties at each tree level.
        // The tree traversal algorithm is the standard queue breadth first
        // (level by level) logic where we quee the root and while the queue
        // is not empty we unqueue element and queue its children.
        const queue = [propertyTreeRoot];
        while (queue.length !== 0) {
            const propertyNode = queue.shift();
            const requiredProperties = propertyNode === null || propertyNode === void 0 ? void 0 : propertyNode.propertyType.getRequiredProperties();
            for (const child of propertyNode.children.values()) {
                // mark this child as present by removing from requiredProperties
                requiredProperties.delete(child.property.name);
                // queue child which is a part of standard queue traversal
                queue.push(child);
            }
            for (const requiredProperty of requiredProperties.values()) {
                // if it's a list, then it's allowed to be omitted - omitted means empty list?
                if (!((_a = requiredProperty.type) === null || _a === void 0 ? void 0 : _a.isList())) {
                    errors.push(ValidationErrorFactory.MissingPropertiesOnUtteranceType({
                        expr,
                        attributes: {
                            utterance: expr.arguments.text,
                            propertyName: requiredProperty.name,
                            typeName: utteranceType.toString(expr),
                        },
                    }));
                }
            }
        }
    }
    return errors;
};
export const validateCondition = (condition, checker) => {
    const errors = [];
    if (condition.when !== undefined) {
        errors.push(...validateExpression(condition.when, checker));
    }
    if (condition.then === undefined) {
        console.warn("undefined then");
    }
    else {
        errors.push(...validateConditionBlock(condition.then, checker));
        errors.push(...validateBlock(condition.then, checker));
    }
    if (condition.else) {
        errors.push(...validateConditionBlock(condition.else, checker));
        errors.push(...validateBlock(condition.else, checker));
    }
    const whenType = checker.getType(condition.when);
    if ((whenType === null || whenType === void 0 ? void 0 : whenType.isBoolean()) === false) {
        errors.push(ValidationErrorFactory.TypeErrorWhenBoolean({
            expr: getExpressionIfLocField(condition.when, condition),
            attributes: {
                whenType: whenType.toString(condition.when),
                whenCondition: checker.boolean.toString(condition.when),
            },
        }));
    }
    return errors;
};
/**
 * Validate that a Condition Block has expressions.
 */
export const validateConditionBlock = (scope) => {
    var _a;
    return scope.expressions === undefined || ((_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.length) === 0
        ? [
            ValidationErrorFactory.EmptyConditionBlock({
                expr: scope,
            }),
        ]
        : [];
};
/**
 * Validate EnsureOrder action call
 * 1. All the args in the list should from same api
 * 2. All the args in the list should be required args
 *
 * Related Github feature request:
 * https://github.com/alexa/ask-ac/issues/553
 */
export const validateEnsureArgOrder = (apply, checker) => {
    const errors = [];
    if (apply.isEnsureArgOrder()) {
        const argumentsValue = apply.getArgumentValue("arguments");
        const argumentsValueThing = checker.getThing(argumentsValue);
        // all the arguments in the list should be required args
        errors.push(...validateArgumentListThing(argumentsValueThing, argumentsValue));
        if ((argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.isLiteral()) && argumentsValueThing.isList()) {
            const items = argumentsValueThing.getItems();
            items === null || items === void 0 ? void 0 : items.forEach((item) => {
                var _a, _b, _c;
                if (item === null || item === void 0 ? void 0 : item.isArgument()) {
                    const referencedArgumentDeclaration = item.getReferencedActionArgumentDeclaration();
                    const type = checker.getType(referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.type);
                    if (type === null || type === void 0 ? void 0 : type.isOptional()) {
                        errors.push(ValidationErrorFactory.InvalidEnsureArgOptional({
                            expr: item,
                            attributes: {
                                argumentName: (_a = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.name) === null || _a === void 0 ? void 0 : _a.name,
                                actionName: (_c = (_b = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.context) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }));
                    }
                }
            });
        }
    }
    return errors;
};
/**
 * Validates that calls to catalog actions like `extendCatalog` or `builtInCatalog` are only allowed
 * at the module scope and not within a dialog sample.
 */
export const validateCatalogCallContext = (apply, checker) => {
    if (!apply.isCatalogDecl()) {
        return [];
    }
    let context = apply.call.context;
    while (context && context.kind !== "Module") {
        if (context.kind === "Sample" || context.kind === "DialogDeclaration") {
            return [
                ValidationErrorFactory.InvalidCatalogCallContext({
                    expr: apply.call,
                    attributes: {
                        callName: apply.getShortName(),
                    },
                }),
            ];
        }
        context = context.context;
    }
    return [];
};
/**
 * Validates the argument provided to builtinCatalog is a valid built in type and
 * the type parameter is of type String.
 */
export const validateBuiltinCatalogAction = (apply, checker) => {
    var _a;
    if (!apply.isBuiltinCatalogAction()) {
        return [];
    }
    const errors = [];
    const builtInTypes = new Set(Object.values(BuiltIns).map((builtIn) => builtIn.replace(BuiltinsNamespace + ".", "")));
    const genericType = (_a = apply.getGenericArguments()) === null || _a === void 0 ? void 0 : _a[0];
    const argValueThing = apply.getArgumentValueThing("name");
    // Validate type parameter is of type String
    if (genericType && !(genericType.isPrimitive() || genericType.isThing())) {
        errors.push(ValidationErrorFactory.InvalidCatalogTypeParameter({
            expr: apply.call,
            attributes: {
                typeName: genericType.shortName,
            },
        }));
    }
    // Validate string argument is a built in type
    if (argValueThing === null || argValueThing === void 0 ? void 0 : argValueThing.isLiteral()) {
        // Get the string value of the argument
        let argString = argValueThing.apply.call.arguments;
        if (typeof argString === "string") {
            // Remove the AMAZON portion. "AMAZON.Actor" -> "Actor"
            let argValue = argString.replace("AMAZON.", "");
            if (!builtInTypes.has(argValue)) {
                errors.push(ValidationErrorFactory.InvalidBuiltinCatalog({
                    expr: getExpressionIfLocField(argValueThing, apply.call),
                    attributes: {
                        argName: argString,
                    },
                }));
            }
        }
    }
    return errors;
};
export const validateInteractionDeclaration = (action, checker) => {
    return [...validateAnnotations(action, checker), ...validateExpression(action.scope, checker)];
};
export const validateCorrection = (action, checker) => [
    ...validateExpression(action.actual, checker),
    ...validateExpression(action.expected, checker),
];
/**
 * Validates that the call to getAllNames.
 *
 * 1. Verify the namespaces provided exist.
 */
export const validateGetAllNamesAction = (apply, checker) => {
    if (!apply.isGetAllNamesAction()) {
        return [];
    }
    const errors = [];
    const namespaces = getNamespacesFromGetAllNames(apply, checker);
    const missingNamespaces = namespaces.filter((namespace) => !checker.global.namespaces.has(namespace));
    if ((missingNamespaces === null || missingNamespaces === void 0 ? void 0 : missingNamespaces.length) > 0) {
        errors.push(ValidationErrorFactory.InvalidNamespacesProvidedToGetAllNames({
            expr: apply.call,
            attributes: {
                namespaces: missingNamespaces.map((ns) => `"${ns}"`).join(", "),
            },
        }));
    }
    return errors;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdmFsaWRhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQzFCLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQztBQUU3QixPQUFPLEVBQTJCLHFCQUFxQixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBTTdHLE9BQU8sRUFBQyxrQkFBa0IsRUFBZSxnQkFBZ0IsRUFBNkIsaUJBQWlCLEVBQUUsUUFBUSxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBQ2hJLE9BQU8sRUFBQyxpQ0FBaUMsRUFBRSxVQUFVLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDckUsT0FBTyxFQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBRWxFLE9BQU8sRUFBQyxrQkFBa0IsRUFBRSxxQkFBcUIsRUFBRSwyQkFBMkIsRUFBRSx5QkFBeUIsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUM3SCxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sRUFBQyxhQUFhLEVBQUUsd0JBQXdCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUN6RSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDbkQsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUMsdUJBQXVCLEVBQWtCLHNCQUFzQixFQUE4QixNQUFNLGlCQUFpQixDQUFDO0FBRTdILE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQy9CLE9BQU8sRUFBQyw0QkFBNEIsRUFB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