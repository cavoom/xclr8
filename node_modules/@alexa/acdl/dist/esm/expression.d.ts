import * as ask from "./ast";
import { FunctionThing, ActionThing, ArgumentThing, DialogThing, ListThing, StringThing, Thing } from "./thing";
import { Apply } from "./apply";
import { TypeChecker } from "./checker";
import { Flow } from "./flow";
import { Type } from "./type";
/**
 * An Algebraic Data Type representing all of the different Expressions in a Dialog Flow.
 */
export type Expression = ActionExpression | BlockExpression | ConditionalBranch | ConfirmAction | DelegateRequest | DelegateToIntent | DialogExpansion | End | Ensure | Expect | InvokeApi | Response | Start;
declare class BaseExpression<Node extends ask.Node | undefined> {
    readonly prev: Expression | undefined;
    readonly flow: Flow<Node>;
    readonly kind: Expression["kind"];
    /**
     * A reference to the Type Environment this Expression belongs in.
     */
    readonly checker: TypeChecker;
    /**
     * The exact ASKIR Expression node which expressed this Expression.
     */
    readonly node: Node;
    /**
     * Sourece Code Location of the Call representing this Expression.
     */
    readonly loc: ask.SourceLocation | undefined;
    /**
     * Source Code URI of the code containing this Expression.
     */
    readonly uri: string | undefined;
    constructor(prev: Expression | undefined, flow: Flow<Node>);
    isAction(): this is ActionExpression;
    isBlock(): this is BlockExpression;
    isConditionalBranch(): this is ConditionalBranch;
    isConfirmAction(): this is ConfirmAction;
    isConfirmArgs(): this is ConfirmArgs;
    isDialogExpansion(): this is DialogExpansion;
    isEnsure(): this is Ensure;
    isExpect(): this is Expect;
    isEnd(): this is End;
    isInvokeApi(): this is InvokeApi;
    isResponse(): this is Response;
    isStart(): this is Start;
    isDelegateToIntent(): this is DelegateToIntent;
    isDelegateRequest(): this is DelegateRequest;
    /**
     * Expressions that can come after a delegation call.
     */
    canFollowDelegation(): boolean;
}
/**
 * Represents the Start of a Dialog Flow. This is usually used to detect the beginning
 * when traversing back through the Stack of previously received Expressions. It is
 * always the first expression in a {@link Flow.interpret} stream.
 */
export declare class Start extends BaseExpression<ask.DialogDeclaration> {
    readonly kind: "Start";
    constructor(prev: Expression | undefined, flow: Flow<ask.DialogDeclaration>);
}
/**
 * Represents the End of a Dialog Flow. This Expression is the last Expression you'll ever
 * receive in a {@link Flow.interpret} stream. Use this to finalize evaluation of the Expression
 * stream.
 */
export declare class End extends BaseExpression<undefined> {
    readonly kind: "End";
    constructor(prev: Expression | undefined, flow: Flow<undefined>);
}
/**
 * Represents entering a Block.
 */
export declare class BlockExpression extends BaseExpression<ask.Block> {
    readonly kind: "Block";
    constructor(prev: Expression | undefined, flow: Flow<ask.Block>);
}
/**
 * Map of names to Things representing the Arguments to some Action Call.
 */
export interface CallArguments extends Record<string, Thing | undefined> {
}
export declare class FunctionExpression extends BaseExpression<ask.Call> {
    /**
     * The Function to call.
     */
    readonly func: FunctionThing | undefined;
    readonly arguments?: CallArguments;
    readonly apply: Apply | undefined;
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, 
    /**
     * The Function to call.
     */
    func: FunctionThing | undefined, 
    /**
     * Optional name-value pairs for the Arguments passed to the API.
     */
    args: CallArguments | undefined);
}
/**
 * A Call to any Action (apis, built-ins, etc.).
 */
export declare class ActionExpression extends FunctionExpression {
    /**
     * The API's Action to call.
     */
    readonly action?: ActionThing | undefined;
    readonly kind: "Action";
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, 
    /**
     * The API's Action to call.
     */
    action?: ActionThing | undefined, 
    /**
     * Optional name-value pairs for the Arguments passed to the API.
     */
    args?: CallArguments);
}
/**
 * Get payload to confirm for expressions that can be confirmed.
 */
interface ConfirmPayload {
    actionName: string | undefined;
    arguments: Record<string, Thing | undefined> | undefined;
}
/**
 * Invoke of an external API Action.
 *
 * ```
 * action String foo(String arg)
 * // ..
 * f = foo("hello")
 * ```
 */
export declare class InvokeApi extends ActionExpression {
    readonly actionKind: "InvokeApi";
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, 
    /**
     * The API's Action to call.
     */
    action: ActionThing | undefined, 
    /**
     * Name-value pairs for the Arguments passed to the API.
     */
    args?: CallArguments);
    getConfirmPayload(): ConfirmPayload;
}
/**
 * Call to expand a Dialog.
 *
 * ```
 * dialog Foo(String arg) {}
 * // ..
 * fooDialog("hello")
 * ```
 */
export declare class DialogExpansion extends FunctionExpression {
    /**
     * The Dialog to call and expand the samples of in the simulation.
     */
    readonly dialog: DialogThing | undefined;
    /**
     * Name-value pairs for the Arguments passed to the Dialog.
     */
    readonly args: CallArguments;
    readonly kind: "Dialog";
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, 
    /**
     * The Dialog to call and expand the samples of in the simulation.
     */
    dialog: DialogThing | undefined, 
    /**
     * Name-value pairs for the Arguments passed to the Dialog.
     */
    args: CallArguments);
}
/**
 * Represents an invound Request via the `expect` action.
 *
 * ```
 * expect(Invoke, my_utterance_event)
 * ```
 */
export declare class Expect extends ActionExpression {
    /**
     * The value of the Request Act.
     */
    readonly act: Thing | undefined;
    /**
     * The received Event.
     */
    readonly event: Thing | undefined;
    readonly actionKind: "Expect";
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, 
    /**
     * The value of the Request Act.
     */
    act: Thing | undefined, 
    /**
     * The received Event.
     */
    event: Thing | undefined);
    /**
     * @returns the type of the Act.
     */
    getActType(): Type | undefined;
    isAffirm(): boolean | undefined;
    isDeny(): boolean | undefined;
    isInvoke(): boolean | undefined;
    isInform(): boolean | undefined;
}
/**
 * Send a Response to the user.
 *
 * Is a Call Expression to `com.amazon.alexa.ask.conversations.response`
 *
 * ```acdl
 * response(
 *   response = my_apla_tempalte
 *   payload = Payload {
 *     key = value
 *   },
 *   act = Request { arguments = [foo.arguments.bar] },
 * })
 * ```
 */
export declare class Response extends ActionExpression {
    readonly flow: Flow<ask.Call>;
    /**
     * The Apply instance for the actual Call Expression to the `response` Action.
     */
    readonly apply: Apply;
    /**
     * The Response template to use for this Response.
     */
    readonly response?: Thing | undefined;
    /**
     * The Response Act value for this Response.
     */
    readonly act?: Thing | undefined;
    /**
     * Optional nextAct value for this Response.
     */
    readonly nextAct?: Thing | undefined;
    /**
     * Value of the Payload to be passed to the APL/A Response Template.
     */
    readonly payload?: Thing | undefined;
    /**
     * Optional literal String representing the surface form of this Response.
     */
    readonly surfaceForm?: StringThing | undefined;
    readonly actionKind: "Response";
    readonly actNode: ask.Node | undefined;
    readonly responseNode: ask.Node | undefined;
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, 
    /**
     * The Apply instance for the actual Call Expression to the `response` Action.
     */
    apply: Apply, 
    /**
     * The Response template to use for this Response.
     */
    response?: Thing | undefined, 
    /**
     * The Response Act value for this Response.
     */
    act?: Thing | undefined, 
    /**
     * Optional nextAct value for this Response.
     */
    nextAct?: Thing | undefined, 
    /**
     * Value of the Payload to be passed to the APL/A Response Template.
     */
    payload?: Thing | undefined, 
    /**
     * Optional literal String representing the surface form of this Response.
     */
    surfaceForm?: StringThing | undefined);
    /**
     * If {@link Response.act} is `Request` then return the list of all the Action Arguments {@link ArgumentThing} that were individually requested.
     *
     * Individually requested arguments must exist for all required Arguments when calling an Action.
     */
    getIndividuallyRequestedArguments(): ArgumentThing[];
}
/**
 * A request to transfer delegation from Alexa Conversations to IM.
 */
export declare class DelegateRequest extends ActionExpression {
    readonly apply: Apply;
    readonly updatedRequest?: Thing | undefined;
    readonly actionKind: "DelegateRequest";
    readonly updatedRequestNode: ask.Node | undefined;
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, apply: Apply, updatedRequest?: Thing | undefined);
    getConfirmPayload(): ConfirmPayload;
}
/**
 * Responds with a `Dialog.DelegateRequest` directive to the intent with the provided
 * slot values.
 *
 * Is a Call Expression to `com.amazon.alexa.ask.conversations.delegateToIntent`
 *
 * ```acdl
 * delegateToIntent<T>(
 *    getWeatherIntent,
 *    Weather {
 *       temp = 10,
 *       location = "Seattle"
 *    }
 * )
 * ```
 */
/**
 * A request to transfer delegation from Alexa Conversations to IM.
 */
export declare class DelegateToIntent extends ActionExpression {
    readonly apply: Apply;
    readonly intent?: Thing | undefined;
    readonly slots?: Thing | undefined;
    readonly actionKind: "DelegateToIntent";
    readonly intentNode: ask.Node | undefined;
    readonly slotsNode: ask.Node | undefined;
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, apply: Apply, intent?: Thing | undefined, slots?: Thing | undefined);
    getConfirmPayload(): ConfirmPayload;
}
/**
 * An ambient Expression to Confirm Arguments that will be passed to some API Action.
 *
 * ```
 * confirmArgs([foo.arguments.bar])
 *
 * ```
 */
export declare class ConfirmArgs extends ActionExpression {
    /**
     * Lis
     */
    readonly confirmArgs: ListThing | undefined;
    readonly actionKind: "ConfirmArgs";
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, 
    /**
     * Lis
     */
    confirmArgs: ListThing | undefined);
}
/**
 * A Response to the user to to confirm that Alexa should call some API.
 */
export declare class ConfirmAction extends ActionExpression {
    readonly response: Thing;
    readonly actionName?: ActionThing | undefined;
    readonly payload?: Thing | undefined;
    readonly actionKind: "ConfirmAction";
    readonly actionNameNode: ask.Argument | undefined;
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, response: Thing, actionName?: ActionThing | undefined, payload?: Thing | undefined);
}
/**
 * An ambient expression informing Alexa how to request various arguments for various actions.
 */
export declare class Ensure extends ActionExpression {
    readonly requestArgs: ListThing | undefined;
    readonly actionKind: "Ensure";
    constructor(prev: Expression | undefined, flow: Flow<ask.Call>, requestArgs: ListThing | undefined);
    /**
     * Gets a list of all the Action Arguments {@link ArgumentThing} that were individually requested.
     *
     * Individually requested arguments must exist for all required Arguments when calling an Action.
     */
    getIndividuallyRequestedArguments(): ArgumentThing[];
}
/**
 * Represents a fork in the Dialog Flow based on Condition. Expressions after receiving a ConditionalBranch
 * are the expressions contained within the if OR within the else. {@link Flow.interpret} will call your
 * callback once if there is no `else` and twice if there is.
 */
export declare class ConditionalBranch extends BaseExpression<ask.Condition> {
    readonly expr: Thing | undefined;
    readonly kind: "Condition";
    constructor(prev: Expression | undefined, flow: Flow<ask.Condition>, expr: Thing | undefined);
}
export {};
//# sourceMappingURL=expression.d.ts.map