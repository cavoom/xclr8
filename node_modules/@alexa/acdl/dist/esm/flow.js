import immutable from "immutable";
import * as ask from "./ast";
import { TypeChecker } from "./checker";
import { ArgumentsThing, ListThing, ObjectThing } from "./thing";
import { BlockExpression, ConditionalBranch, ConfirmAction, ConfirmArgs, DelegateRequest, DelegateToIntent, DialogExpansion, End, Ensure, Expect, InvokeApi, Response, } from "./expression";
import { Apply } from "./apply";
export class Flow {
    constructor(
    /**
     * Type Checker environment for this branch.
     */
    checker, 
    /**
     * The next expression in this branch sequence.
     */
    expression, 
    /**
     * Branch before this node.
     */
    prev, 
    /**
     * Node to continue the branch from
     */
    stack, 
    /**
     * Map of node to resolved Thing at this point in the branch.
     */
    things = immutable.Map(), 
    /**
     * Maps a TypeParameter to its concrete Type.
     */
    types = immutable.Map()) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "expression", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: expression
        });
        Object.defineProperty(this, "prev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: prev
        });
        Object.defineProperty(this, "stack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: stack
        });
        Object.defineProperty(this, "things", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: things
        });
        Object.defineProperty(this, "types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types
        });
    }
    /**
     * This function will walk over each dialog flow, parse each ASKIR {@link ask.Expression} into a
     * high-level {@link Expression} class and call the provided call back.
     *
     * Those Expressions represent concepts like {@link Expect}, {@link InvokeApi}, {@link ConditionalBranch}, {@link DialogExpansion}, etc.
     *
     * The most basic usage:
     * ```
     * flow.interpret(function interpret(expr): InterpretResult<boolean> {
     *   // process this expression in the stream
     *   const result = process(expr);
     *   if (result !== undefined) {
     *      // terminate the interpreter and end with this result
     *      return result;
     *   }
     *   // return a callback to handle the next expression after this one in the stream.
     *   return interpret;
     * })
     * ``
     *
     * Usually, you want to track some state. Do this with recursive closures. Below,
     * we track a variable, `seenEvent`, which we'll set to true if we come across an Expect event.
     *
     * At the end of the Dialog Flow stream, we'll return this value.
     * ```
     * get a list of booleans indicating if each branch in this Dialog Flow contains an Expect event.
     * const seenEvents = flow.interpret(function interpret(expr, seenEvent = false) {
     *   if (expr.isExpect()) {
     *     // if we receive an Expect event, we'll return a closure that sets the seenEvent variable to `true`.
     *     return (nextExpr) => interpret(nextExpr, true)
     *   } else if (expr.isEnd()) {
     *     // at the end, we'll return the result
     *     return seenEvent;
     *   } else {
     *     // otherwise, recursively process the next expression and pass along the `seenEvent` state.
     *     return (nextExpr) => interpret(nextExpr, seenEvent);
     *   }
     * })
     *
     * if (seenEvents.find(seenEvent => seenEvent === true) {
     *   // all
     * }
     * ```
     *
     * @param interpreter callback function to interpret the next Expression and return a
     * @param prev the previous Expression seen in this interpreter stream.
     * @returns a list of {@link State} objects, one for each branch in the Dialog Flow stream.
     */
    interpret(interpreter, prev) {
        return this.walkEachBranch((flow) => {
            const expr = getExpression();
            if (expr !== undefined) {
                const next = interpreter(expr);
                if (typeof next === "function") {
                    return flow.interpret(next, expr);
                }
                return [next];
            }
            // this node does not define an expression that should be evaluated, so we skip to the next one.
            return flow.interpret(interpreter, prev);
            function getExpression() {
                var _a, _b, _c, _d, _e, _f;
                if (flow.expression === undefined) {
                    return new End(prev, flow);
                }
                if (flow.expression.kind === "Condition") {
                    return new ConditionalBranch(prev, flow, flow.checker.getThing(flow.expression.when));
                }
                if (flow.expression.kind === "Call") {
                    const apply = flow.checker.getApply(flow.expression);
                    if (apply === undefined) {
                        return undefined;
                    }
                    if (apply.isResponse()) {
                        return new Response(prev, flow, apply, apply.getArgumentValueThing("response"), apply.getArgumentValueThing("act"), apply.getArgumentValueThing("nextAct"), apply.getArgumentValueThing("payload"), (_a = apply.getArgumentValueThing("surfaceForm")) === null || _a === void 0 ? void 0 : _a.asString());
                    }
                    if (apply.isConfirmAction()) {
                        return new ConfirmAction(prev, flow, apply.getArgumentValueThing("response"), (_b = apply.getArgumentValueThing("actionName")) === null || _b === void 0 ? void 0 : _b.asAction(), apply.getArgumentValueThing("payload"));
                    }
                    if (apply.isConfirmArgs()) {
                        return new ConfirmArgs(prev, flow, (_c = apply.getArgumentValueThing("confirmArgs")) === null || _c === void 0 ? void 0 : _c.asList());
                    }
                    if (apply.isEnsure()) {
                        return new Ensure(prev, flow, (_d = apply.getArgumentValueThing("requestArgs")) === null || _d === void 0 ? void 0 : _d.asList());
                    }
                    if (apply.isExpect()) {
                        return new Expect(prev, flow, apply.getArgumentValueThing("act"), apply.getArgumentValueThing("event"));
                    }
                    if (apply.isDelegateRequest()) {
                        return new DelegateRequest(prev, flow, apply, apply.getArgumentValueThing("updatedRequest"));
                    }
                    if (apply.isDelegateToIntent()) {
                        return new DelegateToIntent(prev, flow, apply, apply.getArgumentValueThing("intent"), apply.getArgumentValueThing("slots"));
                    }
                    if (apply.isUserDefinedApi()) {
                        const action = (_e = flow.checker.getThing(flow.checker.lookupCallDeclaration(apply.call))) === null || _e === void 0 ? void 0 : _e.asAction();
                        return new InvokeApi(prev, flow, action, apply.getArgumentsThing());
                    }
                    if (apply.isDialog()) {
                        const dialog = (_f = flow.checker.getThing(flow.checker.lookupCallDeclaration(apply.call))) === null || _f === void 0 ? void 0 : _f.asDialog();
                        return new DialogExpansion(prev, flow, dialog, apply.getArgumentsThing());
                    }
                }
                else if (flow.expression.kind === "Block") {
                    return new BlockExpression(prev, flow);
                }
                return undefined;
            }
        });
    }
    /**
     * Push a Call or Condition node onto the Call Stack.
     *
     * @param node Call or Condition node to push onto the STack.
     * @returns a new Dialog Flow representing the environment within the Call or Condition
     */
    push(node) {
        return new Flow(this.checker, node, this, [node, ...this.stack], this.things);
    }
    /**
     * Steps to the next {@link expr} in the Dialog Flow.
     *
     * @param expr next expression in the flow
     * @returns a new Flow starting from the next {@link expr}
     */
    step(expr) {
        return new Flow(this.checker, expr, this, this.stack, expr ? this.things.set(expr, this.checker.getThing(expr)) : this.things);
    }
    /**
     * Walks back up the Stack to create a Flow continuing with the return value and next expression.
     *
     * @param returnValue the value returned from this Frame
     * @return Flow a new Data Flow reprsenting the continuation of this Flow after returning the value.
     */
    pop(returnValue) {
        var _a, _b;
        let { things } = this;
        let next;
        let stack;
        const checker = new TypeChecker(this.checker.project, this.checker, this.things, this.types);
        // this code walks up the list of nodes in the call stack and sets the Thing value of each node to the `returnValue`,
        // it is implemented as low-level for and while loops to minimize stack frame allocation as this function is often called within
        // the highly recursive environment of Flow.interpret and Flow.walkEachBranch.
        for (let i = 0; i < this.stack.length; i++) {
            let frameNode = this.stack[i];
            let thing = returnValue;
            if (hasFunctions(returnValue)) {
                // if the returnValue's type contains Function definitions, we need to map the actual Function value's interface
                // to the interface expected by this environment
                thing = (_a = mapInterface(checker, returnValue, this.checker.root.getType(frameNode))) !== null && _a !== void 0 ? _a : thing;
            }
            checker.localThingIndex.set(frameNode, thing);
            things = things.set(frameNode, thing);
            if (frameNode !== undefined) {
                next = frameNode.next;
                if (next === undefined) {
                    // there was no adjacent expression, we will now walk up the context tree
                    // if we encounter a Block, then we break out of the loop and continue unrolling the stack (encountering a Block in the context should trigger a RETURN)
                    while (frameNode !== undefined && frameNode.kind !== "Block") {
                        if (frameNode.kind === "PropertyReference") {
                            // encountered a property reference, extract the property
                            // e.g, DialogCall().prop
                            thing = thing.getProperty(frameNode.name);
                        }
                        else if (frameNode.kind === "Call") {
                            const apply = this.checker.getApply(frameNode);
                            if (apply === null || apply === void 0 ? void 0 : apply.isGetListItem()) {
                                // we encountered a list index, e.g, DialogCall()[0], extract the item from the returned list
                                const index = (_b = apply.getArgumentValueThing("index")) === null || _b === void 0 ? void 0 : _b.asNumber();
                                if (index) {
                                    thing = thing.getItem(index);
                                }
                            }
                        }
                        // overwrite the mapping of Node->Thing in this environment
                        checker.localThingIndex.set(frameNode, thing);
                        things = things.set(frameNode, thing);
                        if (frameNode.next) {
                            // after un-rolling the stack, we found an adjacent node in a Block, we should stop unrolling here
                            next = frameNode.next;
                            break;
                        }
                        frameNode = frameNode.context;
                    }
                }
                if (next !== undefined) {
                    // pop the frames off of the stack.
                    stack = this.stack.slice(i + 1);
                    break;
                }
            }
        }
        return new Flow(checker, next, this, stack !== null && stack !== void 0 ? stack : [], things);
    }
    /**
     * Fork this Dialog Flow into a new dialog flow, starting from this {@link expr}.
     * @param expr expression from which we need to fork the dialog, e.g. a Call to a Dialog or Condition branch.
     * @returns a new Flow starting with the first expression in the forked Dialog Flow.
     */
    fork(expr) {
        var _a, _b, _c, _d;
        if (expr.kind === "Call") {
            const apply = this.checker.getApply(expr);
            if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
                const args = apply.getArguments();
                const genericArgs = apply.getGenericArguments();
                const decl = apply.decl.kind === "DialogDeclaration" ? apply.decl : apply.decl.declaration;
                // resolve the generic arguments and map the TypeParameter nodes to the concrete types
                const types = (_b = (_a = decl.genericArguments) === null || _a === void 0 ? void 0 : _a.map((typeParameter, i) => { var _a; return immutable.Map([[typeParameter, (_a = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs[i]) !== null && _a !== void 0 ? _a : null]]); }).reduce((a, b) => a.merge(b), this.types)) !== null && _b !== void 0 ? _b : immutable.Map();
                const checker = new TypeChecker(this.checker.project, this.checker, this.things, types);
                // plumb the arguments through from the previous frame.
                const things = (_d = (_c = decl.arguments) === null || _c === void 0 ? void 0 : _c.map((arg) => {
                    var _a, _b, _c, _d;
                    let thing;
                    if (((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) && (args === null || args === void 0 ? void 0 : args[(_b = arg.name) === null || _b === void 0 ? void 0 : _b.name])) {
                        thing = apply.getArgumentValueThing(arg.name.name);
                    }
                    else if (((_c = arg.name) === null || _c === void 0 ? void 0 : _c.name) && arg.defaultExpression) {
                        thing = this.checker.root.getThing(arg.defaultExpression);
                    }
                    if (hasFunctions(thing)) {
                        // if the argument's type contains Function definitions, we need to map the actual Function value's interface
                        // to the interface expected by this environment
                        thing = (_d = mapInterface(checker, thing, this.checker.root.getType(arg))) !== null && _d !== void 0 ? _d : thing;
                    }
                    // HACK: mutate the localThingIndex of Node->Thing in the next TypeChecker environment
                    checker.localThingIndex.set(arg, thing);
                    return immutable.Map().set(arg, thing !== null && thing !== void 0 ? thing : null);
                }).reduce((a, b) => a.merge(b), this.things)) !== null && _d !== void 0 ? _d : this.things;
                return new Flow(checker, decl, this, this.stack, things, types);
            }
        }
        return new Flow(new TypeChecker(this.checker.project, this.checker, this.things, this.types), expr, this, this.stack, this.things, this.types);
    }
    visitPrevious(hook) {
        if (this.prev) {
            return hook(this.prev);
        }
        return hook(undefined);
    }
    walkEachBranch(hook) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        let node = this.expression;
        if (node === undefined) {
            return hook(this);
        }
        if (node.kind === "DialogDeclaration") {
            return (_b = (_a = node.samples) === null || _a === void 0 ? void 0 : _a.map((sample) => hook(this.step(sample))).reduce((a, b) => a.concat(b), [])) !== null && _b !== void 0 ? _b : [];
        }
        if (node.kind === "NameDeclaration") {
            if (node.expression) {
                return hook(this.step(node.expression));
            }
        }
        else if (node.kind === "Sample") {
            return hook(this.step(node.scope));
        }
        else if (node.kind === "Block") {
            if ((_c = node.expressions) === null || _c === void 0 ? void 0 : _c[0]) {
                return hook(this.step((_d = node.expressions) === null || _d === void 0 ? void 0 : _d[0]));
            }
        }
        else if (node.kind === "Condition") {
            if (((_f = (_e = node.then) === null || _e === void 0 ? void 0 : _e.expressions) === null || _f === void 0 ? void 0 : _f.length) && ((_h = (_g = node.else) === null || _g === void 0 ? void 0 : _g.expressions) === null || _h === void 0 ? void 0 : _h.length)) {
                return [
                    //
                    ...hook(this.push(node).fork(node.then)),
                    ...hook(this.push(node).fork(node.else)),
                ];
            }
            if ((_k = (_j = node.then) === null || _j === void 0 ? void 0 : _j.expressions) === null || _k === void 0 ? void 0 : _k.length) {
                return hook(this.push(node).step(node.then));
            }
            if ((_m = (_l = node.else) === null || _l === void 0 ? void 0 : _l.expressions) === null || _m === void 0 ? void 0 : _m.length) {
                return hook(this.push(node).step(node.else));
            }
        }
        else if (node.kind === "Call") {
            const apply = this.checker.getApply(node);
            if (apply !== undefined) {
                if (apply.isDialog()) {
                    return this.push(node).fork(node).walkEachBranch(hook);
                }
                if (apply.isGetListItem()) {
                    return hook(this.step(apply.getArgumentValue("list")));
                }
            }
        }
        else if (node.kind === "PropertyReference") {
            return hook(this.step(node.expression));
        }
        while (node !== undefined) {
            if (node.next) {
                return hook(this.step(node.next));
            }
            if (node.kind === "Block") {
                return hook(this.pop(this.checker.getThing(node)));
            }
            node = node.context;
        }
        return [];
    }
    /**
     * Returns true if the resetArgumentsAction resets the argument with value argValueThing. Returns false otherwise.
     * Example of false return:
     * ```
     * policies = [ResetArguments{arguments = [getWeather.arguments.cityName]}] //only reset cityName
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   getWeather(weatherRequest.cityName) // weatherRequest.cityName is reset
     * }
     * ```
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   people = expect(Invoke, getPeopleEvent)
     *   getWeather(weatherRequest.cityName, weatherRequest.date)
     *
     *   getWeather(weatherRequest.cityName, weatherRequest.date) // invalid since weatherRequest.cityName has been reset
     * }
     * ```
     * @param argValueThing 'Thing' object for the argument value we are validating
     * @param argumentActionName action name for the argument being validated
     * @param resetArgumentsAction {@link Apply} object for a an {@link Action} that has a corresponding ResetArguments policy
     * @param resetArgumentsPolicy the ResetArgumentsPolicy for the resetArgumentsAction
     * @param actionChecker checker for resetArgumentsAction
     * @returns true if the resetArgumentsAction resets the argument with value argValueThing which means:
     * 1) argumentActionName and resetArgumentsAction refer to the same action
     * 2) resetArgumentsAction is passed argValueThing
     * 3) resetArgumentsPolicy mentions the argument to which argValueThing is passed in resetArgumentsAction
     */
    doesResetArgumentsResetArgument(argValueThing, argumentActionName, resetArgumentsAction, resetArgumentsPolicy, actionChecker) {
        var _a;
        // when the action has ResetArguments policy, check whether the following three requirements are met:
        // 1. The action with the policy is the same as the action in the argument being validated
        if (((_a = resetArgumentsAction.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== argumentActionName) {
            return false;
        }
        const resetArgumentsActionArgs = resetArgumentsAction.getArguments() || {};
        // 2. The argument value being validated is passed to the action with the policy
        for (const [resetArgumentsActionArgName, resetArgumentsActionArgValue] of Object.entries(resetArgumentsActionArgs)) {
            const resetArgumentsActionArgValueThing = actionChecker.getThing(resetArgumentsActionArgValue.value);
            if (!(resetArgumentsActionArgValueThing === null || resetArgumentsActionArgValueThing === void 0 ? void 0 : resetArgumentsActionArgValueThing.equals(argValueThing))) {
                continue;
            }
            // 3. The policy resets the argument being validated
            for (const policyArgName of resetArgumentsPolicy.arguments) {
                if (policyArgName === resetArgumentsActionArgName)
                    return true;
            }
        }
        return false;
    }
    /**
     * check whether the input argValue has been reset
     * @param argValueThing argValue to check whether it has been reset
     * @param argumentActionDecl The action declaration of the action which use the input argValue
     * @returns
     */
    isArgumentReset(argValueThing, argumentActionDecl) {
        var _a;
        const argumentActionName = (_a = argumentActionDecl.name) === null || _a === void 0 ? void 0 : _a.name;
        if (!argumentActionName) {
            return false;
        }
        const policyInfo = this.checker.project.getPolicyInfo();
        if (policyInfo === undefined || policyInfo.size === 0) {
            // If there's no reset policy configured, directly return false
            return false;
        }
        let isResetByResetArguments = false;
        let resetAllArgumentsSeen = false;
        const resetAllArgumentsArguments = new Set();
        for (let previousExpression = this.prev; previousExpression; previousExpression = previousExpression === null || previousExpression === void 0 ? void 0 : previousExpression.prev) {
            if ((previousExpression === null || previousExpression === void 0 ? void 0 : previousExpression.expression) === undefined) {
                break;
            }
            if (previousExpression.expression.kind !== "Call") {
                continue;
            }
            const previousApply = previousExpression.checker.getApply(previousExpression.expression);
            if (previousApply === undefined) {
                continue;
            }
            if (!previousApply.isUserDefinedApi()) {
                continue;
            }
            const actionName = previousApply.getName();
            if (!actionName) {
                continue;
            }
            const policyForCall = policyInfo.get(actionName);
            if (policyForCall) {
                if (policyForCall.type === "ResetArguments") {
                    if (this.doesResetArgumentsResetArgument(argValueThing, argumentActionName, previousApply, policyForCall, previousExpression.checker)) {
                        isResetByResetArguments = true;
                        break;
                    }
                }
                else if (policyForCall.type === "ResetAllArguments") {
                    resetAllArgumentsSeen = true;
                }
            }
            const previousCallArguments = previousApply.getArguments() || {};
            if (resetAllArgumentsSeen) {
                for (const resetArgumentsActionArgValue of Object.values(previousCallArguments)) {
                    const previousCallArgThing = previousExpression.checker.getThing(resetArgumentsActionArgValue.value);
                    if (!previousCallArgThing) {
                        continue;
                    }
                    resetAllArgumentsArguments.add(previousCallArgThing.token);
                }
            }
            continue;
        }
        if (isResetByResetArguments) {
            return true;
        }
        return resetAllArgumentsArguments.has(argValueThing.token);
    }
}
/**
 * Because of the unfortunate requirement of ACDL to reference an Action by its arguments. E.g. MyAction.arguments.argName
 * The abstract representation of a Function, e.g. `Function1<String, Void>`, does not capture the argument names,
 *
 * This function, `mapInterface`, maps between these interfaces. It is used by {@link Flow} when pushing or popping
 * a stack frame. This is because the expected interface of a caller or calee may be different than the actual value
 * during evaluation.
 *
 * Note: this code will mutate the TypeChecker instance passed into it. This is because we need a TypeChecker instance
 * prior constructing a Thing with a mapped interface. This is unfortuante and quite hacky, but it works for now.
 *
 * @param checker TypeChecker environment of the environment being mapped into into.
 * @param thing value of the Thing to map into the environment
 * @param type type of the Thing required in this environment
 * @returns a Thing with a mapped interface
 */
function mapInterface(checker, thing, type) {
    var _a, _b;
    if (type !== undefined && thing !== undefined) {
        if (thing.isFunction() && type.isFunctionN()) {
            return thing.withArgumentNameMappings(type.getFunctionArgumentDeclarationMappings(thing.type));
        }
        if (thing.isArguments()) {
            return new ArgumentsThing(checker, thing.token, thing.type, thing.origin, (_b = mapInterface(checker, thing.parent, (_a = thing.type.genericArguments) === null || _a === void 0 ? void 0 : _a[0])) === null || _b === void 0 ? void 0 : _b.asFunction());
        }
        if (thing.isLiteral()) {
            // Literal Lists and Objects may contain literal Function references that need to be mapped, so we recurse over them.
            if (thing.isObject() && type.isObject()) {
                const props = thing.getProperties();
                if (props) {
                    Object.entries(props).forEach(([propName, propThing]) => {
                        var _a;
                        const arg = thing.apply.getArgument(propName);
                        propThing = (_a = mapInterface(checker, propThing, type.getPropertyType(propName))) !== null && _a !== void 0 ? _a : propThing;
                        if (propThing && arg) {
                            // here, we override the mapping between the arg Node and the Thing value
                            checker.localThingIndex.set(arg, propThing);
                            if (arg.value) {
                                checker.localThingIndex.set(arg.value, propThing);
                            }
                        }
                    });
                }
                return new ObjectThing(checker, thing.token, thing.type, new Apply(checker, thing.apply.call, thing.apply.decl), thing.origin, thing.parent, thing.loc, thing.uri);
            }
            if (thing.isList()) {
                if (ask.isListLiteral(thing.apply.call.arguments)) {
                    thing.apply.call.arguments.items.forEach((item, i) => {
                        if (item.item) {
                            const itemThing = mapInterface(checker, thing.getItem(i), type.getListItemType());
                            if (itemThing) {
                                // here, we override the mapping between the ListItem Nodes and the Thing value
                                checker.localThingIndex.set(item, itemThing);
                                checker.localThingIndex.set(item.item, itemThing);
                            }
                        }
                    });
                }
                return new ListThing(checker, thing.token, thing.type, new Apply(checker, thing.apply.call, thing.apply.decl), thing.origin, thing.parent, thing.loc, thing.uri);
            }
        }
    }
    return thing;
}
/**
 * Determines if a Type or Thing contains Function types as properties.
 */
function hasFunctions(thing, seen = immutable.Set()) {
    if (thing === undefined) {
        return undefined;
    }
    if (thing.kind === "Thing") {
        return hasFunctions(thing.type, seen);
    }
    if (seen.has(thing)) {
        return undefined;
    }
    seen = seen.add(thing);
    if (thing.isFunction()) {
        return true;
    }
    if (thing.isObject()) {
        for (const prop of thing.properties) {
            if (hasFunctions(prop.type, seen)) {
                return true;
            }
        }
    }
    else if (thing.isList()) {
        return hasFunctions(thing.getListItemType(), seen);
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxvdy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxNQUFNLFdBQVcsQ0FBQztBQUVsQyxPQUFPLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQztBQUU3QixPQUFPLEVBQWEsV0FBVyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2xELE9BQU8sRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBUSxNQUFNLFNBQVMsQ0FBQztBQUN0RSxPQUFPLEVBQ0wsZUFBZSxFQUNmLGlCQUFpQixFQUNqQixhQUFhLEVBQ2IsV0FBVyxFQUNYLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsZUFBZSxFQUNmLEdBQUcsRUFDSCxNQUFNLEVBQ04sTUFBTSxFQUVOLFNBQVMsRUFDVCxRQUFRLEdBQ1QsTUFBTSxjQUFjLENBQUM7QUFFdEIsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFNBQVMsQ0FBQztBQVM5QixNQUFNLE9BQU8sSUFBSTtJQUNmO0lBQ0U7O09BRUc7SUFDTSxPQUFvQjtJQUM3Qjs7T0FFRztJQUNNLFVBQWE7SUFDdEI7O09BRUc7SUFDTSxJQUFzQjtJQUMvQjs7T0FFRztJQUNNLEtBQW1DO0lBQzVDOztPQUVHO0lBQ00sU0FBUyxTQUFTLENBQUMsR0FBRyxFQUEwQjtJQUN6RDs7T0FFRztJQUNNLFFBQVEsU0FBUyxDQUFDLEdBQUcsRUFBa0M7Ozs7O21CQXBCdkQ7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOztJQUNSLENBQUM7SUFFSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ErQ0c7SUFDSSxTQUFTLENBQ2QsV0FBeUQsRUFDekQsSUFBNkI7UUFFN0IsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxFQUFXLEVBQUU7WUFDM0MsTUFBTSxJ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