import * as path from "path";
import * as immutable from "immutable";
import { TypeChecker } from "./checker";
import { evaluateDialogFlow } from "./evaluate";
import { Flow } from "./flow";
import { loadSkillContext } from "./skill-context";
import { EvaluationState } from "./evaluation-state";
import { visitEachChild, visitEachChildType } from "./visit";
import { ValidationErrorFactory } from "./error-factory";
/**
 * Validates a com.amazon.alexa.ask.conversations.skill data structure.
 *
 * 1. It must contain a list of Dialogs with at least one item.
 * 2. If taskContextProjectionInfo is specified, then its contents must be valid. (see validateSki)
 */
export function validateSkill(skill, checker) {
    const errors = [];
    const skillContext = loadSkillContext(skill);
    errors.push(...validateLoadContextAction(skillContext), ...validateSaveContextAction(skillContext), ...validateTrackActions(skillContext));
    const dialogs = checker.project.getRootDialogs();
    if (dialogs === undefined || dialogs.length === 0) {
        const dialogsArray = skill.getArgumentValueThing("dialogs");
        if (dialogsArray !== undefined) {
            // if dialogs array exist, report this error on dialog array loc
            errors.push(ValidationErrorFactory.NoDialogsInSkill({
                expr: dialogsArray.origin,
            }));
        }
        else {
            errors.push(ValidationErrorFactory.NoDialogsInSkill());
        }
    }
    else {
        for (const rootDialog of dialogs) {
            const flow = new Flow(new TypeChecker(skill.checker.project), rootDialog, undefined, []);
            errors.push(...evaluateDialogFlow(flow, new EvaluationState(skillContext)));
        }
    }
    // validate skill locales
    errors.push(...validateSkillLocale(skill, checker));
    // validate skill policies
    errors.push(...validateSkillPolicy(skill, checker));
    return errors;
}
/**
 * validate the policy info in the skill action
 * 1. make sure there's no ResetArguments and ResetAllArguments point to the same api
 * 2. make sure the EnsureArgOrder policy not conflict
 * @param skill
 * @param checker
 * @returns
 */
export function validateSkillPolicy(skill, checker) {
    const errors = [];
    const policies = skill.getArgumentValueThing("policies");
    const policyItems = (policies === null || policies === void 0 ? void 0 : policies.isList()) && policies.isLiteral() ? policies.getListItems() : [];
    const actionsUsedInResetAllArguments = new Map();
    // first loop: record action names used in ResetAllArguments policies
    policyItems === null || policyItems === void 0 ? void 0 : policyItems.forEach((item) => {
        var _a, _b, _c, _d, _e;
        const itemThing = checker.getThing(item);
        if ((_a = itemThing === null || itemThing === void 0 ? void 0 : itemThing.apply) === null || _a === void 0 ? void 0 : _a.isResetAllArguments()) {
            const actionThing = itemThing.getProperty("action");
            if (actionThing === null || actionThing === void 0 ? void 0 : actionThing.isAction()) {
                if (checker.isNameReference(item === null || item === void 0 ? void 0 : item.item)) {
                    // if the item is a nameReference, record the nameReference's name for better error message
                    actionsUsedInResetAllArguments.set((_b = actionThing.name) === null || _b === void 0 ? void 0 : _b.name, (_d = (_c = item === null || item === void 0 ? void 0 : item.item) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name);
                }
                else {
                    actionsUsedInResetAllArguments.set((_e = actionThing.name) === null || _e === void 0 ? void 0 : _e.name, undefined);
                }
            }
        }
    });
    // second loop: check all ResetArguments type policy doesn't use action which already use ResetAllArguments policy
    policyItems === null || policyItems === void 0 ? void 0 : policyItems.forEach((item) => {
        var _a, _b, _c, _d, _e;
        const itemThing = checker.getThing(item);
        if ((_a = itemThing === null || itemThing === void 0 ? void 0 : itemThing.apply) === null || _a === void 0 ? void 0 : _a.isResetArguments()) {
            const argumentsValueThing = itemThing.getProperty("arguments");
            if ((argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.isLiteral()) && argumentsValueThing.isList()) {
                const items = argumentsValueThing.getItems();
                if (items && items.length >= 1 && ((_d = (_c = (_b = items[0]) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.isAction())) {
                    const actionName = (_e = items[0].parent.parent.name) === null || _e === void 0 ? void 0 : _e.name;
                    if (actionsUsedInResetAllArguments.has(actionName)) {
                        const policyName = actionsUsedInResetAllArguments.get(actionName);
                        const errorArguments = {
                            expr: item === null || item === void 0 ? void 0 : item.item,
                            attributes: {
                                actionName,
                                policyName,
                            },
                        };
                        errors.push(policyName !== undefined
                            ? ValidationErrorFactory.InvalidPolicyWithPolicyName(errorArguments)
                            : ValidationErrorFactory.InvalidPolicy(errorArguments));
                    }
                }
            }
        }
    });
    errors.push(...validateEnsureArgOrder(policies, checker));
    return errors;
}
/**
 * validate the EnsureArgOrder policies are not conflict
 *
 * E.G. Below is a invalid case where we can't figure out the order of 'cityName' and 'date'
 * ```
 * EnsureArgOrder(getWeather.arguments.cityName, getWeather.arguments.date)
 * EnsureArgOrder(getWeather.arguments.date, getWeather.arguments.cityName)
 * ```
 *
 * Feature request link: https://github.com/alexa/ask-ac/issues/554
 * @param policyItems
 * @param checker
 * @returns
 */
export function validateEnsureArgOrder(policies, checker) {
    var _a, _b, _c, _d, _e, _f;
    const errors = [];
    const policyItems = (_b = (_a = policies === null || policies === void 0 ? void 0 : policies.asLiteralList()) === null || _a === void 0 ? void 0 : _a.getItems()) !== null && _b !== void 0 ? _b : [];
    if (policyItems === undefined || policyItems.length === 0) {
        return errors;
    }
    // go through all the EnsureArgOrder policy and build the order graph
    const parentToChild = new Map();
    // record the token to Argument Thing, this map is used to provide better error message
    const tokenToArgumentThing = new Map();
    for (const policyItem of policyItems) {
        if ((_c = policyItem === null || policyItem === void 0 ? void 0 : policyItem.apply) === null || _c === void 0 ? void 0 : _c.isEnsureArgOrder()) {
            const argumentsValueThing = policyItem.getProperty("arguments");
            const items = (_e = (_d = argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.asLiteralList()) === null || _d === void 0 ? void 0 : _d.getItems()) !== null && _e !== void 0 ? _e : [];
            if (items && items.length >= 2) {
                for (let i = 0; i < items.length - 1; i++) {
                    const curItem = items[i];
                    const nextItem = items[i + 1];
                    if (curItem === undefined || nextItem === undefined || !curItem.isArgument() || !nextItem.isArgument()) {
                        // If the item in the array is not valid, skip this validation
                        return errors;
                    }
                    if (!parentToChild.has(curItem.token)) {
                        parentToChild.set(curItem.token, [nextItem]);
                        tokenToArgumentThing.set(curItem.token, curItem);
                    }
                    else {
                        (_f = parentToChild.get(curItem.token)) === null || _f === void 0 ? void 0 : _f.push(nextItem);
                    }
                }
            }
        }
    }
    // check each node in the graph to make sure there's no circular reference
    // memo is used to record visited node's circular reference info thus we could avoid revisit same node again
    const memo = new Map();
    for (const token of parentToChild.keys()) {
        if (!memo.has(token)) {
            const circularReference = findCircularReference(token, immutable.Set());
            const circularReferenceArgsFlow = circularReference === null || circularReference === void 0 ? void 0 : circularReference.map((token) => {
                var _a;
                const argThing = tokenToArgumentThing.get(token);
                return `'${(_a = argThing === null || argThing === void 0 ? void 0 : argThing.action) === null || _a === void 0 ? void 0 : _a.actionName}.arguments.${argThing === null || argThing === void 0 ? void 0 : argThing.argumentName}'`;
            });
            if (circularReferenceArgsFlow !== undefined && circularReferenceArgsFlow.length > 0) {
                errors.push(ValidationErrorFactory.InvalidEnsureArgOrder({
                    expr: policies,
                    attributes: {
                        firstArgument: circularReferenceArgsFlow[0],
                        argumentsFlow: circularReferenceArgsFlow.join("-->"),
                    },
                }));
            }
        }
    }
    return errors;
    // DFS to find circular reference for a node
    function findCircularReference(start, seen) {
        if (seen.has(start)) {
            memo.set(start, true);
            return generateCircularReferenceFlow(seen, start);
        }
        seen = seen.add(start);
        const children = parentToChild.get(start);
        if (children === undefined || children.length === 0) {
            seen = seen.delete(start);
            memo.set(start, false);
            return undefined;
        }
        for (const child of children) {
            // we don't want to report same circle again, thus no matter this token has circularReference or not,
            // if we have handled the token already, we could skip
            if (!memo.has(child.token)) {
                const circularReference = findCircularReference(child.token, seen);
                if (circularReference !== undefined) {
                    memo.set(start, true);
                    return circularReference;
                }
            }
        }
        seen = seen.delete(start);
        memo.set(start, false);
        return undefined;
    }
}
function generateCircularReferenceFlow(seen, duplicateToken) {
    const circularReferenceFlow = [];
    let findDuplicate = false;
    seen.forEach((token) => {
        if (!findDuplicate) {
            if (token === duplicateToken) {
                findDuplicate = true;
                circularReferenceFlow.push(token);
            }
        }
        else {
            circularReferenceFlow.push(token);
        }
    });
    circularReferenceFlow.push(duplicateToken);
    return circularReferenceFlow;
}
/**
 * validate the locale info in the skill action
 * 1. There must exist deployable dialog for all specified locales
 * 2. There must exist InteractionModel for all specified locales
 * 3. At least one locale need to be specified for a skill
 * 4. The samples in a dialog must have all required locales for the dialog
 * 5. All the nameRef used in a sample must support all the locales the sample use
 * @param skill
 * @param checker
 * @returns
 */
export function validateSkillLocale(skill, checker) {
    var _a;
    const errors = [];
    const dialogs = skill.getArgumentValueThing("dialogs");
    const locales = skill.getArgumentValueThing("locales");
    const skillResponses = skill.getArgumentValueThing("skillLevelResponses");
    const dialogItems = (_a = checker.project.getRootDialogs()) === null || _a === void 0 ? void 0 : _a.map((dialogDecl) => checker.getThing(dialogDecl));
    const localeItems = (locales === null || locales === void 0 ? void 0 : locales.isList()) && locales.isLiteral() ? locales.getItems() : [];
    if (localeItems !== undefined && localeItems.length > 0) {
        // record required locales set by reading the all the localeItems in the locale list
        const requiredLocales = new Set(localeItems
            .map((locale) => {
            var _a;
            if (((_a = locale === null || locale === void 0 ? void 0 : locale.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name" && locale.origin.name) {
                return locale.origin.name;
            }
            return undefined;
        })
            .filter((s) => s !== undefined));
        errors.push(...validateDialogLocale(requiredLocales, dialogItems));
        errors.push(...validateSkillResponseLocale(requiredLocales, skillResponses, checker));
        errors.push(...validateInteractionModelLocale(requiredLocales, checker));
        errors.push(...validateModuleScopeNameDeclarationsLocale(requiredLocales, checker));
    }
    else {
        errors.push(ValidationErrorFactory.MissingLocale({
            expr: locales === null || locales === void 0 ? void 0 : locales.origin,
        }));
    }
    return errors;
    /**
     * validate all nameDecls' locale info under module scope
     * make sure the slotType used in nameDecl is consistent with locale annotations
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM
     * ```
     * @locale(Locale.en_US)
     * a = apla<deOnlySlot>("./apla")
     *
     * This is invalid because deOnlySlot not exist in en_US IM, but the locale annotation include en_US
     * ```
     *
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     *
     * @locale(Locale.en_US)
     * a = utterances<myType>([
     *   "hello world"
     * ])
     *
     * This is invalid because myType use slotType deOnlySlot which does not exist in en_US IM, but the locale annotation include en_US
     * ```
     */
    function validateModuleScopeNameDeclarationsLocale(defaultLocales, checker) {
        const errors = [];
        const nameDecls = checker.getAllModuleScopeNameDeclarations();
        for (const nameDecl of nameDecls) {
            const annotatedLocales = checker.collectLocaleInfo(nameDecl);
            if (annotatedLocales.length === 0) {
                // if no locale annotation, default to skill action's locale config
                defaultLocales.forEach((locale) => annotatedLocales.push(locale));
            }
            visitEachChild(nameDecl, function visit(node) {
                if (node.kind === "TypeReference") {
                    const thing = checker.getThing(node);
                    errors.push(...validateTypeAgainstRequiredLocales(thing === null || thing === void 0 ? void 0 : thing.type, annotatedLocales, node));
                }
                visitEachChild(node, visit);
            });
        }
        return errors;
    }
    /**
     * check whether the type depends on any slotType which not exist in the IM for required locales
     * E.G.
     * ```
     * type myType {
     *  optional deOnlySlot german
     * }
     *
     * validateTypeAgainstRequiredLocales(myType) will check deOnlySlot exist in all the required locales' IM
     * ```
     *
     * ```
     * type myType2 {
     *  myType name
     * }
     *
     * validateTypeAgainstRequiredLocales(myType2) will check deOnlySlot exist in all the required locales' IM
     * ```
     * @param type The type which we want to check whether it contains invalid slotType
     * @param requiredLocales The Array lof all required locales, a used slotType must exist in all corresponding IMs
     * @param node The origin node where depends on this type, thus we could use it's loc to report error
     * @returns
     */
    function validateTypeAgainstRequiredLocales(type, requiredLocales, node) {
        var _a, _b, _c;
        const errors = [];
        const seen = new Set();
        if (type === null || type === void 0 ? void 0 : type.isSlotType()) {
            errors.push(...validateSlotTypeAgainstRequiredLocales(type.declaration, requiredLocales, node));
        }
        else if (type === null || type === void 0 ? void 0 : type.properties) {
            for (const property of type.properties) {
                if (((_b = (_a = property.type) === null || _a === void 0 ? void 0 : _a.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "SlotType") {
                    errors.push(...validateSlotTypeAgainstRequiredLocales((_c = property.type) === null || _c === void 0 ? void 0 : _c.declaration, requiredLocales, node));
                }
                else {
                    visitEachChildType(property.type, function checkSlotType(type) {
                        if (type.declaration && !seen.has(type.declaration)) {
                            if (!(type.isOptional() || type.isList())) {
                                seen.add(type.declaration);
                            }
                            if (type.declaration.kind === "SlotType") {
                                errors.push(...validateSlotTypeAgainstRequiredLocales(type === null || type === void 0 ? void 0 : type.declaration, requiredLocales, node));
                            }
                            visitEachChildType(type, checkSlotType);
                        }
                    });
                }
            }
        }
        return errors;
    }
    /**
     * check whether the SlotType exist in the IM for required locales
     * @param slotType
     * @param requiredLocales
     * @param node
     * @returns
     */
    function validateSlotTypeAgainstRequiredLocales(slotType, requiredLocales, node) {
        var _a, _b, _c, _d;
        const errors = [];
        const thing = checker.getThing(node);
        const availableLocales = slotType.locales;
        for (const requiredLocale of requiredLocales) {
            if (!availableLocales.includes(requiredLocale) && node.inferred !== true) {
                ((_a = thing === null || thing === void 0 ? void 0 : thing.type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType"
                    ? errors.push(ValidationErrorFactory.MissingSlotTypeForLocale({
                        expr: node,
                        attributes: {
                            slotTypeName: (_b = slotType.name) === null || _b === void 0 ? void 0 : _b.name,
                            locale: requiredLocale,
                        },
                    }))
                    : errors.push(ValidationErrorFactory.MissingSlotTypeForLocaleTypeDependency({
                        expr: node,
                        attributes: {
                            typeName: (_c = node.name) === null || _c === void 0 ? void 0 : _c.name,
                            slotTypeName: (_d = slotType.name) === null || _d === void 0 ? void 0 : _d.name,
                            locale: requiredLocale,
                        },
                    }));
            }
        }
        return errors;
    }
    function validateSkillResponseLocale(requiredLocales, skillResponses, checker) {
        const errors = [];
        if (skillResponses === null || skillResponses === void 0 ? void 0 : skillResponses.isLiteral()) {
            const args = skillResponses.apply.getArguments();
            if (args !== undefined) {
                Object.entries(args).map(([name, arg]) => {
                    var _a, _b;
                    if (((_a = arg.value) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = arg.value) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                        const locales = checker.collectLocaleInfo(arg.value);
                        // if there's no locale info, assume this prompt will be applied to all specified locales
                        // if locale info exist, make sure all required locales exist
                        if (locales.length > 0) {
                            const localesSet = new Set(locales);
                            requiredLocales.forEach((requiredLocale) => {
                                if (requiredLocale && !localesSet.has(requiredLocale)) {
                                    errors.push(ValidationErrorFactory.MissingSkillResponseForLocale({
                                        expr: arg === null || arg === void 0 ? void 0 : arg.value,
                                        attributes: {
                                            skillResponseName: name,
                                            locale: requiredLocale,
                                        },
                                    }));
                                }
                            });
                        }
                    }
                });
            }
        }
        return errors;
    }
    /**
     * validate all of required locales has corresponding IM
     */
    function validateInteractionModelLocale(requiredLocales, checker) {
        var _a;
        const errors = [];
        const interactionModelsPath = checker.project.source.interactionModels;
        // parse the locales from the file names
        const availableLocales = new Set((_a = interactionModelsPath === null || interactionModelsPath === void 0 ? void 0 : interactionModelsPath.map((interactionModel) => path.parse(interactionModel.file).name.replace("-", "_"))) !== null && _a !== void 0 ? _a : []);
        for (const requiredLocale of requiredLocales) {
            if (requiredLocale && !availableLocales.has(requiredLocale)) {
                errors.push(ValidationErrorFactory.MissingInteractionModelForLocale({
                    expr: locales === null || locales === void 0 ? void 0 : locales.origin,
                    attributes: {
                        locale: requiredLocale,
                    },
                }));
            }
        }
        return errors;
    }
    /**
     * all the required locales must have at least one dialog in the skill
     * @param requiredLocales A set which record all required locales (the locales used in skill action)
     * @param dialogItems dialog Thing array
     * @returns
     */
    function validateDialogLocale(requiredLocales, dialogItems) {
        const errors = [];
        const availableLocales = new Set();
        // record available locales set by go through all the deployable dialogs and read from locale annotations
        dialogItems === null || dialogItems === void 0 ? void 0 : dialogItems.forEach((dialog) => {
            if (dialog === null || dialog === void 0 ? void 0 : dialog.isDialog()) {
                const dialogLocales = new Set();
                const locales = recordLocalesFromAnnotations(dialog.origin.annotations, requiredLocales);
                locales.forEach((locale) => dialogLocales.add(locale));
                // go through all the samples and make sure all the dialogLocales exist
                errors.push(...validateSampleLocale(dialogLocales, dialog));
                dialogLocales.forEach((locale) => availableLocales.add(locale));
            }
        });
        // loop each required locale, and check if any deployable dialog use the locale
        requiredLocales.forEach((locale) => {
            if (!availableLocales.has(locale)) {
                errors.push(ValidationErrorFactory.NoDeployableDialogForLocale({
                    expr: dialogs === null || dialogs === void 0 ? void 0 : dialogs.origin,
                    attributes: {
                        locale,
                    },
                }));
            }
        });
        return errors;
    }
    /**
     * for all the locales used for the dialog, there must exist at least one sample in the dialog use that locale
     * @param dialogLocales A set which record all the locales for the dialog
     * @param dialog dialog Thing
     * @returns
     */
    function validateSampleLocale(dialogLocales, dialog) {
        var _a;
        const errors = [];
        const sampleLocales = new Set();
        (_a = dialog.origin.samples) === null || _a === void 0 ? void 0 : _a.forEach((sample) => {
            const locales = recordLocalesFromAnnotations(sample.annotations, dialogLocales);
            errors.push(...validateSampleExprLocale(locales, sample));
            locales.forEach((locale) => sampleLocales.add(locale));
        });
        // loop each required locale, and check if any deployable dialog use the locale
        dialogLocales.forEach((locale) => {
            var _a;
            if (!sampleLocales.has(locale)) {
                errors.push(ValidationErrorFactory.MissingSampleForLocale({
                    expr: dialog === null || dialog === void 0 ? void 0 : dialog.origin,
                    attributes: {
                        dialogName: (_a = dialog.origin.name) === null || _a === void 0 ? void 0 : _a.name,
                        locale,
                    },
                }));
            }
        });
        return errors;
    }
    /**
     * validate all nameReference used in a sample must support all the locales the sample support
     * E.G.
     * ```
     * @locale(Locale.en_US)
     * getWeatherEventUS = utterances<CityAndDate>(["xxx"])
     *
     * @locale(Locale.en_GB)
     * dialog Nothing WeatherInGerman {
     *     @locale(Locale.en_GB)
     *     sample {
     *         // This is invalid as getWeatherEventUS only support en_US without en_GB
     *         result = expect(Invoke, getWeatherEventUS)
     *     }
     * }
     * ```
     * @param sampleLocales The locales sample support
     * @param sample
     * @returns
     */
    function validateSampleExprLocale(sampleLocales, sample) {
        var _a, _b;
        const errors = [];
        (_b = (_a = sample.scope) === null || _a === void 0 ? void 0 : _a.expressions) === null || _b === void 0 ? void 0 : _b.forEach((expr) => {
            errors.push(...validateNodeAgainstRequiredLocales(expr, sampleLocales));
            visitEachChild(expr, function visit(node) {
                errors.push(...validateNodeAgainstRequiredLocales(node, sampleLocales));
                visitEachChild(node, visit);
            });
        });
        return errors;
    }
    /**
     * Validate all the node against all the required locales,
     * make sure the node doesn't depend on slotTypes which can't be used in the required locales
     *
     * @param node
     * @param requiredLocales
     * @returns
     */
    function validateNodeAgainstRequiredLocales(node, requiredLocales) {
        var _a;
        const errors = [];
        if (node.kind === "NameReference" || node.kind === "PropertyReference") {
            const locales = checker.collectLocaleInfo(node);
            // if locales is empty, then the locale will be default to skill actions' locale array
            // which means this name support all the locales we want to deploy, and thus no need to do the validations
            if (locales.length > 0) {
                requiredLocales.forEach((requiredLocale) => {
                    var _a;
                    if (requiredLocale && !locales.includes(requiredLocale)) {
                        errors.push(ValidationErrorFactory.InvalidLocaleInSampleNameOrProperty({
                            expr: node,
                            attributes: {
                                name: (_a = node.name) === null || _a === void 0 ? void 0 : _a.name,
                                locale: requiredLocale,
                            },
                        }));
                    }
                });
            }
        }
        else if (node.kind === "Call") {
            const apply = checker.getApply(node);
            const decl = apply === null || apply === void 0 ? void 0 : apply.decl;
            if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration" || (decl === null || decl === void 0 ? void 0 : decl.kind) === "DialogDeclaration") {
                const thing = checker.getThing(decl);
                if (((thing === null || thing === void 0 ? void 0 : thing.isAction()) && (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi())) || (thing === null || thing === void 0 ? void 0 : thing.isDialog())) {
                    const locales = thing.getLocales();
                    if (locales) {
                        requiredLocales.forEach((requiredLocale) => {
                            var _a;
                            if (requiredLocale && !locales.includes(requiredLocale)) {
                                const name = (_a = thing.name) === null || _a === void 0 ? void 0 : _a.name;
                                if (thing.isDialog()) {
                                    errors.push(ValidationErrorFactory.InvalidLocaleInSampleDialog({
                                        expr: node,
                                        attributes: {
                                            dialogName: name,
                                            locale: requiredLocale,
                                        },
                                    }));
                                }
                                else {
                                    errors.push(ValidationErrorFactory.InvalidLocaleInSampleAction({
                                        expr: node,
                                        attributes: {
                                            actionName: name,
                                            locale: requiredLocale,
                                        },
                                    }));
                                }
                            }
                        });
                    }
                }
            }
            else if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "Type") {
                const locales = decl.getLocales();
                if (locales) {
                    requiredLocales.forEach((requiredLocale) => {
                        var _a;
                        if (requiredLocale && !locales.includes(requiredLocale)) {
                            errors.push(ValidationErrorFactory.InvalidLocaleInSampleType({
                                expr: node,
                                attributes: {
                                    typeName: (_a = decl.name) === null || _a === void 0 ? void 0 : _a.name,
                                    locale: requiredLocale,
                                },
                            }));
                        }
                    });
                }
            }
        }
        else if (node.kind === "TypeReference") {
            const locales = (_a = checker.getType(node)) === null || _a === void 0 ? void 0 : _a.getLocales();
            if (locales) {
                requiredLocales.forEach((requiredLocale) => {
                    var _a;
                    if (requiredLocale && !locales.includes(requiredLocale)) {
                        errors.push(ValidationErrorFactory.InvalidLocaleInSampleType({
                            expr: node,
                            attributes: {
                                typeName: (_a = node.name) === null || _a === void 0 ? void 0 : _a.name,
                                locale: requiredLocale,
                            },
                        }));
                    }
                });
            }
        }
        return errors;
    }
    /**
     * Update the locale set based on the annotations
     * @param locales locale set which need to be updated based on locale annotation
     * @param annotations annotations array
     * @param defaultLocales the default locale set, which will be used when there's no locale annotation available
     */
    function recordLocalesFromAnnotations(annotations, defaultLocales) {
        let localeAnnotationExist = false;
        const locales = new Set();
        annotations === null || annotations === void 0 ? void 0 : annotations.forEach((ann) => {
            if (ann.kind === "Annotation" && ann.call.kind === "Call") {
                const apply = checker.getApply(ann.call);
                if (apply === null || apply === void 0 ? void 0 : apply.isLocaleAction()) {
                    localeAnnotationExist = true;
                    const annLocales = apply.getArgumentValueThing("locales");
                    if ((annLocales === null || annLocales === void 0 ? void 0 : annLocales.isList()) && annLocales.isLiteral()) {
                        const annLocaleItems = annLocales.getItems();
                        if (annLocaleItems !== undefined && annLocaleItems.length > 0) {
                            annLocaleItems.forEach((locale) => {
                                var _a;
                                if (((_a = locale === null || locale === void 0 ? void 0 : locale.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name") {
                                    locales.add(locale.origin.name);
                                }
                            });
                        }
                    }
                }
            }
        });
        if (!localeAnnotationExist) {
            // if there no locale annotation
            // fill the locales with default locales
            defaultLocales.forEach((locale) => locales.add(locale));
        }
        return locales;
    }
}
/**
 * Validate the `loadContext` action configured in a TaskContextProjectionInfo.
 *
 * 1. it cannot accept any arguments
 * 2. it cannot have any generic arguments
 * 3. the return type must be `com.amazon.alexa.ask.conversations.TaskContextProjection`.
 * 4. it must be a user-defined action and not a built-in action.
 */
export function validateLoadContextAction(context) {
    var _a, _b, _c, _d, _e;
    const errors = [];
    const expr = ((_a = context === null || context === void 0 ? void 0 : context.loadContextDeclaration) === null || _a === void 0 ? void 0 : _a.loc) ? context === null || context === void 0 ? void 0 : context.loadContextDeclaration : context === null || context === void 0 ? void 0 : context.skill.call;
    if (context === null || context === void 0 ? void 0 : context.loadContext) {
        const actionName = (_b = context.loadContext.name) === null || _b === void 0 ? void 0 : _b.name;
        if ((_c = context.loadContext.arguments) === null || _c === void 0 ? void 0 : _c.length) {
            errors.push(ValidationErrorFactory.InvalidLoadContextActionArguments({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        if ((_d = context.loadContext.genericArguments) === null || _d === void 0 ? void 0 : _d.length) {
            errors.push(ValidationErrorFactory.InvalidLoadContextActionGenericArguments({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        const returnType = context.loadContext.returnType
            ? context.skill.checker.getType(context.loadContext.returnType)
            : context.skill.checker.void;
        if (returnType && !returnType.isTaskContextProjection()) {
            errors.push(ValidationErrorFactory.InvalidLoadContextActionReturnType({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
    }
    else if ((_e = context === null || context === void 0 ? void 0 : context.loadContextThing) === null || _e === void 0 ? void 0 : _e.isNothing()) {
        errors.push(ValidationErrorFactory.InvalidLoadContextActionNoActionReference({
            expr,
        }));
    }
    return errors;
}
/**
 * Validate the `saveContext` action configured in a TaskContextProjectionInfo.
 *
 * 1. it cannot have any generic arguments.
 * 2. the return type must be `Nothing` or `Void`.
 * 3. it must have exactly one argument of type `TaskContextProjection`.
 * 4. it must be a user-defined action and not a built-in.
 */
export function validateSaveContextAction(context) {
    var _a, _b, _c, _d, _e;
    const errors = [];
    const expr = ((_a = context === null || context === void 0 ? void 0 : context.saveContextDeclaration) === null || _a === void 0 ? void 0 : _a.loc) ? context === null || context === void 0 ? void 0 : context.saveContextDeclaration : context === null || context === void 0 ? void 0 : context.skill.call;
    if (context === null || context === void 0 ? void 0 : context.saveContext) {
        const actionName = (_b = context.saveContext.name) === null || _b === void 0 ? void 0 : _b.name;
        if ((_c = context.saveContext.genericArguments) === null || _c === void 0 ? void 0 : _c.length) {
            errors.push(ValidationErrorFactory.InvalidSaveContextActionGenericArguments({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        const returnType = (_d = context.skill.checker.getType(context.saveContext)) === null || _d === void 0 ? void 0 : _d.getTypeType();
        if (returnType && !((returnType === null || returnType === void 0 ? void 0 : returnType.isVoid()) || (returnType === null || returnType === void 0 ? void 0 : returnType.isNothing()))) {
            errors.push(ValidationErrorFactory.InvalidSaveContextActionReturnType({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        if (context.saveContext.arguments === undefined ||
            context.saveContext.arguments.length === 0 ||
            context.saveContext.arguments.length > 1) {
            errors.push(ValidationErrorFactory.InvalidSaveContextActionArgumentType({
                expr,
                attributes: {
                    actionName,
                },
            }));
        }
        else {
            const argType = context.skill.checker.getType(context.saveContext.arguments[0]);
            if (argType && !argType.isTaskContextProjection()) {
                errors.push(ValidationErrorFactory.InvalidSaveContextActionArgumentType({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
        }
    }
    else if ((_e = context === null || context === void 0 ? void 0 : context.saveContextThing) === null || _e === void 0 ? void 0 : _e.isNothing()) {
        errors.push(ValidationErrorFactory.InvalidSaveContextActionNoActionReference({
            expr,
        }));
    }
    return errors;
}
/**
 * Validates the `trackActions` field configured in `TaskContextProjectionInfo`.
 *
 * 1. the list cannot be empty
 * 2. an action in the list cannot be the `loadContext` or the `saveContext` action.
 * 3. it must be a user-defined API and not a built-in action.
 */
export function validateTrackActions(context) {
    var _a, _b;
    const errors = [];
    if (context) {
        const { checker } = context.skill;
        const expr = context.trackActionsDeclaration ? context.trackActionsDeclaration : context.skill.call;
        if (((_a = context.trackActions) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            errors.push(ValidationErrorFactory.InvalidTrackActionsEmptyList({
                expr,
            }));
        }
        (_b = context.trackActions) === null || _b === void 0 ? void 0 : _b.forEach((action) => {
            var _a, _b, _c, _d, _e, _f;
            const actionFqn = checker.qualifyName(action, (_a = action.name) === null || _a === void 0 ? void 0 : _a.name);
            const actionName = (_b = action.name) === null || _b === void 0 ? void 0 : _b.name;
            if (actionFqn === ((_d = (_c = context.loadContext) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name)) {
                errors.push(ValidationErrorFactory.InvalidTrackActionsLoadContext({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
            else if (actionFqn === ((_f = (_e = context.saveContext) === null || _e === void 0 ? void 0 : _e.name) === null || _f === void 0 ? void 0 : _f.name)) {
                errors.push(ValidationErrorFactory.InvalidTrackActionsSaveContext({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
            const actionType = context.skill.checker.getType(action);
            if (actionType && !actionType.isCustom()) {
                errors.push(ValidationErrorFactory.InvalidTrackActionsBuiltIn({
                    expr,
                    attributes: {
                        actionName,
                    },
                }));
            }
        });
    }
    return errors;
}
/**
 * Validates the context of a call to `com.amazon.alexa.ask.conversations.skill`.
 *
 * 1. the result of the call must be assigned to a name, e.g. `name = skill(..)`.
 * 2. the call can only exist at the module scope, it cannot be within a dialog sample.
 */
export function validateSkillCallContext(skill) {
    if (skill.isSkillAction()) {
        if (skill.call.context.kind !== "NameDeclaration") {
            return [
                ValidationErrorFactory.InvalidSkillCallContextNameDeclaration({
                    expr: skill.call,
                }),
            ];
        }
        if (skill.call.context.context.kind !== "Module") {
            return [
                ValidationErrorFactory.InvalidSkillCallContextModuleScope({
                    expr: skill.call,
                }),
            ];
        }
    }
    return [];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtc2tpbGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdmFsaWRhdGUtc2tpbGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxLQUFLLFNBQVMsTUFBTSxXQUFXLENBQUM7QUFLdkMsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUV0QyxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDOUMsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUM1QixPQUFPLEVBQUMsZ0JBQWdCLEVBQWUsTUFBTSxpQkFBaUIsQ0FBQztBQUUvRCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDbkQsT0FBTyxFQUFDLGNBQWMsRUFBRSxrQkFBa0IsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUUzRCxPQUFPLEVBQUMsc0JBQXNCLEVBQThCLE1BQU0saUJBQWlCLENBQUM7QUFFcEY7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUFDLEtBQVksRUFBRSxPQUFvQjtJQUM5RCxNQUFNLE1BQU0sR0FBaUIsRUFBRSxDQUFDO0lBRWhDLE1BQU0sWUFBWSxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTdDLE1BQU0sQ0FBQyxJQUFJLENBQ1QsR0FBRyx5QkFBeUIsQ0FBQyxZQUFZLENBQUMsRUFDMUMsR0FBRyx5QkFBeUIsQ0FBQyxZQUFZLENBQUMsRUFDMUMsR0FBRyxvQkFBb0IsQ0FBQyxZQUFZLENBQUMsQ0FDdEMsQ0FBQztJQUVGLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7SUFFakQsSUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2pELE1BQU0sWUFB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