import { ValidationErrorFactory } from ".";
/**
 * Node in a tree useful to validate property paths in an utterance. See buildPropertyTree for details.
 */
export class PropertyNode {
    /**
     *
     * @param property a Property in a type
     * @param propertyType the corresponding propertyType
     * @param children nodes corresponding to propertyType.Properties
     */
    constructor(property, propertyType, children = new Map()) {
        Object.defineProperty(this, "property", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: property
        });
        Object.defineProperty(this, "propertyType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: propertyType
        });
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: children
        });
    }
    /**
     * Out of a string in Utterances<MealOrderType> like:
     *  'I want a {pizzaOrder.size} {pizzaOrder.pizzaType} pizza and a {drinkOrder.size} {drinkOrder.drinkType} drink'
     * This will build a tree like seen below where each Parenthesis is a Property with the given name and type:
     *
     *                                                    ('', MealOrderType)
     *
     *                 ('pizzaOrder', PizzaOrderType)                                      ('drinkOrder', DrinkOrderType)
     *
     *     ('pizzaType' ,PizzaType)          ('size', PizzaSizeType)             ('drinkType', DrinkType)        ('size', DrinkSizeType)
     *
     * In the process of building the tree 'no such property' errors can be produced.
     * With the tree, at each node, we can verify if the required properties have been specified
     * @param propertyPaths each ask.Name contains dot separate property path like 'pizzaOrder.size' plus its location for error messages.
     * @param type the type where all the first segments in propertyPaths are supposed to belong to.
     * @param context used for type's toString
     * @param getPropertyMap memoized type's getPropertyMap
     * @returns errors and the root of the tree
     */
    static buildPropertyTree(propertyPaths, type, context, getPropertyMap) {
        var _a, _b;
        const errors = [];
        const root = new PropertyNode({ name: "", type, kind: "Property", index: 0 }, type);
        for (const propertyPath of propertyPaths) {
            const segments = ((_a = propertyPath.name) !== null && _a !== void 0 ? _a : "").split(".");
            let currentType = type;
            let currentNode = root;
            let propertyFound = true;
            for (const segment of segments) {
                const propertyToTypes = getPropertyMap(currentType);
                const segmentProperty = propertyToTypes.get(segment);
                const segmentType = segmentProperty === null || segmentProperty === void 0 ? void 0 : segmentProperty.type;
                if (!segmentProperty) {
                    propertyFound = false;
                    // ignore if slot value is empty between braces as this will be caught later on during validation
                    if (segment.replace(/\s*/g, "").length > 0) {
                        errors.push(ValidationErrorFactory.UnknownProperty({
                            expr: propertyPath,
                            attributes: {
                                propertyName: segment,
                                typeName: currentType.toString(context),
                            },
                        }));
                    }
                    continue;
                }
                if (!segmentType) {
                    propertyFound = false;
                    errors.push(ValidationErrorFactory.NameNotFoundInUtteranceValue({
                        expr: propertyPath,
                        attributes: {
                            value: segment,
                        },
                    }));
                    continue;
                }
                let segmentNode = currentNode.children.get(segment);
                if (!segmentNode) {
                    segmentNode = new PropertyNode(segmentProperty, segmentType);
                    currentNode.children.set(segment, segmentNode);
                }
                currentType = segmentType.getNonOptionalType();
                currentNode = segmentNode;
            }
            const elementType = currentType.isList()
                ? currentType.getListItemType()
                : currentType.isOptional()
                    ? currentType.getNonOptionalType()
                    : currentType;
            const isTypeValid = (elementType === null || elementType === void 0 ? void 0 : elementType.isBuiltIn()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isCoreType()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isAlexaSchema()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isSlotType());
            if (propertyFound && !(elementType === null || elementType === void 0 ? void 0 : elementType.isValidForUtterance())) {
                errors.push(ValidationErrorFactory.UndefinedCatalogCustomType({
                    expr: propertyPath,
                    attributes: {
                        propertyName: (_b = propertyPath.name) !== null && _b !== void 0 ? _b : "",
                        propertyType: elementType === null || elementType === void 0 ? void 0 : elementType.toString(propertyPath),
                    },
                }));
            }
        }
        return { errors, root };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydHktbm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9wZXJ0eS1ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBYSxzQkFBc0IsRUFBQyxNQUFNLEdBQUcsQ0FBQztBQUtyRDs7R0FFRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBQ3ZCOzs7OztPQUtHO0lBQ0gsWUFBcUIsUUFBa0IsRUFBVyxZQUFrQixFQUFXLFdBQVcsSUFBSSxHQUFHLEVBQXdCOzs7OzttQkFBcEc7Ozs7OzttQkFBNkI7Ozs7OzttQkFBNkI7O0lBQTZDLENBQUM7SUFFN0g7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FDN0IsYUFBeUIsRUFDekIsSUFBVSxFQUNWLE9BQTZCLEVBQzdCLGNBQXFEOztRQUVyRCxNQUFNLE1BQU0sR0FBaUIsRUFBRSxDQUFDO1FBQ2hDLE1BQU0sSUFBSSxHQUFHLElBQUksWUFBWSxDQUFDLEVBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbEYsS0FBSyxNQUFNLFlBQVksSUFBSSxhQUFhLEVBQUU7WUFDeEMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxNQUFBLFlBQVksQ0FBQyxJQUFJLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0RCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDdkIsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3ZCLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQztZQUN6QixLQUFLLE1BQU0sT0FBTyxJQUFJLFFBQVEsRUFBRTtnQkFDOUIsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNwRCxNQUFNLGVBQWUsR0FBRyxlQUFl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