import { AxiosInstance } from "axios";
import { AskCliConfig } from "../ask-cli-config";
export declare const MetricActionResult: {
    [RESULT: string]: string;
};
/**
 * Metric action includes the name and results of CLI command.
 */
export declare class MetricAction {
    name: string;
    type: string;
    startTime: Date;
    endTime: Date | null;
    result: string | null;
    failureMessage: string;
    id: string;
    _ended: boolean;
    options: string[];
    optionData: {
        [key: string]: string;
    };
    /**
     * @constructor
     * @param name - The action name.
     * @param type - The action type.
     */
    constructor(name: string, type: string);
    /**
     * Add option to list, store value only if in {@link METRICS.STOREABLE_KEYS}
     * @param optionName name of the option
     * @param optionValue value of the option
     */
    setOption(optionName: string, optionValue: string): void;
    /**
     * Closes action
     * @param error Error object or string indicating error.
     */
    end(error?: Error | string | null): void;
    /**
     * Implementation of custom toJSON method to modify serialization with JSON.stringify
     */
    toJSON(): {
        end_time: Date | null;
        failure_message: string;
        name: string;
        result: string | null;
        start_time: Date;
        type: string;
        id: string;
        options: string[];
    };
}
/**
 * Describes the telemetry data sent by the metric client.
 */
interface MetricClientData {
    version: string;
    machineId: string;
    timeStarted: Date;
    newUser: boolean;
    timeUploaded: Date | null;
    clientId: string;
    actions: MetricAction[];
}
/**
 * Client that communicates with telemetry endpoint.
 */
export declare class MetricClient {
    httpClient: AxiosInstance;
    serverUrl: string;
    postRetries: number;
    enabled: boolean;
    data: MetricClientData;
    askCliConfig: AskCliConfig;
    /**
     * @constructor
     */
    constructor(currentNpmVersion: string, askCliConfig: AskCliConfig);
    /**
     * Starts action
     * @param name - The action name
     * @param type - The action type
     * @return the metric action that was started, {@link MetricAction}
     */
    startAction(name: string, type: string): MetricAction;
    /**
     * Set option for the most recently started action
     * @param optionName name of the option
     * @param optionValue value of the option
     */
    setOption(optionName: string, optionValue: string): void;
    /**
     * Returns current data store in the metric client
     * @return the metric data, {@link MetricClientData}
     */
    getData(): MetricClientData;
    /**
     * Sends data to the metric server
     * @param error - Error object or string indicating error.
     * @returns whether data was sent successfully
     */
    sendData(error?: Error | string | null): Promise<{
        success: boolean;
    }>;
    /**
     * Implementation of custom toJSON method to modify serialization with JSON.stringify
     */
    toJSON(): {
        version: string;
        machine_id: string;
        time_started: Date;
        new_user: boolean;
        time_uploaded: Date | null;
        client_id: string;
        actions: MetricAction[];
    };
    upload(): Promise<void>;
    retry(retries: number, func: any): Promise<void>;
    isEnabled(): boolean;
    /**
     * gets the machine id from ~/.ask/cli_config.
     * Special cases:
     *    1) If ~/.ask/cli_config was not found or could not be parsed this.enabled will be false and
     * no machine id is retrieved since no metrics will be sent
     *    2) If ~/.ask/cli_config was found, but has no machineId we will:
     *         a) write a new uuid to ~/.ask/cli_config if possible
     *         b) diaable metrics if we cannot write to ~/.ask/cli_config
     * @returns a machine id from ~/.ask/cli_config
     */
    getMachineId(): string;
}
export {};
//# sourceMappingURL=metric-client.d.ts.map