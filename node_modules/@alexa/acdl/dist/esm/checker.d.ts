import * as immutable from "immutable";
import * as ask from "./ast";
import { Apply } from "./apply";
import { Locale } from "./ast";
import { Global } from "./global";
import { LexicalScope } from "./lexical-scope";
import { Environment } from "./environment";
import { Project } from "./project";
import { Property } from "./property";
import { Type } from "./type";
import { ResponseInfo } from "./responseInfo";
import { Thing } from "./thing";
import { Token } from "./token";
/**
 * API for querying a Module for error checking, type checking, descriptions and suggestions.
 */
export declare class TypeChecker {
    /**
     * Project context of the module being checked.
     */
    readonly project: Project;
    /**
     * Previous TypeChecker environment.
     */
    readonly prev?: TypeChecker | undefined;
    /**
     * Map of TypeParameter to resolved Type.
     */
    readonly types?: immutable.Map<ask.TypeParameter, Type | null> | undefined;
    readonly ID: number;
    /**
     * Name bindings for expressions in the project.
     */
    readonly global: Global;
    readonly nothing: Type;
    readonly nothingToken: Token;
    readonly thing: Type;
    readonly void: Type;
    readonly voidToken: Token;
    readonly boolean: Type;
    readonly number: Type;
    readonly string: Type;
    readonly enumeration: () => Type;
    /**
     * Global index of Node to its {@link LexicalScope}.
     *
     * i.e. the names available in its lexical environment and a map of the node they point to.
     */
    readonly lexicalScopeIndex: WeakMap<ask.Node, LexicalScope>;
    /**
     * Global index of a Module-scoped Node to its corresponding Thing value.
     *
     * This index is shared across all instances of a {@link TypeChecker} within a {@link Project}. I.e. it is a global index.
     */
    readonly globalThingIndex: Map<ask.Node, Thing | null>;
    /**
     * Global index of a Node to its corresponding Type.
     */
    readonly globalTypeIndex: WeakMap<ask.ActionDeclaration | ask.DialogDeclaration | ask.EnumDeclaration | ask.TypeDeclaration | ask.SlotType, Type>;
    /**
     * Local index of a Node to its corresponding Thing value within the lexical environment represented by this {@link TypeCehcker}.
     */
    readonly localThingIndex: Map<ask.Node, Thing | null>;
    /**
     * Local index of a Node to its corresponding Apply within the lexical environment represented by this {@link TypeChecker}.
     */
    readonly localApplyIndex: Map<ask.Node, Apply | null>;
    constructor(
    /**
     * Project context of the module being checked.
     */
    project: Project, 
    /**
     * Previous TypeChecker environment.
     */
    prev?: TypeChecker | undefined, 
    /**
     * Map of Node to resolved Thing.
     */
    things?: immutable.Map<ask.Node, Thing | null>, 
    /**
     * Map of TypeParameter to resolved Type.
     */
    types?: immutable.Map<ask.TypeParameter, Type | null> | undefined);
    /**
     * Returns a reference to the root TypeChecker instance. TypeCheckers form a chain as we descend into
     * Dialog Sample Blocks and Conditional Blocks. This `root` instance refers to the global TypeChecker.
     *
     * We use this, for example, to look at the raw type signature of an ArgumentDeclaration instead of
     * looking at the type of the value passed into that argument within a Dialog Flow:
     *
     * ```
     * action myAction(String string)
     *
     * Foo(MyAction)
     *
     * dialog Foo(
     *   action bar(String arg)
     * ) {
     *   sample {
     *     // TypeChecker.root.getThing(NameReference(bar)) will return `action bar(String arg)`
     *     // If the TypeChecker is for the scope of this sample when `Foo` was called, then it would refer to `myAction` instead since that was passed in.
     *     bar("hello")
     *   }
     * }
     * ```
     */
    get root(): TypeChecker;
    private readonly tokens;
    /**
     * Get the next unique token.
     */
    nextToken(): string;
    /**
     * Find the URI of the Module containing this node.
     *
     * @param node
     */
    getUri(node: ask.Node): string | undefined;
    /**
     * Lookup an expression by its FQN.
     *
     * @param fqn fully qualified name of the expression.
     */
    lookupQualifiedName(fqn: string | undefined): ask.Node | undefined;
    /**
     * List all known types in a namespace.
     * @param namespace
     */
    listNamespace(namespace: string): LexicalScope | undefined;
    /**
     * Qualify a name within a scope.
     *
     * @param scope to qualify the name within
     * @param name name to qualify
     * @returns the qualified name
     */
    qualifyName(scope: ask.Node, query: ask.Name | string | undefined): string | undefined;
    /**
     * Find where a name is declared in the stack.
     *
     * @param scope scope to trace back from
     * @param name name to find
     */
    lookupName(scope: ask.Node, name: ask.Name | string | undefined): ask.Node | undefined;
    lookupNameReference(ref: ask.NameReference): ask.Node | undefined;
    /**
     * Recursively resolve the name reference when it's NameDeclaration
     * Stop when it's no longer a NameReference expression, or it's no longer a NameDeclaration
     *
     * @param ref nameReference to resolve
     * @returns the last resolved node
     */
    resolveNameReference(ref: ask.NameReference | ask.PropertyReference): ask.Node | undefined;
    /**
     * Recursively resolve the name reference to find the NameDeclaration
     * Stop when it's no longer a NameReference expression
     *
     * @param ref nameReference to resolve
     * @returns the last resolved NameDecl node
     */
    resolveNameReferenceToDecl(ref: ask.NameReference | ask.PropertyReference, seen?: Set<ask.Node>): ask.Node | undefined;
    /**
     * Recursively resolve the name reference until find a call
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToCall(ref: ask.NameReference | ask.PropertyReference): ask.Call | undefined;
    /**
     * Recursively resolve the name reference until find a propertyReference
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToPropReference(ref: ask.NameReference | ask.PropertyReference): ask.PropertyReference | undefined;
    /**
     * Computes and caches the visible names at a Node.
     *
     * @param node the node in which we are looking for visible names
     * @param allowDescend a flag to set whether the code should descend into a Correction's `expected` block and include names in that block within this ${node}'s lexical scope.
     */
    getVisibleNames(node: ask.Node | undefined, allowDescend?: boolean): LexicalScope | undefined;
    /**
     * Collect the names produced by a Node.
     */
    getProducedNames(node: ask.Node, allowDescend: boolean): LexicalScope | undefined;
    /**
     * Find the {@link ask.Name} located at a specific position in the file.
     *
     * @param uri module uri to search
     * @param position line and column number
     */
    findName(uri: string, position: ask.SourcePosition): ask.Name | undefined;
    /**
     * Finds a {@link ask.Name} or {@link ask.Import} at a specific position in the file.
     *
     * @param uri module uri to search
     * @param position line and column number
     */
    findNode(uri: string, position: ask.SourcePosition): ask.Name | ask.Import | undefined;
    /**
     * Finds a {@link ask.Name} or {@link ask.Import} node at a specific position in the file.
     *
     * @param node node to search
     * @param position line and column number
     * @returns the `Name` or `Import` node
     */
    private find;
    /**
     * Finds the type referenced by a TypeReference.
     *
     * @param type type reference to lookup
     */
    lookupTypeReference(type: ask.TypeReference): ask.ActionDeclaration | ask.DialogDeclaration | ask.EnumDeclaration | ask.TypeDeclaration | ask.TypeParameter | ask.SlotType | undefined;
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupCallDeclaration(call: ask.Call): ask.ActionDeclaration | ask.ArgumentDeclaration | ask.DialogDeclaration | ask.NameDeclaration | ask.SlotType | ask.TypeDeclaration | undefined;
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupTypeDeclaration(fqn: string): ask.TypeDeclaration | undefined;
    /**
     * Get auto-completion suggestions for the Node.
     */
    getCompletions(node: ask.Node): any[] | undefined;
    /**
     * Compute a detailed description of the expression.
     *
     * @param node expression to describe.
     */
    getDescription(node: Type | ask.Node | undefined): string | undefined;
    /**
     * Gets a `Thing` instance representing the value of some Node.
     *
     * @param node AST node to get a Thing to represent.
     * @param backtrack backtrack to control type interface
     * @param seen nodes seen so far in this traversal to detect infinite loops
     */
    getThing(node: ask.Node | undefined, token?: Token | undefined, origin?: ask.Node | undefined, seen?: immutable.Set<ask.Node>): Thing | undefined;
    /**
     * Gets the type of a Node.
     *
     * @param node to determine the type of
     * @param backtrack backtrack to control the behavior of the get type search
     * @param seen a set of seen nodes for detecting circular references
     * @returns instantiate type of the node or undefined if it cannot be determined
     */
    getType(node: ask.Node | undefined, backtrack?: boolean, seen?: immutable.Set<ask.Node>): Type | undefined;
    /**
     * Get the type of a Call implied by its context.
     *
     * @param call
     */
    getImpliedType(call: ask.Call): Type | undefined;
    /**
     * Get an Apply for this call.
     *
     * @param call to analyze
     * @param backtrack whether to look back up the tree to infer types
     */
    getApply(call: ask.Call, backtrack?: boolean, seenNames?: immutable.Set<ask.Node>): Apply | undefined;
    /**
     * Find an Argument's TypeProperty based on its position or name in a Call to a TypeDeclaration.
     *
     * @param type type declaration called
     * @param argument argument value in the call
     */
    findArgumentTypeProperty(type: Type, argument: ask.Argument): Property | undefined;
    /**
     * Find an Argument's declaration based on its name or position
     *
     * @param action action or dialog declaration
     * @param argument argument value in the call
     */
    findArgumentDeclaration(action: ask.ActionDeclaration | ask.DialogDeclaration, argument: ask.Argument): ask.ArgumentDeclaration | undefined;
    instantiateActionDeclaration(decl: ask.ActionDeclaration | ask.DialogDeclaration, call: ask.Call): Apply;
    /**
     * Instantiate a TypeDeclaration given some typeArgs and a type environment.
     *
     * @param type type declaration to instantiate
     * @param typeArgs known type arguments
     * @param env type environment
     */
    instantiateTypeDeclaration(type: ask.ActionDeclaration | ask.DialogDeclaration | ask.EnumDeclaration | ask.TypeDeclaration | ask.SlotType, typeArgs?: (Type | undefined)[] | undefined, functionArgumentNames?: string[], functionName?: string): Type | undefined;
    /**
     * Instantiate a type by substituting all type parameters and propagating the types to all super types.
     *
     * @param type type reference to instantiate
     * @param env optional lookup table of known names
     */
    instantiateTypeReference(type: ask.TypeReference | undefined, env?: Environment | undefined): Type | undefined;
    /**
     * Instantiate a TypeParameter.
     *
     * @param param type parameter.
     */
    instantiateTypeParameter(param: ask.TypeParameter): Type;
    private instantiateAlexaSchemaType;
    /**
     * determine if the a propertyReference is a type used in an event
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * u = utterances<Person>(["Hi {name}"])
     * personInfo = expect(Invoke, u)
     * a = personInfo.name
     * ```
     * `a` is a property reference and it's from the event expr, thus should return true
     *
     */
    isPropertyReferenceFromEvent(value: ask.PropertyReference): boolean;
    /**
     * determine if the a propertyReference is refer to api result
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * action Person getPerson()
     * person = getPerson()
     *
     *
     * a = person.name
     * ```
     * `a` is a property reference and it's refer to api result, thus should return true
     *
     */
    isPropertyReferenceFromApiInvocation(value: ask.PropertyReference): boolean;
    /**
     * Get all Nodes referenced by a source Node.
     *
     * @param source node to start the search from
     * @returns a set of all Nodes referenced by this
     */
    getReferences(source: ask.Node): Set<ask.Node>;
    /**
     * Get all response call used in a module.
     *
     * @param module module where to retrieve the responses
     * @returns a set of all responses
     */
    getResponseInfosInModule(module: ask.Module | undefined): ResponseInfo[];
    /**
     * Find the very beginning expr of property chain
     *
     * ```
     * a.b.c => a
     * a().b.c => a()
     * com.api.a.b.c => com.api.a
     * ```
     */
    getPropertyChainRootExpression(propertyRef: ask.PropertyReferenceExpression): ask.Expression | undefined;
    /**
     * check whether the node is a nameReference
     *
     * 1. if node is of "NameReference" Type, then it's a nameReference
     * 2. if node is of "PropertyReference", then check whether it's QFN point to a node. E.G. test.getPerson,
     *    "test" is a namespace, thus this should also be treated as nameReference
     */
    isNameReference(node: ask.Node | undefined): boolean;
    /**
     * Get all NameDeclarations under module scope
     */
    getAllModuleScopeNameDeclarations(): ask.NameDeclaration[];
    /**
     * collect locale info based on input
     *
     * E.G.
     * 1. when input is a nameDecl
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     *
     * collectLocaleInfo(myWelcome) => ['en_US']
     * ```
     *
     * 2. when input is a nameReference
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(temp) => ['en_US']
     * ```
     *
     * 3. when input is a propertyReference
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(test.temp) => ['en_US']
     *
     * 4. when input is variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeEN = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeGB)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB']
     *
     * 5. when input is nested variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeUS = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcomeEN = variations(myWelcomeEN, myWelcomeGB)
     *
     * @locale(Locale.ja_JP)
     * myWelcomeJP = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeJP)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB', 'en_JP']
     */
    collectLocaleInfo(input: ask.NameReference | ask.PropertyReference | ask.Call | ask.NameDeclaration): Locale[];
}
export interface PolicyInfo {
    type: "ResetArguments" | "ResetAllArguments";
    actionFqn: string;
    arguments: string[];
}
//# sourceMappingURL=checker.d.ts.map