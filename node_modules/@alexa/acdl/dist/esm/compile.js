import path from "path";
import * as ask from "./ast";
import { AlexaSchema } from "./ast";
import { sanitize, trimScheme } from "./util";
/**
 * Compile a Project to a record of relative build paths to serialized ASK IR files.
 *
 * @param project ACDL project to compile.
 */
export function compileProject(project) {
    const compiledProject = {
        modules: {},
    };
    for (const source of project.sourceModules) {
        const sourcePath = trimScheme(source.uri);
        const relative = path.relative(source.baseDir, sourcePath);
        const relativeDir = path.dirname(relative);
        let fileName = `${path.basename(sourcePath, ".acdl")}`;
        if (!fileName.endsWith(".json")) {
            fileName = `${fileName}.json`;
        }
        const relativeFilePath = path.join(relativeDir, fileName);
        const compiledModule = compileModule(project, source.content);
        compiledProject.modules[relativeFilePath] = compiledModule;
    }
    return compiledProject;
}
/**
 * Compile source to valid ask-module JSON.
 *
 * @param project project containing the source.
 * @param module source module, either an ACDLFile or ask-module.
 * @param validateJsonSchema whether to validate JSON schema or not
 */
export function compileModule(project, module, validateJsonSchema = false) {
    var _a, _b;
    const checker = project.getTypeChecker();
    const moduleUri = checker.getUri(module);
    if (!moduleUri) {
        throw new Error(`Cannot compile a Module when the Project instance doesn't load it.`);
    }
    const compiledModule = {
        schema: "https://amazonalexa.com/ask/2020/12/Module",
        exports: (_a = module.expressions) === null || _a === void 0 ? void 0 : _a.map((e) => {
            var _a;
            return e.kind === "ActionDeclaration" ||
                e.kind === "DialogDeclaration" ||
                e.kind === "EnumDeclaration" ||
                e.kind === "NameDeclaration" ||
                e.kind === "TypeDeclaration"
                ? (_a = e.name) === null || _a === void 0 ? void 0 : _a.name
                : undefined;
        }).filter((s) => s !== undefined),
        expressions: (_b = module.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => compileExpression(expr, { checker, moduleUri })),
    };
    if (validateJsonSchema) {
        ask.validateModuleSchema(compiledModule);
    }
    return compiledModule;
}
/**
 * Maps an internal AST Expression to its equivalent `@alexa/ask-module-spec` representation.
 *
 * @param data data to serialize
 */
export function compileExpression(data, context) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const { checker, moduleUri } = context;
    if (data === undefined) {
        return undefined;
    }
    if (Array.isArray(data)) {
        return data.map((item) => compileExpression(item, context));
    }
    if (ask.isNode(data)) {
        if (data.kind === "ActionDeclaration") {
            const expr = {
                kind: "ActionDeclaration",
                name: compileExpression(data.name, context),
                arguments: sanitize(compileExpression(data.arguments, context)),
                returnType: compileExpression(data.returnType, context),
                genericArguments: sanitize(compileExpression(data.genericArguments, context)),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Annotation") {
            return compileExpression(data.call, context);
        }
        if (data.kind === "ArgumentDeclaration") {
            let type = context.checker.instantiateTypeReference(data.type);
            let defaultExpression = compileExpression(data.defaultExpression, context);
            if (type === undefined) {
                throw resolveTypeToReference(data);
            }
            const expr = {
                name: (_a = data.name) === null || _a === void 0 ? void 0 : _a.name,
                defaultExpression,
                type: compileExpression(type === null || type === void 0 ? void 0 : type.toTypeReference(data), context),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Argument") {
            const expr = compileExpression(data.value, context);
            return expr;
        }
        if (data.kind === "Call") {
            let action = checker.getApply(data);
            let returnType = (_b = checker.getThing(data)) === null || _b === void 0 ? void 0 : _b.type;
            if (action === undefined || returnType === undefined) {
                throw new Error(`cannot resolve Apply for ${data.kind}`);
            }
            let args;
            if (Array.isArray(data.arguments)) {
                if (action.isType() &&
                    action.getReturnType().isPrimitive() &&
                    data.arguments.length === 1 &&
                    ask.isCall(data.arguments[0].value)) {
                    // handle sub-types of primitives, e.g. CityName("New York")
                    args = data.arguments[0].value.arguments;
                }
                else {
                    const mappings = {};
                    if (action.decl.kind === "Type" && action.decl.isFunctionN() && ((_c = action.decl.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "TypeDeclaration") {
                        // this is a call to an abstract function, we must map its argument names to arg0, arg1, ..., argN
                        (_d = action.decl.getFunctionArgumentDeclarations()) === null || _d === void 0 ? void 0 : _d.forEach((arg, i) => {
                            var _a, _b;
                            if ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) {
                                mappings[(_b = arg.name) === null || _b === void 0 ? void 0 : _b.name] = `arg${i}`;
                            }
                        });
                    }
                    args = Object.entries(action.getArguments() || {})
                        .map(([name, arg]) => {
                        var _a;
                        if (name !== undefined) {
                            return {
                                // See comment in "Strip Optional from argument" test in askir.test.ts
                                [(_a = mappings[name]) !== null && _a !== void 0 ? _a : name]: compileExpression(arg.value, { ...context, blockOptionalTypeReferences: true }),
                            };
                        }
                        return {};
                    })
                        .reduce((a, b) => ({ ...a, ...b }), {});
                }
            }
            else if (ask.isListLiteral(data.arguments)) {
                args = data.arguments.items.map((item) => compileExpression(item.item, context));
            }
            else if (ask.isUtterance(data.arguments)) {
                args = data.arguments.text;
            }
            else {
                args = data.arguments;
            }
            const name = action.decl.kind === "Type" &&
                action.decl.isFunction() &&
                ((_e = action.decl.declaration) === null || _e === void 0 ? void 0 : _e.kind) !== "ActionDeclaration" &&
                ((_f = action.decl.declaration) === null || _f === void 0 ? void 0 : _f.kind) !== "DialogDeclaration"
                ? // this call is referencing an action defined as an argument or variable, so we should use its local name.
                    assertNotNull((_g = data.name) === null || _g === void 0 ? void 0 : _g.name, "Call.name must be defined.")
                : // otherwise use the declaration's name (fully qualified name).
                    typeof action.decl.name === "string"
                        ? action.decl.name
                        : (_h = action.decl.name) === null || _h === void 0 ? void 0 : _h.name;
            const serializedCall = {
                kind: "Call",
                name,
                genericArguments: (_j = action.getGenericArguments()) === null || _j === void 0 ? void 0 : _j.map((a) => compileExpression(a === null || a === void 0 ? void 0 : a.toTypeReference(data), context)),
                arguments: sanitize(args),
                type: resolveTypeToReference(data, returnType),
                annotations: compileExpression(data.annotations, context),
            };
            return serializedCall;
        }
        if (data.kind === "Condition") {
            const expr = {
                kind: "Condition",
                when: compileExpression(data.when, context),
                then: sanitize(compileExpression(data.then, context)),
                else: sanitize(compileExpression(data.else, context)),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "When") {
            return compileExpression(data.expression, context);
        }
        if (data.kind === "Correction") {
            const expr = {
                kind: "Correction",
                actual: sanitize(compileExpression(data.actual, context)),
                expected: sanitize(compileExpression(data.expected, context)),
            };
            return expr;
        }
        if (data.kind === "InteractionDeclaration") {
            const expr = {
                kind: "InteractionDeclaration",
                expressions: compileExpression(data.scope, context),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "DialogDeclaration") {
            // Non reusable dialog must return void otherwise it will not be recognized as a deployable dialog
            // by the backend that returns the error:
            //   The skill does not contain any deployable dialog for locale en_US.
            // That is why we use blockVoid in the returnType compileExpression.
            // The blockVoid in the samples is because the last expression inside the sample must also not be
            // void because the backend will throw a type mismatch
            // error between sample return of nothing and the last expression in the sample (say a response)
            // returning void
            const expr = {
                kind: "DialogDeclaration",
                name: (_k = data.name) === null || _k === void 0 ? void 0 : _k.name,
                arguments: sanitize(compileExpression(data.arguments, context)),
                genericArguments: sanitize(compileExpression(data.genericArguments, context)),
                returnType: compileExpression(data.returnType, { ...context, blockVoid: true }),
                samples: compileExpression(data.samples, { ...context, blockVoid: true }),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "EnumDeclaration") {
            if (((_l = data.name) === null || _l === void 0 ? void 0 : _l.name) === undefined) {
                throw new Error(`name undefined for 'enum'`);
            }
            if (data.items === undefined || data.items.length === 0) {
                throw new Error(`empty enum: '${data.name.name}'`);
            }
            const expr = {
                kind: "EnumDeclaration",
                name: data.name.name,
                items: (_m = data.items) === null || _m === void 0 ? void 0 : _m.map((item) => compileExpression(item, context)),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "EnumItemDeclaration") {
            if (((_o = data.name) === null || _o === void 0 ? void 0 : _o.name) === undefined) {
                throw new Error(`undefined name on enum item '${(_p = data.context.name) === null || _p === void 0 ? void 0 : _p.name}'`);
            }
            const expr = {
                kind: "EnumItemDeclaration",
                name: data.name.name,
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Name") {
            const name = checker.qualifyName(data, data.name);
            return name;
        }
        if (data.kind === "NameReference") {
            const name = {
                kind: "NameReference",
                name: checker.qualifyName(data, data.name),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return name;
        }
        if (data.kind === "NameDeclaration") {
            const expr = {
                kind: data.context.kind === "Module"
                    ? "QualifiedNameDeclaration"
                    : ask.isInteractionDeclaration(data.context.context) || ask.isCorrection(data.context.context)
                        ? "InteractionNameDeclaration"
                        : "NameDeclaration",
                name: compileExpression(data.name, context),
                type: resolveTypeToReference(data),
                expression: compileExpression(data.expression, context),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "PropertyReference") {
            const qualifiedName = ask.PropertyReference.tryResolveQualifiedName(data);
            if (checker.lookupQualifiedName(qualifiedName) !== undefined) {
                const name = {
                    kind: "NameReference",
                    name: qualifiedName,
                    type: resolveTypeToReference(data),
                    annotations: compileExpression(data.annotations, context),
                };
                return name;
            }
            const prop = {
                kind: "PropertyReference",
                name: (_q = data.name) === null || _q === void 0 ? void 0 : _q.name,
                expression: compileExpression(data.expression, context),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return prop;
        }
        if (data.kind === "Sample") {
            const expr = {
                kind: "Sample",
                expressions: compileExpression(data.scope, context),
                type: resolveTypeToReference(data),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "Block") {
            return (_r = data.expressions) === null || _r === void 0 ? void 0 : _r.map((expr) => compileExpression(expr, context));
        }
        if (data.kind === "TypeDeclaration") {
            const expr = {
                kind: "TypeDeclaration",
                name: compileExpression(data.name, context),
                extensions: sanitize(compileExpression(data.extensions, context)),
                genericArguments: sanitize(compileExpression(data.genericArguments, context)),
                properties: (_s = data.properties) === null || _s === void 0 ? void 0 : _s.map((prop) => compileExpression(prop, context)),
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "TypeParameter") {
            const expr = {
                name: compileExpression(data.name, context),
                constraints: sanitize(compileExpression(data.constraints, context)),
            };
            return expr;
        }
        if (data.kind === "TypeProperty") {
            const qualified = checker.qualifyName(data, (_t = data.type) === null || _t === void 0 ? void 0 : _t.name);
            const expr = {
                name: (_u = data.name) === null || _u === void 0 ? void 0 : _u.name,
                type: compileExpression(data.type, context),
                optional: qualified === AlexaSchema.Optional || data.optional === true,
                annotations: compileExpression(data.annotations, context),
            };
            return expr;
        }
        if (data.kind === "TypeReference") {
            return getSerializedTypeReference(data, (type) => {
                var _a;
                if (context.blockVoid && type.isVoid()) {
                    type = checker.nothing;
                }
                if (context.blockOptionalTypeReferences) {
                    while (type === null || type === void 0 ? void 0 : type.isOptional()) {
                        type = assertDefined(data, type === null || type === void 0 ? void 0 : type.getOptionalType());
                    }
                }
                else {
                    // flatten Optionals. Optional<Optional<Optional<T>>> into Optional<T>
                    while ((type === null || type === void 0 ? void 0 : type.isOptional()) && ((_a = type === null || type === void 0 ? void 0 : type.getOptionalType()) === null || _a === void 0 ? void 0 : _a.isOptional())) {
                        type = assertDefined(data, type === null || type === void 0 ? void 0 : type.getOptionalType());
                    }
                }
                return type;
            });
        }
        if (data.kind === "Utterance") {
            return data.text;
        }
    }
    throw new Error(`invalid ask expression: ${data}`);
    function assertNotNull(t, msg) {
        if (t === undefined) {
            throw new Error(msg);
        }
        return t;
    }
    function assertDefined(node, type) {
        var _a, _b;
        if (type === undefined) {
            throw new Error(`could not resolve type of '${node.kind}' expression at ${moduleUri}(${(_a = node === null || node === void 0 ? void 0 : node.loc) === null || _a === void 0 ? void 0 : _a.begin.line},${(_b = node === null || node === void 0 ? void 0 : node.loc) === null || _b === void 0 ? void 0 : _b.begin.character})`);
        }
        return type;
    }
    function getTypeOrThrow(node) {
        return assertDefined(node, checker.getType(node));
    }
    function resolveTypeToReference(node, type = checker.getType(node)) {
        return compileExpression(assertDefined(node, type).toTypeReference(node.context), context);
    }
    /**
     * Retrieves a serialized version of the typeReference with the type optionally transformed
     * @param typeReference Type reference node
     * @param typeTransformer optional transformer for the type
     * @returns a serialized version of the typeReference with the type optionally transformed
     */
    function getSerializedTypeReference(typeReference, typeTransformer = (type) => type) {
        let type = getTypeOrThrow(typeReference);
        const typeRef = typeTransformer(type).toTypeReference(typeReference);
        const expr = {
            kind: "TypeReference",
            name: compileExpression(typeRef.name, context),
            arguments: sanitize(compileExpression(typeRef.arguments, context)),
            annotations: compileExpression(typeReference.annotations, context),
        };
        return expr;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21waWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUV4QixPQUFPLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQztBQUM3QixPQUFPLEVBQUMsV0FBVyxFQUFvQyxNQUFNLE9BQU8sQ0FBQztBQUlyRSxPQUFPLEVBQUMsUUFBUSxFQUFFLFVBQVUsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQVM1Qzs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGNBQWMsQ0FBQyxPQUFnQjtJQUM3QyxNQUFNLGVBQWUsR0FBb0I7UUFDdkMsT0FBTyxFQUFFLEVBQUU7S0FDWixDQUFDO0lBQ0YsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLENBQUMsYUFBYSxFQUFFO1FBQzFDLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDMUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQzNELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0MsSUFBSSxRQUFRLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDO1FBQ3ZELElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQy9CLFFBQVEsR0FBRyxHQUFHLFFBQVEsT0FBTyxDQUFDO1NBQy9CO1FBQ0QsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMxRCxNQUFNLGNBQWMsR0FBRyxhQUFhLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFRLENBQUMsQ0FBQztR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