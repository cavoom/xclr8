import * as ask from "./ast";
import { Type } from "./type";
/**
 * Visit each child in a Node and call a callback to process it.
 *
 * This function is a general purpose tool for building other recursive search functions.
 *
 * @param node node to visit each child of
 * @param fn function to call with each child node
 */
export declare function visitEachChild(expr: ask.Node | undefined, fn: (node: ask.Node) => void): void;
/**
 * Visit each property type and type's generic type in a Type and call a callback to process it.
 *
 * This function is a general purpose tool for building other recursive search functions.
 *
 * E.G.
 * ```
 * type myType {
 *   type1 id
 *   optional type2 name
 *   List<type3> hobbies
 * }
 *
 * visitEachChildType(myType) will visit [type1, Optional<type2>, List<type3>]
 *
 * visitEachChildType(List<type3>) will visit [type3]
 * ```
 * ```
 *
 * @param Type type to visit each child of
 * @param fn function to call with each child node
 */
export declare function visitEachChildType(type: Type | undefined, fn: (node: Type) => void): void;
/**
 * generic collect function
 * This function visit all child of the input Node, use provided fn to find target
 * and use provided reduce function to combine all found
 * @param node The Node where to collect target
 * @param fn function used to find target in the given Node
 * @param reduce function used to combine all founds
 * @param zero the initial result
 * @returns all the found targets after combination
 */
export declare function collect<T>(node: ask.Node, fn: (node: ask.Node) => T, reduce: (a: T, b: T) => T, zero: T): T;
/**
 * visit all child of a Node and collect all target in an array
 * @param node The Node where to collect target
 * @param fn function used to find target in the given Node
 * @returns an array of target
 */
export declare function collectArray<T>(node: ask.Node, fn: (node: ask.Node) => T[]): T[];
/**
 * Visit each child in a Node and transform it with the provided callback.
 *
 * This function is a general purpose tool for building other recursive compilation passes.
 *
 * @param node node to visit each child of
 * @param fn function to call with each child node
 */
export declare function transformEachChild<N extends ask.Node | undefined>(expr: N, fn: <N extends ask.Node>(node: N) => N): N;
//# sourceMappingURL=visit.d.ts.map