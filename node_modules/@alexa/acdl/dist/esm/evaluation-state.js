import { Map as ImmutableMap, Set as ImmutableSet } from "immutable";
/**
 * The EvaluationState is an immutable class that tracks information observed while processing an
 * {@link Expression} stream with {@link Flow.interpret}. As the Dialog Flow forks on {@link DialogExpansion}
 * expansions and {@link ConditionalBranch}
 */
export class EvaluationState {
    constructor(skillContext, 
    /**
     * Arguments that have been requested. The string is the argument name.
     */
    requestedArguments = ImmutableMap(), pendingConfirmations = ImmutableSet(), errors = [], 
    /**
     * A LIFO queue (Stack) of all expressions seen in the Flow until this time.
     */
    expressionStack = [], 
    /**
     * The most recent received Event.
     */
    previousEvent = undefined, 
    /**
     * The most recent API invocation.
     */
    previousApi = undefined, 
    /**
     * Most recent offer that has been affirmed but not invoked
     */ pendingOffer = undefined, 
    /**
     * API invocations that we have not yet ensured has a request prompt for each required argument.
     */
    pendingRequestPromptValidation = ImmutableMap(), 
    /**
     * Set of Dialogs that have been expanded so far in this dialog flow. We use this to detect
     * circular references to dialogs.
     */
    expandedDialogs = ImmutableSet(), 
    /**
     * Flag to indicate if a circular refrence has been detected.
     */
    isCircular = false) {
        Object.defineProperty(this, "skillContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: skillContext
        });
        Object.defineProperty(this, "requestedArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: requestedArguments
        });
        Object.defineProperty(this, "pendingConfirmations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: pendingConfirmations
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
        Object.defineProperty(this, "expressionStack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: expressionStack
        });
        Object.defineProperty(this, "previousEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: previousEvent
        });
        Object.defineProperty(this, "previousApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: previousApi
        });
        Object.defineProperty(this, "pendingOffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: pendingOffer
        });
        Object.defineProperty(this, "pendingRequestPromptValidation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: pendingRequestPromptValidation
        });
        Object.defineProperty(this, "expandedDialogs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: expandedDialogs
        });
        Object.defineProperty(this, "isCircular", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isCircular
        });
    }
    /**
     * Push an Expression onto the `expressionStack` and update `previousEvent` and `previousApi` accordingly.
     *
     * @param expression the next expression seen in the dialog flow.
     * @returns a new EvaluationState with the updated `expressionStack`, previousEvent` and `previousApi`.
     */
    pushExpr(expression) {
        var _a;
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, [expression, ...this.expressionStack], expression.isExpect() ? expression : this.previousEvent, expression.isInvokeApi() ? expression : this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, expression.isDialogExpansion() && ((_a = expression.dialog) === null || _a === void 0 ? void 0 : _a.origin.kind) === "DialogDeclaration"
            ? this.expandedDialogs.add(expression.dialog.origin)
            : this.expandedDialogs, this.isCircular);
    }
    hasExpandedDialog(dialog) {
        var _a;
        return ((_a = dialog.dialog) === null || _a === void 0 ? void 0 : _a.origin.kind) === "DialogDeclaration" ? this.expandedDialogs.has(dialog.dialog.origin) : false;
    }
    /**
     * For a given API argument, if the argument is a built in or slot type, only the argument needs to be requested.
     * If the argument type is built in or slot this will return [`person`] assuming argument.argumentName is 'person'
     * If the argument is an object type, then we need to get to all paths leading to built in and slot types.
     * If the argument type looks like:
     *
     * type Person {
     *    PersonName name
     *    Number age
     *    Car car
     *    optional Number friendCount;
     * }
     *
     *
     * type Car {
     *   CarModel model;
     * }
     *
     * Where CarModel and PersonName are slot types.
     *
     * This method will return [`person.properties.name`, `person.properties.age`, `person.properties.car.properties.model`]
     *
     * @param argument argument to retrieve property paths that should be requested from
     * @returns The properties paths that should be requested put of argument
     */
    getArgumentPaths(argument) {
        var _a, _b;
        const argumentType = (_a = argument.type.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        if (!argumentType || !argument.argumentName) {
            return [];
        }
        const returnValue = [];
        const queue = [{ path: argument.argumentName, type: argumentType }];
        const seen = new Set([argumentType.toString()]);
        while (queue.length !== 0) {
            const { path, type } = queue.shift();
            if (type.isObject()) {
                for (const property of (_b = type.properties) !== null && _b !== void 0 ? _b : []) {
                    if (!property.type || property.type.isOptional() || seen.has(property.type.toString())) {
                        continue;
                    }
                    seen.add(property.type.toString());
                    queue.push({ type: property.type, path: path + ".properties." + property.name });
                }
            }
            else {
                returnValue.push(path);
            }
        }
        return returnValue;
    }
    /**
     * Keep track of this API invocation and check later if it has all necessary request prompts.
     * Called for mandatory arguments of an invoked API originated from an event in evaluateInvokeApi or
     * for arguments to ensure/confirmArgs/response with more than one value in validateRequestPromptInArgsList
     * to add to pendingRequestPromptValidation
     * @param api api invocation
     * @param argName the name of the argument
     * @returns
     */
    withPendingRequestPromptValidation(api, arg) {
        var _a, _b;
        const argumentPaths = this.getArgumentPaths(arg);
        let apiPendingArguments = this.pendingRequestPromptValidation.get(api);
        if (apiPendingArguments) {
            const pendingArgPaths = (_b = (_a = apiPendingArguments.get(arg)) === null || _a === void 0 ? void 0 : _a.merge(argumentPaths)) !== null && _b !== void 0 ? _b : ImmutableSet(argumentPaths);
            apiPendingArguments = apiPendingArguments.set(arg, pendingArgPaths);
        }
        else {
            apiPendingArguments = ImmutableMap([[arg, ImmutableSet(argumentPaths)]]);
        }
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation.set(api, apiPendingArguments), this.expandedDialogs, this.isCircular);
    }
    /**
     * Checks if this State has any outstanding/pending Confirmation Expressions such as
     * ConfirmAction and ConfirmArguments.
     */
    hasPendingConfirmation() {
        return !this.pendingConfirmations.isEmpty();
    }
    /**
     * Track a ConfirmAction or ConfirmArgs Response that is pending Confirmation.
     *
     * @param confirmation the response asking for confirmation from the user.
     */
    withPendingConfirmation(confirmation) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations.add(confirmation), this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    withCircular(isCircular) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, isCircular);
    }
    withPendingOffer(pendingOffer) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    clearPendingOffer() {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, undefined, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    /**
     * Add new discovered errors to the state.
     *
     * @param errors new errors
     */
    withError(...errors) {
        return new EvaluationState(this.skillContext, this.requestedArguments, this.pendingConfirmations, 
        // TODO: why do we need to filter undefined errors ... there should never be any
        [...this.errors, ...errors.filter((e) => e !== undefined)], this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, this.pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    /**
     * @returns `true` if this state contains errors, `false` otherwise.
     */
    hasErrors() {
        return this.errors.length > 0;
    }
    /**
     * Register some {@link ArgumentThing}s as individually requested and are guarnateed to exist.
     *
     * @param ambient whether this argument request is ambient (meaning order of expression does not matter). Only the `ensure` block counts as an ambient request.
     * @param requestedArgs list of arguments that have been individually requested from the user.
     */
    withRequestedArguments(ambient, ...requestedArgs) {
        var _a, _b, _c, _d, _e, _f, _g;
        let { requestedArguments } = this;
        let { pendingRequestPromptValidation } = this;
        for (const requestedArg of requestedArgs) {
            const referencedActionDeclaration = requestedArg.getReferencedActionArgumentActionDeclaration();
            const referencedArgumentName = (_b = (_a = requestedArg.getReferencedActionArgumentDeclaration()) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
            const referencedArgumentPath = requestedArg.getReferencedActionArgumentPath();
            if (!referencedArgumentName || !referencedActionDeclaration || !referencedArgumentPath) {
                continue;
            }
            requestedArguments = requestedArguments.update(referencedActionDeclaration, ImmutableSet(), (args) => args.add(referencedArgumentName));
            if (!ambient) {
                continue;
            }
            for (let [expr, pendingArgs] of pendingRequestPromptValidation.entries()) {
                if (expr.isInvokeApi() && ((_c = expr.action) === null || _c === void 0 ? void 0 : _c.origin) === referencedActionDeclaration) {
                    deleteArg();
                }
                else if (expr.isResponse()) {
                    const args = (_f = (_e = (_d = expr.act) === null || _d === void 0 ? void 0 : _d.getProperty("arguments")) === null || _e === void 0 ? void 0 : _e.asLiteralList()) === null || _f === void 0 ? void 0 : _f.getItems();
                    if (args) {
                        for (const arg of args) {
                            if ((_g = arg === null || arg === void 0 ? void 0 : arg.asArgument()) === null || _g === void 0 ? void 0 : _g.equals(requestedArg)) {
                                deleteArg();
                            }
                        }
                    }
                }
                function deleteArg() {
                    for (const [pendingArg, pathsSet] of pendingArgs) {
                        if ((referencedArgumentName && pendingArg.argumentName === referencedArgumentName) || pendingArg.equals(requestedArg)) {
                            pendingRequestPromptValidation = pendingRequestPromptValidation.set(expr, pendingArgs.set(pendingArg, pathsSet.delete(referencedArgumentPath)));
                        }
                    }
                }
            }
        }
        return new EvaluationState(this.skillContext, requestedArguments, this.pendingConfirmations, this.errors, this.expressionStack, this.previousEvent, this.previousApi, this.pendingOffer, pendingRequestPromptValidation, this.expandedDialogs, this.isCircular);
    }
    /**
     * Checks if an Action's argument is requested via previous Expressions.
     *
     * Case 1: `ensure` as a previous expression in this flow.
     * ```
     * ensure(
     *   RequestArguments {arguments = [foo.arguments.arg], response = apla }
     * )
     * // arg is requested by `ensure` above
     * foo(arg = argValue)
     * ```
     *
     * Case 2: a `response` with `Request` act.
     * ```
     * response(apla, Request { arguments = [foo.arguments.arg] })
     * // arg is requested by `response` above
     * foo(arg = argValue)
     * ```
     *
     * Case 3: same value passed to a previously requested argument.
     * ```
     * response(apla, Request { arguments = [foo.arguments.arg] })
     * foo(arg = argValue)
     * // because foo.arguments.arg is requested, argValue is considered requested for other actions also.
     * bar(arg = argValue)
     * ```
     *
     * TODO: this function does not cover the case where `ensure` is located AFTER an Expression. Implementing
     * this logic is accomplished by {@link Flow.isArgumentRequested} but is computationally expensive. Our
     * goal is to change that behavior and instead use {@link EvaluationState} to keep track of this until
     * the {@link End} of the Dialog Flow and then validate all actions lacking requested arguments then. That
     * way the validation will be constant time.
     *
     * @param arg the argument we are looking up a request prompt for
     * @param argValueThing the value of the argument
     * @returns true if the argument has been requested, false otherwise.
     */
    isArgumentRequested(arg, argValueThing) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const argId = arg === null || arg === void 0 ? void 0 : arg.token;
        if (argId === undefined) {
            return false;
        }
        const actionDeclaration = arg === null || arg === void 0 ? void 0 : arg.getReferencedActionArgumentActionDeclaration();
        const referencedArgumentName = (_b = (_a = arg === null || arg === void 0 ? void 0 : arg.getReferencedActionArgumentDeclaration()) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
        if (actionDeclaration && referencedArgumentName && ((_c = this.requestedArguments.get(actionDeclaration)) === null || _c === void 0 ? void 0 : _c.has(referencedArgumentName))) {
            // this argument is directly requested
            return true;
        }
        if (argValueThing === undefined) {
            // if we don't know the argument's value, then we can't determine if it is requested anymore.
            return false;
        }
        // now check if there is a call to another API with the same value where that argument was requested.
        for (const expr of this.expressionStack) {
            if (expr.isInvokeApi() && expr.action) {
                if (expr.arguments) {
                    const argsList = (_d = expr.action.getArguments()) === null || _d === void 0 ? void 0 : _d.getArgumentsList();
                    if (argsList !== undefined) {
                        for (const exprArg of argsList) {
                            const exprArgValue = (_e = expr.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValueThing(exprArg);
                            if (exprArgValue === null || exprArgValue === void 0 ? void 0 : exprArgValue.equals(argValueThing)) {
                                const exprArgReferencedArgumentName = (_g = (_f = exprArg === null || exprArg === void 0 ? void 0 : exprArg.getReferencedActionArgumentDeclaration()) === null || _f === void 0 ? void 0 : _f.name) === null || _g === void 0 ? void 0 : _g.name;
                                if (exprArgReferencedArgumentName && ((_h = this.requestedArguments.get(expr.action.origin)) === null || _h === void 0 ? void 0 : _h.has(exprArgReferencedArgumentName))) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGlvbi1zdGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldmFsdWF0aW9uLXN0YXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxHQUFHLElBQUksWUFBWSxFQUFFLEdBQUcsSUFBSSxZQUFZLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFXbkU7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyxlQUFlO0lBQzFCLFlBQ1csWUFBc0M7SUFFL0M7O09BRUc7SUFDTSxxQkFBcUIsWUFBWSxFQUErQyxFQUNoRix1QkFBK0QsWUFBWSxFQUFFLEVBQzdFLFNBQXlCLEVBQUU7SUFDcEM7O09BRUc7SUFDTSxrQkFBZ0MsRUFBRTtJQUMzQzs7T0FFRztJQUNNLGdCQUFvQyxTQUFTO0lBQ3REOztPQUVHO0lBQ00sY0FBcUMsU0FBUztJQUV2RDs7T0FFRyxDQUFVLGVBQW1DLFNBQVM7SUFFekQ7O09BRUc7SUFDTSxpQ0FBaUMsWUFBWSxFQUduRDtJQUVIOzs7T0FHRztJQUNNLGtCQUFrQixZQUFZLEVBQXlCO0lBRWhFOztPQUVHO0lBQ00sYUFBYSxLQUFLOzs7OzttQkExQ2xCOzs7Ozs7bUJBS0E7Ozs7OzttQkFDQTs7Ozs7O21CQUNBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUk7Ozs7OzttQkFLSjs7Ozs7O21CQVNBOzs7Ozs7bUJBS0E7O0lBQ1IsQ0FBQztJQUVKOzs7OztPQUtHO0lBQ0ksUUFBUSxDQUEwQixVQUFnQjs7UUFDdkQsT0FBTyxJQUFJLGVBQWUsQ0FDeEIsSUFBSSxDQUFDLFlBQVksRUFDakIsSUFBSSxDQUFDLGtCQUFrQixFQUN2QixJQUFJLENBQUMsb0JBQW9CLEVBQ3pCLElBQUksQ0FBQyxNQUFNLEVBQ1gsQ0FBQyxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQ3JDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFB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