var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Type_environment, _Type_extensions, _Type_properties, _Type_propertiesIndex, _Type_locales, _Type_leafTypes;
import * as ask from "./ast";
import { Apply } from "./apply";
import { ActionTypeName, AlexaConversations, AlexaConversationsNamespace, AlexaSchema, AlexaSchemaNamespace, BuiltinsNamespace, DialogTypeName, SlotTypesNamespace, } from "./ast";
import { getName, getNamespace, isNotUndefined } from "./util";
import { ActionThing, AnyThing, ArgumentsThing, ArgumentThing, BooleanThing, DialogThing, FunctionThing, ListThing, NothingThing, NumberThing, ObjectThing, StringThing, VoidThing, } from "./thing";
import { visitEachChildType } from "./visit";
export function isType(obj) {
    return (obj === null || obj === void 0 ? void 0 : obj.kind) === "Type";
}
/**
 * A Type represents an instantiated Type in some context.
 *
 * Any `genericArguments` are either explicitly substituted or inferred from the surrounding context.
 *
 * This class provides a lazily-evaluated API for querying properties of the type.
 */
export class Type {
    constructor(checker, 
    /**
     * Declaration of the instantiated type.
     */
    declaration, 
    /**
     * Instantiated type arguments.
     */
    genericArguments, 
    /**
     * Source node of this Type.
     */
    // readonly source?: ask.Node,
    functionArgumentNames, 
    /**
     * Name of the function (if this is an abstract function signature)
     */
    functionName) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "declaration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: declaration
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: genericArguments
        });
        Object.defineProperty(this, "functionArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionArgumentNames
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionName
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Type"
        });
        // cache lazily evaluated environment - use `null` to indicate "cached, but empty".
        _Type_environment.set(this, void 0);
        // cache lazily evaluated list of base types - use `null` to indicate "cached, but empty".
        _Type_extensions.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_properties.set(this, void 0);
        // cache lazily evaluated property index - use `null` to indicate "cached, but empty".
        _Type_propertiesIndex.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_locales.set(this, void 0);
        /**
         * Cached lazily evaluated set of all the leaf types (including this) in this type.
         *
         * Note: We could store this as a Map<string, Type> if we want to include the full type path to the leaf type.
         */
        _Type_leafTypes.set(this, void 0);
    }
    /**
     * String representation of this Type.
     */
    toString(context) {
        var _a, _b, _c, _d;
        const inScope = context ? this.checker.lookupName(context, this.shortName) : undefined;
        const name = (inScope === null || inScope === void 0 ? void 0 : inScope.kind) === "TypeDeclaration" && ((_a = inScope.name) === null || _a === void 0 ? void 0 : _a.name) && inScope.name.name === ((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) ? this.shortName : (_c = this.name) === null || _c === void 0 ? void 0 : _c.name;
        if (this.isFunctionN() && this.functionArgumentNames !== undefined) {
            const prefix = this.isAction() ? "action" : this.isDialog() ? "dialog" : "function";
            return `${prefix} ${(_d = this.getFunctionReturnType()) === null || _d === void 0 ? void 0 : _d.toString()}${this.functionName ? ` ${this.functionName}` : ""}(${this.functionArgumentNames
                .map((name, i) => {
                let argType = this.getFunctionArgumentType(i);
                const isOptional = (argType === null || argType === void 0 ? void 0 : argType.isOptional()) === true;
                if (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                    while (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                        argType = argType.getOptionalType();
                    }
                }
                return `${isOptional ? "optional " : ""}${argType === null || argType === void 0 ? void 0 : argType.toString()} ${name}`;
            })
                .join(", ")})`;
        }
        return `${name}${this.genericArguments ? `<${this.genericArguments.map((a) => a === null || a === void 0 ? void 0 : a.toString(context)).join(", ")}>` : ""}`;
    }
    toTypeReference(context) {
        var _a;
        const ref = new ask.TypeReference(this.name, (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a.map((arg) => arg === null || arg === void 0 ? void 0 : arg.toTypeReference()), undefined, undefined);
        if (context) {
            ref.context = context;
        }
        return ref;
    }
    get shortName() {
        var _a, _b, _c;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) ? getName((_c = this.declaration.name) === null || _c === void 0 ? void 0 : _c.name) : undefined;
    }
    /**
     * Name of this Type.
     */
    get name() {
        var _a;
        return (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name;
    }
    get namespace() {
        var _a, _b;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) ? getNamespace((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : undefined;
    }
    /**
     * The type environment of this Type.
     *
     * Maps type aliases for Type Parameters to instantiated Types.
     */
    get environment() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_environment, "f") === undefined) {
            if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeDeclaration") {
                const genericArguments = this.declaration.genericArguments || [];
                __classPrivateFieldSet(this, _Type_environment, ((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.map((arg, i) => {
                    var _a, _b;
                    const name = (_b = (_a = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i]) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
                    return name === undefined
                        ? {}
                        : {
                            [name]: arg,
                        };
                }).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
            }
        }
        return __classPrivateFieldGet(this, _Type_environment, "f") || undefined;
    }
    /**
     * Ordered list of this Type's base types (the types it "extends").
     */
    get extensions() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_extensions, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_extensions, (_a = this.resolveExtensions()) !== null && _a !== void 0 ? _a : null, "f");
        }
        return (_b = __classPrivateFieldGet(this, _Type_extensions, "f")) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveExtensions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // instantiate the base types
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
            // Beta 1 loads Slot Types from the interaction model - they always extend string.
            return [this.checker.string];
        }
        if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration") {
            const actionArity = (_e = (_d = this.declaration.arguments) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0;
            const typeArgs = [
                ...((_g = (_f = this.declaration.arguments) === null || _f === void 0 ? void 0 : _f.map((arg) => this.checker.getType(arg.type))) !== null && _g !== void 0 ? _g : []),
                this.checker.getType(this.declaration.returnType),
            ];
            const actionType = this.checker.instantiateTypeDeclaration(this.checker.lookupTypeDeclaration(((_h = this.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "ActionDeclaration" ? ActionTypeName(actionArity) : DialogTypeName(actionArity)), typeArgs);
            if (actionType) {
                return [actionType];
            }
            return [this.checker.nothing];
        }
        if (((_j = this.declaration) === null || _j === void 0 ? void 0 : _j.kind) === "EnumDeclaration") {
            return [this.checker.enumeration()];
        }
        if (((_k = this.declaration) === null || _k === void 0 ? void 0 : _k.kind) === "EnumItemDeclaration") {
            const enumType = this.checker.getType(this.declaration.context);
            if (enumType) {
                return [enumType];
            }
        }
        else if (((_l = this.declaration) === null || _l === void 0 ? void 0 : _l.kind) === "TypeDeclaration" || ((_m = this.declaration) === null || _m === void 0 ? void 0 : _m.kind) === "TypeParameter") {
            const extensions = this.declaration.kind === "TypeDeclaration"
                ? this.declaration.extensions
                : this.declaration.kind === "TypeParameter"
                    ? this.declaration.constraints
                    : undefined;
            if (extensions) {
                return extensions
                    .map((extension) => {
                    var _a;
                    // map the input typeArgs to the base-type's arguments
                    const extEnv = ((_a = extension.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => {
                        var _a;
                        return ({
                            [(_a = arg === null || arg === void 0 ? void 0 : arg.name) === null || _a === void 0 ? void 0 : _a.name]: this.checker.instantiateTypeReference(arg, this.environment),
                        });
                    }).reduce((a, b) => ({ ...a, ...b }), {})) || undefined;
                    return this.checker.instantiateTypeReference(extension, extEnv);
                })
                    .filter(isNotUndefined);
            }
            if (((_o = this.declaration.name) === null || _o === void 0 ? void 0 : _o.name) !== AlexaSchema.Nothing && ((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) !== AlexaSchema.Thing) {
                return [this.checker.thing];
            }
        }
        else {
            return [this.checker.nothing];
        }
        return undefined;
    }
    /**
     * Ordered list of all Properties in this Type.
     *
     * @returns list of properties if any, `null` otherwise.
     */
    get properties() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        if (__classPrivateFieldGet(this, _Type_properties, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_properties, "f");
        }
        const properties = [];
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration") {
            // enum item has no properties, this will change when we support values https://github.com/alexa/ask-ac/issues/198
        }
        else if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" || this.isFunctionN()) {
            const typeType = this.checker.lookupTypeDeclaration(AlexaSchema.Type);
            const actionType = this.checker.lookupTypeDeclaration(AlexaConversations.Action);
            const argumentsType = this.checker.lookupTypeDeclaration(AlexaSchema.Arguments);
            const returnType = (_d = this.getFunctionReturnType()) !== null && _d !== void 0 ? _d : this.checker.thing;
            if (actionType && typeType && returnType) {
                properties.push({
                    kind: "Property",
                    index: 0,
                    name: "arguments",
                    type: new Type(this.checker, argumentsType, [this]),
                }, {
                    kind: "Property",
                    index: 1,
                    name: "returnType",
                    type: this.checker.instantiateTypeDeclaration(typeType, [returnType]),
                });
            }
        }
        else if (((_e = this.declaration) === null || _e === void 0 ? void 0 : _e.kind) === "TypeDeclaration") {
            if (((_f = this.declaration.name) === null || _f === void 0 ? void 0 : _f.name) === AlexaSchema.Type) {
                // this is the intrinsic `Type<T>` type that has varying behavior based on what type it references.
                const type = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g[0];
                if (type) {
                    if (((_h = type.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "EnumDeclaration") {
                        (_j = type.declaration.items) === null || _j === void 0 ? void 0 : _j.forEach((item, index) => {
                            var _a, _b;
                            if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
                                properties.push({
                                    kind: "Property",
                                    index,
                                    name: (_b = item.name) === null || _b === void 0 ? void 0 : _b.name,
                                    declaration: item,
                                    type: this.checker.getType(item),
                                });
                            }
                        });
                    }
                    else {
                        const propertiesType = this.checker.lookupTypeDeclaration(AlexaSchema.Properties);
                        if (propertiesType) {
                            properties.push({
                                kind: "Property",
                                index: 0,
                                name: "properties",
                                type: new Type(this.checker, propertiesType, [type]),
                            });
                        }
                    }
                }
            }
            else if (((_k = this.declaration.name) === null || _k === void 0 ? void 0 : _k.name) === AlexaSchema.Properties || ((_l = this.declaration.name) === null || _l === void 0 ? void 0 : _l.name) === AlexaSchema.ArgumentProperties) {
                const property = ((_m = this.declaration.name) === null || _m === void 0 ? void 0 : _m.name) === AlexaSchema.Properties ? AlexaSchema.Property : AlexaSchema.ArgumentProperty;
                const typeType = this.checker.lookupTypeDeclaration(AlexaSchema.Type);
                const propType = this.checker.lookupTypeDeclaration(property);
                const type = (_o = this.genericArguments) === null || _o === void 0 ? void 0 : _o[0];
                if (typeType && propType && (type === null || type === void 0 ? void 0 : type.properties) !== undefined) {
                    properties.push(...type.properties.map((prop) => ({
                        ...prop,
                        type: this.checker.instantiateTypeDeclaration(propType, [prop.type]),
                        declaration: undefined,
                    })));
                }
            }
            else if (((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) === AlexaConversations.ActionContextValues ||
                ((_q = this.declaration.name) === null || _q === void 0 ? void 0 : _q.name) === AlexaSchema.ArgumentValues ||
                ((_r = this.declaration.name) === null || _r === void 0 ? void 0 : _r.name) === AlexaSchema.Arguments) {
                // Arguments<F>, ArgumentValues<F> and ActionContextValues<A> all compute a type based on the arguments
                const targetType = (_s = this.genericArguments) === null || _s === void 0 ? void 0 : _s[0];
                const containerType = ((_t = this.declaration.name) === null || _t === void 0 ? void 0 : _t.name) === AlexaConversations.ActionContextValues
                    ? this.checker.lookupTypeDeclaration(AlexaSchema.Optional)
                    : this.declaration.name.name === AlexaSchema.Arguments
                        ? this.checker.lookupTypeDeclaration(AlexaSchema.Argument)
                        : undefined;
                properties.push(...((_v = (_u = targetType === null || targetType === void 0 ? void 0 : targetType.getFunctionArgumentDeclarations()) === null || _u === void 0 ? void 0 : _u.map((arg, index) => {
                    var _a, _b, _c, _d;
                    const innerType = this.checker.instantiateTypeReference(arg.type);
                    const prop = {
                        kind: "Property",
                        index,
                        name: (_a = arg.name) === null || _a === void 0 ? void 0 : _a.name,
                        type: ((_b = containerType === null || containerType === void 0 ? void 0 : containerType.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaSchema.Optional && (innerType === null || innerType === void 0 ? void 0 : innerType.isOptional())
                            ? innerType
                            : containerType
                                ? this.checker.instantiateTypeDeclaration(containerType, [innerType])
                                : ((_d = (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) === AlexaSchema.ArgumentValues
                                    ? innerType
                                    : undefined,
                        declaration: arg,
                    };
                    return prop;
                })) !== null && _v !== void 0 ? _v : []));
            }
            else if (((_w = this.declaration.name) === null || _w === void 0 ? void 0 : _w.name) === AlexaSchema.Optional) {
                // Optional<T> type would contain all the properties of `T`.
                const argumentType = (_x = this.genericArguments) === null || _x === void 0 ? void 0 : _x[0];
                if (argumentType && argumentType.properties) {
                    properties.push(...argumentType.properties);
                }
            }
            else {
                properties.push(...(((_z = (_y = this.declaration) === null || _y === void 0 ? void 0 : _y.properties) === null || _z === void 0 ? void 0 : _z.map((prop, index) => {
                    var _a;
                    let type = prop.type !== undefined ? this.checker.instantiateTypeReference(prop.type, this.environment) : undefined;
                    if (prop.optional === true && (type === null || type === void 0 ? void 0 : type.isOptional()) === false) {
                        const optionalType = this.checker.lookupTypeDeclaration(AlexaSchema.Optional);
                        if (optionalType) {
                            type = this.checker.instantiateTypeDeclaration(optionalType, [type]);
                        }
                    }
                    return {
                        kind: "Property",
                        declaration: prop,
                        index,
                        name: (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name,
                        type,
                    };
                })) || []));
            }
        }
        const seen = new Set();
        const _properties = [];
        addProperties(properties);
        if (this.extensions) {
            for (const ext of this.extensions) {
                if (ext.properties) {
                    addProperties(ext.properties);
                }
            }
        }
        __classPrivateFieldSet(this, _Type_properties, _properties || null, "f");
        return __classPrivateFieldGet(this, _Type_properties, "f") || undefined;
        function addProperties(properties) {
            if (properties) {
                for (const property of properties) {
                    if (!seen.has(property.name)) {
                        _properties.push(property);
                        seen.add(property.name);
                    }
                }
            }
        }
    }
    /**
     * Index of all Properties by name.
     */
    get propertiesIndex() {
        var _a;
        if (__classPrivateFieldGet(this, _Type_propertiesIndex, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_propertiesIndex, ((_a = this.properties) === null || _a === void 0 ? void 0 : _a.map((p) => ({
                [p.name]: p,
            })).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
        }
        return __classPrivateFieldGet(this, _Type_propertiesIndex, "f") || undefined;
    }
    /**
     * Apply a Call to this Type.
     *
     *
     * @param call expression of input to the Action.
     */
    apply(call, checker = this.checker) {
        return new Apply(checker, call, this);
    }
    /**
     * Instantiate a new Thing of this Type.
     *
     * @param node AST node this Thing value originates from.
     * @returns a Thing instance representing this distinct Thing
     */
    getThing(token, origin, parent, apply) {
        var _a;
        // use the environment of the Application or default to this environment
        const checker = (_a = apply === null || apply === void 0 ? void 0 : apply.checker) !== null && _a !== void 0 ? _a : this.checker;
        if (this.isPrimitive()) {
            if (this.isStringLike()) {
                return new StringThing(checker, token, this, apply, origin, parent);
            }
            if (this.isBoolean()) {
                return new BooleanThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNumber()) {
                return new NumberThing(checker, token, this, apply, origin, parent);
            }
            if (this.isVoid()) {
                return new VoidThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNothing()) {
                return new NothingThing(checker, token, this, apply, origin, parent);
            }
        }
        else if (this.isAction()) {
            return new ActionThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isDialog()) {
            return new DialogThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isFunction()) {
            return new FunctionThing(checker, token, this, (origin === null || origin === void 0 ? void 0 : origin.kind) === "ArgumentDeclaration" ? origin : undefined);
        }
        else if (this.isList()) {
            return new ListThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArgument()) {
            return new ArgumentThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArguments()) {
            return new ArgumentsThing(checker, token, this, origin, parent === null || parent === void 0 ? void 0 : parent.asFunction());
        }
        else if (this.isObject()) {
            return new ObjectThing(checker, token, this, apply, origin, parent);
        }
        return new AnyThing(checker, token, this, apply, origin, parent);
    }
    /**
     * Get the type of a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getPropertyType(argument) {
        var _a;
        return (_a = this.getProperty(argument)) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Get a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getProperty(argument) {
        var _a, _b, _c;
        if (argument === undefined) {
            return undefined;
        }
        if (ask.isArgument(argument)) {
            if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                return this.getProperty(argument.name.name);
            }
            if (typeof argument.index === "number") {
                return this.getProperty(argument.index);
            }
        }
        else if (typeof argument === "number") {
            return (_b = this.properties) === null || _b === void 0 ? void 0 : _b[argument];
        }
        else {
            const prop = (_c = this.propertiesIndex) === null || _c === void 0 ? void 0 : _c[argument];
            if (prop) {
                return prop;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const prop = ext.getProperty(argument);
                    if (prop) {
                        return prop;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Get the Nodes referenced by this Type.
     */
    getReferences() {
        var _a;
        const references = new Set();
        (_a = this.properties) === null || _a === void 0 ? void 0 : _a.forEach((prop) => {
            var _a, _b;
            if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                findReferences(prop.type);
            }
        });
        return references;
        function findReferences(type) {
            var _a, _b, _c;
            if ((type === null || type === void 0 ? void 0 : type.declaration) !== undefined && !references.has(type.declaration)) {
                references.add(type.declaration);
                (_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.forEach(findReferences);
                (_b = type.extensions) === null || _b === void 0 ? void 0 : _b.forEach(findReferences);
                (_c = type.properties) === null || _c === void 0 ? void 0 : _c.forEach((prop) => {
                    var _a, _b;
                    if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                        findReferences(prop.type);
                    }
                });
            }
        }
    }
    /**
     * Scan this type for any type arguments or super-types that consist of TypeParameters.
     */
    hasTypeParameters() {
        var _a, _b, _c;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return true;
        }
        return (((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.find((t) => t === null || t === void 0 ? void 0 : t.hasTypeParameters())) !== undefined ||
            ((_c = this.extensions) === null || _c === void 0 ? void 0 : _c.find((e) => e.hasTypeParameters())) !== undefined);
    }
    /**
     * A type has a catalog if it is:
     * - a built-in slot type
     * - a custom slot type found in the interaction model
     * - has an association with a catalog using `@catalog` annotation
     */
    hasCatalog() {
        var _a, _b, _c;
        return ((_c = (((_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(BuiltinsNamespace)) || ((_b = this.namespace) === null || _b === void 0 ? void 0 : _b.startsWith(SlotTypesNamespace)) || this.hasCatalogAnnotation())) !== null && _c !== void 0 ? _c : false);
    }
    hasCatalogAnnotation() {
        var _a, _b;
        return (ask.isTypeDeclaration(this.declaration) &&
            ((_b = (_a = this.declaration.annotations) === null || _a === void 0 ? void 0 : _a.filter((annotation) => { var _a; return (_a = this.checker.getApply(annotation.call)) === null || _a === void 0 ? void 0 : _a.isCatalogAction(); }).length) !== null && _b !== void 0 ? _b : 0) > 0);
    }
    /**
     * A custom type is one that is not defined in:
     * 1. com.amazon.alexa.schema
     * 2. com.amazon.alexa.ask.conversations
     * 3. com.amazon.ask.types.builtins.AMAZON
     *
     * TODO: validate that users can't use these namespaces: https://github.com/alexa/ask-ac/issues/3
     */
    isCustom() {
        return !(this.isBuiltIn() || this.isAlexaSchema() || this.isCoreType());
    }
    /**
     * Checks if this is a built in type provided by the platform.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     *
     * TODO: should we also consider Alexa Schema as built-in?
     */
    isBuiltIn() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(BuiltinsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * @returns true if the type can be used as the result type of an utterance
     */
    isValidForUtterance() {
        return this.isBuiltIn() || this.isCoreType() || this.isAlexaSchema() || this.isSlotType() || this.hasCatalog();
    }
    /**
     * Checks if this is a valid UtteranceEvent wrapper type
     */
    isValidUtteranceWrapper() {
        return (!this.isPrimitive() || this.isNothing()) && !this.isBuiltIn();
    }
    /**
     * Checks if this type is defined in an interaction model.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     */
    isSlotType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(SlotTypesNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in the AC core library.
     *
     * Namespace:
     * `com.amazon.alexa.ask.conversations`
     */
    isCoreType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(AlexaConversationsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in Alexa Schema.
     *
     * Namespace:
     * `com.amazon.alexa.schema`
     */
    isAlexaSchema() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(AlexaSchemaNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Check if this type is the top-level Skill type.
     */
    isSkill() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaConversations.Skill;
    }
    /**
     * Check if this type is the SkillLevelResponses type.
     */
    isSkillLevelResponses() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaConversations.SkillLevelResponses;
    }
    /**
     * Check if this type is the InvocationName type.
     */
    isInvocationName() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaConversations.InvocationName;
    }
    /**
     * A complex type is one with at least one property.
     */
    isObject() {
        var _a, _b;
        return ((_b = (_a = this.properties) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0;
    }
    /**
     * Check if a name is (inclusively) found in this type's hierarchy.
     *
     * @param name name of type to find
     */
    isNameInHierarchy(name) {
        return this.findNameInHierarchy(name) !== undefined;
    }
    /**
     * Find a type by name in this type's hierarchy.
     *
     * E.g.
     * ```
     * looking for UtteranceEvent<T>
     *
     * // type is the one we're looking for
     * UtteranceEvent<T> => UtteranceEvent<T>
     *
     * // search the type's hierarchy.
     * type A : UtteranceEvent<String> => UtteranceEvent<String>
     *
     * // type does not exist
     * type B => undefined
     * ```
     *
     *
     * @param name name of the type to find
     */
    findNameInHierarchy(name) {
        var _a, _b, _c;
        if (name !== undefined) {
            if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && typeof name === "function" ? name((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : ((_c = this.name) === null || _c === void 0 ? void 0 : _c.name) === name) {
                return this;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const found = ext.findNameInHierarchy(name);
                    if (found) {
                        return found;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Check if this is the intrinsic `Properties<T>` type that computes the properties of some type, `T`.
     */
    isProperties() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Properties;
    }
    /**
     * Check if this is the intrinsic `Property<T>`.
     */
    isProperty() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Property;
    }
    /**
     * If this is a type `Property<T>`, return the inner type, `T`.
     */
    getPropertyTypeType() {
        var _a;
        if (this.isProperty()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * Check if this is the `Type<T>` type.
     *
     * ```
     * type Person {
     *   String name
     * }
     *
     * // Type<Person>
     * person = Person
     * ```
     */
    isType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Type;
    }
    /**
     * Get the type of the `Type<T>` type - in this case, `T`.
     *
     * ```
     * Type<Person> => Person
     * ```
     */
    getTypeType() {
        var _a, _b;
        if (this.isType()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return (_b = this.findNameInHierarchy(AlexaSchema.Type)) === null || _b === void 0 ? void 0 : _b.getTypeType();
    }
    /**
     * Is the `ReturnValue<T>` intrinsic type.
     */
    isReturnValue() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.ReturnValue;
    }
    /**
     * Get the type parameter of the `ReturnValue<T>`.
     */
    getReturnValueType() {
        var _a;
        return this.isReturnValue() ? (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0] : undefined;
    }
    /**
     * Is this Type `alexa.schema.Nothing` (the Bottom Type)?
     */
    isNothing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Nothing;
    }
    /**
     * Is this Type `alexa.schema.Thing` (the Bottom Type)?
     */
    isThing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Thing;
    }
    /**
     * Is this type `Nothing`, `Void`, `Boolean`, `Number`, `String`, `Date` or `Time`.
     */
    isPrimitive() {
        return this.isNothing() || this.isVoid() || this.isBoolean() || this.isNumber() || this.isStringLike();
    }
    /**
     * Is this type one of 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'.
     */
    isResponseAct() {
        return (this.isRequest() ||
            this.isConfirmArgs() ||
            this.isConfirmAction() ||
            this.isNotify() ||
            this.isOffer() ||
            this.isReqAlt() ||
            this.isBye() ||
            this.isReqMore());
    }
    /**
     * Is this the Void type, `com.amazon.alexa.schema.Void`?
     *
     * @version 1.0.0-beta2
     */
    isVoid() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Void;
    }
    /**
     * Is this type, `Optional<T>`?
     *
     * Also known as a union, `T | Void`.
     */
    isOptional() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Optional;
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isBoolean() {
        return this.isNameInHierarchy(AlexaSchema.Boolean);
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isNumber() {
        return this.isNameInHierarchy(AlexaSchema.Number);
    }
    /**
     * Is this a String-like Type?
     *
     * TODO: should Date and Time really be considered String-like?
     */
    isStringLike() {
        return this.isString() || this.isUtterance();
    }
    /**
     * is this type String or a sub-type of String.
     */
    isString() {
        return this.isNameInHierarchy(AlexaSchema.String);
    }
    /**
     * Is this the core `com.amazon.alexa.ask.conversations.UtteranceEvent` type?
     */
    isUtteranceEvent() {
        return this.isNameInHierarchy(AlexaConversations.UtteranceEvent);
    }
    /**
     * Get the UtteranceEvent's inner type.
     *
     * E.g.
     *
     * ```
     * UtteranceEvent<Person> => Person
     * ```
     */
    getUtteranceEventType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaConversations.UtteranceEvent)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Get the IntentEvent's inner type.
     *
     * E.g.
     *
     * ```
     * IntentEvent<Person> => Person
     * ```
     */
    getIntentEventType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaConversations.IntentEvent)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic `Utterance` type, representing a type-safe sample utterance string.
     *
     * ```
     * // UtteranceEvent<Person>
     * u = utterances<Person>(
     *   // List<Utterance<Person>>
     *   [
     *     // Utterance<Person>
     *     "i am {name}"
     *   ]
     * )
     * ```
     */
    isUtterance() {
        return this.isNameInHierarchy(AlexaConversations.Utterance);
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Argument type representing an argument on some action.
     *
     * ```
     * action A(String arg)
     *
     * // Argument<String>
     * a = A.arguments.arg
     * ```
     */
    isArgument() {
        return this.isNameInHierarchy(AlexaSchema.Argument);
    }
    /**
     * @returns the type `T` in `Argument<T>`.
     */
    getArgumentType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaSchema.Argument)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Arguments type representing the arguments of some Action.
     *
     * ```
     * action A(String arg)
     *
     * // Arguments<A>
     * a = A.arguments
     * ```
     */
    isArguments() {
        return this.isNameInHierarchy(AlexaSchema.Arguments);
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * Utterance<Person> => (type) Person
     * utterances<Person>([
     *   "hello" => (type) Person
     * ])
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getUtteranceType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaConversations.Utterance)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Get the type of an Optional.
     *
     * ```
     * Optional<String> => (type) String
     * Optional<T> => (type parameter) T
     * ```
     */
    getOptionalType() {
        var _a;
        if (this.isOptional()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * If this is Optional<T> returns T else returns this
     * @returns
     */
    getNonOptionalType() {
        var _a;
        return this.isOptional() && ((_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0]) ? this.genericArguments[0] : this;
    }
    /**
     * Checks if this type is the `Locale` enum type.
     */
    isLocale() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Locale;
    }
    /**
     * Checks if this type is the `AnnotationTarget` enum type.
     */
    isAnnotationTarget() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.AnnotationTarget;
    }
    /**
     * Checks if this is a type that extends the base Function type.
     *
     * Both Action and Dialog types extend Function.
     *
     * @returns
     */
    isFunction() {
        return this.findNameInHierarchy(AlexaSchema.Function) !== undefined;
    }
    /**
     * Checks if this Type extends one of `FunctionN` functions where `N` is a numerical value representing
     * the number of arguments in the Function.
     */
    isFunctionN() {
        return this.getFunctionN() !== undefined;
    }
    /**
     * Gets the `FunctionN` type in this Type's hierarchy if this is of type `FunctionN` where `N` is a
     * numerical value representing the number of arguments in the Function.
     */
    getFunctionN() {
        return this.findNameInHierarchy((s) => s.startsWith(AlexaSchema.Function) && s !== AlexaSchema.Function);
    }
    /**
     * If this Type is a Function (Dialog or Action) then
     * @returns
     */
    getFunctionReturnType() {
        var _a, _b, _c, _d;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.checker.instantiateTypeReference(this.declaration.returnType);
        }
        if (this.isFunctionN()) {
            const functionN = this.getFunctionN();
            return (_c = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _c === void 0 ? void 0 : _c[((_d = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _d === void 0 ? void 0 : _d.length) - 1];
        }
        return undefined;
    }
    getFunctionArgumentType(index) {
        var _a, _b;
        return (_b = (_a = this.getFunctionN()) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[index];
    }
    getFunctionArgumentTypes() {
        var _a, _b, _c, _d, _e;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return (_c = this.declaration.arguments) === null || _c === void 0 ? void 0 : _c.map((arg) => this.checker.getType(arg));
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => { var _a; return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]; });
            }
            // parse the value of N in a FunctionN/ActionN/DialogN.
            const nStr = (_d = this.shortName) === null || _d === void 0 ? void 0 : _d.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    args.push((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e[i]);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Get the ArgumentDeclarations for this Type if the Type is a Function.
     */
    getFunctionArgumentDeclarations() {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.declaration.arguments;
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => {
                    var _a, _b, _c;
                    const decl = new ask.ArgumentDeclaration(new ask.Name(name), (_b = (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.toTypeReference());
                    (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.setAsParentOn(decl);
                    return decl;
                });
            }
            const nStr = (_c = this.shortName) === null || _c === void 0 ? void 0 : _c.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    // BUG: we are moving the TypeReference to the TypeDeclaration so it has the wrong lexical scope.
                    const decl = new ask.ArgumentDeclaration(new ask.Name(`arg${i}`), (_e = (_d = this.genericArguments) === null || _d === void 0 ? void 0 : _d[i]) === null || _e === void 0 ? void 0 : _e.toTypeReference());
                    (_f = this.declaration) === null || _f === void 0 ? void 0 : _f.setAsParentOn(decl);
                    args.push(decl);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Takes two Function types and creates a mapping between their respective argument names based on position.
     *
     * This is the foundation on which we allow functions passed around as arguments to be compatible even
     * when they don't have the same argument names. We do not wish for argument names to be relevant for
     * the compatibility of functions.
     *
     * Ex. `foo.getFunctionArgumentDeclarationMappings(Foo)`:
     * ```
     * action String Foo(String arg)
     *
     * dialog Bar(
     *   action String foo(String str)
     * ) {
     *   sample {
     *     // here, foo's `str` will be mapped to Foo's `arg`.
     *     foo(str = "hello")
     *   }
     * }
     * ```
     *
     * @param other the other type we are mapping this argument's names to.
     * @returns resulting mappings will map from `this`'s argument names to `other`'s argument names.
     */
    getFunctionArgumentDeclarationMappings(other) {
        var _a;
        if (other === undefined || !(other.isFunction() && this.isFunction())) {
            return undefined;
        }
        const thisArgs = this.getFunctionArgumentDeclarations();
        if (thisArgs === undefined) {
            return undefined;
        }
        return (_a = other
            .getFunctionArgumentDeclarations()) === null || _a === void 0 ? void 0 : _a.map((arg, i) => {
            var _a, _b;
            const argDecl = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs[i];
            if (((_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name) && ((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name)) {
                return {
                    [argDecl.name.name]: arg.name.name,
                };
            }
            return {};
        }).reduce((a, b) => ({ ...a, ...b }), {});
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialogDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "DialogDeclaration";
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialog() {
        return this.findNameInHierarchy(AlexaConversations.Dialog) !== undefined;
    }
    /**
     * Checks if this type is a fully qualified TypeDeclaration.
     */
    isTypeDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeDeclaration";
    }
    /**
     * Checks if this type is a fully qualified ActionDeclaration.
     */
    isActionDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration";
    }
    isAction() {
        return this.findNameInHierarchy(AlexaConversations.Action) !== undefined;
    }
    /**
     * Checks if this is a type
     * @returns
     */
    isEnum() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumDeclaration";
    }
    /**
     * Checks if this is a Type representing an item in an `enum`.
     * @returns
     */
    isEnumItem() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration";
    }
    /**
     * Is this `com.amazon.alexa.ask.conversations.Args` or a sub-type.
     *
     * This type represents var args in an Action.
     *
     * ```
     * action void A(Args<String>)
     *
     * a = A(
     *   "no need",
     *   "to surround these with",
     *   "[ and ]"
     * )
     * ```
     */
    isArgs() {
        return this.isNameInHierarchy(AlexaConversations.Args);
    }
    /**
     * Does this Type extend `alexa.schema.List`.
     */
    isList() {
        return this.isNameInHierarchy(AlexaSchema.List);
    }
    isTaskContextProjection() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.TaskContextProjection;
    }
    isTaskContextProjectionType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.TaskContextProjectionType;
    }
    isTaskContextProjectionAnnotation() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.taskContextProjection;
    }
    isTaskContextProjectionInfo() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.TaskContextProjectionInfo;
    }
    /**
     * Is this type one of 'Invoke', 'Inform', 'Affirm', 'Deny', 'RequestAct'.
     */
    isRequestAct() {
        var _a;
        return this.isInvoke() || this.isInform() || this.isAffirm() || this.isDeny() || ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.RequestAct;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Invoke"
     */
    isInvoke() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Invoke;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Inform"
     */
    isInform() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Inform;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Affirm"
     */
    isAffirm() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Affirm;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Deny"
     */
    isDeny() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Deny;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Offer"
     */
    isOffer() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Offer;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqAlt"
     */
    isReqAlt() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ReqAlt;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isReqMore() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ReqMore;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Request"
     */
    isRequest() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Request;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.RequestArguments"
     */
    isRequestArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.RequestArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmAction"
     */
    isConfirmAction() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmAction;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmArgs"
     */
    isConfirmArgs() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmArgs;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmArguments"
     */
    isConfirmArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Bye"
     */
    isBye() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Bye;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Notify"
     */
    isNotify() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Notify;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APLA"
     */
    isApla() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.APLA;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.MultiModalResponse"
     */
    isMultiModalResponse() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.MultiModalResponse;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APL"
     */
    isApl() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.APL;
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * List<String> => (type) String
     * List<T> => (type parameter) T
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getListItemType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaSchema.List)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Check if this type is a sub-type (or same type) as a `baseType`.
     *
     * A type, `A` extends another type, `B` if `A & B == B`.
     *
     * In other words, the intersection of A and B should be exactly B.
     *
     * @param baseType base type
     */
    extends(baseType) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (baseType === undefined) {
            return false;
        }
        if (this.isNothing()) {
            // Nothing is a sub type of all Things
            return true;
        }
        if (baseType.isThing()) {
            // Thing is the base type of all Things.
            return true;
        }
        if (this.isVoid() && baseType.isOptional()) {
            return true;
        }
        if (this.isVoid() && baseType.isNothing()) {
            // for backwards compatibility, we will equate `Nothing` and `Void`.
            return true;
        }
        if ((((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" && ((_b = baseType.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration") ||
            (((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" && ((_d = baseType.declaration) === null || _d === void 0 ? void 0 : _d.kind) === "DialogDeclaration")) {
            // if we are comparing literal actions/dialogs, then their name must be identical regardless of compatibility
            // we still uphold nominal rules when comparing static references.
            return ((_e = this.declaration.name) === null || _e === void 0 ? void 0 : _e.name) === ((_f = baseType.declaration.name) === null || _f === void 0 ? void 0 : _f.name);
        }
        if (this.isFunctionN() && baseType.isFunctionN()) {
            if (baseType.isAction() && !this.isAction()) {
                return false;
            }
            if (baseType.isDialog() && !this.isDialog()) {
                return false;
            }
            const thisArgs = (_g = this.getFunctionN()) === null || _g === void 0 ? void 0 : _g.getFunctionArgumentTypes();
            const baseTypeArgs = (_h = baseType.getFunctionN()) === null || _h === void 0 ? void 0 : _h.getFunctionArgumentTypes();
            if (!((_k = (_j = this.getFunctionReturnType()) === null || _j === void 0 ? void 0 : _j.extends(baseType.getFunctionReturnType())) !== null && _k !== void 0 ? _k : false)) {
                // return types are co-variant, this function's return type must extend the base function's return type
                return false;
            }
            // Lengths are different, lets check the extraneous arguments in baseType and ensure they're optional
            if ((thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length) && (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length)) {
                const startArgPos = (_l = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== null && _l !== void 0 ? _l : 0;
                for (let i = startArgPos; i < baseTypeArgs.length; i++) {
                    if (!baseTypeArgs[i].isOptional() || !baseTypeArgs[i].isArgs()) {
                        return false;
                    }
                }
            }
            return ((_m = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.map((thisArg, i) => {
                const otherArg = baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs[i];
                if (otherArg === undefined) {
                    return thisArg.isOptional() || thisArg.isArgs();
                }
                // arguments are contra-variant, the base type's argument must be a super-type of this function's argument.
                return otherArg.extends(thisArg);
            }).reduce((a, b) => a && b, true)) !== null && _m !== void 0 ? _m : false);
        }
        if (((_o = this.name) === null || _o === void 0 ? void 0 : _o.name) === ((_p = baseType.name) === null || _p === void 0 ? void 0 : _p.name)) {
            if (this.genericArguments) {
                if (this.genericArguments.length === ((_q = baseType.genericArguments) === null || _q === void 0 ? void 0 : _q.length)) {
                    return this.genericArguments.find((genericArg, i) => (genericArg === null || genericArg === void 0 ? void 0 : genericArg.extends(baseType === null || baseType === void 0 ? void 0 : baseType.genericArguments[i])) !== true) === undefined;
                }
                return false;
            }
            return true;
        }
        // Check optional types, we currently allow Optional<T> as assignable to T.
        if (baseType.isOptional()) {
            return this.extends(baseType.getOptionalType());
        }
        else if (this.isOptional()) {
            return (_s = (_r = this.getOptionalType()) === null || _r === void 0 ? void 0 : _r.extends(baseType)) !== null && _s !== void 0 ? _s : false;
        }
        return ((_t = this.extensions) === null || _t === void 0 ? void 0 : _t.find((extension) => (extension === null || extension === void 0 ? void 0 : extension.extends(baseType)) === true)) !== undefined;
    }
    /**
     * Check if two instantiated types are identical.
     *
     * @param other
     */
    equals(other) {
        var _a;
        if (this.name !== undefined && this.name === other.name) {
            if (this.genericArguments !== undefined && this.genericArguments.length === ((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                for (let i = 0; i < this.genericArguments.length; i++) {
                    const _this = this.genericArguments[i];
                    const _other = other.genericArguments[i];
                    if (_this === undefined || _other === undefined) {
                        return false;
                    }
                    if (!_this.equals(_other)) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Get the union of this type and another. We only have limited support for unions at this time.
     *
     * Rules:
     * 1. Void | Void = Void
     * 2. Nothing | T = T
     * 3. Void | T = Optional<T>
     * 4. Optional<T> | T = Optional<T>
     * 5. A | B = A & B
     *
     * RE: Rule #5 - when two non-Optional or Void types are unioned, we take their intersection. I.e. we
     * reduce their type to their most common denominator. We will change this once we add full support for
     * union types.
     *
     * @param other other type to union this type with
     * @returns the unioned type.
     */
    union(other) {
        var _a, _b;
        if (other === undefined) {
            return this;
        }
        if (this.equals(other)) {
            return this;
        }
        if (this.isNothing()) {
            return other;
        }
        if (other === null || other === void 0 ? void 0 : other.isNothing()) {
            return this;
        }
        if (this.isVoid() && (other === null || other === void 0 ? void 0 : other.isVoid())) {
            return this;
        }
        if (this.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(AlexaSchema.Optional), [other]);
        }
        if (other.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(AlexaSchema.Optional), [this]);
        }
        if (this.isOptional()) {
            return this.checker.void.union((_a = this.getOptionalType()) === null || _a === void 0 ? void 0 : _a.union(other));
        }
        if (other.isOptional()) {
            return this.checker.void.union((_b = other.getOptionalType()) === null || _b === void 0 ? void 0 : _b.union(this));
        }
        return this.intersect(other);
        // return this.getIntersection(other);
    }
    intersect(other) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.isNothing() || (other === null || other === void 0 ? void 0 : other.isNothing())) {
            return this.checker.nothing;
        }
        if (other === undefined) {
            return undefined;
        }
        if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ((_b = other.name) === null || _b === void 0 ? void 0 : _b.name)) {
            if (((_c = this.genericArguments) === null || _c === void 0 ? void 0 : _c.length) === 0 && ((_d = other.genericArguments) === null || _d === void 0 ? void 0 : _d.length) === 0) {
                return this;
            }
            if (((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e.length) === ((_f = other.genericArguments) === null || _f === void 0 ? void 0 : _f.length)) {
                const genericArguments = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g.map((genericArg, i) => { var _a, _b; return (_b = genericArg === null || genericArg === void 0 ? void 0 : genericArg.intersect((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a[i])) !== null && _b !== void 0 ? _b : this.checker.thing; });
                return new Type(this.checker, this.declaration, genericArguments);
            }
        }
        else if (this.extends(other)) {
            for (const ext of (_h = this.extensions) !== null && _h !== void 0 ? _h : []) {
                if (ext.extends(other)) {
                    return ext.intersect(other);
                }
            }
        }
        else if (other.extends(this)) {
            for (const ext of (_j = other.extensions) !== null && _j !== void 0 ? _j : []) {
                if (ext.extends(this)) {
                    return ext.intersect(this);
                }
            }
        }
        else {
            for (const thisExt of (_k = this.extensions) !== null && _k !== void 0 ? _k : []) {
                for (const otherExt of (_l = other.extensions) !== null && _l !== void 0 ? _l : []) {
                    if (thisExt.extends(otherExt)) {
                        return thisExt.intersect(otherExt);
                    }
                }
            }
        }
        return this.checker.thing;
    }
    narrow(other) {
        if (other === undefined) {
            return this;
        }
        if (other.extends(this)) {
            // if the other type is more narrow, choose it
            return other;
        }
        if (this.extends(other)) {
            // if this type is more general, choose the other
            return this;
        }
        // these types have no intersection, this case is impossible.
        return this.checker.nothing;
    }
    /**
     * Find all locales this type support
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales() {
        if (__classPrivateFieldGet(this, _Type_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_locales, "f");
        }
        const slotTypes = new Set();
        const seen = new Set();
        // Find all slotTypes this type depends on
        if (this.isSlotType()) {
            slotTypes.add(this.declaration);
        }
        else {
            // recursively look up the child types
            visitEachChildType(this, function collectSlotType(type) {
                var _a;
                if (type.declaration && !seen.has(type.toString())) {
                    seen.add(type.toString());
                    if (((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
                        slotTypes.add(type.declaration);
                    }
                    visitEachChildType(type, collectSlotType);
                }
            });
        }
        // calculate the overlap locales that all slotTypes support
        let locales;
        for (const slotType of slotTypes.values()) {
            if (!locales) {
                locales = [...slotType.locales];
            }
            else {
                locales = locales.filter((locale) => slotType.locales.includes(locale));
            }
        }
        __classPrivateFieldSet(this, _Type_locales, locales, "f");
        return __classPrivateFieldGet(this, _Type_locales, "f");
    }
    /**
     * Gets a map of required property names to properties in this.properties
     * @returns a map of required property names to properties in this.properties
     */
    getRequiredProperties() {
        var _a;
        return new Map((_a = this.properties) === null || _a === void 0 ? void 0 : _a.reduce((acc, property) => {
            var _a, _b, _c;
            if (((_a = property.type) === null || _a === void 0 ? void 0 : _a.isOptional()) || (((_b = property.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "TypeProperty" && ((_c = property.declaration) === null || _c === void 0 ? void 0 : _c.optional) === true)) {
                return acc;
            }
            acc.push([property.name, property]);
            return acc;
        }, []));
    }
    /**
     * Gets a map of property names to corresponding properties
     * @returns a map of property names to corresponding properties
     */
    getPropertyMap() {
        var _a;
        return new Map(((_a = this.properties) !== null && _a !== void 0 ? _a : []).map((property) => [property.name, property]));
    }
    /**
     * Retrieves generic arguments nested in a Type declaration of the form Apply<Optional<T>,K>.
     * For such type this will return an array with two elements, a type object corresponding to T
     * and a type object corresponding to K.
     */
    getNestedGenericArguments() {
        var _a, _b;
        // This is the recursion termination case for when we reach T in  Action1<Optional<T>, Nothing>
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return [this];
        }
        const typeGenericArguments = (_b = this.genericArguments) !== null && _b !== void 0 ? _b : [];
        if (typeGenericArguments.length === 0) {
            // This is a special case found in Action1<Optional<T>, Nothing>. Nothing has no
            // nested generic arguments so we just return a type object corresponding to Nothing
            return [this];
        }
        // Call getNestedGenericArguments recursively on each of this.genericArguents
        const returnValue = [];
        for (const typeGenericArgument of typeGenericArguments) {
            if (!typeGenericArgument) {
                continue;
            }
            returnValue.push(...typeGenericArgument.getNestedGenericArguments());
        }
        return returnValue;
    }
    /**
     * Leaf types of a type are the types that have no properties.
     *
     * This method recursively searches all of the properties of this type (extensions included)
     * until is finds all of leaf type.
     *
     * i.e.
     *
     * ```acdl
     * type NestedEmptyType {}
     *
     * type NestedType {
     *  String name
     *  NestedEmptyType empty
     * }
     *
     * type Weather {
     *   Number temperature
     * }
     *
     * type Example {
     *  String str
     *  NestedType nestedProp
     *  Weather weather
     * }
     * ```
     *
     * Processing the type `Example` would return the following array of types: `[String, Number, NestedEmptyType]`
     *
     * @param seen - the types that have been processed so far.
     * @returns Array of unique leaf types.
     */
    getLeafTypes(seen = new Set()) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (__classPrivateFieldGet(this, _Type_leafTypes, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_leafTypes, "f");
        }
        // We've already processed this type
        if (seen === null || seen === void 0 ? void 0 : seen.has(this.toString())) {
            return [];
        }
        if (this.isOptional()) {
            return (_b = (_a = this.getOptionalType()) === null || _a === void 0 ? void 0 : _a.getLeafTypes(seen)) !== null && _b !== void 0 ? _b : [];
        }
        if (this.isList()) {
            return (_d = (_c = this.getListItemType()) === null || _c === void 0 ? void 0 : _c.getLeafTypes(seen)) !== null && _d !== void 0 ? _d : [];
        }
        seen.add(this.toString());
        // Base case: A non optional Type with no properties
        if (!((_e = this.properties) === null || _e === void 0 ? void 0 : _e.length)) {
            return [this];
        }
        const seenLeafTypes = new Set();
        const leafTypes = [];
        // Recursive case: Get the leaf types by searching through properties
        for (const property of (_f = this.properties) !== null && _f !== void 0 ? _f : []) {
            const leafs = (_h = (_g = property.type) === null || _g === void 0 ? void 0 : _g.getLeafTypes(seen)) !== null && _h !== void 0 ? _h : [];
            for (const leaf of leafs) {
                const typeName = (_j = leaf === null || leaf === void 0 ? void 0 : leaf.name) === null || _j === void 0 ? void 0 : _j.name;
                if (typeName && !seenLeafTypes.has(typeName)) {
                    leafTypes.push(leaf);
                    seenLeafTypes.add(typeName);
                }
            }
        }
        __classPrivateFieldSet(this, _Type_leafTypes, leafTypes, "f");
        return __classPrivateFieldGet(this, _Type_leafTypes, "f");
    }
    /**
     *
     * Searches a type for either an empty base type or for all empty leaf types.
     *
     * An empty type is defined as a type that has no properties and is neither a primitive or a catalog.
     *
     * @param type - the type to search for empty types.
     * @returns The empty subtypes in this type, or this if it's an empty base type.
     */
    getEmptyLeafTypes() {
        // The TaskContextProjection types are used with the loadContext and saveContext() api calls
        // and are allowed to have empty types. i.e (ReturnType, Action, ActionContextValues)
        if (this.isTaskContextProjection() || this.isTaskContextProjectionInfo()) {
            return [];
        }
        const genericEnvironment = this.environment || {};
        // we are currently unable to retrieve properties for generic types in some resuable dialog scenarios
        // hence the condition about the leaf type not being a generic type.
        // See https://github.com/alexa/ask-ac/issues/1357
        return this.getLeafTypes().filter((leafType) => { var _a; return !leafType.isPrimitive() && !leafType.hasCatalog() && !genericEnvironment[((_a = leafType.name) === null || _a === void 0 ? void 0 : _a.name) || ""]; });
    }
}
_Type_environment = new WeakMap(), _Type_extensions = new WeakMap(), _Type_properties = new WeakMap(), _Type_propertiesIndex = new WeakMap(), _Type_locales = new WeakMap(), _Type_leafTypes = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDO0FBRTdCLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDOUIsT0FBTyxFQUNMLGNBQWMsRUFDZCxrQkFBa0IsRUFDbEIsMkJBQTJCLEVBQzNCLFdBQVcsRUFDWCxvQkFBb0IsRUFDcEIsaUJBQWlCLEVBQ2pCLGNBQWMsRUFDZCxrQkFBa0IsR0FDbkIsTUFBTSxPQUFPLENBQUM7QUFHZixPQUFPLEVBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFN0QsT0FBTyxFQUNMLFdBQVcsRUFDWCxRQUFRLEVBQ1IsY0FBYyxFQUNkLGFBQWEsRUFDYixZQUFZLEVBQ1osV0FBVyxFQUNYLGFBQWEsRUFDYixTQUFTLEVBQ1QsWUFBWSxFQUNaLFdBQVcsRUFDWCxXQUFXLEVBQ1gsV0FBVyxFQUVYLFNBQVMsR0FDVixNQUFNLFNBQVMsQ0FBQztBQUVqQixPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFM0MsTUFBTSxVQUFVLE1BQU0sQ0FBQyxHQUFRO0lBQzdCLE9BQU8sQ0FBQSxHQUFHLGFBQUgsR0FBRyx1QkFBSCxHQUFHLENBQUUsSUFBSSxNQUFLLE1BQU0sQ0FBQztBQUM5QixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxPQUFPLElBQUk7SUFHZixZQUNXLE9BQW9CO0lBQzdCOztPQUVHO0lBQ00sV0FRWTtJQUNyQjs7T0FFRztJQUNNLGdCQUF1QztJQUNoRDs7T0FFRztJQUNILDhCQUE4QjtJQUNyQixxQkFBZ0M7SUFDekM7O09BRUc7SUFDTSxZQUFxQjs7Ozs7bUJBekJyQjs7Ozs7O21CQUlBOzs7Ozs7bUJBWUE7Ozs7OzttQkFLQTs7Ozs7O21CQUlB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