var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ActionThing_locales, _DialogThing_locales;
import * as ask from "./ast";
import { AlexaSchema } from "./ast";
import { Type } from "./type";
import { visitEachChild } from "./visit";
class BaseThing {
    constructor(checker, 
    /**
     * Unique token identifying this Thing.
     */
    token, 
    /**
     * Represents the Type of this Thing.
     */
    type, 
    /**
     * Optional `Apply` instance if this `Thing` is the result of a Call.
     */
    apply, 
    /**
     * The node that this Thing originates from.
     */
    origin, 
    /**
     * The parent of this THing, e.g. `person` in `person.name`.
     */
    parent, 
    /**
     * Location of this Thing in the Source Tree.
     */
    loc = origin === null || origin === void 0 ? void 0 : origin.loc, 
    /**
     * URI of the SourceFile of this Thing.
     */
    uri = origin === null || origin === void 0 ? void 0 : origin.uri) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: token
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "apply", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: apply
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parent
        });
        Object.defineProperty(this, "loc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: loc
        });
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uri
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Thing"
        });
        Object.defineProperty(this, "propertiesIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    get root() {
        if (this.parent === undefined) {
            return this;
        }
        return this.parent.root;
    }
    /**
     * Checks if this Thing is a literal value.
     */
    isLiteral() {
        return this.apply !== undefined && this.apply.isType();
    }
    /**
     * Get a new Thing representing this Thing refined to a more narrow type within a specific context.
     *
     * @returns the more narrowly typed thing.
     */
    cast(type, origin) {
        if (this.isAction()) {
            return new ActionThing(this.checker, this.token, type, this.origin);
        }
        if (this.isDialog()) {
            return new DialogThing(this.checker, this.token, type, this.origin);
        }
        if (type.isArgument()) {
            return new ArgumentThing(this.checker, this.token, type, undefined, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isArguments()) {
            return new ArgumentsThing(this.checker, this.token, type, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isObject()) {
            return new ObjectThing(this.checker, this.token, type, this.apply, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isList()) {
            return new ListThing(this.checker, this.token, type, this.apply, origin !== null && origin !== void 0 ? origin : this.origin, this.parent);
        }
        if (type.isPrimitive()) {
            return type.getThing(this.token, origin !== null && origin !== void 0 ? origin : this.origin, this.parent, this.apply);
        }
        return type.getThing(this.token, origin !== null && origin !== void 0 ? origin : this.origin, this.parent, this.apply);
    }
    /**
     * Check if this Thing equals the {@link other} Thing. Equality is determined by the unique {@link Thing.token}
     * given to the Thing.
     *
     * @param other other thing to compare against this Thing.
     * @returns `true` if they are the exact same value, `false` otherwise.
     */
    equals(other) {
        return this.token === (other === null || other === void 0 ? void 0 : other.token);
    }
    /**
     * Helper method to compare if this {@link Thing} complies with some type-narrowing assertion, {@link f};
     * @param f function which narrows the type of this thing.
     * @returns `true` if the condition passes or `false` otherwise.
     */
    is(f) {
        return f(this);
    }
    /**
     * Casts this `Thing` to {@link T} if the condition {@link f} passes, otherwise returns `undefined`.
     *
     * @param f assertion function to apply to this Thing.
     * @returns casts this `Thing` to {@link T} if the condition {@link f} passes, otherwise returns `undefined`.
     */
    as(f) {
        return this.is(f) ? this : undefined;
    }
    /**
     * Checks if this is a {@link NothingThing} instance.
     */
    isNothing() {
        return this instanceof NothingThing;
    }
    /**
     * Checks if this is a {@link VoidThing} instance.
     */
    isVoid() {
        return this instanceof VoidThing;
    }
    /**
     * Checks if this is a {@link ObjectThing} instance.
     */
    isObject() {
        return this instanceof ObjectThing;
    }
    /**
     * Checks if this is a {@link AnyThing} instance.
     */
    isAny() {
        return this instanceof AnyThing;
    }
    /**
     * Checks if this is a {@link Primitive} instance.
     */
    isPrimitive() {
        return this instanceof PrimitiveThing;
    }
    /**
     * @returns a {@link Primitive} instance if this is one, otherwise `undefined`.
     */
    asPrimitive() {
        return this.isPrimitive() ? this : undefined;
    }
    /**
     * @returns a {@link StringThing} instance if this is one, otherwise `undefined`.
     */
    asString() {
        return this.isString() ? this : undefined;
    }
    /**
     * Checks if this is a {@link StringThing instance.
     */
    isString() {
        return this instanceof StringThing;
    }
    /**
     * @returns a {@link NumberThing} instance if this is one, otherwise `undefined`.
     */
    asNumber() {
        return this.isNumber() ? this : undefined;
    }
    isNumber() {
        return this instanceof NumberThing;
    }
    asBoolean() {
        return this.isBoolean() ? this : undefined;
    }
    isBoolean() {
        return this instanceof BooleanThing;
    }
    asList() {
        return this.isList() ? this : undefined;
    }
    isList() {
        return this instanceof ListThing;
    }
    asLiteralList() {
        return this.isList() && this.isLiteral() ? this : undefined;
    }
    isLiteralList() {
        return this.isLiteral() && this.isList();
    }
    isFunction() {
        return this instanceof FunctionThing;
    }
    asFunction() {
        return this.isFunction() ? this : undefined;
    }
    isAction() {
        return this instanceof ActionThing;
    }
    asAction() {
        return this.isAction() ? this : undefined;
    }
    isArgument() {
        return this instanceof ArgumentThing;
    }
    asArgument() {
        return this.isArgument() ? this : undefined;
    }
    isArguments() {
        return this instanceof ArgumentsThing;
    }
    asArguments() {
        return this.isArguments() ? this : undefined;
    }
    isDialog() {
        return this instanceof DialogThing;
    }
    asDialog() {
        return this.isDialog() ? this : undefined;
    }
    isUnion() {
        return this instanceof UnionThing;
    }
    getPropertiesList() {
        var _a;
        return Object.values((_a = this.getProperties()) !== null && _a !== void 0 ? _a : {});
    }
    /**
     * @returns an object where the keys are the names of arguments and the values are {@link Thing} instances
     * representing values within a simulation or abstract values during type checking.
     */
    getProperties() {
        if (this.isLiteral()) {
            const args = this.apply.getArguments();
            if (args !== undefined) {
                return Object.keys(args)
                    .map((propName) => ({
                    [propName]: this.getProperty(propName),
                }))
                    .reduce((a, b) => ({ ...a, ...b }), {});
            }
        }
        return undefined;
    }
    /**
     * If this {@link Thing} is an Object containing properties, or a {@link UnionThing} of many Object Types that
     * contain properties, then return a {@link Thing} representing that property. This interface applies in both the
     * abstract type-checking phase of the compiler as well as during evaluation of a Dialog {@link Flow}.
     *
     * @returns a {@link Thing} value representing the value of a property of "this" {@link Thing}. If this is not
     * an {@link ObjectThing} or the property does not exist, then `undefined` is returned.
     */
    getProperty(name) {
        var _a, _b, _c;
        if (this.propertiesIndex === undefined) {
            this.propertiesIndex = new Map();
        }
        const propertyName = typeof name === "string" ? name : name === null || name === void 0 ? void 0 : name.name;
        if (propertyName === undefined) {
            return undefined;
        }
        const propertyToken = `${this.token}[${propertyName}]`;
        if (this.isObject()) {
            let thing = this.propertiesIndex.get(propertyName);
            if (thing === undefined) {
                if (this.isLiteral()) {
                    thing = this.checker.getThing((_a = this.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue(propertyName), propertyToken);
                }
                else {
                    thing = (_b = this.type
                        .getPropertyType(propertyName)) === null || _b === void 0 ? void 0 : _b.getThing(propertyToken, typeof name === "string" ? undefined !== null && undefined !== void 0 ? undefined : new ask.Name(name) : name, this);
                    this.propertiesIndex.set(propertyName, thing !== null && thing !== void 0 ? thing : null);
                }
            }
            return thing !== null && thing !== void 0 ? thing : undefined;
        }
        if (this.isUnion()) {
            const things = this.things.map((thing) => { var _a; return (_a = thing.getProperty(name)) !== null && _a !== void 0 ? _a : this.checker.void.getThing(propertyToken, undefined); });
            const type = things
                .map((t) => { var _a; return (_a = t === null || t === void 0 ? void 0 : t.type) !== null && _a !== void 0 ? _a : this.checker.nothing; })
                .reduce((a, b) => { var _a; return (_a = a.union(b)) !== null && _a !== void 0 ? _a : this.checker.nothing; }, this.checker.nothing);
            return new UnionThing(this.checker, propertyToken, type, typeof name === "string" ? undefined : name, things);
        }
        if (this.isArgument()) {
            const thing = (_c = this.type.getPropertyType(propertyName)) === null || _c === void 0 ? void 0 : _c.getThing(propertyToken, undefined);
            this.propertiesIndex.set(propertyName, thing !== null && thing !== void 0 ? thing : null);
            return thing;
        }
        return undefined;
    }
    /**
     * If this is a {@link ListThing} or a {@link UnionThing} of many {@link ListThing} types, then return a {@link Thing}
     * representing the item at the specified {@link index} in the list.
     *
     * @param index the index of the item to access in the list. The index can either be a literal number or an abstract {@link NumberThing}
     * @param origin optional override of the node from which this {@link Thing} value originated from.
     * @returns a {@link Thing} representing the item if it exists or `undefined` otherwise.
     */
    getItem(index, origin) {
        var _a, _b, _c;
        const literal = typeof index === "number" ? index : typeof index.literal === "number" ? index.literal : index.token;
        const itemToken = `${this.token}[${literal}]`;
        if (this.isList()) {
            if (typeof literal === "number") {
                const item = this.checker.getThing((_b = (_a = this.apply) === null || _a === void 0 ? void 0 : _a.getListItems()) === null || _b === void 0 ? void 0 : _b[literal], itemToken);
                if (item) {
                    return item;
                }
            }
            return (_c = this.type.getListItemType()) === null || _c === void 0 ? void 0 : _c.getThing(itemToken, origin || (typeof index === "number" ? undefined : index.origin), this);
        }
        if (this.isUnion()) {
            const things = this.things.map((thing) => { var _a; return (_a = thing.getItem(index, origin)) !== null && _a !== void 0 ? _a : this.checker.void.getThing(itemToken, origin); });
            const type = things
                .map((t) => { var _a; return (_a = t === null || t === void 0 ? void 0 : t.type) !== null && _a !== void 0 ? _a : this.checker.nothing; })
                .reduce((a, b) => { var _a; return (_a = a.union(b)) !== null && _a !== void 0 ? _a : this.checker.nothing; }, this.checker.nothing);
            return new UnionThing(this.checker, itemToken, type, typeof index === "number" ? origin : index.origin, things);
        }
        return undefined;
    }
    /**
     * Find all locales this Base Thing support
     * The base thing depends on it's type to calculate locales
     *
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales() {
        return this.type.getLocales();
    }
}
/**
 * Base type of all Things that contain Properties.
 */
export class ObjectThing extends BaseThing {
    /**
     * Checks if this is a literal Object or an abstract Object such as one received from an Event during simulation.
     */
    isLiteral() {
        var _a;
        return ((_a = this.apply) === null || _a === void 0 ? void 0 : _a.isType()) === true;
    }
}
/**
 * Represents a Function value within a Dialog Flow simulation.
 *
 * This class encapsulates the Tree and TypeChecker environment that contains this Function and provides
 * a friendly interface over it so that consumers such as {@link evaluateDialogFlow} are insulated from
 * the various mappings between abstract Function signatures and concrete Functions/Action/Dialogs passed
 * around during the simulation.
 */
export class FunctionThing extends ObjectThing {
    constructor(checker, token, type, origin, abstractToConcreteArgumentNames) {
        super(checker, token, type, undefined, origin, undefined);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "abstractToConcreteArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: abstractToConcreteArgumentNames
        });
    }
    /**
     * Name of the Function.
     */
    get name() {
        var _a;
        return (_a = this.origin) === null || _a === void 0 ? void 0 : _a.name;
    }
    /**
     * Get this Function's properties. This function overrides the type of `Arguments<this>` so that we
     * can apply mappings between the argument names of the type signature and the argument names of
     * an action passed in as an argument to a dialog or stored on some variable.
     *
     * @param name property name
     * @returns a Thing value representing that property value.
     */
    getProperty(name) {
        const nameStr = typeof name === "string" ? name : name === null || name === void 0 ? void 0 : name.name;
        if (nameStr === "arguments" && this.abstractToConcreteArgumentNames !== undefined) {
            // the arguments type must have its properties mapped.
            return new ArgumentsThing(this.checker, `${this.token}[arguments]`, new Type(this.checker, this.checker.lookupTypeDeclaration(AlexaSchema.Arguments), [this.type]), undefined, this);
        }
        return super.getProperty(name);
    }
    /**
     * Create a new FunctionThing where the argument names are mapped. Consumers will use the mapped interface
     * to supply or reference arguments. This is so that we can pass Functions around as arguments without
     * requiring the ArgumentDeclaration's signature have the same argument names.
     *
     * @param argumentNameMappings map of argument name to underlying argument name.
     * @returns a new copy of this Thing with mapped argument names.
     */
    withArgumentNameMappings(argumentNameMappings) {
        if (this.isAction()) {
            return new ActionThing(this.checker, this.token, this.type, this.origin, argumentNameMappings);
        }
        if (this.isDialog()) {
            return new DialogThing(this.checker, this.token, this.type, this.origin, argumentNameMappings);
        }
        return new FunctionThing(this.checker, this.token, this.type, this.origin, argumentNameMappings);
    }
}
/**
 * Represents an Action value within a Dialog Flow simulation.
 */
export class ActionThing extends FunctionThing {
    constructor(checker, token, type, origin, abstractToConcreteArgumentNames) {
        super(checker, token, type, origin, abstractToConcreteArgumentNames);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "abstractToConcreteArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: abstractToConcreteArgumentNames
        });
        Object.defineProperty(this, "concreteToAbstractArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _ActionThing_locales.set(this, void 0);
        if (abstractToConcreteArgumentNames) {
            this.concreteToAbstractArgumentNames = {};
            for (const abstractArgumentName in abstractToConcreteArgumentNames) {
                // create a reverse lookup from the abstract action signature to a concrete action instance
                this.concreteToAbstractArgumentNames[abstractToConcreteArgumentNames[abstractArgumentName]] = abstractArgumentName;
            }
        }
    }
    /**
     * Name of the Action referenced by this Thing.
     */
    get actionName() {
        var _a;
        return (_a = this.name) === null || _a === void 0 ? void 0 : _a.name;
    }
    getArguments() {
        var _a;
        return (_a = this.getProperty("arguments")) === null || _a === void 0 ? void 0 : _a.asArguments();
    }
    /**
     * Get a named Argument from this Action.
     *
     * @param name name of the argument
     * @returns the Argument
     */
    getArgument(name) {
        var _a, _b;
        return (_b = (_a = this.getArguments()) === null || _a === void 0 ? void 0 : _a.getProperty(name)) === null || _b === void 0 ? void 0 : _b.asArgument();
    }
    /**
     * calculate the locales for the action
     * first collect all the type associated with this action (return type, generic type, property type)
     * find the locales supported by all the types
     * @returns
     */
    getLocales() {
        var _a, _b, _c;
        if (__classPrivateFieldGet(this, _ActionThing_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _ActionThing_locales, "f");
        }
        const types = [];
        const returnType = ((_a = this.origin) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" ? this.checker.getType((_b = this === null || this === void 0 ? void 0 : this.origin) === null || _b === void 0 ? void 0 : _b.returnType) : undefined;
        // add return type
        if (returnType) {
            types.push(returnType);
        }
        // add property type
        (_c = this.origin.arguments) === null || _c === void 0 ? void 0 : _c.forEach((argDecl) => {
            const propertyType = this.checker.getType(argDecl);
            if (propertyType) {
                if (propertyType.isFunction()) {
                    const functionReturnType = propertyType.getFunctionReturnType();
                    const argumentTypes = propertyType.getFunctionArgumentTypes();
                    if (functionReturnType) {
                        types.push(functionReturnType);
                    }
                    if (argumentTypes) {
                        types.push(...argumentTypes);
                    }
                }
                else {
                    types.push(propertyType);
                }
            }
        });
        // find the locales supported by all types
        let locales;
        for (const type of types) {
            const typeLocales = type.getLocales();
            if (typeLocales) {
                if (locales === undefined) {
                    locales = [...typeLocales];
                }
                else {
                    locales = locales.filter((locale) => typeLocales.includes(locale));
                }
            }
        }
        __classPrivateFieldSet(this, _ActionThing_locales, locales, "f");
        return __classPrivateFieldGet(this, _ActionThing_locales, "f");
    }
}
_ActionThing_locales = new WeakMap();
/**
 * Represents a Dialog value within a Dialog Flow simulation.
 */
export class DialogThing extends FunctionThing {
    constructor(checker, token, type, origin, abstractToConcreteArgumentNames) {
        super(checker, token, type, origin, abstractToConcreteArgumentNames);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "abstractToConcreteArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: abstractToConcreteArgumentNames
        });
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _DialogThing_locales.set(this, void 0);
    }
    /**
     * calculate the locales for the dialog
     * first collect all the type associated with this dialog (return type, generic type, property type)
     * find the locales supported by all the types
     * @returns
     */
    getLocales() {
        var _a, _b, _c, _d;
        if (__classPrivateFieldGet(this, _DialogThing_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _DialogThing_locales, "f");
        }
        const types = [];
        const { checker } = this;
        const returnType = ((_a = this.origin) === null || _a === void 0 ? void 0 : _a.kind) === "DialogDeclaration" ? this.checker.getType((_b = this === null || this === void 0 ? void 0 : this.origin) === null || _b === void 0 ? void 0 : _b.returnType) : undefined;
        // add return type
        if (returnType) {
            types.push(returnType);
        }
        // add property type
        (_c = this.origin.arguments) === null || _c === void 0 ? void 0 : _c.forEach((argDecl) => {
            const propertyType = this.checker.getType(argDecl);
            if (propertyType) {
                if (propertyType.isFunction()) {
                    const functionReturnType = propertyType.getFunctionReturnType();
                    const argumentTypes = propertyType.getFunctionArgumentTypes();
                    if (functionReturnType)
                        types.push(functionReturnType);
                    if (argumentTypes)
                        types.push(...argumentTypes);
                }
                else {
                    types.push(propertyType);
                }
            }
        });
        // find the locales supported by all types
        let locales;
        for (const type of types) {
            const typeLocales = type.getLocales();
            if (typeLocales) {
                if (locales === undefined) {
                    locales = [...typeLocales];
                }
                else {
                    locales = locales.filter((locale) => typeLocales.includes(locale));
                }
            }
        }
        (_d = this.origin.samples) === null || _d === void 0 ? void 0 : _d.forEach((sample) => {
            visitEachChild(sample, function updateLocales(node) {
                if (node.kind === "NameReference" || node.kind === "PropertyReference") {
                    const usedLocales = checker.collectLocaleInfo(node);
                    if (usedLocales.length > 0) {
                        if (locales === undefined) {
                            locales = [...usedLocales];
                        }
                        else {
                            locales = locales.filter((locale) => usedLocales.includes(locale));
                        }
                    }
                }
                else if (node.kind === "Call") {
                    const apply = checker.getApply(node);
                    const decl = apply === null || apply === void 0 ? void 0 : apply.decl;
                    if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration" || (decl === null || decl === void 0 ? void 0 : decl.kind) === "DialogDeclaration") {
                        const thing = checker.getThing(decl);
                        if (((thing === null || thing === void 0 ? void 0 : thing.isAction()) && (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi())) || (thing === null || thing === void 0 ? void 0 : thing.isDialog())) {
                            const usedLocales = thing.getLocales();
                            if (usedLocales) {
                                if (locales === undefined) {
                                    locales = [...usedLocales];
                                }
                                else {
                                    locales = locales.filter((locale) => usedLocales.includes(locale));
                                }
                            }
                        }
                    }
                    else if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "Type") {
                        const usedLocales = decl.getLocales();
                        if (usedLocales) {
                            if (locales === undefined) {
                                locales = [...usedLocales];
                            }
                            else {
                                locales = locales.filter((locale) => usedLocales.includes(locale));
                            }
                        }
                    }
                }
                visitEachChild(node, updateLocales);
            });
        });
        __classPrivateFieldSet(this, _DialogThing_locales, locales, "f");
        return __classPrivateFieldGet(this, _DialogThing_locales, "f");
    }
}
_DialogThing_locales = new WeakMap();
export class ArgumentThing extends BaseThing {
    get action() {
        var _a, _b;
        return ((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction()) ? this.parent.parent : undefined;
    }
    getReferencedActionArgumentTypeInformation() {
        var _a, _b, _c;
        const referenceInfo = this.getReferencedActionArgumentPropertyReferenceInformation();
        if (!referenceInfo) {
            return undefined;
        }
        const { declaration: actionDeclaration, argumentName, argumentPathSegments } = referenceInfo;
        const argumentDeclaration = (_a = actionDeclaration.arguments) === null || _a === void 0 ? void 0 : _a.find((argDecl) => { var _a; return ((_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name) === argumentName; });
        if (!(argumentDeclaration === null || argumentDeclaration === void 0 ? void 0 : argumentDeclaration.type) || !argumentPathSegments) {
            return undefined;
        }
        let currentType = this.checker.getType(argumentDeclaration.type);
        for (let i = 1; i < argumentPathSegments.length && currentType; i++) {
            const argumentPathSegment = argumentPathSegments[i];
            currentType = (_b = currentType.getPropertyMap().get(argumentPathSegment)) === null || _b === void 0 ? void 0 : _b.type;
        }
        return { argumentName, actionName: (_c = actionDeclaration.name) === null || _c === void 0 ? void 0 : _c.name, type: currentType };
    }
    /**
     * If the argument references an argument to another action
     * @returns
     * If the argument value is a property reference rooted in an API call (like getPizza.arguments.pizzaOrder.pizzaType)
     * returns an object with 4 properties:
     *    declaration has the declaration of the API (getPizza's declaration)
     *    argumentName has the name of the argument in the api ("pizzaOrder")
     *    argumentPath has the property path starting at the argument name ("pizzaOrder.pizzaType")
     *    argumentPAthSegments has ["pzzaOrder", "pizzaType"]
     */
    getReferencedActionArgumentPropertyReferenceInformation() {
        var _a, _b, _c, _d, _e;
        const argumentPathSegments = [];
        let argumentName;
        let actionDeclaration;
        // There are two main cases to get a referenced argument information
        if (((_b = (_a = this.origin) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
            // The first case is when the reference is from a PropertyReference like getWeather.arguments.city.name.
            // this.action will be null in this case and in order to find the information we have to...
            let currentExpression = this.origin.context;
            // Loop through the expressions
            while (currentExpression) {
                // untill we find a thing which is an ActionDeclaration
                const expressionThing = this.checker.getThing(currentExpression);
                if (((_c = expressionThing === null || expressionThing === void 0 ? void 0 : expressionThing.origin) === null || _c === void 0 ? void 0 : _c.kind) !== "ActionDeclaration") {
                    argumentPathSegments.push((_e = (_d = currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.name) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : "");
                    currentExpression = (currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.kind) === "PropertyReference" ? currentExpression.expression : undefined;
                    continue;
                }
                // When we find the action declaration, the previous property was "arguments" and one property before that
                // was the argument name
                if (argumentPathSegments.length < 2 || argumentPathSegments[argumentPathSegments.length - 1] !== "arguments") {
                    return undefined;
                }
                else {
                    argumentName = argumentPathSegments[argumentPathSegments.length - 2];
                    actionDeclaration = expressionThing.origin;
                    argumentPathSegments.reverse();
                    // remove "arguments"
                    argumentPathSegments.splice(0, 1);
                    break;
                }
            }
        }
        else if (this.action) {
            // The second case is for something like getWeather.arguments.CityName where this.action is defined
            actionDeclaration = this.action.origin;
            // in this case the argument will be in argumentName
            if (this.argumentName) {
                argumentName = this.argumentName;
                argumentPathSegments.push(argumentName);
            }
        }
        if (!actionDeclaration || !argumentName) {
            return undefined;
        }
        return {
            declaration: actionDeclaration,
            argumentName,
            argumentPathSegments,
            argumentPath: argumentPathSegments.join("."),
        };
    }
    getReferencedActionArgumentPropertyReferenceInformationOld() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (((_b = (_a = this.origin) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.kind) !== "PropertyReference") {
            return undefined;
        }
        const expressions = [];
        let currentExpression = this.origin.context;
        while ((currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.kind) === "PropertyReference") {
            expressions.push(currentExpression);
            currentExpression = currentExpression.expression;
        }
        expressions.reverse();
        if (expressions.length < 2 || (currentExpression === null || currentExpression === void 0 ? void 0 : currentExpression.kind) !== "NameReference" || ((_d = (_c = expressions[0]) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) !== "arguments") {
            return undefined;
        }
        const nameReferenceThing = this.checker.getThing(currentExpression);
        if (((_e = nameReferenceThing === null || nameReferenceThing === void 0 ? void 0 : nameReferenceThing.origin) === null || _e === void 0 ? void 0 : _e.kind) !== "ActionDeclaration") {
            return undefined;
        }
        return {
            declaration: nameReferenceThing.origin,
            argumentName: (_g = (_f = expressions[1].name) === null || _f === void 0 ? void 0 : _f.name) !== null && _g !== void 0 ? _g : "",
            argumentPathSegments: expressions.map((e) => { var _a, _b; return (_b = (_a = e.name) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : ""; }),
            argumentPath: expressions
                .slice(1)
                .map((x) => { var _a, _b; return (_b = (_a = x.name) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : ""; })
                .join("."),
        };
    }
    /**
     * An argument might reference an action argument when it uses something like getPizza.arguments.
     * This method returns the declaration for that action (like getPizza's declaration). There are two cases:
     *   1) argument references a "non object" action argument as in getPizza.arguments.pizzaType where pizzaType is of slot type PizzaType
     *   2) argument references an object action argument as in getPizza.arguments.pizzaOrder.pizzaType where pizzaOrder is
     *   of type PizzaOrder. The PizzaOrder type has a pizzaType property of slot type PizzaType
     * For case 1 the declaration is in action.origin.
     * For case 2 the declaration name is in the property reference and it needs to be lookedUp which is done in
     * this.getPropertyReferenceToAPIInformation
     * If the argument does not reference an action argument, this returns undefined
     * @returns the declaration of action referenced in argument
     */
    getReferencedActionArgumentActionDeclaration() {
        var _a;
        return (_a = this.getReferencedActionArgumentPropertyReferenceInformation()) === null || _a === void 0 ? void 0 : _a.declaration;
    }
    /**
     * If an argument references an action argument returns the property path to that argument
     */
    getReferencedActionArgumentPath() {
        var _a;
        return (_a = this.getReferencedActionArgumentPropertyReferenceInformation()) === null || _a === void 0 ? void 0 : _a.argumentPath;
    }
    get argumentName() {
        var _a;
        return ((_a = this.origin) === null || _a === void 0 ? void 0 : _a.kind) === "Name" ? this.origin.name : undefined;
    }
    get isOptional() {
        var _a, _b;
        return (_b = this.checker.root.getType((_a = this.origin) === null || _a === void 0 ? void 0 : _a.context)) === null || _b === void 0 ? void 0 : _b.isOptional();
    }
    /**
     * If an argument references an action argument returns the declaration for that action argument
     */
    getReferencedActionArgumentDeclaration() {
        var _a;
        const propertyReferenceInformation = this.getReferencedActionArgumentPropertyReferenceInformation();
        if (!propertyReferenceInformation) {
            return undefined;
        }
        return (_a = propertyReferenceInformation.declaration.arguments) === null || _a === void 0 ? void 0 : _a.find((argDecl) => { var _a; return ((_a = argDecl.name) === null || _a === void 0 ? void 0 : _a.name) === propertyReferenceInformation.argumentName; });
    }
}
export class ArgumentsThing extends ObjectThing {
    constructor(checker, token, type, origin, parent) {
        super(checker, token, type, undefined, origin, parent);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parent
        });
    }
    getArgumentsList() {
        var _a, _b, _c, _d, _e;
        if (((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.origin) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_d = (_c = this.parent) === null || _c === void 0 ? void 0 : _c.origin) === null || _d === void 0 ? void 0 : _d.kind) === "DialogDeclaration") {
            return (_e = this.parent.origin.arguments) === null || _e === void 0 ? void 0 : _e.map((arg) => { var _a, _b; return (_b = super.getProperty((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name)) === null || _b === void 0 ? void 0 : _b.asArgument(); });
        }
        return undefined;
    }
    getProperty(name) {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = this.parent) === null || _a === void 0 ? void 0 : _a.abstractToConcreteArgumentNames) !== undefined) {
            const nameStr = typeof name === "string" ? name : name === null || name === void 0 ? void 0 : name.name;
            if (nameStr !== undefined) {
                return (_e = super.getProperty((_d = (_c = (_b = this.parent) === null || _b === void 0 ? void 0 : _b.abstractToConcreteArgumentNames) === null || _c === void 0 ? void 0 : _c[nameStr]) !== null && _d !== void 0 ? _d : nameStr)) === null || _e === void 0 ? void 0 : _e.asArgument();
            }
        }
        return (_f = super.getProperty(name)) === null || _f === void 0 ? void 0 : _f.asArgument();
    }
}
export class TypeThing extends ObjectThing {
    constructor(checker, token, type, origin) {
        super(checker, token, type, undefined, origin, undefined);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
    }
}
class PrimitiveThing extends BaseThing {
    /**
     * The literal data value of this primitive thing (if it is specified).
     *
     * If this is an abstract thing, such as the result of an event, then `undefined` is returned.
     */
    get literal() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const lit = ((_a = this.type) === null || _a === void 0 ? void 0 : _a.isBoolean()) && typeof ((_b = this.apply) === null || _b === void 0 ? void 0 : _b.call.arguments) === "boolean"
            ? (_c = this.apply) === null || _c === void 0 ? void 0 : _c.call.arguments
            : ((_d = this.type) === null || _d === void 0 ? void 0 : _d.isStringLike()) && typeof ((_e = this.apply) === null || _e === void 0 ? void 0 : _e.call.arguments) === "string"
                ? this.apply.call.arguments
                : ((_f = this.type) === null || _f === void 0 ? void 0 : _f.isNumber()) && typeof ((_g = this.apply) === null || _g === void 0 ? void 0 : _g.call.arguments) === "number"
                    ? this.apply.call.arguments
                    : ((_h = this.type) === null || _h === void 0 ? void 0 : _h.isVoid()) && ((_j = this.apply) === null || _j === void 0 ? void 0 : _j.call.arguments) === null
                        ? null
                        : ((_k = this.type) === null || _k === void 0 ? void 0 : _k.isNothing()) && ((_l = this.apply) === null || _l === void 0 ? void 0 : _l.call.arguments) === null
                            ? null
                            : undefined;
        return lit;
    }
    isLiteral() {
        var _a;
        if ((_a = this.apply) === null || _a === void 0 ? void 0 : _a.isType()) {
            const args = this.apply.call.arguments;
            return args === null || typeof args === "boolean" || typeof args === "string" || typeof args === "number" || Array.isArray(args);
        }
        return false;
    }
}
export class AnyThing extends BaseThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
export class NothingThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
export class VoidThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
export class BooleanThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
export class NumberThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
export class StringThing extends PrimitiveThing {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
export class ListThing extends PrimitiveThing {
    isLiteral() {
        var _a;
        return ask.isListLiteral((_a = this.apply) === null || _a === void 0 ? void 0 : _a.call.arguments);
    }
    getItems() {
        var _a;
        if (this.isLiteral()) {
            return (_a = this.apply) === null || _a === void 0 ? void 0 : _a.call.arguments.items.map((item) => this.checker.getThing(item, undefined, item));
        }
        return undefined;
    }
    getListItems() {
        var _a;
        if (this.isLiteral()) {
            return (_a = this.apply) === null || _a === void 0 ? void 0 : _a.call.arguments.items;
        }
        return undefined;
    }
}
/**
 * TODO: remove this class
 */
export class UnionThing extends BaseThing {
    constructor(checker, token, type, origin, 
    /**
     *
     */
    things) {
        super(checker, token, type, undefined, origin, undefined);
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: origin
        });
        Object.defineProperty(this, "things", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: things
        });
        Object.defineProperty(this, "thingKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Union"
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGhpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsT0FBTyxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUM7QUFDN0IsT0FBTyxFQUFvQixXQUFXLEVBQThCLE1BQU0sT0FBTyxDQUFDO0FBS2xGLE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQWlEdkMsTUFBTSxTQUFTO0lBS2IsWUFDVyxPQUFvQjtJQUM3Qjs7T0FFRztJQUNNLEtBQVk7SUFDckI7O09BRUc7SUFDTSxJQUFVO0lBQ25COztPQUVHO0lBQ00sS0FBd0I7SUFDakM7O09BRUc7SUFDTSxNQUE0QjtJQUNyQzs7T0FFRztJQUNNLE1BQXlCO0lBQ2xDOztPQUVHO0lBQ00sTUFBc0MsTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLEdBQUc7SUFDMUQ7O09BRUc7SUFDTSxNQUEwQixNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsR0FBRzs7Ozs7bUJBNUJyQzs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOztRQWpDWDs7OzttQkFBeUIsT0FBTztXQUFDO1FBRWpDOzs7OztXQUErRDtJQWdDNUQsQ0FBQztJQUVKLElBQVcsSUFBSTtRQUNiLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDN0IsT0FBTyxJQUFXLENBQUM7U0FDcEI7UUFDRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7T0FFRztJQUNJLFNBQVM7UUFHZCxPQUFPLElBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFB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