import * as antlr from "antlr4ts";
import * as acdl from "./syntax";
import * as ask from "./ast";
import { SourceFile } from "./source-file";
import { ParseError } from "./error";
import { TryMonad } from "./try";
export declare class Counter {
    private counter;
    constructor(counter?: number);
    nextId(): number;
}
export declare class ParseContext<E extends ask.Node = any> {
    readonly uri: string;
    readonly namespace: string | undefined;
    readonly nameCounter: Counter;
    readonly errors: ParseError[];
    readonly scope: ask.Expression[];
    readonly imports: ask.Import[];
    constructor(uri: string, namespace: string | undefined, nameCounter: Counter, errors: ParseError[], scope: ask.Expression[], imports: ask.Import[]);
    hasOptionalImported(): boolean;
    withScope(scope: ask.Expression[]): ParseContext<E>;
    addError(err: ParseError): void;
    newName(): string;
}
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
export declare function loadModuleFileSync(baseDir: string, uri: string): SourceFile<ask.Module> | undefined;
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
export declare function loadModuleFile(baseDir: string, uri: string): Promise<SourceFile<ask.Module> | undefined>;
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
export declare function loadACDLFileSync(dir: string, uri: string, content?: string): SourceFile<ask.Module | undefined>;
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
export declare function loadACDLFile(dir: string, uri: string, content?: string): Promise<SourceFile<ask.Module | undefined>>;
/**
 * Parse an ACDL file.
 *
 * @param content ACDL file content
 */
export declare function parseACDLFile(uri: string, content: string): [module: ask.Module | undefined, errors: ParseError[] | undefined];
/**
 * Parse the qualified name component of a module-level declaration.
 *
 * That include:
 * - ActionDeclaration
 * - DialogDeclaration
 * - QualifiedNameDeclaration
 * - TypeDeclaration
 */
export declare function parseModuleLevelNameDeclaration(node: acdl.QualifiedNameContext | acdl.IdentifierContext, context: ParseContext): ask.Name;
export declare function parseEnumDeclaration(type: acdl.EnumDeclarationContext, context: ParseContext): ask.EnumDeclaration;
export declare function parseEnumItem(item: acdl.EnumItemContext, context: ParseContext): ask.EnumItem;
export declare function parseAnnotationList(annotationList: acdl.AnnotationListContext | undefined, context: ParseContext): ask.Annotation[] | undefined;
export declare function parseTypeDeclaration(type: acdl.TypeDeclarationContext, context: ParseContext): ask.TypeDeclaration;
export declare function parseTypeArgumentDeclarations(args: acdl.TypeArgumentDeclarationsContext | undefined, context: ParseContext): ask.TypeParameter[] | undefined;
export declare function parseTypeArgumentDeclaration(arg: acdl.TypeArgumentDeclarationContext, context: ParseContext<ask.TypeParameter>): ask.TypeParameter;
export declare function parseTypeReference(reference: acdl.TypeReferenceContext, context: ParseContext): ask.TypeReference;
export declare function parseTypeProperty(property: acdl.TypePropertyContext, context: ParseContext<ask.TypeProperty>): ask.TypeProperty;
export declare function parseNamespaceDeclaration(namespace: acdl.NamespaceDeclarationContext, context: ParseContext): ask.Name;
export declare function parseDialogDeclaration(dialog: acdl.DialogDeclarationContext, context: ParseContext): ask.DialogDeclaration;
export declare function parseSampleDeclaration(sample: acdl.SampleDeclarationContext, context: ParseContext): ask.Sample;
type ExtractBlockExpression<T extends ask.Block<any, any>> = T extends ask.Block<infer E, any> ? E : ask.Expression;
export declare function parseScope<T extends ask.Block>(body: acdl.BlockContext, context: ParseContext, ctor: new (expressions: ExtractBlockExpression<T>[], loc?: ask.SourceLocation) => T): T | undefined;
export declare function parseScopeExpression(expr: acdl.BlockExpressionContext, context: ParseContext<any>): ask.Expression | undefined;
export declare function parseInteractionDeclaration(expr: acdl.InteractionDeclarationContext, context: ParseContext<any>): ask.InteractionDeclaration;
export declare function parseExpression(expr: acdl.ExpressionContext, context: ParseContext<any>): ask.Expression | undefined;
export declare function parseNameReference(expr: acdl.IdentifierExprContext, context: ParseContext<ask.NameReference>): ask.NameReference;
export declare function parsePropertyReference(expr: acdl.PropertyReferenceContext, context: ParseContext<ask.PropertyReference>): ask.PropertyReference | undefined;
export declare function parseCondition(expr: acdl.ConditionContext, context: ParseContext<ask.Condition>): ask.Condition | undefined;
export declare function parseCorrection(expr: acdl.CorrectionContext, context: ParseContext<ask.Correction>): ask.Correction;
export declare function parseBinaryExpression(expr: acdl.BinaryExprContext, context: ParseContext<any>): TryMonad<ask.Call>;
export declare function parseBooleanOperator(expr: acdl.BinaryExprContext, context: ParseContext): string | undefined;
export declare function parseCall(expr: acdl.CallContext, context: ParseContext<any>): ask.Call;
export declare function parseArgumentValue(argument: acdl.CallArgumentContext, context: ParseContext<ask.Argument>, index: number): ask.Argument;
export declare function parseLiteral(literal: acdl.LiteralContext | acdl.LiteralExprContext, context: ParseContext): TryMonad<ask.Call>;
export declare function parseSlotValues(string: acdl.LiteralContext | undefined): string[] | undefined;
export declare function parseUtteranceQualifiedName(fullName: string, context: acdl.StringContext, prefix?: string): ask.Name;
export declare function getSlotLocation(context: acdl.StringContext, id: string): {
    begin: {
        line: number;
        character: number;
    };
    end: {
        line: number;
        character: number;
    };
};
export declare function createLiteral(type: string, value: string | null | boolean | number | undefined | ask.Utterance, loc: ask.SourceLocation): ask.Call;
export declare function parseIsOperator(expr: acdl.IsExprContext, context: ParseContext): ask.Call;
export declare function parseInOperator(expr: acdl.InExprContext, context: ParseContext): ask.Call;
export declare function parseObject(obj: acdl.ObjectContext, context: ParseContext): ask.Call;
export declare function parseObjectProperty(member: acdl.ObjectKeyValueContext, context: ParseContext<ask.Argument>): ask.Argument;
/**
 * Parse a List literal to a call
 *
 * ```
 * list = ["a", "b"]
 * // or
 * list = List<String> ["a", "b"]
 *
 * // translates to an internal representations
 * alexa.lang.expression<List<String>>(items = ["a", "b"])
 * ```
 *
 * @param expr
 * @param parent
 * @param errors
 */
export declare function parseList(expr: acdl.ListContext, context: ParseContext<ask.Call>): ask.Call;
/**
 * Parse syntactic sugar for accessing a list.
 *
 * ```
 * List<String> list = ...
 *
 * // access a list by index 0
 * list[0]
 *
 * // is syntactic sugar for the `inList` action:
 * com.amazon.alexa.ask.conversations.inList(list = list, index = 0)
 * com.amazon.alexa.ask.conversations.inList(list, 0)
 * ```
 *
 * TODO: support accessing properties in a List.
 * ```
 * // how should we translate this?
 * c = list[0].a.b.c
 *
 * // perhaps generate a variable for the result of accessing the list
 * var1 = inList(list, 0)
 * // and then a name expression?
 * c = var1.a.b.c
 * ```
 *
 * @param expr syntax for the list
 * @param parent
 * @param errors
 */
export declare function parseListIndex(expr: acdl.ListIndexContext, context: ParseContext<ask.Call>): ask.Call;
export declare function parseActionDeclaration(action: acdl.ActionDeclarationContext, context: ParseContext<ask.ActionDeclaration>): ask.ActionDeclaration;
export declare function parseFunctionSignature(action: acdl.FunctionSignatureContext, context: ParseContext<ask.ActionDeclaration | ask.DialogDeclaration>, isTopLevel?: boolean): {
    name: ask.Name;
    args: ask.ArgumentDeclaration[] | undefined;
    returnType: ask.TypeReference;
    genericArguments: ask.TypeParameter[] | undefined;
};
export declare function parseArgumentDeclarations(argumentDecls: acdl.ArgumentDeclarationsContext, context: ParseContext): ask.ArgumentDeclaration[] | undefined;
export declare function parseArgumentDeclaration(argument: acdl.ArgumentDeclarationContext, context: ParseContext<ask.ArgumentDeclaration>): ask.ArgumentDeclaration;
/**
 * Parse a name initialization expression.
 *
 * ```acdl
 * a = <expr>
 * ```
 *
 * @param nameDecl name parse tree
 * @param parent parent expression
 */
export declare function parseNameDeclaration(nameDecl: acdl.NameDeclarationContext | acdl.QualifiedNameDeclarationContext, context: ParseContext): ask.NameDeclaration;
/**
 * Parse an identifier.
 *
 * @param id identifier parse tree
 * @param context parse context
 */
export declare function parseIdentifier(id: acdl.IdentifierContext): ask.Name;
export declare function parseIdentifierLocation(id: acdl.IdentifierContext | acdl.QualifiedNameContext): ask.SourceLocation;
/**
 * Parse a qualified name.
 *
 * @param name identifier or qualified name.
 * @param parent parent expression
 */
export declare function parseQualifiedName(name: acdl.IdentifierContext | acdl.QualifiedNameContext, prefix?: string): ask.Name;
/**
 * Parse the location from a node in the parse tree.
 *
 * @param node parse tree node.
 */
export declare function parseLocation(node: antlr.ParserRuleContext): ask.SourceLocation;
export declare function parseJsDoc(context: acdl.JsdocContext | undefined): string | undefined;
export {};
//# sourceMappingURL=parse.d.ts.map