import * as immutable from "immutable";
import * as ask from "./ast";
import { Apply } from "./apply";
import { AlexaConversations, AlexaSchema, ThenScope } from "./ast";
import { computeGlobal } from "./global";
import { computeLexicalScope, emptyLexicalScope, mergeLexicalScope } from "./lexical-scope";
import { getName, getNamespace, isQualifiedNamePattern, stringifyTypeParameter } from "./util";
import { Type } from "./type";
// TODO: decide whether we should implement our own immutable set instead of depending on `immutable-js`
import { memoize } from "./lazy";
import { visitEachChild, collectArray } from "./visit";
import { ActionThing, DialogThing, NothingThing, UnionThing, VoidThing } from "./thing";
import { tokens } from "./token";
let i = 0;
/**
 * API for querying a Module for error checking, type checking, descriptions and suggestions.
 */
export class TypeChecker {
    constructor(
    /**
     * Project context of the module being checked.
     */
    project, 
    /**
     * Previous TypeChecker environment.
     */
    prev, 
    /**
     * Map of Node to resolved Thing.
     */
    things, 
    /**
     * Map of TypeParameter to resolved Type.
     */
    types) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: project
        });
        Object.defineProperty(this, "prev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: prev
        });
        Object.defineProperty(this, "types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types
        });
        Object.defineProperty(this, "ID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (i += 1)
        });
        /**
         * Name bindings for expressions in the project.
         */
        Object.defineProperty(this, "global", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nothing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nothingToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "void", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "voidToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "boolean", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "number", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "string", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "enumeration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of Node to its {@link LexicalScope}.
         *
         * i.e. the names available in its lexical environment and a map of the node they point to.
         */
        Object.defineProperty(this, "lexicalScopeIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of a Module-scoped Node to its corresponding Thing value.
         *
         * This index is shared across all instances of a {@link TypeChecker} within a {@link Project}. I.e. it is a global index.
         */
        Object.defineProperty(this, "globalThingIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of a Node to its corresponding Type.
         */
        Object.defineProperty(this, "globalTypeIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Local index of a Node to its corresponding Thing value within the lexical environment represented by this {@link TypeCehcker}.
         */
        Object.defineProperty(this, "localThingIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        /**
         * Local index of a Node to its corresponding Apply within the lexical environment represented by this {@link TypeChecker}.
         */
        Object.defineProperty(this, "localApplyIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "tokens", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.globalTypeIndex = (_a = prev === null || prev === void 0 ? void 0 : prev.globalTypeIndex) !== null && _a !== void 0 ? _a : new WeakMap();
        this.tokens = (_b = prev === null || prev === void 0 ? void 0 : prev.tokens) !== null && _b !== void 0 ? _b : tokens();
        this.global = (_c = prev === null || prev === void 0 ? void 0 : prev.global) !== null && _c !== void 0 ? _c : computeGlobal(project);
        this.globalThingIndex = (_d = prev === null || prev === void 0 ? void 0 : prev.globalThingIndex) !== null && _d !== void 0 ? _d : new Map();
        this.lexicalScopeIndex = (_e = prev === null || prev === void 0 ? void 0 : prev.lexicalScopeIndex) !== null && _e !== void 0 ? _e : new WeakMap();
        this.thing = (_f = prev === null || prev === void 0 ? void 0 : prev.thing) !== null && _f !== void 0 ? _f : this.instantiateAlexaSchemaType(AlexaSchema.Thing);
        this.nothing = (_g = prev === null || prev === void 0 ? void 0 : prev.nothing) !== null && _g !== void 0 ? _g : this.instantiateAlexaSchemaType(AlexaSchema.Nothing);
        this.void = (_h = prev === null || prev === void 0 ? void 0 : prev.void) !== null && _h !== void 0 ? _h : this.instantiateAlexaSchemaType(AlexaSchema.Void);
        this.nothingToken = (_j = prev === null || prev === void 0 ? void 0 : prev.nothingToken) !== null && _j !== void 0 ? _j : this.nextToken();
        this.voidToken = (_k = prev === null || prev === void 0 ? void 0 : prev.voidToken) !== null && _k !== void 0 ? _k : this.nextToken();
        this.boolean = (_l = prev === null || prev === void 0 ? void 0 : prev.boolean) !== null && _l !== void 0 ? _l : this.instantiateAlexaSchemaType(AlexaSchema.Boolean);
        this.number = (_m = prev === null || prev === void 0 ? void 0 : prev.number) !== null && _m !== void 0 ? _m : this.instantiateAlexaSchemaType(AlexaSchema.Number);
        this.string = (_o = prev === null || prev === void 0 ? void 0 : prev.string) !== null && _o !== void 0 ? _o : this.instantiateAlexaSchemaType(AlexaSchema.String);
        this.enumeration = (_p = prev === null || prev === void 0 ? void 0 : prev.enumeration) !== null && _p !== void 0 ? _p : memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.Enumeration));
        // this.apl = prev?.apl ?? memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.APL));
        // this.apla = prev?.apla ?? memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.APLA));
        if (prev === undefined) {
            const checker = this;
            for (const expr of this.global.scope.values()) {
                if (expr === undefined) {
                    // return;
                }
                else if (Array.isArray(expr)) {
                    expr.forEach((expr) => { var _a; return checker.globalThingIndex.set(expr, (_a = checker.getThing(expr)) !== null && _a !== void 0 ? _a : null); });
                }
                else {
                    checker.globalThingIndex.set(expr, (_q = checker.getThing(expr)) !== null && _q !== void 0 ? _q : null);
                }
            }
        }
        if (things) {
            for (const [node, thing] of things.entries()) {
                this.localThingIndex.set(node, thing);
            }
        }
    }
    /**
     * Returns a reference to the root TypeChecker instance. TypeCheckers form a chain as we descend into
     * Dialog Sample Blocks and Conditional Blocks. This `root` instance refers to the global TypeChecker.
     *
     * We use this, for example, to look at the raw type signature of an ArgumentDeclaration instead of
     * looking at the type of the value passed into that argument within a Dialog Flow:
     *
     * ```
     * action myAction(String string)
     *
     * Foo(MyAction)
     *
     * dialog Foo(
     *   action bar(String arg)
     * ) {
     *   sample {
     *     // TypeChecker.root.getThing(NameReference(bar)) will return `action bar(String arg)`
     *     // If the TypeChecker is for the scope of this sample when `Foo` was called, then it would refer to `myAction` instead since that was passed in.
     *     bar("hello")
     *   }
     * }
     * ```
     */
    get root() {
        let curr = this;
        while (curr.prev !== undefined) {
            curr = curr.prev;
        }
        return curr;
    }
    /**
     * Get the next unique token.
     */
    nextToken() {
        return this.tokens.next().value;
    }
    /**
     * Find the URI of the Module containing this node.
     *
     * @param node
     */
    getUri(node) {
        const mod = node.getModule();
        if (mod) {
            for (const file of this.project.sourceModules.concat(this.project.externalModules)) {
                if ((file === null || file === void 0 ? void 0 : file.content) === mod) {
                    return file.uri;
                }
            }
        }
        return undefined;
    }
    /**
     * Lookup an expression by its FQN.
     *
     * @param fqn fully qualified name of the expression.
     */
    lookupQualifiedName(fqn) {
        const found = fqn ? this.global.scope.get(fqn) : undefined;
        return Array.isArray(found) ? found[0] : found;
    }
    /**
     * List all known types in a namespace.
     * @param namespace
     */
    listNamespace(namespace) {
        return this.global.namespaces.get(namespace);
    }
    /**
     * Qualify a name within a scope.
     *
     * @param scope to qualify the name within
     * @param name name to qualify
     * @returns the qualified name
     */
    qualifyName(scope, query) {
        var _a, _b;
        const name = typeof query === "object" ? query === null || query === void 0 ? void 0 : query.name : query;
        if (name === undefined) {
            return undefined;
        }
        if (isQualifiedNamePattern(name)) {
            // For backward compatibility reasons, the names within `slotTypes` namespace
            // are translated into `ask.interactionModel.slotTypes` namespace.
            // The `slotTypes` namespace is deprecated.
            if (name.startsWith("slotTypes.")) {
                return `ask.interactionModel.slotTypes.${name.substring("slotTypes.".length)}`;
            }
            return name;
        }
        const found = this.lookupName(scope, name);
        if ((found === null || found === void 0 ? void 0 : found.kind) === "NameDeclaration") {
            return (_a = found.name) === null || _a === void 0 ? void 0 : _a.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "TypeParameter") {
            return name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "TypeDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "ActionDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "DialogDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "EnumDeclaration") {
            return (_b = found.name) === null || _b === void 0 ? void 0 : _b.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "SlotType") {
            return found.name.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "ResponseTemplate") {
            if (found.isPrompt()) {
                return `${ask.PromptsNamespace}.${found.name}`;
            }
            if (found.isDisplay()) {
                return `${ask.DisplayNamespace}.${found.name}`;
            }
        }
        return name;
    }
    /**
     * Find where a name is declared in the stack.
     *
     * @param scope scope to trace back from
     * @param name name to find
     */
    lookupName(scope, name) {
        if (name === undefined) {
            return undefined;
        }
        const nameStr = typeof name === "string" ? name : name.name;
        if (this.global.scope.has(nameStr)) {
            const found = this.global.scope.get(nameStr);
            return Array.isArray(found) ? found[0] : found;
        }
        const lexicalScope = this.getVisibleNames(scope);
        if (lexicalScope) {
            const found = lexicalScope.get(nameStr);
            return Array.isArray(found) ? found[0] : found;
        }
        return undefined;
    }
    lookupNameReference(ref) {
        return this.lookupName(ref, ref.name);
    }
    /**
     * Recursively resolve the name reference when it's NameDeclaration
     * Stop when it's no longer a NameReference expression, or it's no longer a NameDeclaration
     *
     * @param ref nameReference to resolve
     * @returns the last resolved node
     */
    resolveNameReference(ref) {
        const decl = this.resolveNameReferenceToDecl(ref);
        if (ask.isNameDeclaration(decl)) {
            return decl.expression;
        }
        return decl;
    }
    /**
     * Recursively resolve the name reference to find the NameDeclaration
     * Stop when it's no longer a NameReference expression
     *
     * @param ref nameReference to resolve
     * @returns the last resolved NameDecl node
     */
    resolveNameReferenceToDecl(ref, seen = new Set()) {
        const found = ask.isPropRef(ref)
            ? this.lookupQualifiedName(ask.PropertyReference.tryResolveQualifiedName(ref))
            : this.lookupNameReference(ref);
        if (found === undefined) {
            return undefined;
        }
        if (seen.has(found)) {
            // circular reference
            return undefined;
        }
        seen.add(found);
        if (ask.isNameDeclaration(found)) {
            return this.isNameReference(found.expression)
                ? this.resolveNameReferenceToDecl(found.expression, seen)
                : found;
        }
        return found;
    }
    /**
     * Recursively resolve the name reference until find a call
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToCall(ref) {
        const found = this.resolveNameReference(ref);
        return ask.isCall(found) ? found : undefined;
    }
    /**
     * Recursively resolve the name reference until find a propertyReference
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToPropReference(ref) {
        const found = this.resolveNameReference(ref);
        return ask.isPropRef(found) ? found : undefined;
    }
    /**
     * Computes and caches the visible names at a Node.
     *
     * @param node the node in which we are looking for visible names
     * @param allowDescend a flag to set whether the code should descend into a Correction's `expected` block and include names in that block within this ${node}'s lexical scope.
     */
    getVisibleNames(node, allowDescend = true) {
        var _a, _b;
        if (node === undefined) {
            return immutable.Map();
        }
        // we skip caching the Correction block since its lexical scope varies on how it is approached (unfortunately)
        // 1. when the Correction Node is within a Block node, we consider the names in `expected` as a part of the lexical scope
        // 2. when we are in the Correction's `expected` or `actual` blocks, we do not consider the `expected` block as part of the lexical scope
        // we need this special behavior the Correction's expected block has abnormal lexical scope laws
        const useCache = node.kind !== "Correction";
        if (useCache && this.lexicalScopeIndex.has(node)) {
            return this.lexicalScopeIndex.get(node);
        }
        const inheritedNames = this.getVisibleNames((_a = node.previous) !== null && _a !== void 0 ? _a : node.context, ((_b = node.previous) === null || _b === void 0 ? void 0 : _b.kind) === "Correction");
        const producedNames = this.getProducedNames(node, allowDescend);
        const lexicalScope = inheritedNames !== undefined && producedNames !== undefined
            ? // TODO: check for conflicts or allow shadowing?
                inheritedNames.merge(producedNames)
            : inheritedNames === undefined
                ? producedNames
                : inheritedNames;
        if (useCache) {
            this.lexicalScopeIndex.set(node, lexicalScope);
        }
        return lexicalScope;
    }
    /**
     * Collect the names produced by a Node.
     */
    getProducedNames(node, allowDescend) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (node.kind === "Module") {
            const imports = (_b = (_a = node.imports) === null || _a === void 0 ? void 0 : _a.map((imprt) => {
                var _a;
                if (imprt.name) {
                    if (imprt.kind === "ImportName") {
                        const namespace = getNamespace(imprt.name);
                        const name = getName(imprt.name);
                        const expr = (_a = this.global.namespaces.get(namespace)) === null || _a === void 0 ? void 0 : _a.get(name);
                        if (expr) {
                            return immutable.Map({
                                [name]: expr,
                            });
                        }
                    }
                    else {
                        return this.global.namespaces.get(imprt.name);
                    }
                }
                return undefined;
            }).filter((scope) => scope !== undefined)) !== null && _b !== void 0 ? _b : [];
            // regard content in same namespace as import
            const thisNamespace = ((_c = node.namespace) === null || _c === void 0 ? void 0 : _c.name) ? this.global.namespaces.get(node.namespace.name) : undefined;
            const declared = (_e = (_d = node.expressions) === null || _d === void 0 ? void 0 : _d.map((expr) => {
                var _a;
                if (expr.kind !== "InteractionDeclaration" &&
                    ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name) &&
                    (expr.kind === "ActionDeclaration" ||
                        expr.kind === "DialogDeclaration" ||
                        expr.kind === "EnumDeclaration" ||
                        expr.kind === "NameDeclaration" ||
                        expr.kind === "TypeDeclaration")) {
                    if (node.namespace !== undefined) {
                        // we're in an ACDL module so import the short name into lexical scope
                        return immutable.Map({
                            [expr.name.name]: expr,
                            [getName(expr.name.name)]: expr,
                        });
                    }
                    return immutable.Map({
                        [expr.name.name]: expr,
                    });
                }
                return undefined;
            }).filter((scope) => scope !== undefined)) !== null && _e !== void 0 ? _e : [];
            return [...imports, thisNamespace, ...declared].reduce(mergeLexicalScope, emptyLexicalScope()).map((value) => {
                if (Array.isArray(value)) {
                    const set = new Set(value);
                    if (set.size === 1) {
                        return value[0];
                    }
                    return Array.from(set);
                }
                return value;
            });
        }
        if ((node.kind === "NameDeclaration" || node.kind === "EnumDeclaration") && ((_f = node.name) === null || _f === void 0 ? void 0 : _f.name) !== undefined) {
            return immutable.Map({
                [node.name.name]: node,
            });
        }
        if ((node === null || node === void 0 ? void 0 : node.kind) === "ActionDeclaration" || (node === null || node === void 0 ? void 0 : node.kind) === "DialogDeclaration" || (node === null || node === void 0 ? void 0 : node.kind) === "TypeDeclaration") {
            const genericArguments = computeLexicalScope(node.genericArguments);
            if (node.kind === "DialogDeclaration") {
                const argumentsScope = computeLexicalScope(node.arguments);
                return genericArguments.merge(argumentsScope);
            }
            return genericArguments;
        }
        if (node.kind === "Correction" && allowDescend) {
            if ((_h = (_g = node.expected) === null || _g === void 0 ? void 0 : _g.expressions) === null || _h === void 0 ? void 0 : _h.length) {
                return this.getVisibleNames(node.expected.expressions[node.expected.expressions.length - 1]);
            }
        }
        else if (node.kind === "Argument") {
            // special lexical scoping logic for validateArg, see https://github.com/alexa/ask-ac/issues/690
            const annotationName = this.lookupName(node.context, node.context.name);
            if ((annotationName === null || annotationName === void 0 ? void 0 : annotationName.kind) === "ActionDeclaration" && ((_j = annotationName.name) === null || _j === void 0 ? void 0 : _j.name) === AlexaConversations.validateArg) {
                if (((_k = node.name) === null || _k === void 0 ? void 0 : _k.name) === "condition" || (node.name === undefined && node.index === 0)) {
                    // we only want the argument names to be visible for the `condition` argument.
                    if (node.context.context.kind === "Annotation" && node.context.context.context.kind === "ActionDeclaration") {
                        return computeLexicalScope(node.context.context.context.arguments);
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Find the {@link ask.Name} located at a specific position in the file.
     *
     * @param uri module uri to search
     * @param position line and column number
     */
    findName(uri, position) {
        const found = this.findNode(uri, position);
        return ask.isName(found) ? found : undefined;
    }
    /**
     * Finds a {@link ask.Name} or {@link ask.Import} at a specific position in the file.
     *
     * @param uri module uri to search
     * @param position line and column number
     */
    findNode(uri, position) {
        var _a;
        const module = this.project.getModule(uri);
        const { expressions, imports, namespace } = (_a = module === null || module === void 0 ? void 0 : module.content) !== null && _a !== void 0 ? _a : {};
        return this.find(expressions, position) || this.find(imports, position) || this.find(namespace, position);
    }
    /**
     * Finds a {@link ask.Name} or {@link ask.Import} node at a specific position in the file.
     *
     * @param node node to search
     * @param position line and column number
     * @returns the `Name` or `Import` node
     */
    find(node, position) {
        if (node === undefined || node === null) {
            return undefined;
        }
        if (Array.isArray(node)) {
            for (const i of node) {
                const found = this.find(i, position);
                if (found !== undefined) {
                    return found;
                }
            }
        }
        else if (typeof node === "object") {
            if ((node === null || node === void 0 ? void 0 : node.loc) !== undefined) {
                if (ask.locationContains(node.loc, position, true)) {
                    if (ask.isName(node) || ask.isImport(node)) {
                        return node;
                    }
                }
            }
            for (const [name, value] of Object.entries(node)) {
                if (name === "context" || name === "previous") {
                    continue;
                }
                const found = this.find(value, position);
                if (found !== undefined) {
                    return found;
                }
            }
        }
        return undefined;
    }
    /**
     * Finds the type referenced by a TypeReference.
     *
     * @param type type reference to lookup
     */
    lookupTypeReference(type) {
        var _a;
        const target = this.lookupName(type, (_a = type.name) === null || _a === void 0 ? void 0 : _a.name);
        if ((target === null || target === void 0 ? void 0 : target.kind) === "ActionDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "DialogDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "EnumDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "TypeDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "TypeParameter" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "SlotType") {
            return target;
        }
        return undefined;
    }
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupCallDeclaration(call) {
        var _a;
        const target = this.lookupName(call, (_a = call.name) === null || _a === void 0 ? void 0 : _a.name);
        if (target !== undefined &&
            (target.kind === "ActionDeclaration" ||
                target.kind === "ArgumentDeclaration" ||
                target.kind === "DialogDeclaration" ||
                target.kind === "NameDeclaration" ||
                target.kind === "SlotType" ||
                target.kind === "TypeDeclaration")) {
            return target;
        }
        return undefined;
    }
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupTypeDeclaration(fqn) {
        const names = this.global.scope.get(fqn);
        const expr = Array.isArray(names) ? names[0] : names;
        if ((expr === null || expr === void 0 ? void 0 : expr.kind) === "TypeDeclaration") {
            return expr;
        }
        return undefined;
    }
    /**
     * Get auto-completion suggestions for the Node.
     */
    getCompletions(node) {
        var _a, _b, _c, _d, _e, _f;
        // TODO: type safe interface
        if (node.kind === "Name") {
            const { context } = node;
            if (context.kind === "Utterance") {
                const type = (_a = this.getType(context.context)) === null || _a === void 0 ? void 0 : _a.getUtteranceType();
                if (type !== undefined) {
                    const alreadyProvided = new Set((_b = context.names) === null || _b === void 0 ? void 0 : _b.map((n) => n.name).filter((n) => n !== undefined && n !== node.name));
                    return (_c = type.properties) === null || _c === void 0 ? void 0 : _c.map((prop) => prop.name).filter((n) => n !== undefined && !alreadyProvided.has(n)).map((label) => ({
                        label,
                    }));
                }
            }
            else if (context.kind === "Block") {
                return Object.keys(this.getVisibleNames(node) || {}).map((label) => ({ label }));
            }
            else {
                return this.getCompletions(node.context);
            }
        }
        else if (this.isNameReference(node)) {
            return Object.keys(this.getVisibleNames(node) || {})
                .filter((label) => !label.includes("."))
                .map((label) => ({
                label,
            }));
        }
        else if (node.kind === "PropertyReference") {
            const exprType = this === null || this === void 0 ? void 0 : this.getType(node.expression);
            if (exprType) {
                return (_d = exprType.properties) === null || _d === void 0 ? void 0 : _d.map((property) => ({
                    label: property.name,
                }));
            }
        }
        else if (node.kind === "Argument") {
            return (_f = (_e = this.getApply(node.context)) === null || _e === void 0 ? void 0 : _e.argumentDeclarations) === null || _f === void 0 ? void 0 : _f.map((arg) => {
                var _a;
                return ({
                    label: typeof arg.name === "string" ? arg.name : (_a = arg.name) === null || _a === void 0 ? void 0 : _a.name,
                });
            });
        }
        return undefined;
    }
    /**
     * Compute a detailed description of the expression.
     *
     * @param node expression to describe.
     */
    getDescription(node) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (node !== undefined) {
            if (node.kind === "Name") {
                const { context } = node;
                if (context.kind === "Utterance") {
                    const type = (_a = this.getType(context.context)) === null || _a === void 0 ? void 0 : _a.getUtteranceType();
                    if (type && node.name) {
                        return `(property) ${type.toString(node)} ${node.name}`;
                    }
                }
                return this.getDescription(context);
            }
            if (node.kind === "NameReference") {
                const type = this.getType(node);
                if (type && ((_b = node.name) === null || _b === void 0 ? void 0 : _b.name)) {
                    return `(name) ${type.toString(node)} ${node.name.name}`;
                }
            }
            else if (node.kind === "NameDeclaration") {
                if (((_c = node.name) === null || _c === void 0 ? void 0 : _c.name) && node.expression) {
                    const type = this.getType(node);
                    if (type) {
                        return `(name) ${type.toString(node)} ${node.name.name}`;
                    }
                }
            }
            else if (node.kind === "PropertyReference") {
                if (this.isNameReference(node)) {
                    const type = this.getType(node);
                    if (type && ((_d = node.name) === null || _d === void 0 ? void 0 : _d.name)) {
                        return `(name) ${type.toString(node)} ${node.name.name}`;
                    }
                }
                const propertyName = (_e = node.name) === null || _e === void 0 ? void 0 : _e.name;
                const returnType = this.getType(node);
                if (returnType && propertyName) {
                    return `(property) ${returnType.toString(node)} ${propertyName}`;
                }
            }
            else if (node.kind === "TypeReference") {
                const type = this.getType(node);
                if (((_f = node.name) === null || _f === void 0 ? void 0 : _f.name) && type) {
                    const label = ((_g = type === null || type === void 0 ? void 0 : type.declaration) === null || _g === void 0 ? void 0 : _g.kind) === "TypeParameter" ? "type parameter" : "type";
                    return `(${label}) ${type.toString(node)}`;
                }
            }
            else if (node.kind === "Type") {
                return node.toString(node.declaration);
            }
            else if (node.kind === "TypeParameter") {
                if ((_h = node.name) === null || _h === void 0 ? void 0 : _h.name) {
                    return `(type parameter) ${node.name.name}`;
                }
            }
            else if (node.kind === "TypeProperty") {
                const type = this.getType(node.type);
                if (type && ((_j = node.name) === null || _j === void 0 ? void 0 : _j.name)) {
                    return `(property) ${type.toString(node)} ${node.name.name}`;
                }
            }
            else if (node.kind === "TypeDeclaration") {
                return `(type declaration) ${(_k = node.name) === null || _k === void 0 ? void 0 : _k.name}${node.genericArguments ? `<${node.genericArguments.map((arg) => stringifyTypeParameter(arg))}>` : ""}`;
            }
            else if (node.kind === "EnumDeclaration") {
                return `(enum declaration) ${(_l = node.name) === null || _l === void 0 ? void 0 : _l.name}`;
            }
            else if (node.kind === "EnumItemDeclaration") {
                return `(enum item) ${(_m = node.name) === null || _m === void 0 ? void 0 : _m.name}`;
            }
            else if (node.kind === "DialogDeclaration" || node.kind === "ActionDeclaration") {
                const type = node.kind === "ActionDeclaration" ? "action" : "dialog";
                const returnType = this.getType(node.returnType);
                const argumentDeclarations = node.arguments && node.arguments.length > 0
                    ? `(\n  ${node.arguments.map((a) => { var _a, _b; return `${(_a = this.getType(a)) === null || _a === void 0 ? void 0 : _a.toString(node)} ${(_b = a.name) === null || _b === void 0 ? void 0 : _b.name}`; }).join(",\n  ")}\n)`
                    : "()";
                if (returnType && ((_o = node.name) === null || _o === void 0 ? void 0 : _o.name)) {
                    return `${type} ${returnType.toString(node)} ${node.name.name}${argumentDeclarations}`;
                }
            }
            else if (node.kind === "ArgumentDeclaration") {
                const type = this.getType(node.type);
                if (type && ((_p = node.name) === null || _p === void 0 ? void 0 : _p.name)) {
                    return `(argument) ${type.toString(node)} ${(_q = node.name) === null || _q === void 0 ? void 0 : _q.name}`;
                }
            }
            else if (node.kind === "Argument") {
                const type = this.getType(node.value);
                if (type && ((_r = node.name) === null || _r === void 0 ? void 0 : _r.name)) {
                    return `(argument) ${type.toString(node)} ${(_s = node.name) === null || _s === void 0 ? void 0 : _s.name}`;
                }
            }
            else if (node.kind === "Call") {
                return this.getDescription((_t = this.getApply(node)) === null || _t === void 0 ? void 0 : _t.decl);
            }
        }
        return undefined;
    }
    /**
     * Gets a `Thing` instance representing the value of some Node.
     *
     * @param node AST node to get a Thing to represent.
     * @param backtrack backtrack to control type interface
     * @param seen nodes seen so far in this traversal to detect infinite loops
     */
    getThing(node, token, origin = node, seen = immutable.Set()) {
        var _a, _b, _c;
        if (node === undefined) {
            return undefined;
        }
        if (seen.has(node)) {
            // circular reference
            return undefined;
        }
        const checker = this;
        seen = seen.add(node);
        if (this.globalThingIndex.has(node)) {
            return (_a = this.globalThingIndex.get(node)) !== null && _a !== void 0 ? _a : undefined;
        }
        if (!this.localThingIndex.has(node)) {
            this.localThingIndex.set(node, (_b = getThing(node, seen)) !== null && _b !== void 0 ? _b : null);
        }
        return (_c = this.localThingIndex.get(node)) !== null && _c !== void 0 ? _c : undefined;
        function getThing(node, seen) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            if (node.kind === "NameReference" ||
                node.kind === "PropertyReference" ||
                (node.kind === "Call" && ((_a = checker.getApply(node, undefined, seen)) === null || _a === void 0 ? void 0 : _a.isGetListItem()))) {
                let rootThing = undefined;
                if (node.kind === "PropertyReference") {
                    const nameRef = checker.lookupName(node, ask.PropertyReference.tryResolveQualifiedName(node));
                    if (nameRef) {
                        rootThing = checker.getThing(nameRef, token, node, seen);
                    }
                    else {
                        rootThing = (_b = checker.getThing(node.expression, undefined, undefined, seen)) === null || _b === void 0 ? void 0 : _b.getProperty(node.name);
                    }
                }
                else if (node.kind === "Call") {
                    const apply = checker.getApply(node);
                    const index = (_c = checker.getThing(apply.getArgumentValue("index"))) === null || _c === void 0 ? void 0 : _c.asNumber();
                    let listThing = checker.getThing(apply.getArgumentValue("list"), undefined, undefined, seen);
                    // If listThing is Optional<List> then we need to unwrap the List from the generic
                    // argument and transform it from an AnyThing to a ListThing.
                    if (!(listThing === null || listThing === void 0 ? void 0 : listThing.isList()) && (listThing === null || listThing === void 0 ? void 0 : listThing.type.isOptional())) {
                        const genericType = (_e = (_d = listThing === null || listThing === void 0 ? void 0 : listThing.type) === null || _d === void 0 ? void 0 : _d.genericArguments) === null || _e === void 0 ? void 0 : _e[0];
                        if (genericType && genericType.isList()) {
                            listThing = genericType.getThing(checker.nextToken(), origin, listThing, apply);
                        }
                    }
                    if (index) {
                        rootThing = (_f = listThing === null || listThing === void 0 ? void 0 : listThing.asList()) === null || _f === void 0 ? void 0 : _f.getItem(index, node);
                    }
                }
                else {
                    rootThing = checker.getThing(checker.lookupNameReference(node), token, undefined, seen);
                }
                if (rootThing === undefined) {
                    return undefined;
                }
                return search(node.context);
                function search(context) {
                    if (context === undefined) {
                        return rootThing;
                    }
                    if (context.kind === "Block") {
                        if (context instanceof ThenScope) {
                            if (context.context.when) {
                                return descend(context.context.when.expression, search(context.context));
                            }
                            return search(context.context);
                        }
                        if (context.context.kind === "Sample") {
                            const sample = context.context;
                            if (sample.annotations) {
                                for (const annotation of sample.annotations) {
                                    const annotationApply = checker.getApply(annotation.call);
                                    if (annotationApply === null || annotationApply === void 0 ? void 0 : annotationApply.isWhen()) {
                                        const condition = annotationApply.getArgumentValue("condition");
                                        if (condition) {
                                            return descend(condition, search(context.context));
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else if (context.kind === "Argument") {
                        const apply = checker.getApply(context.context);
                        if (apply === null || apply === void 0 ? void 0 : apply.isAnd()) {
                            const left = apply.getArgument("left");
                            const right = apply.getArgument("right");
                            if (left === context) {
                                return search(context.context);
                            }
                            if (right === context) {
                                return descend(left, search(context.context));
                            }
                        }
                    }
                    return search(context.context);
                }
                function descend(when, thing) {
                    var _a;
                    if (when === undefined) {
                        return thing;
                    }
                    if (when.kind === "Argument") {
                        return descend(when.value, thing);
                    }
                    if (when.kind === "Call") {
                        const apply = checker.getApply(when, true, seen);
                        if (apply) {
                            if (apply.isIs()) {
                                const isThing = apply.getArgumentValueThing("thing");
                                const type = (_a = apply.getGenericArguments()) === null || _a === void 0 ? void 0 : _a[0];
                                if (type && (isThing === null || isThing === void 0 ? void 0 : isThing.equals(thing))) {
                                    return thing.cast(thing.type.narrow(type));
                                }
                            }
                            else if (apply.isAnd()) {
                                const left = descend(apply.getArgumentValue("left"), thing);
                                const right = descend(apply.getArgumentValue("right"), left);
                                if (left === undefined && right === undefined) {
                                    return search(when.context);
                                }
                                if (left === undefined || right === undefined) {
                                    return left || right;
                                }
                                const intersection = left.type.narrow(right.type);
                                if (intersection) {
                                    return search(when.context).cast(intersection);
                                }
                            }
                            else if (apply.isOr()) {
                                const left = descend(apply.getArgumentValue("left"), thing);
                                const right = descend(apply.getArgumentValue("right"), thing);
                                const union = left.type.union(right.type);
                                if (union) {
                                    return thing.cast(union);
                                }
                            }
                            else if (apply.isEq() || apply.isNeq()) {
                                const left = apply.getArgumentValueThing("left");
                                const right = apply.getArgumentValueThing("right");
                                if ((left === null || left === void 0 ? void 0 : left.equals(thing)) || (right === null || right === void 0 ? void 0 : right.equals(thing))) {
                                    const operand = (left === null || left === void 0 ? void 0 : left.equals(thing)) ? right : left;
                                    if ((operand === null || operand === void 0 ? void 0 : operand.type.isVoid()) || (operand === null || operand === void 0 ? void 0 : operand.type.isNothing())) {
                                        if (apply.isEq()) {
                                            return new VoidThing(checker, thing.token, checker.void, thing.apply, thing.origin, thing.parent);
                                        }
                                        let { type } = thing;
                                        while (type === null || type === void 0 ? void 0 : type.isOptional()) {
                                            type = type.getOptionalType();
                                        }
                                        return type ? thing.cast(type) : thing;
                                    }
                                    return thing;
                                }
                            }
                        }
                    }
                    return thing;
                }
            }
            if (node.kind === "NameDeclaration") {
                const expr = checker.getThing(node.expression, token !== null && token !== void 0 ? token : checker.nextToken(), (_g = node.expression) !== null && _g !== void 0 ? _g : node, seen);
                if (node.type && (expr === null || expr === void 0 ? void 0 : expr.type.isNothing())) {
                    return (_h = checker.getType(node.type)) === null || _h === void 0 ? void 0 : _h.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), (_j = node.expression) !== null && _j !== void 0 ? _j : node);
                }
                return expr;
            }
            if (node.kind === "Call") {
                const apply = checker.getApply(node, true, seen);
                if (apply !== undefined) {
                    if (apply.isType()) {
                        const returnType = apply.getReturnType(seen);
                        if (returnType === null || returnType === void 0 ? void 0 : returnType.isNothing()) {
                            return new NothingThing(checker, checker.nothingToken, checker.nothing, apply, origin !== null && origin !== void 0 ? origin : node, undefined);
                        }
                        if (returnType === null || returnType === void 0 ? void 0 : returnType.isVoid()) {
                            return new VoidThing(checker, checker.voidToken, checker.void, apply, origin !== null && origin !== void 0 ? origin : node, undefined);
                        }
                        return returnType === null || returnType === void 0 ? void 0 : returnType.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node, undefined, apply);
                    }
                    if (apply.isAction()) {
                        return (_k = apply.getReturnType(seen)) === null || _k === void 0 ? void 0 : _k.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node, undefined, apply);
                    }
                    if (apply.isDialog()) {
                        return (_l = apply.getReturnType(seen)) === null || _l === void 0 ? void 0 : _l.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node);
                    }
                }
                return undefined;
            }
            if (node.kind === "Annotation") {
                return checker.getThing(node.call, token, undefined, seen);
            }
            if (node.kind === "Argument") {
                return checker.getThing(node.value, token, undefined, seen);
            }
            if (node.kind === "ListItem") {
                return checker.getThing(node.item, token, undefined, seen);
            }
            if (node.kind === "ListLiteral") {
                return checker.getThing(node.context, token, undefined, seen);
            }
            if (node.kind === "ResponseTemplate") {
                // TODO
            }
            else if (node.kind === "Sample") {
                return checker.getThing(node.scope, token !== null && token !== void 0 ? token : checker.nextToken(), node, seen);
            }
            else if (node.kind === "ActionDeclaration") {
                return new ActionThing(checker, checker.nextToken(), checker.getType(node), node);
            }
            else if (node.kind === "DialogDeclaration") {
                return new DialogThing(checker, checker.nextToken(), checker.getType(node), node);
            }
            else if (node.kind === "Condition") {
                const then = ((_o = (_m = node.then) === null || _m === void 0 ? void 0 : _m.expressions) === null || _o === void 0 ? void 0 : _o.length)
                    ? checker.getThing(node.then.expressions[node.then.expressions.length - 1], undefined, undefined, seen)
                    : checker.void.getThing(checker.nextToken(), node);
                const _else = ((_q = (_p = node.else) === null || _p === void 0 ? void 0 : _p.expressions) === null || _q === void 0 ? void 0 : _q.length)
                    ? checker.getThing(node.else.expressions[node.else.expressions.length - 1], undefined, undefined, seen)
                    : checker.void.getThing(checker.nextToken(), node);
                if (then && _else) {
                    return new UnionThing(checker, checker.nextToken(), checker.getType(node), node, [then, _else]);
                }
                if (then) {
                    return new UnionThing(checker, checker.nextToken(), checker.getType(node), node, [then]);
                }
                return undefined;
            }
            else if (node.kind === "Block" && node.expressions && node.expressions.length > 0) {
                return checker.getThing(node.expressions[node.expressions.length - 1]);
            }
            else if (node.kind === "When") {
                return checker.getThing(node.expression, token, origin, seen);
            }
            // recursion
            return ((_r = checker.getType(node)) !== null && _r !== void 0 ? _r : checker.thing).getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node);
        }
    }
    /**
     * Gets the type of a Node.
     *
     * @param node to determine the type of
     * @param backtrack backtrack to control the behavior of the get type search
     * @param seen a set of seen nodes for detecting circular references
     * @returns instantiate type of the node or undefined if it cannot be determined
     */
    getType(node, backtrack = true, seen = immutable.Set()) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (node === undefined || seen.has(node)) {
            return undefined;
        }
        if (node.kind === "Call") {
            const apply = this.getApply(node, backtrack);
            if (apply === null || apply === void 0 ? void 0 : apply.isGetListItem()) {
                return (_a = this.getThing(node, undefined, undefined, seen)) === null || _a === void 0 ? void 0 : _a.type;
            }
            return apply === null || apply === void 0 ? void 0 : apply.getReturnType(seen.add(node));
        }
        if (node.kind === "Annotation") {
            return this.getType(node.call, backtrack, seen);
        }
        if (node.kind === "Utterance") {
            return this.getType(node.context, backtrack);
        }
        if (node.kind === "NameDeclaration") {
            if (node.type) {
                return this.instantiateTypeReference(node.type);
            }
            // infer the type from the expression
            return (_b = this.getThing(node.expression, undefined, node, seen.add(node))) === null || _b === void 0 ? void 0 : _b.type;
        }
        if (node.kind === "NameReference") {
            return (_c = this.getThing(node, undefined, node, seen)) === null || _c === void 0 ? void 0 : _c.type;
        }
        if (node.kind === "PropertyReference") {
            return (_d = this.getThing(node, undefined, node, seen)) === null || _d === void 0 ? void 0 : _d.type;
        }
        if (node.kind === "ListLiteral") {
            // empty list defaults to List<Thing>, otherwise List<T> where T is the intersection of all Types in the List.
            // TODO: should it default to List<Nothing> so that it is a List compatible with all lists? Probably...
            const itemType = node.items.length === 0
                ? this.thing
                : node.items
                    .map((item) => this.getType(item.item, false, seen))
                    // reduce the list of types to a single type which is their shared sub type
                    // if two types have an `undefined` intersection, assume as `Thing`
                    // initial value of reduction is nothing (0, "zero") - nothing intersects with all types, so the first value in the list always takes precedence
                    .reduce((a, b) => { var _a; return (_a = a === null || a === void 0 ? void 0 : a.union(b)) !== null && _a !== void 0 ? _a : this.thing; }, this.nothing);
            if (itemType === undefined) {
                return undefined;
            }
            if (node.context.kind === "Call" && ((_e = node.context.name) === null || _e === void 0 ? void 0 : _e.name) === AlexaConversations.Args) {
                return this.instantiateAlexaSchemaType(AlexaConversations.Args, itemType);
            }
            return this.instantiateAlexaSchemaType(AlexaSchema.List, itemType);
        }
        if (node.kind === "ArgumentDeclaration") {
            return this.instantiateTypeReference(node.type);
        }
        if (node.kind === "TypeReference") {
            return this.instantiateTypeReference(node);
        }
        if (node.kind === "Condition") {
            const then = (_f = this.getType(node.then, backtrack, seen)) !== null && _f !== void 0 ? _f : this.nothing; // then as `undefined` is impossible
            const _else = node.else ? (_g = this.getType(node.else, backtrack, seen)) !== null && _g !== void 0 ? _g : this.nothing : this.void;
            return then === null || then === void 0 ? void 0 : then.union(_else);
        }
        if (node.kind === "Correction") {
            return this.void;
        }
        if (node.kind === "When") {
            return this.getType(node.expression);
        }
        if (node.kind === "Block") {
            if (node.expressions && node.expressions.length > 0) {
                return this.getType(node.expressions[node.expressions.length - 1], backtrack, seen);
            }
            return this.void;
        }
        if (node.kind === "ActionDeclaration" || node.kind === "DialogDeclaration") {
            return new Type(this, node, undefined);
        }
        if (node.kind === "TypeDeclaration") {
            // Type<T>
            const typeType = this.lookupTypeDeclaration(AlexaSchema.Type);
            const type = this.instantiateTypeDeclaration(node, undefined);
            if (type) {
                return new Type(this, typeType, [type]);
            }
        }
        else if (node.kind === "TypeParameter") {
            return this.instantiateTypeParameter(node);
        }
        else if (node.kind === "ResponseTemplate") {
            if (node.type === ask.ResponseTemplateType.Display) {
                return this.instantiateTypeDeclaration(this.lookupTypeDeclaration(AlexaConversations.APL), [this.thing]);
            }
            if (node.type === ask.ResponseTemplateType.Prompt) {
                return this.instantiateTypeDeclaration(this.lookupTypeDeclaration(AlexaConversations.APLA), [this.thing]);
            }
        }
        else if (node.kind === "SlotType") {
            return this.instantiateTypeDeclaration(node);
        }
        else if (node.kind === "Sample") {
            return this.getType(node.scope, backtrack, seen);
        }
        else if (node.kind === "ListItem") {
            return this.getType(node.item, backtrack, seen);
        }
        else if (node.kind === "Argument") {
            return this.getType(node.value, backtrack, seen);
        }
        else if (node.kind === "TypeProperty") {
            let propertyType = (_h = this.getType(node.type, backtrack, seen)) !== null && _h !== void 0 ? _h : this.nothing;
            if (node.optional === true && !propertyType.isOptional()) {
                propertyType = new Type(this, this.lookupTypeDeclaration(AlexaSchema.Optional), [propertyType]);
            }
            return new Type(this, this.lookupTypeDeclaration(AlexaSchema.Property), [propertyType]);
        }
        else if (node.kind === "EnumDeclaration") {
            const typeType = this.lookupTypeDeclaration(AlexaSchema.Type);
            const type = this.instantiateTypeDeclaration(node);
            if (type) {
                /**
                 * e.g.
                 * ```
                 * enum A {
                 *   a
                 * }
                 *
                 * A // type: `Type<A>`
                 * A.a // type: `A`
                 * ``
                 */
                return new Type(this, typeType, [type]);
            }
        }
        else if (node.kind === "EnumItemDeclaration") {
            return (_j = this.getType(node.context, backtrack, seen)) === null || _j === void 0 ? void 0 : _j.getTypeType();
        }
        return undefined;
    }
    /**
     * Get the type of a Call implied by its context.
     *
     * @param call
     */
    getImpliedType(call) {
        var _a, _b, _c;
        const callContext = call.context;
        if ((callContext.kind === "NameDeclaration" || callContext.kind === "ArgumentDeclaration") && callContext.type) {
            return this.instantiateTypeReference(callContext.type);
        }
        if (callContext.kind === "ListItem") {
            return (_b = (_a = this.getApply(callContext.context.context, true)) === null || _a === void 0 ? void 0 : _a.getReturnType()) === null || _b === void 0 ? void 0 : _b.getListItemType();
        }
        if (callContext.kind === "Argument") {
            return (_c = this.getApply(callContext.context, true)) === null || _c === void 0 ? void 0 : _c.getType(callContext);
        }
        return undefined;
    }
    /**
     * Get an Apply for this call.
     *
     * @param call to analyze
     * @param backtrack whether to look back up the tree to infer types
     */
    getApply(call, backtrack = true, seenNames = immutable.Set()) {
        var _a, _b;
        const checker = this;
        if (!backtrack) {
            return getApply();
        }
        if (!this.localApplyIndex.has(call)) {
            this.localApplyIndex.set(call, (_a = getApply()) !== null && _a !== void 0 ? _a : null);
        }
        return (_b = this.localApplyIndex.get(call)) !== null && _b !== void 0 ? _b : undefined;
        function getApply() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            if (checker.prev) {
                return (_a = checker.root.getApply(call, backtrack, seenNames)) === null || _a === void 0 ? void 0 : _a.instantiate(checker);
            }
            if (((_b = call.name) === null || _b === void 0 ? void 0 : _b.name) === undefined) {
                if (backtrack) {
                    let impliedType = checker.getImpliedType(call);
                    while (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isOptional()) {
                        // if the implied type is optional and we have a non-null call, then we know we are instantiating the Some type
                        impliedType = impliedType.getOptionalType();
                    }
                    if (ask.isListLiteral(call.arguments) && (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isThing())) {
                        // if checker is a list literal in an argument that is of type, `Thing`, then infer the the type of the list from the literal items.
                        impliedType = checker.getType(call.arguments);
                    }
                    const implied = impliedType === null || impliedType === void 0 ? void 0 : impliedType.apply(call);
                    if (implied) {
                        return implied;
                    }
                }
                if (ask.isListLiteral(call.arguments)) {
                    return (_c = checker.getType(call.arguments, backtrack, seenNames)) === null || _c === void 0 ? void 0 : _c.apply(call);
                }
                return undefined;
            }
            if (((_d = call.name) === null || _d === void 0 ? void 0 : _d.name) === AlexaSchema.String && (typeof call.arguments === "string" || ask.isUtterance(call.arguments))) {
                // string literal, let's check if this string should be treated as an utterance or some other specialized string
                if (backtrack) {
                    const impliedType = checker.getImpliedType(call);
                    if (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isStringLike()) {
                        return impliedType.apply(call);
                    }
                }
            }
            else if (call.name.name === AlexaSchema.Number && typeof call.arguments === "number") {
                // number literal, let's check if it should be up-casted to a specialized string based on context
                // e.g. Ordinal ord = 1
                // `1` should be interpreted as Ordinal(1), not Number(1)
                if (backtrack) {
                    const impliedType = checker.getImpliedType(call);
                    if (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isNumber()) {
                        return impliedType.apply(call);
                    }
                }
            }
            const decl = checker.lookupCallDeclaration(call);
            if (decl === undefined) {
                return undefined;
            }
            if (decl.kind === "TypeDeclaration") {
                if (decl.genericArguments === undefined) {
                    // concrete type
                    return (_e = checker.instantiateTypeDeclaration(decl, undefined)) === null || _e === void 0 ? void 0 : _e.apply(call);
                }
                if (((_f = call.genericArguments) === null || _f === void 0 ? void 0 : _f.length) === decl.genericArguments.length) {
                    // generic with explicits
                    return (_g = checker
                        .instantiateTypeDeclaration(decl, call.genericArguments.map((a) => checker.instantiateTypeReference(a)))) === null || _g === void 0 ? void 0 : _g.apply(call);
                }
                return new Apply(checker, call, decl);
            }
            if (decl.kind === "SlotType") {
                return (_h = checker.instantiateTypeDeclaration(decl)) === null || _h === void 0 ? void 0 : _h.apply(call);
            }
            if (decl.kind === "ArgumentDeclaration" || decl.kind === "NameDeclaration") {
                // either a concrete reference to an action or an abstract action signature (argument declaration).
                const actionThing = checker.getThing(decl);
                if (!actionThing || !actionThing.type || ((_j = actionThing.origin) === null || _j === void 0 ? void 0 : _j.kind) === "ActionDeclaration") {
                    return undefined;
                }
                // actual type of the argument declaration
                const actualType = actionThing.type.isOptional() ? actionThing.type.getOptionalType() : actionThing.type;
                // abstract type of the argument declaration, e.g. FunctionN<..>
                const abstractType = checker.root.getType(decl);
                if (abstractType && (actualType === null || actualType === void 0 ? void 0 : actualType.isFunction())) {
                    return new Apply(checker, call, actualType);
                }
                return undefined;
            }
            return new Apply(checker, call, decl);
        }
    }
    /**
     * Find an Argument's TypeProperty based on its position or name in a Call to a TypeDeclaration.
     *
     * @param type type declaration called
     * @param argument argument value in the call
     */
    findArgumentTypeProperty(type, argument) {
        var _a;
        if (type.properties === undefined) {
            return undefined;
        }
        if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
            return type.getProperty(argument.name.name);
        }
        if (typeof argument.index === "number") {
            return type.getProperty(argument.index);
        }
        return undefined;
    }
    /**
     * Find an Argument's declaration based on its name or position
     *
     * @param action action or dialog declaration
     * @param argument argument value in the call
     */
    findArgumentDeclaration(action, argument) {
        var _a, _b;
        if (action.arguments === undefined) {
            return undefined;
        }
        if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
            // named argument
            return (_b = action.arguments) === null || _b === void 0 ? void 0 : _b.find((arg) => { var _a, _b; return ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) === ((_b = argument.name) === null || _b === void 0 ? void 0 : _b.name); });
        }
        if (argument.index) {
            return action.arguments[argument.index];
        }
        return undefined;
    }
    instantiateActionDeclaration(decl, call) {
        return new Apply(this, call, decl);
    }
    /**
     * Instantiate a TypeDeclaration given some typeArgs and a type environment.
     *
     * @param type type declaration to instantiate
     * @param typeArgs known type arguments
     * @param env type environment
     */
    instantiateTypeDeclaration(type, typeArgs, functionArgumentNames, functionName) {
        var _a;
        if (typeArgs === undefined) {
            const cached = this.globalTypeIndex.get(type);
            if (cached !== undefined) {
                return cached;
            }
        }
        let newType = new Type(this, type, typeArgs, functionArgumentNames, functionName);
        if (newType.isReturnValue()) {
            // compute the intrinsic type alias `ReturnValue<A>`
            // we substitute this type with the type of the value returned by the action or dialog
            const returnValueType = newType.getReturnValueType();
            if ((returnValueType === null || returnValueType === void 0 ? void 0 : returnValueType.isAction()) || (returnValueType === null || returnValueType === void 0 ? void 0 : returnValueType.isDialog())) {
                const returnType = (_a = returnValueType.getPropertyType("returnType")) === null || _a === void 0 ? void 0 : _a.getTypeType();
                if (returnType) {
                    newType = returnType;
                }
            }
        }
        if (typeArgs === undefined) {
            // cache a forward-reference to the constructed type if there are no type arguments
            this.globalTypeIndex.set(type, newType);
        }
        return newType;
    }
    /**
     * Instantiate a type by substituting all type parameters and propagating the types to all super types.
     *
     * @param type type reference to instantiate
     * @param env optional lookup table of known names
     */
    instantiateTypeReference(type, env) {
        var _a, _b, _c, _d, _e;
        if (type === undefined) {
            return undefined;
        }
        if (env === null || env === void 0 ? void 0 : env[(_a = type.name) === null || _a === void 0 ? void 0 : _a.name]) {
            return env === null || env === void 0 ? void 0 : env[(_b = type.name) === null || _b === void 0 ? void 0 : _b.name];
        }
        const typeDecl = this.lookupTypeReference(type);
        if ((typeDecl === null || typeDecl === void 0 ? void 0 : typeDecl.kind) === "TypeParameter") {
            return this.instantiateTypeParameter(typeDecl);
        }
        if (typeDecl !== undefined) {
            let typeArgs;
            if (typeDecl.kind === "TypeDeclaration" || typeDecl.kind === "ActionDeclaration" || typeDecl.kind === "DialogDeclaration") {
                if (typeDecl.genericArguments) {
                    if (type.arguments === undefined || ((_c = type.arguments) === null || _c === void 0 ? void 0 : _c.length) === 0) {
                        typeArgs = typeDecl.genericArguments.map((arg) => {
                            const type = this.getType(arg);
                            if ((type === null || type === void 0 ? void 0 : type.extensions) === undefined || type.extensions.length === 0) {
                                return this.thing;
                            }
                            if (type.extensions.length === 1) {
                                return type.extensions[0];
                            }
                            // TODO: how should we handle a multiple-inheritance lower bound.
                            return this.thing;
                        });
                    }
                    else {
                        typeArgs = (_d = type.arguments) === null || _d === void 0 ? void 0 : _d.map((arg) => this.instantiateTypeReference(arg, env));
                    }
                    // infer the type arguments
                }
            }
            return this.instantiateTypeDeclaration(typeDecl, typeArgs, type.functionArgumentNames, type.functionArgumentNames !== undefined && type.context.kind === "ArgumentDeclaration" ? (_e = type.context.name) === null || _e === void 0 ? void 0 : _e.name : undefined);
        }
        return undefined;
    }
    /**
     * Instantiate a TypeParameter.
     *
     * @param param type parameter.
     */
    instantiateTypeParameter(param) {
        return new Type(this, param, undefined);
    }
    instantiateAlexaSchemaType(name, ...genericArguments) {
        const decl = this.lookupQualifiedName(name);
        if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "TypeDeclaration") {
            const type = this.instantiateTypeDeclaration(decl, genericArguments.length > 0 ? genericArguments : undefined);
            if (type) {
                return type;
            }
        }
        throw new Error(`could not find alexa schema type: ${name}`);
    }
    /**
     * determine if the a propertyReference is a type used in an event
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * u = utterances<Person>(["Hi {name}"])
     * personInfo = expect(Invoke, u)
     * a = personInfo.name
     * ```
     * `a` is a property reference and it's from the event expr, thus should return true
     *
     */
    isPropertyReferenceFromEvent(value) {
        const rootExpr = this.getPropertyChainRootExpression(value);
        if (this.isNameReference(rootExpr)) {
            const rootExprValue = this.resolveNameReferenceToCall(rootExpr);
            if (rootExprValue !== undefined) {
                const rootExprValueApply = this.getApply(rootExprValue);
                // TODO: don't use hard code once know how to determine the type is from event
                if ((rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isExpect()) || (rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isUserSays())) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * determine if the a propertyReference is refer to api result
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * action Person getPerson()
     * person = getPerson()
     *
     *
     * a = person.name
     * ```
     * `a` is a property reference and it's refer to api result, thus should return true
     *
     */
    isPropertyReferenceFromApiInvocation(value) {
        const rootExpr = this.getPropertyChainRootExpression(value);
        if (this.isNameReference(rootExpr)) {
            const rootExprValue = this.resolveNameReferenceToCall(rootExpr);
            if (rootExprValue !== undefined) {
                const rootExprValueApply = this.getApply(rootExprValue);
                if (rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isUserDefinedApi()) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get all Nodes referenced by a source Node.
     *
     * @param source node to start the search from
     * @returns a set of all Nodes referenced by this
     */
    getReferences(source) {
        const checker = this;
        const references = new Set();
        visitEachChild(source, findReferences);
        return references;
        function findReferences(node) {
            var _a;
            const ref = (node === null || node === void 0 ? void 0 : node.kind) === "Type" ? node.declaration : node;
            if (node === undefined || ref === undefined || references.has(ref)) {
                return;
            }
            references.add(ref);
            if (node.kind === "Call") {
                const apply = checker.getApply(node);
                // findReferences(apply?.decl);
                const decl = (apply === null || apply === void 0 ? void 0 : apply.decl.kind) === "Type" ? apply.decl.declaration : apply === null || apply === void 0 ? void 0 : apply.decl;
                if (decl) {
                    findReferences(decl);
                }
                visitEachChild(node, findReferences);
            }
            else if (node.kind === "NameReference") {
                findReferences(checker.lookupNameReference(node));
            }
            else if (node.kind === "Type") {
                (_a = node.getReferences()) === null || _a === void 0 ? void 0 : _a.forEach((ref) => references.add(ref));
            }
            else {
                visitEachChild(node, findReferences);
            }
            return false;
        }
    }
    /**
     * Get all response call used in a module.
     *
     * @param module module where to retrieve the responses
     * @returns a set of all responses
     */
    getResponseInfosInModule(module) {
        if (module === undefined) {
            return [];
        }
        const checker = this;
        return collectArray(module, findResponses);
        function findResponses(node) {
            if (node === undefined) {
                return [];
            }
            if (node.kind === "Call") {
                const apply = checker.getApply(node);
                if ((apply === null || apply === void 0 ? void 0 : apply.isResponse()) || (apply === null || apply === void 0 ? void 0 : apply.isConfirmAction()) || (apply === null || apply === void 0 ? void 0 : apply.isConfirmArgs()) || (apply === null || apply === void 0 ? void 0 : apply.isEnsure())) {
                    return [...apply.getResponseInfo()];
                }
            }
            return collectArray(node, findResponses);
        }
    }
    /**
     * Find the very beginning expr of property chain
     *
     * ```
     * a.b.c => a
     * a().b.c => a()
     * com.api.a.b.c => com.api.a
     * ```
     */
    getPropertyChainRootExpression(propertyRef) {
        let temp = propertyRef;
        while ((temp === null || temp === void 0 ? void 0 : temp.kind) === "PropertyReference") {
            const fullName = ask.PropertyReference.tryResolveQualifiedName(temp);
            if (fullName !== undefined && this.lookupQualifiedName(fullName) !== undefined) {
                return temp;
            }
            temp = temp.expression;
        }
        return temp;
    }
    /**
     * check whether the node is a nameReference
     *
     * 1. if node is of "NameReference" Type, then it's a nameReference
     * 2. if node is of "PropertyReference", then check whether it's QFN point to a node. E.G. test.getPerson,
     *    "test" is a namespace, thus this should also be treated as nameReference
     */
    isNameReference(node) {
        if (node === undefined) {
            return false;
        }
        if (node.kind === "NameReference") {
            return true;
        }
        if (node.kind === "PropertyReference") {
            const fqn = ask.PropertyReference.tryResolveQualifiedName(node);
            if (this.lookupQualifiedName(fqn) !== undefined) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get all NameDeclarations under module scope
     */
    getAllModuleScopeNameDeclarations() {
        const nameDecls = [];
        this.global.scope.forEach((value) => {
            if (value) {
                if (Array.isArray(value)) {
                    value.forEach((node) => {
                        if (node.kind === "NameDeclaration") {
                            nameDecls.push(node);
                        }
                    });
                }
                else if (value.kind === "NameDeclaration") {
                    nameDecls.push(value);
                }
            }
        });
        return nameDecls;
    }
    /**
     * collect locale info based on input
     *
     * E.G.
     * 1. when input is a nameDecl
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     *
     * collectLocaleInfo(myWelcome) => ['en_US']
     * ```
     *
     * 2. when input is a nameReference
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(temp) => ['en_US']
     * ```
     *
     * 3. when input is a propertyReference
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(test.temp) => ['en_US']
     *
     * 4. when input is variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeEN = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeGB)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB']
     *
     * 5. when input is nested variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeUS = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcomeEN = variations(myWelcomeEN, myWelcomeGB)
     *
     * @locale(Locale.ja_JP)
     * myWelcomeJP = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeJP)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB', 'en_JP']
     */
    collectLocaleInfo(input) {
        var _a, _b, _c, _d, _e, _f, _g;
        const locales = [];
        // handle variations action call
        if (input.kind === "Call") {
            const apply = this.getApply(input);
            if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                const argumentValueThing = apply.getArgumentValueThing("variations");
                if (argumentValueThing === null || argumentValueThing === void 0 ? void 0 : argumentValueThing.isList()) {
                    const items = argumentValueThing.getListItems();
                    items === null || items === void 0 ? void 0 : items.forEach((item) => {
                        var _a, _b;
                        if (((_a = item === null || item === void 0 ? void 0 : item.item) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = item === null || item === void 0 ? void 0 : item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                            locales.push(...this.collectLocaleInfo(item.item));
                        }
                    });
                }
            }
            return locales;
        }
        // handle nameDecl
        if (ask.isNameDeclaration(input)) {
            if (((_a = input.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
                const apply = this.getApply(input.expression);
                if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                    return this.collectLocaleInfo(input.expression);
                }
                else if (((_c = (_b = input.expression) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === "MultiModalResponse") {
                    const apla = apply === null || apply === void 0 ? void 0 : apply.getArgumentValue("apla");
                    const apl = apply === null || apply === void 0 ? void 0 : apply.getArgumentValue("apl");
                    return [...getArgumentValueLocales(apla, this), ...getArgumentValueLocales(apl, this)];
                }
            }
            (_d = input.annotations) === null || _d === void 0 ? void 0 : _d.forEach((annotation) => {
                if (annotation.kind === "Annotation" && annotation.call && annotation.call.kind === "Call") {
                    const apply = this.getApply(annotation.call);
                    if (apply !== undefined && apply.isLocaleAction()) {
                        const localeValueThing = apply.getArgumentValueThing("locales");
                        if (localeValueThing === null || localeValueThing === void 0 ? void 0 : localeValueThing.isList()) {
                            const items = localeValueThing.getListItems();
                            items === null || items === void 0 ? void 0 : items.forEach((item) => {
                                var _a, _b, _c;
                                if (ask.isPropRef(item === null || item === void 0 ? void 0 : item.item) && ((_b = (_a = item === null || item === void 0 ? void 0 : item.item.expression) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === "Locale" && ((_c = item.item.name) === null || _c === void 0 ? void 0 : _c.name)) {
                                    locales.push(item.item.name.name);
                                }
                            });
                        }
                    }
                }
            });
        }
        // handle nameReference and propertyReference
        if (input.kind === "NameReference" || input.kind === "PropertyReference") {
            const thing = this.getThing(input);
            if (ask.isNameDeclaration((_e = thing === null || thing === void 0 ? void 0 : thing.origin) === null || _e === void 0 ? void 0 : _e.context)) {
                return this.collectLocaleInfo((_f = thing === null || thing === void 0 ? void 0 : thing.origin) === null || _f === void 0 ? void 0 : _f.context);
            }
            if (thing === null || thing === void 0 ? void 0 : thing.isObject()) {
                return (_g = thing.getLocales()) !== null && _g !== void 0 ? _g : [];
            }
        }
        return locales;
        function getArgumentValueLocales(value, checker) {
            if ((value && checker.isNameReference(value)) || ask.isNameDeclaration(value)) {
                return checker.collectLocaleInfo(value);
            }
            return [];
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGVja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxTQUFTLE1BQU0sV0FBVyxDQUFDO0FBQ3ZDLE9BQU8sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDO0FBRTdCLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDOUIsT0FBTyxFQUFDLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQWlCLE1BQU0sT0FBTyxDQUFDO0FBQ2pGLE9BQU8sRUFBQyxhQUFhLEVBQVMsTUFBTSxVQUFVLENBQUM7QUFDL0MsT0FBTyxFQUFDLG1CQUFtQixFQUFFLGlCQUFpQixFQUFnQixpQkFBaUIsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRXhHLE9BQU8sRUFBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFDLE1BQU0sUUFBUSxDQUFDO0FBRzdGLE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDNUIsd0dBQXdHO0FBQ3hHLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDL0IsT0FBTyxFQUFDLGNBQWMsRUFBRSxZQUFZLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFckQsT0FBTyxFQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFTLFVBQVUsRUFBRSxTQUFTLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDN0YsT0FBTyxFQUFRLE1BQU0sRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUV0QyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFFVjs7R0FFRztBQUNILE1BQU0sT0FBTyxXQUFXO0lBMER0QjtJQUNFOztPQUVHO0lBQ2EsT0FBZ0I7SUFDaEM7O09BRUc7SUFDYSxJQUFrQjtJQUNsQzs7T0FFRztJQUNILE1BQThDO0lBQzlDOztPQUVHO0lBQ00sS0FBcUQ7Ozs7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