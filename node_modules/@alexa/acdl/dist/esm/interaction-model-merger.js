function toMap(items, keySelector) {
    const result = {};
    for (const item of items) {
        result[keySelector(item)] = item;
    }
    return result;
}
function mergeStrings(first, second) {
    return first !== undefined || second !== undefined ? [...new Set([...(first !== null && first !== void 0 ? first : []), ...(second !== null && second !== void 0 ? second : [])]).values()] : undefined;
}
export function mergeArrays(first, second, itemMerger) {
    const result = [];
    const firstByName = toMap(first, itemMerger.keySelector);
    const secondByName = toMap(second, itemMerger.keySelector);
    for (const firstItem of first) {
        const secondItem = secondByName[itemMerger.keySelector(firstItem)];
        if (secondItem === undefined) {
            result.push(firstItem);
        }
        else {
            try {
                result.push(itemMerger.merge(firstItem, secondItem));
            }
            catch (e) {
                itemMerger.handleError(firstItem, secondItem, e);
            }
        }
    }
    for (const secondItem of second) {
        const firstItem = firstByName[itemMerger.keySelector(secondItem)];
        if (firstItem === undefined) {
            result.push(secondItem);
        }
    }
    return result;
}
/**
 * Merges intents.
 */
class IntentMerger {
    constructor(intentSlotMerger) {
        Object.defineProperty(this, "intentSlotMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: intentSlotMerger
        });
    }
    keySelector(item) {
        return item.name;
    }
    merge(first, second) {
        var _a, _b;
        const samples = mergeStrings(first.samples, second.samples);
        return {
            ...first,
            slots: mergeArrays((_a = first.slots) !== null && _a !== void 0 ? _a : [], (_b = second.slots) !== null && _b !== void 0 ? _b : [], this.intentSlotMerger),
            ...(samples ? { samples } : {}),
        };
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge intent '${first.name}': ${err.message}`);
    }
}
/**
 * Merges intent slots.
 */
export class IntentSlotMerger {
    keySelector(item) {
        return item.name;
    }
    merge(first, second) {
        if (first.type === second.type) {
            const samples = mergeStrings(first.samples, second.samples);
            return {
                ...first,
                ...(samples ? { samples } : {}),
            };
        }
        else {
            throw new Error(`Intent slot type differs: '${first.type}' != '${second.type}'`);
        }
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge intent slot '${first.name}': ${err.message}`);
    }
}
/**
 * Merges slot type values.
 */
export class SlotTypeValueMerger {
    keySelector(item) {
        return item.name.value;
    }
    merge(first, second) {
        var _a;
        if (first.id !== second.id) {
            throw new Error(`Slot type value identifier differs: ${first.id} != ${second.id}`);
        }
        const synonyms = (_a = mergeStrings(first.name.synonyms, second.name.synonyms)) !== null && _a !== void 0 ? _a : [];
        return {
            ...first,
            name: {
                ...first.name,
                ...(synonyms ? { synonyms } : {}),
            },
        };
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge slot type value '${first.name.value}': ${err.message}`);
    }
}
/**
 * Merges slot types.
 */
export class SlotTypeMerger {
    constructor(slotTypeValueMerger) {
        Object.defineProperty(this, "slotTypeValueMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: slotTypeValueMerger
        });
    }
    keySelector(item) {
        return item.name;
    }
    merge(first, second) {
        var _a, _b;
        if (!first.valueSupplier && !second.valueSupplier) {
            return {
                ...first,
                values: mergeArrays((_a = first.values) !== null && _a !== void 0 ? _a : [], (_b = second.values) !== null && _b !== void 0 ? _b : [], this.slotTypeValueMerger),
            };
        }
        else {
            throw new Error(`Slot type already exists with different value supplier.`);
        }
    }
    handleError(first, _second, err) {
        throw new Error(`Failed to merge slot type '${first.name}': ${err.message}`);
    }
}
Object.defineProperty(SlotTypeMerger, "INSTANCE", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new SlotTypeMerger(new SlotTypeValueMerger())
});
/**
 * Merges two interaction models into one (the second one into the first one).
 *
 * Takes all fields from the first interaction model, except for these which are combined together
 * - `intents`
 *   - `slots` - fails if they differ in `type`
 *     - `samples` - union of both samples
 *   - `samples` - union of both samples
 * - `types` - fails if they differ in `valueSupplier`
 *   - `values` - fails if they differ in `id`
 *     - `synonyms` - union of both synonyms
 *
 * ~~~
 * {
 *   interactionModel: {
 *     languageModel: {
 *       intents: [
 *         {
 *           name: 'intentName',
 *           slots: [
 *             {
 *               name: 'slotName',
 *               samples: [...]
 *             }
 *           ]
 *           samples: [...]
 *         }, ...
 *       ]
 *       types: [
 *         {
 *           name: 'typeName'
 *           values: [
 *             {
 *               name: {
 *                 value: 'valueName',
 *                 synonyms: [...]
 *               }
 *             }
 *           ]
 *         }, ...
 *       ]
 *     }
 *   }
 * }
 * ~~~
 *
 * Intents are merged from both models. If same intent is defined in both models, their slots and samples are merged.
 * If the intent slot types do not match, an error will be raised.
 *
 * Slot types are merged from both models. If same slot type is defined in both models, an error will be raised.
 *
 * Note: The code should be written in a way that when new fields are added, they are preserved.
 */
export class InteractionModelMerger {
    constructor(intentMerger, slotTypeMerger) {
        Object.defineProperty(this, "intentMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: intentMerger
        });
        Object.defineProperty(this, "slotTypeMerger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: slotTypeMerger
        });
    }
    /**
     * Merges two interaction models into one (the second one into the first one).
     *
     * @param first First interaction model data.
     * @param second Second interaction model data.
     * @returns The merged interaction model.
     */
    mergeInteractionModels(first, second) {
        return {
            ...first,
            interactionModel: this.mergeInteractionModelSchemas(first.interactionModel, second.interactionModel),
        };
    }
    mergeInteractionModelSchemas(first, second) {
        return {
            ...first,
            languageModel: this.mergeLanguageModels(first.languageModel, second.languageModel),
        };
    }
    mergeLanguageModels(first, second) {
        var _a, _b;
        const types = first.types !== undefined || second.types !== undefined
            ? mergeArrays((_a = first.types) !== null && _a !== void 0 ? _a : [], (_b = second.types) !== null && _b !== void 0 ? _b : [], this.slotTypeMerger)
            : undefined;
        return {
            ...first,
            intents: mergeArrays(first.intents, second.intents, this.intentMerger),
            ...(types ? { types } : {}),
        };
    }
}
Object.defineProperty(InteractionModelMerger, "INSTANCE", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new InteractionModelMerger(new IntentMerger(new IntentSlotMerger()), SlotTypeMerger.INSTANCE)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJhY3Rpb24tbW9kZWwtbWVyZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVyYWN0aW9uLW1vZGVsLW1lcmdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxTQUFTLEtBQUssQ0FBSSxLQUFVLEVBQUUsV0FBZ0M7SUFDNUQsTUFBTSxNQUFNLEdBQXNCLEVBQUUsQ0FBQztJQUVyQyxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtRQUN4QixNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQ2xDO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEtBQTJCLEVBQUUsTUFBNEI7SUFDN0UsT0FBTyxLQUFLLEtBQUssU0FBUyxJQUFJLE1BQU0sS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLGFBQUwsS0FBSyxjQUFMLEtBQUssR0FBSSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUNoSSxDQUFDO0FBUUQsTUFBTSxVQUFVLFdBQVcsQ0FBSSxLQUFVLEVBQUUsTUFBVyxFQUFFLFVBQXlCO0lBQy9FLE1BQU0sTUFBTSxHQUFRLEVBQUUsQ0FBQztJQUN2QixNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN6RCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUUzRCxLQUFLLE1BQU0sU0FBUyxJQUFJLEtBQUssRUFBRTtRQUM3QixNQUFNLFVB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