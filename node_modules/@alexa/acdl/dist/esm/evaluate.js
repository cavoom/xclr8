import * as ask from "./ast";
import { AlexaConversations } from "./ast";
import { typeError } from "./error";
import { getExpressionIfLocField, ValidationErrorFactory } from "./error-factory";
import { getName } from "./util";
/**
 * Validates that the Dialog is deployable. A deployable dialog is one that accepts no arguments and returns `Nothing` or `Void`.
 */
export function evaluateDialogFlow(flow, state) {
    // TODO: validate that it does not accept arguments
    var _a, _b;
    return [
        evaluateFlow(flow, state).map((state) => state.errors),
        (_b = (_a = flow.expression.samples) === null || _a === void 0 ? void 0 : _a.map((sample) => validateSampleStartWithInvoke(flow.step(sample), state))) !== null && _b !== void 0 ? _b : [],
    ].flat(2);
}
/**
 * Validates that the data flow is correct.
 *
 * @param node
 * @param flow
 * @returns
 */
export function evaluateFlow(flow, state) {
    return flow.interpret(function evaluate(expr, nextState = state) {
        if (expr.isEnd()) {
            return evaluateEnd(expr, nextState.pushExpr(expr));
        }
        nextState = evaluateExpression(expr, nextState).pushExpr(expr);
        if (nextState.isCircular) {
            // detected a circular reference, stop execution.
            return nextState;
        }
        return (next) => evaluate(next, nextState);
    }, undefined);
}
export function evaluateExpression(expr, state) {
    if (!expr.isStart() && !expr.canFollowDelegation()) {
        state = state.withError(...validatePriorDelegation(expr));
    }
    if (expr.isExpect()) {
        return evaluateExpect(expr, state);
    }
    if (expr.isResponse()) {
        return evaluateResponse(expr, state);
    }
    if (expr.isConfirmAction()) {
        return evaluateConfirmAction(expr, state);
    }
    if (expr.isConfirmArgs()) {
        return evaluateConfirmArgs(expr, state);
    }
    if (expr.isEnsure()) {
        return evaluateEnsure(expr, state);
    }
    if (expr.isInvokeApi()) {
        return evaluateInvokeApi(expr, state);
    }
    if (expr.isConditionalBranch()) {
        return evaluateConditionalBranch(expr, state);
    }
    if (expr.isDelegateRequest()) {
        return evaluateDelegateRequest(expr, state);
    }
    if (expr.isDelegateToIntent()) {
        return evaluateDelegateToIntent(expr, state);
    }
    if (expr.isDialogExpansion()) {
        return evaluateDialogExpansion(expr, state);
    }
    return state;
}
/**
 * Called at the end of a single dialog flow. During evaluation, we often delay validation until
 * the end as an optimization. For example, checking if an argument is requested - if the ensure()
 * block is called later on in the dialog flow, we don't want to be searching forward all the time
 * because searching forward is slow. Instead, we track that in {@link EvaluationState} and then
 * perform the validation here. This reduces the time complexity significantly.
 */
export function evaluateEnd(endExpr, state) {
    return state.withError(...validateLastExpressionEndsTurn(), ...evaluatePendingRequestPromptValidations());
    function isFlowExpressionTerminal(flow) {
        var _a;
        if (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
            const apply = flow.checker.getApply(flow === null || flow === void 0 ? void 0 : flow.expression);
            return (apply === null || apply === void 0 ? void 0 : apply.isResponse()) || (apply === null || apply === void 0 ? void 0 : apply.isDelegateToIntent()) || (apply === null || apply === void 0 ? void 0 : apply.isDelegateRequest());
        }
        return false;
    }
    // Validates the last expression in a sample is a response call or a return value from a reusable
    // dialog, or a delegate request.
    function validateLastExpressionEndsTurn() {
        var _a, _b;
        // The last flow containing an expression in the dialog sample
        const lastFlow = endExpr.flow.prev;
        if (isFlowExpressionTerminal(lastFlow)) {
            return [];
        }
        const isLastExprFromDialogCall = isFlowFromDialogCall(lastFlow);
        // Handle when a sample ends with a name reference and not a response call, in which case
        // we need to ensure the name reference is from a reusable dialog call that ends with response call/return value.
        if (((_a = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" && isLastExprFromDialogCall) {
            // The flow containing the second to last expression in the dialog sample
            let prevFlow = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.prev;
            // Go up the flow stack until we hit the previous expression
            while (((_b = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.expression) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                prevFlow = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.prev;
            }
            if (isFlowExpressionTerminal(prevFlow)) {
                return [];
            }
        }
        const errorFactory = isLastExprFromDialogCall
            ? ValidationErrorFactory.InvalidLastExpressionInSampleFromDialogCall
            : ValidationErrorFactory.InvalidLastExpressionInSample;
        return [errorFactory({ expr: lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression })];
    }
    /**
     * Under the right conditions produces one error message for each string in paths
     * @param expr API with error
     * @param argument argument that gave origin to the paths
     * @param paths paths where an error should be produced
     * @returns the errors for the paths
     */
    function getPendingRequestValidationError(expr, argument, paths) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        if (expr.isInvokeApi()) {
            if (argument.argumentName !== undefined) {
                const argValue = (_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue(argument);
                return paths.map((path) => {
                    var _a;
                    return ValidationErrorFactory.MissingRequestPromptForRequiredApiArgument({
                        expr: argValue,
                        attributes: { argumentName: path, actionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName },
                    });
                });
            }
            else {
                return [];
            }
        }
        else if (expr.isEnsure() || expr.isConfirmArgs()) {
            const errors = [];
            const requestArgs = expr.isEnsure() ? expr.requestArgs : expr.confirmArgs;
            if (requestArgs !== undefined) {
                const items = requestArgs.getItems();
                if (items !== undefined) {
                    for (let requestArgumentsIndex = 0; requestArgumentsIndex < items.length; requestArgumentsIndex++) {
                        const requestArg = items[requestArgumentsIndex];
                        const args = (_b = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValueThing("arguments");
                        const argsNode = (_c = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("arguments");
                        if ((args === null || args === void 0 ? void 0 : args.isLiteral()) && args.isList()) {
                            const argsList = args.getItems();
                            if (argsList !== undefined) {
                                for (let argIndex = 0; argIndex < argsList.length; argIndex++) {
                                    const thisArg = argsList[argIndex];
                                    if (thisArg === argument) {
                                        const requestArgsNode = (_d = expr.apply) === null || _d === void 0 ? void 0 : _d.getArgumentValue(expr.isEnsure() ? "requestArgs" : "confirmArgs");
                                        let loc = expr.loc; // default to the entire `ensure` block
                                        loc = (_e = requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.loc) !== null && _e !== void 0 ? _e : loc;
                                        if ((requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.kind) === "Call" && ask.isListLiteral(requestArgsNode.arguments)) {
                                            // in-lined list, `ensure(RequestArguments { .. }, RequestArguments { .. }, ..)`
                                            const requestArgNode = requestArgsNode.arguments.items[requestArgumentsIndex].item;
                                            loc = (_f = requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.loc) !== null && _f !== void 0 ? _f : loc;
                                            if ((requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.kind) === "Call") {
                                                // this is the RequestArguments { .. } node, it is still inline so let's try and make the error even more granular
                                                loc = (_g = argsNode === null || argsNode === void 0 ? void 0 : argsNode.loc) !== null && _g !== void 0 ? _g : loc;
                                                if ((argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                                                    loc = (_h = argsNode.arguments.items[argIndex].item) === null || _h === void 0 ? void 0 : _h.loc;
                                                }
                                            }
                                        }
                                        errors.push(...paths.map((path) => {
                                            const errorArgument = {
                                                expr: { loc: loc !== null && loc !== void 0 ? loc : expr.loc, uri: expr.uri },
                                                attributes: {
                                                    argumentName: path,
                                                },
                                            };
                                            return expr.isEnsure()
                                                ? ValidationErrorFactory.MissingRequestPromptForMultipleArguments(errorArgument)
                                                : ValidationErrorFactory.MissingRequestPromptForConfirmArgs(errorArgument);
                                        }));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return errors;
        }
        else {
            // do our best to resolve the location of the argument missing the request prompt
            let loc = (_k = (_j = expr.actNode) === null || _j === void 0 ? void 0 : _j.loc) !== null && _k !== void 0 ? _k : expr.loc;
            // options:
            // response(Request { arguments = [ Foo.arguments.arg ] })
            // response(Request { arguments = nameRef })
            // response(nameRef)
            if (((_l = expr.actNode) === null || _l === void 0 ? void 0 : _l.kind) === "Call") {
                const argsNode = (_o = (_m = expr.act) === null || _m === void 0 ? void 0 : _m.apply) === null || _o === void 0 ? void 0 : _o.getArgumentValue("arguments");
                const args = (_s = (_r = (_q = (_p = expr.act) === null || _p === void 0 ? void 0 : _p.apply) === null || _q === void 0 ? void 0 : _q.getArgumentValueThing("arguments")) === null || _r === void 0 ? void 0 : _r.asLiteralList()) === null || _s === void 0 ? void 0 : _s.getItems();
                if (args !== undefined && (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                    for (const [i, arg] of args.entries()) {
                        if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && arg === argument) {
                            loc = (_u = (_t = argsNode.arguments) === null || _t === void 0 ? void 0 : _t.items) === null || _u === void 0 ? void 0 : _u[i].loc;
                            break;
                        }
                    }
                }
            }
            let errorExpr = getExpressionIfLocField(expr.actNode, expr);
            if ((_w = (_v = expr.act) === null || _v === void 0 ? void 0 : _v.apply) === null || _w === void 0 ? void 0 : _w.isConfirmArgsAct()) {
                return paths.map((path) => ValidationErrorFactory.MissingRequestPromptForConfirmArgs({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            else if (((_y = (_x = expr.act) === null || _x === void 0 ? void 0 : _x.apply) === null || _y === void 0 ? void 0 : _y.isRequestArguments()) || ((_0 = (_z = expr.act) === null || _z === void 0 ? void 0 : _z.apply) === null || _0 === void 0 ? void 0 : _0.isRequestAct())) {
                return paths.map((path) => ValidationErrorFactory.MissingRequestPromptForMultipleArguments({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            return [];
        }
    }
    function evaluatePendingRequestPromptValidations() {
        const returnValue = [];
        const pendingRequests = Array.from(state.pendingRequestPromptValidation.entries());
        for (const [api, argumentsMap] of pendingRequests) {
            const sortedArgumentsAndPaths = Array.from(argumentsMap.entries())
                .map((argumentAndSet) => ({ argument: argumentAndSet[0], paths: Array.from(argumentAndSet[1]) }))
                .sort((a, b) => a.argument.argumentName.localeCompare(b.argument.argumentName));
            for (const argumentAndPaths of sortedArgumentsAndPaths) {
                returnValue.push(...getPendingRequestValidationError(api, argumentAndPaths.argument, argumentAndPaths.paths));
            }
        }
        return returnValue;
    }
}
export function evaluateDialogExpansion(expr, state) {
    var _a, _b, _c;
    if (state.hasExpandedDialog(expr)) {
        const apply = expr.apply;
        for (const node of expr.flow.stack) {
            if (node.kind === "Call") {
                const prevApply = expr.flow.checker.getApply(node);
                if (apply.getName() === (prevApply === null || prevApply === void 0 ? void 0 : prevApply.getName())) {
                    const validationErrorExpr = getExpressionIfLocField((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call);
                    return state.withCircular(true).withError(apply.decl.kind === "DialogDeclaration"
                        ? ValidationErrorFactory.CircularReferenceDialog({
                            expr: validationErrorExpr,
                            attributes: {
                                dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                            },
                        })
                        : ValidationErrorFactory.CircularReferenceName({
                            expr: validationErrorExpr,
                            attributes: {
                                name: (_c = apply.decl.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }), ...collectCallStackErrors(expr.flow));
                }
            }
        }
    }
    return state;
}
function collectCallStackErrors(flow) {
    var _a, _b;
    if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
        return [];
    }
    if (flow.expression.kind === "Call") {
        const apply = flow.checker.getApply(flow.expression);
        if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
            return [
                ValidationErrorFactory.CircularReferenceDialog({
                    expr: getExpressionIfLocField((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call),
                    attributes: {
                        dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
                ...flow.visitPrevious(collectCallStackErrors),
            ];
        }
    }
    return flow.visitPrevious(collectCallStackErrors);
}
/**
 * Validate the prior lines to expect.
 *
 * 1. `Invoke` must be first event or follow response with `Request`, `Notify`, `Offer`, `ReqMore`, or `ReqAlt` Acts. TODO: we must verify if it is valid to follow `Request` - our tests used this case but it is documented as invalid.
 * 2. `Affirm` or `Deny` must follow response with `ConfirmArgs`, `ConfirmAction`, `Offer` Acts or `confirmAction`.
 * 3. `Inform` must follow response with `Request` or `ReqAlt` Acts.
 *
 * @param expect expect being evaluated
 * @param expectActType expect's actType
 * @param expectActValue expect's act argument value from expect.apply?.getArgumentValue("act")
 * @param stateExpressionStack expression stack from the state
 * @returns errors from lines prior tp expect
 */
function validateEventPriorToExpect(expect, expectActType, expectActValue, stateExpressionStack) {
    var _a, _b;
    if (!expectActType) {
        return [];
    }
    for (const expr of stateExpressionStack) {
        if (expr.isInvokeApi() || expr.isExpect()) {
            const errorArguments = {
                expr: expectActValue,
                attributes: {
                    requestAct: expectActType.toString(expectActValue),
                },
            };
            if (expectActType.isInvoke()) {
                // TODO: verify if Invoke can follow 'Request' act.
                return [ValidationErrorFactory.InvalidEventInvoke(errorArguments)];
            }
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [ValidationErrorFactory.InvalidEventAffirmOrDeny(errorArguments)];
            }
            if (expectActType.isInform()) {
                return [ValidationErrorFactory.InvalidEventInform(errorArguments)];
            }
            // catch all, we should never reach here since we first validate that expectActType is Invoke, Inform, Affirm or Deny
            return [ValidationErrorFactory.InvalidEvent(errorArguments)];
        }
        if (expr.isEnsure() || expr.isDialogExpansion() || expr.isConfirmArgs() || expr.isBlock() || expr.isConditionalBranch()) {
            // ignore these calls since they do not affect the user/alexa lines.
            // TODO: why ignore ConfirmArgs?
            // return [];
        }
        else if (expr.isConfirmAction()) {
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [];
            }
            return [
                ValidationErrorFactory.InvalidEventFollowingConfirmAction({
                    expr: expectActValue,
                    attributes: {
                        requestAct: expectActType.toString(expect.node),
                    },
                }),
            ];
        }
        else if (expr.isDelegateToIntent() || expr.isDelegateRequest()) {
            return [];
        }
        else if (expr.isResponse()) {
            const nextRequestActType = (_a = expr.nextAct) === null || _a === void 0 ? void 0 : _a.type;
            let requestActType = (_b = expr.act) === null || _b === void 0 ? void 0 : _b.type;
            if (nextRequestActType && !(nextRequestActType.isNothing() || nextRequestActType.isVoid())) {
                requestActType = nextRequestActType;
            }
            if (requestActType === undefined) {
                // could not resolve the request act, so ignore these validations
                return [];
            }
            if (requestActType.isOffer()) {
                // all dialog acts can follow Offer
                return [];
            }
            if (requestActType.isConfirmArgs() || requestActType.isConfirmAction()) {
                if (expectActType.isAffirm() || expectActType.isDeny()) {
                    return [];
                }
                return [invalidEventError("Affirm", "Deny")];
            }
            if (requestActType.isNotify() || requestActType.isReqMore() || requestActType.isBye()) {
                if (expectActType.isInvoke()) {
                    return [];
                }
                return [invalidEventError("Invoke")];
            }
            if (requestActType.isReqAlt()) {
                if (expectActType.isInvoke() || expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Invoke", "Inform")];
            }
            if (requestActType.isRequest()) {
                if (expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Inform")];
            }
            function invalidEventError(...expected) {
                const suggestions = expected.length === 1
                    ? `'${expected[0]}'`
                    : `${expected
                        .slice(0, expected.length - 1)
                        .map((e) => `'${e}'`)
                        .join(", ")} or '${expected[expected.length - 1]}'`;
                return ValidationErrorFactory.InvalidEventResponse({
                    expr: getExpressionIfLocField(expectActValue, expect),
                    attributes: {
                        responseAct: expectActType === null || expectActType === void 0 ? void 0 : expectActType.toString(expect.node),
                        requestAct: requestActType === null || requestActType === void 0 ? void 0 : requestActType.toString(expect.node),
                        suggestions,
                    },
                });
            }
        }
    }
    if (expectActType.isInvoke()) {
        return [];
    }
    return [
        ValidationErrorFactory.InvalidFirstEvent({
            expr: expectActValue,
            attributes: {
                dialogAct: expectActType.toString(expect.node),
            },
        }),
    ];
}
/**
 * Called to perform Inform validations if the expect's act is inform
 * @param expect expect being evaluated
 * @returns errors for expect with Inform act
 */
function validateExpectInform(expect) {
    var _a, _b, _c;
    const errors = [];
    // Each sample sentence in "inform" event should contain at least one slot.
    const eventValue = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("event");
    if (!expect.checker.isNameReference(eventValue)) {
        // this case should already be caught by other validation
        return errors;
    }
    const nameDecl = expect.checker.resolveNameReference(eventValue);
    if (ask.isCall(nameDecl)) {
        const apply = expect.checker.getApply(nameDecl);
        if ((apply === null || apply === void 0 ? void 0 : apply.getName()) === AlexaConversations.utterances) {
            let items = [];
            const value = apply.getArgumentValue("samples");
            if (expect.checker.isNameReference(value)) {
                const found = expect.checker.resolveNameReference(value);
                const foundType = expect.checker.getType(value);
                if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                    items = found.arguments.items;
                }
            }
            else if ((value === null || value === void 0 ? void 0 : value.kind) === "Call" && ask.isListLiteral(value.arguments)) {
                items = value.arguments.items;
            }
            for (const item of items) {
                if (item.item === undefined || item.item.kind !== "Call") {
                    // do nothing, because this case should already be caught by other validation
                }
                else if (typeof item.item.arguments === "string" ||
                    (ask.isUtterance(item.item.arguments) && ((_b = item.item.arguments.names) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
                    errors.push(ValidationErrorFactory.InformUtteranceSampleMissingSlot({
                        expr: getExpressionIfLocField((_c = expect.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("event"), expect),
                    }));
                    // only report this error once
                    break;
                }
            }
        }
    }
    return errors;
}
export const evaluateExpect = (expect, state) => {
    var _a, _b, _c, _d, _e, _f;
    // for expect action, the RequestAct could only be Invoke, Inform, Affirm or Deny
    const value = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act");
    const actType = expect.getActType();
    if (actType === undefined) {
        // don't do anything when type is undefined as it should be caught by another validator
        return state;
    }
    if (!expect.isInvoke() && !expect.isInform() && !expect.isAffirm() && !expect.isDeny()) {
        return state.withError(ValidationErrorFactory.InvalidRequestAct({
            expr: value,
            attributes: { actName: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
        }));
    }
    if ((actType.isAffirm() || actType.isDeny()) && ((_c = (_b = expect.event) === null || _b === void 0 ? void 0 : _b.apply) === null || _c === void 0 ? void 0 : _c.isUtterances())) {
        const utteranceType = (_f = (_e = (_d = expect.event) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getReturnType()) === null || _f === void 0 ? void 0 : _f.getUtteranceEventType();
        if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isNothing()) && !(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isThing())) {
            return state.withError(ValidationErrorFactory.ExpectedEmptyRequestActType({
                expr: value,
                attributes: { typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName, actType: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
            }));
        }
        if (actType.isDeny()) {
            // resets pending offer if action is not affirmed
            state = state.clearPendingOffer();
        }
    }
    const eventErrors = validateEventPriorToExpect(expect, actType, value, state.expressionStack);
    if (actType.isInform()) {
        return state.withError(...eventErrors, ...validateExpectInform(expect));
    }
    return state.withError(...eventErrors);
};
/**
 * Validate DelegateRequest action used in dialog sample.
 *
 * - `delegateRequest`'s cannot be chained together.
 * - slots must come from an event or api call, optionally wrapped in a complex object.
 */
export const evaluateDelegateRequest = (requestExpression, state) => {
    var _a, _b, _c, _d;
    const errors = [];
    if ((_b = (_a = requestExpression.updatedRequest) === null || _a === void 0 ? void 0 : _a.apply) === null || _b === void 0 ? void 0 : _b.isIntentRequest()) {
        const slots = ((_c = requestExpression.updatedRequest) === null || _c === void 0 ? void 0 : _c.isObject()) ? requestExpression.updatedRequest.getProperty("slots") : undefined;
        const genericArguments = (_d = requestExpression.updatedRequest.type.genericArguments) !== null && _d !== void 0 ? _d : [];
        const expectedSlotsType = genericArguments[0];
        evaluateUpdatedIntentRequest(requestExpression, expectedSlotsType, slots, errors);
    }
    return state.withError(...errors);
};
/**
 * Validate DelegateToIntent action used in dialog sample.
 *
 * - `delegateToIntent`'s cannot be chained together.
 * - slots must come from an event or api call, optionally wrapped in a complex object.
 */
export const evaluateDelegateToIntent = (requestExpression, state) => {
    var _a;
    const errors = [];
    const genericArguments = (_a = requestExpression.apply.getGenericArguments()) !== null && _a !== void 0 ? _a : [];
    const expectedSlotsType = genericArguments[0];
    evaluateUpdatedIntentRequest(requestExpression, expectedSlotsType, requestExpression.slots, errors);
    return state.withError(...errors);
};
/**
 * Validate the slots of updated intent request passed to a delegation action.
 *
 * @param requestExpression Delegation action.
 * @param slots Value of slots to validate.
 * @param errors Mutable error list to append any errors found.
 */
const evaluateUpdatedIntentRequest = (requestExpression, expectedSlotsType, slots, errors) => {
    if (slots !== undefined && !slots.isNothing()) {
        const requestExpressionName = requestExpression.apply.getName();
        const callName = requestExpressionName ? getName(requestExpressionName) : undefined;
        if (expectedSlotsType === undefined || expectedSlotsType.isThing()) {
            errors.push(ValidationErrorFactory.InvalidDelegationArgumentType({
                expr: requestExpression,
                attributes: {
                    callName,
                },
            }));
        }
        if (!originatesFromApiOrEvent(slots)) {
            errors.push(ValidationErrorFactory.InvalidDelegationSlots({
                expr: requestExpression,
                attributes: {
                    callName,
                },
            }));
        }
    }
};
/**
 * Determines whether the thing values originate from API or event.
 * Complex objects and lists whose leaf values originate from API or event are also considered as valid.
 *
 * @param thing Thing to verify.
 * @param listAllowed Indicates whether lists are allowed. By default, lists are not allowed at top level.
 * @param allowedDepth Allowed depth of complex objects. By default, set to one to prevent nested complex objects.
 * @returns Whether the thing values originate from API or event.
 */
const originatesFromApiOrEvent = (thing, listAllowed = false, allowedDepth = 1) => {
    var _a, _b;
    // lists are not allowed at top level
    if (!listAllowed && ((_a = thing === null || thing === void 0 ? void 0 : thing.apply) === null || _a === void 0 ? void 0 : _a.isList())) {
        return false;
    }
    const originType = getOriginType(thing);
    // values coming from API or event are valid
    if (isFromOrigin(originType, "event", "api")) {
        return true;
    }
    // otherwise, it has to be either a complex object/list with values that originate from API or event
    if (!isFromOrigin(originType, "literal") || !(thing.isObject() || thing.isList())) {
        return false;
    }
    // in the first implementation, the complex objects within complex objects are not allowed (allowedDepth === 1)
    if (allowedDepth < 0 || (thing.isObject() && allowedDepth === 0)) {
        return false;
    }
    // for lists, all item values have to comply with same constraints
    if (thing.isList()) {
        const items = (_b = thing.asList()) === null || _b === void 0 ? void 0 : _b.getItems();
        if (items === undefined || items.length === 0) {
            return false;
        }
        for (const value of items) {
            // not sure when the item value can be undefined, so report an error in such case
            if (value === undefined) {
                return false;
            }
            // evaluate the value recursively with same allowed depth
            if (!originatesFromApiOrEvent(value, true, allowedDepth - 1)) {
                return false;
            }
        }
        return true;
    }
    // for complex objects, all field values have to comply with same constraints
    if (thing.isObject()) {
        const obj = thing.apply;
        if (obj === undefined) {
            return false;
        }
        for (const value of Object.values(obj.getArgumentsThing())) {
            // not sure when the field value can be undefined, so report an error in such case
            if (value === undefined) {
                return false;
            }
            // evaluate the value recursively with decreased allowed depth
            if (!originatesFromApiOrEvent(value, true, allowedDepth - 1)) {
                return false;
            }
        }
        return true;
    }
    return false;
};
/**
 * Validate Response action used in dialog sample
 * including specific validations to the four args (Response, ResponseAct, next ResponseAct, Payload)
 * and make sure those args are used in allowed combination
 */
export const evaluateResponse = (response, state) => validateResponseAct(response, state.withRequestedArguments(false, ...response.getIndividuallyRequestedArguments())).withError(
// 2. validations for the nextAct
...validateNextAct(response, state), 
// 3. validations for the payload
...validatePayload(response, state), 
// 4. validations for the prompt
...validatePrompt(response.apply), ...validatePriorResponseCall(response));
/**
 * Validate the act used in response action
 * 1. The act could only be one of valid ResponseAct: 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'
 * 2. ReqAlt cannot be the first act
 * 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
 * 4. for ConfirmArgs, make sure the payload property exist in argument list
 */
export const validateResponseAct = (response, state) => {
    var _a, _b;
    const { act } = response;
    const actNode = response.apply.getArgumentValue("act");
    if (act === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return state;
    }
    // 1. The act could only be one of valid ResponseAct
    if (!act.type.isResponseAct()) {
        state = state.withError(ValidationErrorFactory.InvalidDialogActArgument({
            expr: actNode,
            attributes: {
                dialogAct: act.type.toString(actNode),
            },
        }));
    }
    if (act.type.isConfirmAction()) {
        state = evaluateConfirmAction(response, state);
    }
    // 2. ReqAlt cannot be the first act
    if (act.type.isReqAlt()) {
        state = state.withError(ValidationErrorFactory.InvalidReqAltFirstAct({
            expr: actNode,
        }));
    }
    // 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
    if (act.isObject() && act.type.isConfirmArgs()) {
        const preErrorCount = state.errors.length;
        state = validateConfirmArgsAct(response, state);
        // 4. for ConfirmArgs, make sure the payload property exist in argument list
        if (preErrorCount === state.errors.length) {
            if (act.isObject()) {
                const args = act.getProperty("arguments");
                const nameSet = new Set();
                if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
                    args.apply.call.arguments.items.forEach((item) => {
                        var _a, _b, _c, _d, _e;
                        if (response.checker.isNameReference(item.item)) {
                            const nameDecl = response.checker.resolveNameReference(item.item);
                            if ((nameDecl === null || nameDecl === void 0 ? void 0 : nameDecl.kind) !== undefined && nameDecl.kind === "PropertyReference" && ((_a = nameDecl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined) {
                                nameSet.add(nameDecl.name.name);
                            }
                        }
                        else if (((_b = item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                            if (((_d = (_c = item.item) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) !== undefined) {
                                nameSet.add((_e = item.item) === null || _e === void 0 ? void 0 : _e.name.name);
                            }
                        }
                    });
                }
                const payloadValue = response.apply.getPayloadValue();
                if ((payloadValue === null || payloadValue === void 0 ? void 0 : payloadValue.kind) === "Call") {
                    const payloadApply = response.checker.getApply(payloadValue);
                    if (payloadApply !== undefined && payloadApply.call.arguments !== undefined && Array.isArray(payloadApply.call.arguments)) {
                        for (const args of payloadApply.call.arguments) {
                            const name = typeof args.name === "string" ? args.name : (_a = args.name) === null || _a === void 0 ? void 0 : _a.name;
                            if (name !== undefined) {
                                if (!nameSet.has(name)) {
                                    state = state.withError(ValidationErrorFactory.MismatchedConfirmArgsPayloadProperty({
                                        expr: payloadValue,
                                        attributes: {
                                            propertyName: name,
                                        },
                                    }));
                                }
                                else {
                                    nameSet.delete(name);
                                }
                            }
                        }
                        if (nameSet.size > 0) {
                            for (const name of nameSet) {
                                state = state.withError(ValidationErrorFactory.MissingConfirmedArgsInPayload({
                                    expr: payloadValue,
                                    attributes: {
                                        argumentName: name,
                                    },
                                }));
                            }
                        }
                    }
                }
            }
        }
    }
    // 4. OfferAct arguments should belong to the Offered actionName
    if (act.isObject() && act.type.isOffer()) {
        const offerActionName = act.getProperty("actionName");
        const offerArguments = act.getProperty("arguments");
        const offerArgumentsNode = act.apply.getArgumentValue("arguments");
        if (offerArguments === undefined || offerActionName === undefined || !offerActionName.isAction()) {
            if (offerActionName) {
                return addPendingOfferIfAction(act, state);
            }
            return state; // should not happen as actionName for Offer act is required
        }
        // return errors; // should not happen as the arguments for Offer act must be a List Call
        if (offerArguments.isList() && offerArguments.isLiteral()) {
            offerArguments.apply.call.arguments.items.forEach((arg, i) => {
                var _a, _b, _c, _d, _e;
                const argItem = response.checker.isNameReference(arg.item)
                    ? response.checker.resolveNameReference(arg.item)
                    : arg.item;
                if (!ask.isPropRef(argItem)) {
                    return; // TODO: check if "Call" can be assigned to argument(s)
                }
                // determine the precise location for this error
                let expr = response;
                if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                    expr = getExpressionIfLocField(actNode, expr);
                    if ((offerArgumentsNode === null || offerArgumentsNode === void 0 ? void 0 : offerArgumentsNode.kind) === "Call") {
                        expr = getExpressionIfLocField(offerArgumentsNode, expr);
                        if (ask.isListLiteral(offerArgumentsNode.arguments)) {
                            expr = getExpressionIfLocField((_b = (_a = offerArgumentsNode.arguments) === null || _a === void 0 ? void 0 : _a.items[i]) === null || _b === void 0 ? void 0 : _b.item, expr);
                        }
                    }
                }
                const argValueStr = argItem.printPropertyChainThroughRoot();
                const argThing = response.checker.getThing(arg);
                if (((_d = (_c = argThing === null || argThing === void 0 ? void 0 : argThing.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.isAction()) && !argThing.parent.parent.equals(offerActionName)) {
                    state = state.withError(ValidationErrorFactory.MismatchedActionArgumentsListValue({
                        expr,
                        attributes: {
                            argumentValue: argValueStr,
                            actionName: (_e = offerActionName.origin.name) === null || _e === void 0 ? void 0 : _e.name,
                        },
                    }));
                }
            });
        }
        // Offer.carryOverArguments
        const offerCarryoverArguments = act.getProperty("carryOverArguments");
        const offerCarryoverArgumentsNode = act.apply.getArgumentValue("carryOverArguments");
        if (offerCarryoverArguments === undefined || !offerCarryoverArguments.isList() || !offerCarryoverArguments.isLiteral()) {
            return state; // should not happen as the arguments for Offer act must be a List Call
        }
        (_b = offerCarryoverArguments.getItems()) === null || _b === void 0 ? void 0 : _b.forEach((carryOverArgument, i) => {
            var _a, _b, _c, _d, _e, _f;
            if ((carryOverArgument === null || carryOverArgument === void 0 ? void 0 : carryOverArgument.isObject()) && carryOverArgument.isLiteral()) {
                const arg = carryOverArgument.getProperty("argument");
                if ((arg === null || arg === void 0 ? void 0 : arg.type.isArgument()) && ((_b = (_a = arg.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction())) {
                    if (!arg.parent.parent.equals(offerActionName)) {
                        const carryOverValueStr = ask.isPropRef((_c = arg.origin) === null || _c === void 0 ? void 0 : _c.context) ? arg.origin.context.printPropertyChainThroughRoot() : "todo";
                        // determine the most precise location for the argument's error.
                        // TODO: this is gross, refactor it
                        let expr = response;
                        if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                            expr = getExpressionIfLocField(actNode, expr);
                            if ((offerCarryoverArgumentsNode === null || offerCarryoverArgumentsNode === void 0 ? void 0 : offerCarryoverArgumentsNode.kind) === "Call") {
                                expr = getExpressionIfLocField(offerCarryoverArgumentsNode, expr);
                                if (ask.isListLiteral(offerCarryoverArgumentsNode.arguments)) {
                                    const carryOverArgNode = (_e = (_d = offerCarryoverArgumentsNode.arguments) === null || _d === void 0 ? void 0 : _d.items[i]) === null || _e === void 0 ? void 0 : _e.item;
                                    if (carryOverArgNode !== undefined) {
                                        expr = getExpressionIfLocField(carryOverArgNode, expr);
                                        if (carryOverArgNode.kind === "Call") {
                                            expr = getExpressionIfLocField(carryOverArgument.apply.getArgumentValue("argument"), expr);
                                        }
                                    }
                                }
                            }
                        }
                        state = state.withError(ValidationErrorFactory.MismatchedActionCarryOverArguments({
                            expr,
                            attributes: {
                                carryOverValue: carryOverValueStr,
                                actionName: (_f = offerActionName.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                            },
                        }));
                    }
                }
            }
        });
        return state;
    }
    // 5. validate ConfirmAction Act
    // if (act.type.isConfirmAction()) {
    //   errors.push(...validateConfirmAction(apply, checker));
    // }
    // 6. validate Request Act
    if (act.type.isRequest()) {
        const args = act.getProperty("arguments");
        if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
            state = state.withError(...validateArgumentList(act.apply.getArgumentValue("arguments"), act.getProperty("arguments")));
        }
        // If the argList contains multiple args, make sure each arg has request prompt
        state = validateRequestPromptInArgsList(response, act, state);
    }
    // 7. For Notify Act, it can only use the last API action name and an API call can only be notified once
    if (act.type.isNotify() && act.isObject() && act.isLiteral()) {
        // const actValueApply = act.apply;
        const actionDecl = act.getProperty("actionName");
        if (actionDecl === null || actionDecl === void 0 ? void 0 : actionDecl.isAction()) {
            const validateNotify = (expr) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                if (expr === undefined) {
                    return [
                        ValidationErrorFactory.InvalidNotifyActionNameUnusedAction({
                            expr: response,
                            attributes: {
                                actionName: (_a = actionDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                            },
                        }),
                    ];
                }
                if (expr.isInvokeApi()) {
                    const actionName = (_b = expr.action) === null || _b === void 0 ? void 0 : _b.actionName;
                    if (actionName && actionName !== ((_c = actionDecl.name) === null || _c === void 0 ? void 0 : _c.name)) {
                        return [
                            ValidationErrorFactory.InvalidNotifyActionNameLastAction({
                                expr: getExpressionIfLocField((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call" ? (_e = (_d = response.apply.getArgumentValueThing("act")) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValue("actionName") : actNode, response),
                                attributes: {
                                    currentActionName: (_f = actionDecl.name) === null || _f === void 0 ? void 0 : _f.name,
                                    previousActionName: actionName,
                                },
                            }),
                        ];
                    }
                    return [];
                }
                if (expr.isResponse()) {
                    const actionName = (_g = actionDecl.name) === null || _g === void 0 ? void 0 : _g.name;
                    const { act } = expr;
                    if ((act === null || act === void 0 ? void 0 : act.type.isNotify()) && act.isObject() && act.isLiteral()) {
                        const actionNameProp = act.getProperty("actionName");
                        if ((actionNameProp === null || actionNameProp === void 0 ? void 0 : actionNameProp.isAction()) && actionName === ((_h = actionNameProp.origin.name) === null || _h === void 0 ? void 0 : _h.name)) {
                            return [
                                ValidationErrorFactory.InvalidNotifyActionNameAlreadyNotified({
                                    expr: response,
                                    attributes: {
                                        actionName: (_j = actionDecl.name) === null || _j === void 0 ? void 0 : _j.name,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return validateNotify(expr.prev);
            };
            state = addPendingOfferIfAction(response.nextAct, state.withError(...validateNotify(response.prev)));
        }
    }
    return state;
};
/**
 * Modifies pending offer state if actionName is provided in Offer
 */
export const addPendingOfferIfAction = (act, state) => {
    var _a, _b, _c, _d;
    if (act === null || act === void 0 ? void 0 : act.type.isOffer()) {
        const action = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("actionName");
        if (((_b = action === null || action === void 0 ? void 0 : action.origin) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" && ((_d = (_c = action === null || action === void 0 ? void 0 : action.origin) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name)) {
            return state.withPendingOffer(action.origin.name.name);
        }
    }
    return state;
};
/**
 * Validate nextAct used in response action
 * 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
 * 2. nextAct could only follow Notify act
 * 3. the ReqAlt act can only be the next Act to a Notify Act with "success = false"
 * 4. for ReqAlt, the items in the "arguments" list should be from the same Action
 * 5. for ReqAlt, actionName used in Notify and ReqAlt argument list should be consistent
 */
export const validateNextAct = (response, state) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const errors = [];
    const { act } = response;
    const actArg = response.apply.getArgumentValue("act");
    const actionName = act === null || act === void 0 ? void 0 : act.getProperty("actionName");
    const actType = act === null || act === void 0 ? void 0 : act.type;
    if (actArg === undefined || act === undefined || actType === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return [];
    }
    const { nextAct } = response;
    const nextActArg = response.apply.getArgument("nextAct");
    const nextActType = nextAct === null || nextAct === void 0 ? void 0 : nextAct.type;
    if (nextActArg === undefined || nextAct === undefined || nextActType === undefined || nextActType.isNothing() || nextActType.isVoid()) {
        // don't do anything when type is undefined as it is an optional argument
    }
    else if (!nextActType.isOffer() && !nextActType.isBye() && !nextActType.isReqAlt() && !nextActType.isReqMore()) {
        // 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
        errors.push(ValidationErrorFactory.InvalidNextAct({
            expr: nextActArg,
            attributes: {
                responseAct: nextActType.toString(nextActArg),
            },
        }));
    }
    else {
        // 2. nextAct could only follow Notify act
        if (!actType.isNotify()) {
            errors.push(ValidationErrorFactory.InvalidNextActNotify({
                expr: actArg,
                attributes: {
                    responseAct: actType.toString(actArg),
                },
            }));
        }
        else {
            // validations for ReqAlt act
            if (nextAct.type.isReqAlt()) {
                const reqAltArguments = nextAct.getProperty("arguments");
                if ((reqAltArguments === null || reqAltArguments === void 0 ? void 0 : reqAltArguments.isList()) && reqAltArguments.isLiteral()) {
                    errors.push(...validateArgumentList((_a = nextAct === null || nextAct === void 0 ? void 0 : nextAct.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("arguments"), nextAct.getProperty("arguments")));
                }
                const successValue = act.getProperty("success");
                if (successValue === undefined || !successValue.isBoolean()) {
                    // should be caught by other validation
                    return errors;
                }
                if (successValue.literal === true) {
                    // 3. The ReqAlt act can only be the next Act to a Notify Act with "success = false"
                    errors.push(ValidationErrorFactory.InvalidReqAltNextAct({
                        expr: nextActArg,
                    }));
                }
                if (nextAct.isObject() && nextAct.isLiteral()) {
                    const reqAlt = nextAct.getProperty("arguments");
                    const reqAltNode = nextAct.apply.getArgumentValue("arguments");
                    if ((reqAlt === null || reqAlt === void 0 ? void 0 : reqAlt.isList()) && reqAlt.isLiteral()) {
                        const argumentListErrors = validateArgumentList(reqAltNode, reqAlt);
                        if (argumentListErrors.length > 0) {
                            errors.push(...argumentListErrors);
                        }
                        else {
                            // 5. actionName used in Notify and ReqAlt argument list should be consistent
                            // could rely on the first item to retrieve rootExpr cause we already checked the items in the list are from the same Action
                            const item = reqAlt.getItem(0);
                            if (((_c = (_b = item === null || item === void 0 ? void 0 : item.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.isAction()) && (actionName === null || actionName === void 0 ? void 0 : actionName.isAction())) {
                                if (((_d = item.parent.parent.origin.name) === null || _d === void 0 ? void 0 : _d.name) !== ((_e = actionName.origin.name) === null || _e === void 0 ? void 0 : _e.name)) {
                                    errors.push(ValidationErrorFactory.MismatchedArgsInReqAlt({
                                        expr: reqAltNode,
                                        attributes: {
                                            reqAltActionName: (_f = item.parent.parent.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                                            notifyActionName: (_g = actionName.origin.name) === null || _g === void 0 ? void 0 : _g.name,
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * Validate confirmAction action used in dialog sample
 */
export const evaluateConfirmAction = (confirm, state) => {
    var _a, _b, _c, _d, _e;
    let action;
    // location of the ConfirmAction act on which we will attach errors.
    let errorExpr;
    // let actionNameLoc: ask.SourceLocation | undefined;
    if (confirm.isResponse()) {
        if (!((_a = confirm.act) === null || _a === void 0 ? void 0 : _a.type.isConfirmAction())) {
            // why?
            return state;
        }
        const actionName = confirm.act.getProperty("actionName");
        if (actionName === null || actionName === void 0 ? void 0 : actionName.isAction()) {
            action = actionName;
            errorExpr =
                ((_b = confirm.actNode) === null || _b === void 0 ? void 0 : _b.kind) === "Call"
                    ? getExpressionIfLocField((_c = confirm.act.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("actionName"), confirm.actNode, confirm)
                    : getExpressionIfLocField(confirm.actNode, confirm);
        }
        else {
            return state;
        }
    }
    else if (confirm.isConfirmAction()) {
        action = confirm.actionName;
        errorExpr = getExpressionIfLocField((_d = confirm.actionNameNode) === null || _d === void 0 ? void 0 : _d.value, confirm);
    }
    const confirmedPayload = confirm.payload;
    if (action === undefined) {
        return state;
    }
    if (!action.isAction()) {
        return state;
    }
    const actionName = (_e = action.origin.name) === null || _e === void 0 ? void 0 : _e.name;
    return state.withError(...[
        validatePayload(confirm, state),
        confirm.flow.interpret((expr) => interpret(expr, state), confirm).map((state) => state.errors),
    ].flat(2));
    function interpret(expr, state, foundEvent = false) {
        var _a;
        const errorArguments = {
            expr: errorExpr,
            attributes: {
                actionName,
            },
        };
        const missingApiInvocationError = ValidationErrorFactory.MissingApiInvocationAfterConfirmAction(errorArguments);
        const missingAffirmOrDenyError = ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmAction(errorArguments);
        if (expr.isEnd()) {
            return state.withError(missingApiInvocationError);
        }
        if (expr.isInvokeApi()) {
            if ((_a = expr.action) === null || _a === void 0 ? void 0 : _a.equals(action)) {
                if (!foundEvent) {
                    return state.withError(missingAffirmOrDenyError);
                }
                if (confirmedPayload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
        }
        else if (expr.isDelegateToIntent() || expr.isDelegateRequest()) {
            return state.withError(ValidationErrorFactory.InvalidDelegationActionConfirmation(errorArguments));
        }
        else if (expr.isResponse() || expr.isConfirmAction()) {
            return foundEvent ? state.withError(missingApiInvocationError) : state.withError(missingAffirmOrDenyError, missingApiInvocationError);
        }
        else if (expr.isExpect()) {
            const type = expr.getActType();
            if (type !== undefined) {
                if (type.isAffirm() || (type === null || type === void 0 ? void 0 : type.isDeny())) {
                    if (type.isDeny()) {
                        // it's ok for an api call to not proceed a deny.
                        return state;
                    }
                    return (next) => interpret(next, state.pushExpr(expr), true);
                }
                return state.withError(missingAffirmOrDenyError);
            }
        }
        return (next) => interpret(next, state.pushExpr(expr), foundEvent);
    }
};
/**
 * Validate confirmArgs action used in dialog sample
 * traverse the confirmArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure all arguments in the argument list refer to the same action
 * 3. Make sure all arguments in the argument list has request prompt
 */
export const evaluateConfirmArgs = (confirm, state) => {
    var _a, _b;
    if (confirm.node === undefined) {
        return state;
    }
    const errors = [];
    // const confirmArgs = act.getArgumentValueThing("confirmArgs");
    if (((_a = confirm.confirmArgs) === null || _a === void 0 ? void 0 : _a.isList()) && confirm.confirmArgs.isLiteral()) {
        if (confirm.isResponse())
            errors.push(...validateConfirmArgsFlow(confirm, state));
        for (const arg of (_b = confirm.confirmArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            if ((arg === null || arg === void 0 ? void 0 : arg.type.isConfirmArguments()) && arg.isObject() && arg.isLiteral()) {
                errors.push(...validatePrompt(arg.apply));
                const confirmedArgs = arg.getProperty("arguments");
                const confirmedArgsNode = arg.apply.getArgumentValue("arguments");
                if ((confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isList()) && (confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isLiteral())) {
                    // the items in the "arguments" list should be from the same Action
                    errors.push(...validateArgumentList(confirmedArgsNode, confirmedArgs));
                    // Make sure all arguments in the argument list has request prompt
                    state = validateRequestPromptInArgsList(confirm, arg, state);
                }
            }
        }
    }
    return state.withError(...errors);
};
/**
 * Validate the ConfirmArgs act used in response action
 * 1. make sure the items in the "arguments" list should be from the same Action
 * 2. make sure all arguments in the argument list has request prompt
 * 3. make sure there exist Affirm or Deny event after ConfirmArgs Act
 * 4. make sure the next api call is consistent with the action whose arguments are been confirmed
 * @param response
 * @param confirmArgsAct
 * @param branch
 */
export const validateConfirmArgsAct = (confirm, state) => {
    var _a, _b;
    const errors = [];
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    const argsNode = (_b = confirm.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValue("act");
    if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
        const argumentListErrors = validateArgumentList(argsNode, args);
        errors.push(...argumentListErrors);
        // when all arguments in the list are from the same action
        // make sure the next api call is consistent with the action whose arguments are been confirmed
        if (argumentListErrors.length === 0) {
            errors.push(...validateConfirmArgsFlow(confirm, state));
        }
        // Make sure all arguments in the argument list has request prompt
        state = validateRequestPromptInArgsList(confirm, confirm.act, state);
    }
    return state.withError(...errors);
};
/**
 * The next api call after Confirm Args dialog act must be consistent with the action which is been confirmed.
 */
export const validateConfirmArgsFlow = (confirm, state) => {
    var _a, _b, _c;
    let actionDeclaration = undefined;
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    if (args === null || args === void 0 ? void 0 : args.isList()) {
        for (const arg of (_b = args.getItems()) !== null && _b !== void 0 ? _b : []) {
            const argItem = arg === null || arg === void 0 ? void 0 : arg.asArgument();
            if (!argItem) {
                continue;
            }
            actionDeclaration = argItem.getReferencedActionArgumentActionDeclaration();
            if (actionDeclaration) {
                break;
            }
        }
    }
    else if (args === null || args === void 0 ? void 0 : args.isUnion()) {
        // TODO: validate each variation of the arguments.
        // return state;
        throw new Error("should be impossible.");
    }
    if (actionDeclaration === undefined) {
        return [];
    }
    const actionName = (_c = actionDeclaration.name) === null || _c === void 0 ? void 0 : _c.name;
    const errorExpr = getExpressionIfLocField(confirm.apply.getArgumentValue("act"), confirm);
    return confirm.flow
        .interpret((expr) => visit(expr, state), confirm)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state, affirmed = false) {
        var _a;
        const { flow } = expr;
        const missingEventAfterConfirmArgsError = ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
            expr: errorExpr,
            attributes: {
                actionName,
            },
        });
        if (expr.isEnd()) {
            const missingApiError = ValidationErrorFactory.MissingApiInvocationAfterConfirmArgs({
                expr: errorExpr,
                attributes: {
                    actionName,
                },
            });
            return affirmed ? state.withError(missingApiError) : state.withError(missingEventAfterConfirmArgsError, missingApiError);
        }
        if (expr.isAction()) {
            if (expr === null || expr === void 0 ? void 0 : expr.isInvokeApi()) {
                if (!affirmed) {
                    return state.withError(missingEventAfterConfirmArgsError, ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeCall({
                        expr,
                        attributes: {
                            calledActionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName,
                            confirmedActionName: actionName,
                        },
                    }));
                }
                if (confirm.payload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
            if (expr.isExpect() && !affirmed) {
                const actType = expr.getActType();
                if ((actType === null || actType === void 0 ? void 0 : actType.isAffirm()) || (actType === null || actType === void 0 ? void 0 : actType.isDeny())) {
                    if (actType.isDeny()) {
                        return state;
                    }
                    return (next) => visit(next, state.pushExpr(expr), true);
                }
                if (actType) {
                    return state.withError(missingEventAfterConfirmArgsError, ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeExpect({
                        expr,
                        attributes: {
                            actionName,
                            requestAct: actType.toString(flow.expression),
                        },
                    }));
                }
            }
            else if (!affirmed && ((expr === null || expr === void 0 ? void 0 : expr.isResponse()) || (expr === null || expr === void 0 ? void 0 : expr.isConfirmAction()))) {
                return state.withError(ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
                    expr: confirm,
                    attributes: {
                        actionName,
                    },
                }));
            }
        }
        return (next) => visit(next, state.pushExpr(expr), affirmed);
    }
};
/**
 * Validate the arguments to an API match the payload in a previous ConfirmArgs or ConfirmAction act.
 */
function validateConfirmPayload(state, confirm, apiOrDelegate) {
    var _a;
    const confirmedPayload = confirm.isResponse() || confirm.isConfirmAction() ? confirm.payload : undefined;
    const payload = apiOrDelegate.getConfirmPayload();
    const errors = Object.entries((_a = payload.arguments) !== null && _a !== void 0 ? _a : {})
        .map(([name, arg]) => {
        var _a, _b;
        const actualArg = confirmedPayload === null || confirmedPayload === void 0 ? void 0 : confirmedPayload.getProperty(name);
        if (actualArg === undefined || actualArg.equals(arg)) {
            return [];
        }
        // return a pair of errors for the mis-matched argument
        return [
            ValidationErrorFactory.MismatchedPayloadPropertyValueActionArgument({
                expr: getExpressionIfLocField((_a = confirm.apply) === null || _a === void 0 ? void 0 : _a.getArgument("payload"), confirm),
                attributes: {
                    propertyName: name,
                    actionName: payload.actionName,
                },
            }),
            ValidationErrorFactory.MismatchedPayloadPropertyValuePreviouslyConfirmed({
                expr: getExpressionIfLocField((_b = apiOrDelegate.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValue(name), arg),
                attributes: {
                    argumentName: name,
                    actionName: payload.actionName,
                },
            }),
        ];
    })
        .reduce((a, b) => a.concat(b), []);
    return state.withError(...errors);
}
/**
 * Validate ensure action used in dialog sample
 * traverse the requestArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure each all arguments in the argument list refer to the same action
 * 3. When the arguments list of RequestArguments contains multiple args, make sure each arg has request prompt
 */
export const evaluateEnsure = (ensure, state) => {
    var _a, _b;
    if (ensure.node === undefined) {
        return state;
    }
    const errors = [];
    state = state.withRequestedArguments(true, ...ensure.getIndividuallyRequestedArguments());
    // const requestArgsNode = ensure.requestArgs.origin;
    if (((_a = ensure.requestArgs) === null || _a === void 0 ? void 0 : _a.isList()) && ensure.requestArgs.isLiteral()) {
        for (const requestArg of (_b = ensure.requestArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            const args = requestArg === null || requestArg === void 0 ? void 0 : requestArg.getProperty("arguments");
            errors.push(...validateArgumentListThing(args, args === null || args === void 0 ? void 0 : args.origin));
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                errors.push(...validatePrompt(requestArg.apply));
            }
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                state = validateRequestPromptInArgsList(ensure, requestArg, state);
            }
        }
    }
    return state.withError(...errors);
};
/**
 * Validations of the List<Argument<Thing>> type
 * the items in the "arguments" list should be from the same Action
 * @param value
 * @param branch
 */
export function validateArgumentList(value, valueThing) {
    return validateArgumentListThing(valueThing, value);
}
export function validateArgumentListThing(list, expr) {
    var _a, _b;
    const parseErrors = [];
    if (list === undefined) {
        return parseErrors;
    }
    else if (list.isUnion()) {
        return list.things.map((t) => validateArgumentListThing(t, expr)).reduce((a, b) => a.concat(b), []);
    }
    else if ((list === null || list === void 0 ? void 0 : list.isLiteral()) && list.isList()) {
        const actionNamesSet = new Set();
        const items = (_a = list.getItems()) !== null && _a !== void 0 ? _a : [];
        if (items.length === 0) {
            parseErrors.push(ValidationErrorFactory.ExpectedNonEmptyArgumentList({ expr }));
            return parseErrors;
        }
        for (const itemThing of (_b = list.getItems()) !== null && _b !== void 0 ? _b : []) {
            if (itemThing === undefined) {
                // This will happen when referring to the arguments of a reusable dialog:
                //    ensure(RequestArguments {arguments = [saveRating.arguments.arg0], response = feedback_prompt})
                // saveRating is an argument to the reusable dialog:
                //    dialog Nothing GetFeedback(Action1<Number, Nothing> saveRating)
                // For this case, currently skipping the validations for argument reference and type below
                continue;
            }
            if (!itemThing.isArgument()) {
                continue;
            }
            const argumentInformation = itemThing.getReferencedActionArgumentTypeInformation();
            if (!argumentInformation || !argumentInformation.actionName) {
                parseErrors.push(ValidationErrorFactory.ArgumentMustReferToActionArgument({
                    expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                    attributes: { argumentName: itemThing.argumentName },
                }));
            }
            else {
                actionNamesSet.add(argumentInformation.actionName);
                if (argumentInformation.type && !argumentInformation.type.isValidForUtterance()) {
                    parseErrors.push(ValidationErrorFactory.ArgumentMustReferToActionArgumentWithUtteranceType({
                        expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                        attributes: { argumentName: itemThing.argumentName, typeName: argumentInformation.type.toString() },
                    }));
                }
            }
        }
        if (actionNamesSet.size > 1) {
            const actionNames = Array.from(actionNamesSet.values())
                .map((n) => "'" + n + "'")
                .join(", ");
            return [
                ValidationErrorFactory.MismatchedActionArgumentsList({
                    expr,
                    attributes: {
                        actionNames: actionNames,
                    },
                }),
            ];
        }
    }
    return parseErrors;
}
/**
 * Validate response argument in response, confirmAction, ensure and confirmArgs actions
 * The type of response should be APL-A
 *
 * Right now the type validation won't check response type cause the response type could be anything
 */
export const validatePrompt = (apply) => {
    var _a, _b, _c;
    const errors = [];
    const promptNode = apply.getArgumentValue("response");
    const prompt = apply.getArgumentValueThing("response");
    if (prompt !== undefined) {
        if (((_a = prompt.type) === null || _a === void 0 ? void 0 : _a.isApla()) || ((_b = prompt.type) === null || _b === void 0 ? void 0 : _b.isMultiModalResponse())) {
            // APLA and MultiModalResponse are valid prompt
            // TODO: we should probably check if the APLA property is set, right?
        }
        else {
            errors.push(ValidationErrorFactory.MissingAplaInResponse({
                expr: promptNode,
                attributes: {
                    type: (_c = prompt.type) === null || _c === void 0 ? void 0 : _c.toString(promptNode),
                },
            }));
        }
    }
    return errors;
};
export const validateRequestPromptInArgsList = (expr, act, state) => {
    var _a, _b, _c, _d;
    if (act === undefined) {
        return state;
    }
    if (act.isUnion()) {
        // return args.things.map((thing) => validateRequestPromptInArgsList(thing, state)).reduce((a, b) => a.concat(b), []);
        throw new Error("this should be impossible.");
    }
    else if (expr.isConfirmArgs() || act.type.isRequest() || act.type.isRequestArguments() || act.type.isConfirmArgs()) {
        const args = (_c = (_b = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("arguments")) === null || _b === void 0 ? void 0 : _b.asLiteralList()) === null || _c === void 0 ? void 0 : _c.getItems();
        if (args && args.length > 1) {
            for (const arg of args) {
                const argName = (_d = arg === null || arg === void 0 ? void 0 : arg.origin) === null || _d === void 0 ? void 0 : _d.name;
                if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && argName !== undefined) {
                    if ((expr.isResponse() || expr.isEnsure() || expr.isConfirmArgs()) && !state.isArgumentRequested(arg)) {
                        state = state.withPendingRequestPromptValidation(expr, arg);
                    }
                }
            }
        }
    }
    return state;
};
/**
 * Validate the user Defined api call inside dialog sample
 * 1. make sure the argument is api result or event result
 * 2. make sure the required argument has Request Prompt
 * 3. make sure the argument(event result) has not been reset
 * 4. make sure all of the api arguments leaf types are primitive or backed by a catalog
 * 5. make sure the the api return value leaf types are primitive or backed by a catalog
 */
export const evaluateInvokeApi = (api, state) => {
    var _a;
    if (api.node === undefined) {
        return state;
    }
    const apiName = (_a = api.action) === null || _a === void 0 ? void 0 : _a.actionName;
    const shortApiName = getName(apiName !== null && apiName !== void 0 ? apiName : "");
    const errors = [
        ...validateLoadContextIsCalledOnce(),
        ...validateArguments(),
        ...validateOfferedApiInvocation(),
        ...validateReturnValue(),
    ];
    return state.withError(...errors).clearPendingOffer();
    // Validate the return value of an api is not an empty type or contains an empty sub-type
    function validateReturnValue() {
        var _a;
        const returnType = (_a = api.apply) === null || _a === void 0 ? void 0 : _a.getReturnType();
        const invalidLeafs = returnType === null || returnType === void 0 ? void 0 : returnType.getEmptyLeafTypes();
        if (invalidLeafs === null || invalidLeafs === void 0 ? void 0 : invalidLeafs.length) {
            return [
                ValidationErrorFactory.InvalidApiReturnType({
                    expr: api.node,
                    attributes: {
                        apiName: shortApiName,
                        unbackedMessage: unbackedCatalogMsg(invalidLeafs),
                    },
                }),
            ];
        }
        return [];
    }
    function validateArguments() {
        var _a, _b, _c, _d;
        return ((_d = (_c = (_b = (_a = api.action) === null || _a === void 0 ? void 0 : _a.getArguments()) === null || _b === void 0 ? void 0 : _b.getArgumentsList()) === null || _c === void 0 ? void 0 : _c.flatMap((arg) => {
            const argValueNode = api.apply.getArgumentValue(arg);
            const argValue = api.apply.getArgumentValueThing(arg);
            if (argValue !== undefined) {
                return validateArgValue(argValueNode, argValue, arg);
            }
            return [];
        })) !== null && _d !== void 0 ? _d : []);
    }
    function validateOfferedApiInvocation() {
        var _a, _b;
        const invokedAction = (_b = (_a = api.apply) === null || _a === void 0 ? void 0 : _a.decl.name) === null || _b === void 0 ? void 0 : _b.name;
        if (state.pendingOffer && state.pendingOffer != invokedAction) {
            return [
                ValidationErrorFactory.InvokedActionNotOffered({
                    expr: api,
                    attributes: {
                        offeredAction: state.pendingOffer,
                        invokedAction: invokedAction,
                    },
                }),
            ];
        }
        return [];
    }
    /**
     * Validate argument value
     *
     * 1. make sure the argument value is api result or event result
     * 2. when the argValue is event result, make sure it has request prompt
     * 3. ensure the sub types of the argument are non-empty or backed by a catalog
     *
     * @param argValue the argument value
     * @param argDecl the declaration of the argument, we could know the argument name, type and whether the argument is optional based on it
     * @returns Parse errors
     */
    function validateArgValue(argValue, argValueThing, argDecl) {
        var _a, _b;
        const argDeclType = argDecl.type.getArgumentType();
        const invalidApiArgumentError = ValidationErrorFactory.InvalidApiArgument({
            expr: argValue,
        });
        const errors = [...validateArgHasNoEmptyLeafTypes(argDeclType)];
        if (argValueThing.isNothing()) {
            return errors;
        }
        if (argValueThing.isLiteral()) {
            // A literal argument can only be a list
            if (argValueThing.isList()) {
                errors.push(...((_b = (_a = argValueThing.getItems()) === null || _a === void 0 ? void 0 : _a.flatMap(validateArgValueThing)) !== null && _b !== void 0 ? _b : []));
            }
            else {
                // TODO: validate type literal with multiple properties
                // errors.push(invalidApiArgumentError);
            }
        }
        else {
            errors.push(...validateArgValueThing(argValueThing));
        }
        return errors;
        // Validates that the base type or any sub-type is non empty.
        function validateArgHasNoEmptyLeafTypes(type) {
            const emptyLeaves = type === null || type === void 0 ? void 0 : type.getEmptyLeafTypes();
            if (emptyLeaves === null || emptyLeaves === void 0 ? void 0 : emptyLeaves.length) {
                return [
                    ValidationErrorFactory.ApiArgumentWithNoCatalog({
                        expr: argValue,
                        attributes: {
                            argName: argDecl.argumentName,
                            apiName: shortApiName,
                            unbackedMessage: unbackedCatalogMsg(emptyLeaves),
                        },
                    }),
                ];
            }
            return [];
        }
        // Validates the origin of an argument. For now it must be from an API result or an entity produced by an event.
        function validateArgValueThing(argValueThing) {
            var _a;
            const origin = getOriginType(argValueThing);
            if (argValueThing === undefined || argValueThing.isNothing()) {
                return [];
            }
            if (argValueThing.isUnion()) {
                return argValueThing.things.map(validateArgValueThing).reduce((a, b) => a.concat(b), []);
            }
            if (argValueThing.parent === undefined) {
                // if we're directly referencing a value, it must be an API cal
                if (isFromOrigin(origin, "api") === false) {
                    return [invalidApiArgumentError];
                }
            }
            else if (isFromOrigin(origin, "event", "api") === false) {
                // if we're indexing an object, it can be from an event or an API call.
                return [invalidApiArgumentError];
            }
            if (isFromOrigin(origin, "event")) {
                if (!state.isArgumentRequested(argDecl, argValueThing)) {
                    if (!((argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isOptional()) || (argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isArgs()))) {
                        // if this is a required argument and it has not been requested in this dialog flow, we must keep track of it
                        // and only error if we don't find an `ensure` block later in the dialog flow.
                        // const arg = api.action?.getArgument(argDecl);
                        state = state.withPendingRequestPromptValidation(api, argDecl);
                    }
                }
            }
            // Both the eventResult and apiResult follow the same reset rule
            if (api.flow.isArgumentReset(argValueThing, api.apply.decl)) {
                const argumentName = (argValue === null || argValue === void 0 ? void 0 : argValue.kind) === "PropertyReference" ? argValue.printPropertyChainThroughRoot() : (_a = argValue === null || argValue === void 0 ? void 0 : argValue.name) === null || _a === void 0 ? void 0 : _a.name;
                return [
                    ValidationErrorFactory.ResetArgument({
                        expr: argValue,
                        attributes: {
                            argumentName,
                        },
                    }),
                ];
            }
            return [];
        }
    }
    /**
     * A call to the configured loadContext action must be called at most once per dialog sample.
     *
     * @see https://github.com/alexa/ask-ac/issues/225
     */
    function validateLoadContextIsCalledOnce() {
        var _a, _b, _c;
        if (apiName && ((_c = (_b = (_a = state.skillContext) === null || _a === void 0 ? void 0 : _a.loadContext) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === apiName) {
            return api.flow.visitPrevious(function walk(flow) {
                var _a;
                if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
                    return [];
                }
                if (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
                    const apply = flow.checker.getApply(flow.expression);
                    if (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi()) {
                        const thisName = apply === null || apply === void 0 ? void 0 : apply.getName();
                        if (thisName) {
                            if (thisName === apiName) {
                                return [
                                    ValidationErrorFactory.InvalidLoadContextMultipleCall({
                                        expr: api,
                                        attributes: {
                                            actionName: apiName,
                                        },
                                    }),
                                ];
                            }
                            return [
                                ValidationErrorFactory.InvalidLoadContextNotFirstCall({
                                    expr: api,
                                    attributes: {
                                        actionName: apiName,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return flow.visitPrevious(walk);
            });
        }
        return [];
    }
    // Stringifies types into a readable catalog error message
    function unbackedCatalogMsg(types) {
        const stringifiedTypeNames = types.map((type) => `"${type.shortName}"`).join(", ");
        return types.length === 1
            ? `refers to a type ${stringifiedTypeNames} that has no properties and is not associated with a catalog.`
            : `refers to the types ${stringifiedTypeNames} that have no properties and are not associated with a catalog.`;
    }
};
/**
 * Validate payload argument in response and confirmAction action
 *
 * 1. the expression assigned to payload is either null, Thing, or an ObjectLiteral
 * 2. the value assigned to payload property can only be a name directly referring to an api result or a type used in an event
 * 3. validate payload against next api call
 *
 * The Simulator can only understand payload values to be either a slot in the event or the return value of an api invocation
 */
export const validatePayload = (response, state) => {
    var _a;
    if (response.payload === undefined) {
        return [];
    }
    const errors = [];
    const expr = getExpressionIfLocField((_a = response.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("payload"), response);
    validatePayloadThing(response.payload);
    return errors;
    function validatePayloadThing(payload) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (payload.isUnion()) {
            throw new Error("this should be impossible.");
            // payload.things.forEach(validatePayloadThing);
        }
        else if (payload.isPrimitive()) {
            if (payload.isLiteral() && (payload.isVoid() || payload.isNothing())) {
                // null and nothing literals are allowed.
            }
            else {
                // TODO: i need to properly handle Optional -> which is AnyThing right now
                errors.push(ValidationErrorFactory.InvalidPayloadType({
                    expr,
                }));
            }
        }
        else if (!payload.isLiteral()) {
            errors.push(ValidationErrorFactory.InvalidPayloadType({
                expr,
            }));
        }
        else {
            // now we have an object literal `{ prop = value }`
            Object.entries((_a = payload.getProperties()) !== null && _a !== void 0 ? _a : {}).forEach(([name, propThing]) => {
                if (propThing !== undefined) {
                    const origin = getOriginType(propThing);
                    if (propThing.parent === undefined) {
                        // if we're directly referencing a value, it must be an API cal
                        if (isFromOrigin(origin, "api") === false) {
                            errors.push(ValidationErrorFactory.InvalidPayloadPropertyValue({
                                expr,
                            }));
                        }
                    }
                    else if (isFromOrigin(origin, "event", "api") === false) {
                        // if we're indexing an object, it can be from an event or an API call.
                        errors.push(ValidationErrorFactory.InvalidPayloadPropertyValue({
                            expr,
                        }));
                    }
                }
            });
        }
        // payload type should be consistent with response type
        if (((_c = (_b = response.response) === null || _b === void 0 ? void 0 : _b.type) === null || _c === void 0 ? void 0 : _c.genericArguments) && ((_e = (_d = response.response) === null || _d === void 0 ? void 0 : _d.type) === null || _e === void 0 ? void 0 : _e.genericArguments.length) > 0) {
            const responseGenericType = (_g = (_f = response.response) === null || _f === void 0 ? void 0 : _f.type) === null || _g === void 0 ? void 0 : _g.genericArguments[0];
            if (responseGenericType !== undefined && !payload.type.extends(responseGenericType)) {
                errors.push(typeError(payload.type, responseGenericType, response.node, getExpressionIfLocField((_h = response.apply) === null || _h === void 0 ? void 0 : _h.getArgumentValue("payload"), response)));
            }
        }
    }
};
function isFromOrigin(actualOrigin, ...expectedOrigin) {
    const allowedOrigins = new Set(expectedOrigin);
    if (actualOrigin === undefined) {
        return undefined;
    }
    if (typeof actualOrigin === "string") {
        return allowedOrigins.has(actualOrigin);
    }
    let accumulator = true;
    for (const o of actualOrigin) {
        if (o === undefined) {
            return undefined;
        }
        accumulator = allowedOrigins.has(o) && accumulator;
    }
    return accumulator;
}
function getOriginType(thing) {
    var _a;
    if (thing === undefined) {
        return undefined;
    }
    if (thing.parent !== undefined) {
        // a thing is from an API call or an Event if the root is from an API or expect event
        return getOriginType(thing.parent);
    }
    if (thing.isLiteral()) {
        return "literal";
    }
    if (thing.isUnion()) {
        return thing.things
            .map((t) => getOriginType(t))
            .reduce((a, b) => {
            if (Array.isArray(a) && Array.isArray(b)) {
                return a.concat(b);
            }
            if (Array.isArray(a)) {
                return [...a, b];
            }
            if (Array.isArray(b)) {
                return [a, ...b];
            }
            return [a, b];
        }, []);
    }
    if (((_a = thing.origin) === null || _a === void 0 ? void 0 : _a.kind) === "ArgumentDeclaration") {
        // origin is an argument declaration, this relies on re-usable dialog expansion logic ....
        // for now, return false?
        return "argument";
    }
    const { apply } = thing;
    if (apply === undefined) {
        return undefined;
    }
    if (apply.isExpect()) {
        return "event";
    }
    if (apply.isUserDefinedApi()) {
        return "api";
    }
    if (apply.isOperator()) {
        return "operator";
    }
    if (apply.isNativeAction()) {
        return "native";
    }
    if (apply.isBuiltin()) {
        return "built-in";
    }
    return undefined;
}
export function validateGlobalWelcome(project, checker) {
    const welcomeCalls = project.modules
        .map((module) => {
        var _a, _b, _c;
        return (_c = (_b = (_a = module.content) === null || _a === void 0 ? void 0 : _a.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => {
            var _a;
            if (expr.kind === "Call" || (expr.kind === "NameDeclaration" && ((_a = expr.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call")) {
                const apply = checker.getApply(expr.kind === "Call" ? expr : expr.expression);
                if (apply === null || apply === void 0 ? void 0 : apply.isWelcome()) {
                    return [expr];
                }
            }
            return [];
        }).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : [];
    })
        .reduce((a, b) => a.concat(b), []);
    if (welcomeCalls.length > 1) {
        return welcomeCalls.map((welcome) => ValidationErrorFactory.TooManyWelcomeCalls({
            expr: welcome,
            attributes: {
                welcomeCallCount: welcomeCalls.length,
            },
        }));
    }
    return [];
}
/**
 * validate all required prompts are exist in current skill
 */
export function validateSkillLevelResponses(project) {
    var _a;
    const errors = [];
    const promptsNameSet = new Set();
    // Check if required prompts exist in current skill
    (_a = project.responseTemplates) === null || _a === void 0 ? void 0 : _a.forEach((prompt) => {
        if (prompt.isPrompt()) {
            promptsNameSet.add(prompt.name);
        }
    });
    Object.values(ask.AlexaConversationPrompts).forEach((requiredPrompt) => {
        if (!promptsNameSet.has(requiredPrompt)) {
            errors.push(ValidationErrorFactory.MissingRequiredPrompts({
                attributes: {
                    promptName: requiredPrompt,
                },
            }));
        }
    });
    return errors;
}
/**
 * Verify the expect of Invoke event exists by recursively calling the @function doesSampleStartWithInvoke
 *
 * E.G. Below is a valid example, as it has expect with Invoke event:
 * dialog void A {
 *   sample {
 *     expect(Invoke, invocationUtterances)
 *     // ... conversation flow's logic
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * It makes sure all the branches have an Invoke event if conditional branches exist.
 * E.G. The dialog below is not a valid one as it misses Invoke in one condition branch:
 * dialog void B {
 *   sample {
 *     if (some_condition) {
 *       expect(RequestAlt, invocationUtterances)
 *     } else {
 *       expect(Invoke, invocationUtterances)
 *     }
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * @param sample sample node to validate through the expressions to find Invoke event
 * @param flow type checker
 * @returns
 */
export const validateSampleStartWithInvoke = (flow, state) => {
    const sample = flow.expression;
    const dialogDecl = sample.context;
    return flow
        .interpret((expr) => visit(expr, state), undefined)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state) {
        var _a, _b, _c;
        if (expr.isEnd()) {
            // if we reach the end then don't report any error - the sample will be flagged as not having an expressions.
            return state;
        }
        if (expr.isDialogExpansion()) {
            // skip dialog expansion (treat it as transient).
            return (next) => visit(next, state);
        }
        if (expr.isExpect()) {
            if (expr.isInvoke()) {
                return state;
            }
            // TODO: specialize error message for the wrong act typ
            // TODO: is the origin location a bad idea?
            return state.withError(ValidationErrorFactory.MissingExpectInvokeEvent({
                expr: getExpressionIfLocField((_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act"), expr, sample),
                attributes: {
                    dialogName: (_b = dialogDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                },
            }));
        }
        if (expr.isEnsure() || expr.isConditionalBranch() || expr.isDialogExpansion() || expr.isBlock()) {
            // these blocks don't count as evaluated actions, so we  move to the next expressions
            // return expr.flow.interpret(state, EvaluationState.combine, evaluate);
            return (next) => visit(next, state.pushExpr(expr));
        }
        return state.withError(ValidationErrorFactory.MissingExpectInvokeEvent({
            expr: getExpressionIfLocField(expr, sample),
            attributes: {
                dialogName: (_c = dialogDecl.name) === null || _c === void 0 ? void 0 : _c.name,
            },
        }));
    }
};
/**
 * Returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 * This will recursevely follow conditionExpressionThing.parent to find the root parent. Once there
 * returns true if it is either:
 *   1) the last user defined API or
 *   2) an event out of an expect call or
 *   3) an operator or native action where at least one argument is 1) or 2)
 * @param conditionExpressionThing condition expression thing
 * @param lastApiName name of the last user defined API called
 * @returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 */
const isConditionExpressionFromLastApiOrFromExpect = (conditionExpressionThing, lastApiName) => {
    if (conditionExpressionThing === undefined) {
        return false;
    }
    if (conditionExpressionThing.parent !== undefined) {
        return isConditionExpressionFromLastApiOrFromExpect(conditionExpressionThing.parent, lastApiName);
    }
    if (!conditionExpressionThing.apply) {
        return false;
    }
    if (conditionExpressionThing.apply.isExpect()) {
        return true;
    }
    if (conditionExpressionThing.apply.isUserDefinedApi()) {
        return conditionExpressionThing.apply.getName() === lastApiName;
    }
    if (conditionExpressionThing.apply.isOperator() || conditionExpressionThing.apply.isNativeAction()) {
        for (const arg in conditionExpressionThing.apply.getArguments()) {
            const argThing = conditionExpressionThing.apply.getArgumentValueThing(arg);
            if (!argThing || isConditionExpressionFromLastApiOrFromExpect(argThing, lastApiName)) {
                return true;
            }
        }
    }
    return false;
};
/**
 * This function validates Condition.when for the following checkpoints:
 * 2. validate the when condition contains any data from the last API invocation call
 * 3. validate then when expression to have a boolean return type
 *
 * @param cond Condition.when Call | NameReference
 * @param condition type checker for querying the expressions
 * @returns type Validator<T>
 */
export const evaluateConditionalBranch = (condition, state) => {
    var _a, _b;
    state = state.withError(...validateFirstExpressionInCondition());
    const { when } = condition.flow.expression;
    if ((when === null || when === void 0 ? void 0 : when.expression) === undefined) {
        return state;
    }
    if (!isConditionExpressionFromLastApiOrFromExpect(condition.expr, (_b = (_a = state.previousApi) === null || _a === void 0 ? void 0 : _a.apply) === null || _b === void 0 ? void 0 : _b.getName())) {
        return state.withError(ValidationErrorFactory.ConditionWhenMustCompareApiResponse({
            expr: getExpressionIfLocField(when, when.context),
        }));
    }
    return state;
    // check that the first expression in each conditional block is another ConditionalBranch, API invocation, Notify Response or Confirm Action
    function validateFirstExpressionInCondition() {
        return condition.flow
            .interpret(function visit(expr, block) {
            var _a;
            if (expr.isEnd() || !isInCondition(expr)) {
                // This Expression does not exist within the ConditionalBranch, so let the "a condition must contain at least one expression" validator catch this.
                return [
                    ValidationErrorFactory.ExprRequiredInConditionBlock({
                        expr: getExpressionIfLocField(block, condition),
                    }),
                ];
            }
            if (expr.isConditionalBranch()) {
                // if the next expression is a Conditional, it's valid
                return [];
            }
            if (expr.isBlock() && block === undefined) {
                // this is the first block encountered after the Conditional Branch, we should use this as the location of the errors.
                return (next) => visit(next, expr);
            }
            if (expr.isDialogExpansion() || expr.isEnsure() || expr.isConfirmArgs() || expr.isBlock()) {
                // if we encounter another conditional branch, dialog expansion or an ambient expression such as ensure or confirmArgs - continue evaluating the dialog flow
                return (expr) => visit(expr, block);
            }
            if (expr.isInvokeApi() || expr.isDelegateToIntent() || expr.isDelegateRequest()) {
                // we allow API invocations (including builtin delegation actions) and ConfirmAction
                // TODO: need to confirm whether ConfirmAction is allowed in a Conditional Branch. I can't remember why ... it doesn't seem to align with requirements?
                return [];
            }
            if (expr.isResponse()) {
                if (((_a = expr.act) === null || _a === void 0 ? void 0 : _a.type.isNotify()) === false) {
                    return [
                        ValidationErrorFactory.InvalidFirstResponseInConditionBlock({
                            expr: getExpressionIfLocField(expr.actNode, expr),
                        }),
                    ];
                }
                // Notify Response is valid, no error.
                return [];
            }
            return [
                ValidationErrorFactory.InvalidFirstExprInConditionBlock({
                    expr,
                }),
            ];
        }, condition)
            .flat();
    }
    /**
     * HACK: Check if this Expression is directly in the context of the ConditionalBranch being expanded.
     *
     * We need this hack because of a short-coming of interpret (ugh!) - we don't know when an Expression
     * in the Stream originated from within a Condition or outside, making this validation difficult.
     */
    function isInCondition(expr) {
        if (expr.flow.stack.length === 0) {
            return false;
        }
        for (const prevExpr of expr.flow.stack) {
            if (prevExpr.kind === "Condition") {
                return prevExpr === condition.flow.expression;
            }
        }
        return false;
    }
};
/**
 * Validates that a `delegateToIntent` call was not the previous expression.
 *
 * @param expr - Expression that is not allowed to follow delegation
 * @param state - EvaluationState
 */
export const validatePriorDelegation = (expr) => {
    const errors = [];
    const { prev } = expr;
    if ((prev === null || prev === void 0 ? void 0 : prev.isDelegateToIntent()) || (prev === null || prev === void 0 ? void 0 : prev.isDelegateRequest())) {
        const directive = prev;
        const callName = getCallName(expr);
        errors.push(ValidationErrorFactory.InvalidExpressionAfterDelegation({
            expr: expr,
            attributes: {
                directiveName: directive.apply.getShortName(),
                callName: callName,
            },
        }));
    }
    return errors;
    // Gets a name for the invalid expression call that wasn't allowed after the delegate directive.
    function getCallName(expression) {
        var _a, _b;
        if (expression.kind === "Action") {
            return (_a = expression.apply) === null || _a === void 0 ? void 0 : _a.getShortName();
        }
        return ask.isCall(expression.node) ? (_b = expression.node.name) === null || _b === void 0 ? void 0 : _b.name : undefined;
    }
};
/**
 * Returns true if the flow originated from a dialog call.
 */
function isFlowFromDialogCall(flow) {
    if ((flow === null || flow === void 0 ? void 0 : flow.stack.length) !== 1) {
        return false;
    }
    const stackNode = flow.stack[0];
    if ((stackNode === null || stackNode === void 0 ? void 0 : stackNode.kind) === "Call") {
        const apply = flow.checker.getApply(stackNode);
        return apply === null || apply === void 0 ? void 0 : apply.isDialog();
    }
    return false;
}
/**
 * Validates if response calls with 'Request' request acts are called consecutively
 */
export const validatePriorResponseCall = (response) => {
    var _a, _b, _c, _d;
    const errors = [];
    if ((_a = response.prev) === null || _a === void 0 ? void 0 : _a.isResponse()) {
        const reqAct = response.apply.getArgumentValue("act");
        const prevReqAct = response.prev.apply.getArgumentValue("act");
        if (((_b = reqAct === null || reqAct === void 0 ? void 0 : reqAct.name) === null || _b === void 0 ? void 0 : _b.name) === ((_c = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _c === void 0 ? void 0 : _c.name) && ((_d = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _d === void 0 ? void 0 : _d.name) === "Request") {
            errors.push(ValidationErrorFactory.InvalidEventInform({
                expr: response,
                attributes: {
                    requestAct: "Inform",
                },
            }));
        }
    }
    return errors;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZXZhbHVhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUM7QUFJN0IsT0FBTyxFQUFvQixrQkFBa0IsRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUU1RCxPQUFPLEVBQTJCLFNBQVMsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQW1CNUQsT0FBTyxFQUFDLHVCQUF1QixFQUFrQixzQkFBc0IsRUFBOEIsTUFBTSxpQkFBaUIsQ0FBQztBQUU3SCxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBTy9COztHQUVHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFDLElBQWlDLEVBQUUsS0FBc0I7SUFDMUYsbURBQW1EOztJQUVuRCxPQUFPO1FBQ0wsWUFBWSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFDdEQsTUFBQSxNQUFBLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTywwQ0FBRSxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLDZCQUE2QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsbUNBQUksRUFBRTtLQUN4RyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNaLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUFDLElBQVUsRUFBRSxLQUFzQjtJQUM3RCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxRQUFRLENBQUMsSUFBSSxFQUFFLFNBQVMsR0FBRyxLQUFLO1FBQzdELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ2hCLE9BQU8sV0FBVyxDQUFDLElBQUksRUFB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