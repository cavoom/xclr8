import * as ask from "./ast";
import { ParseError } from ".";
import { Type } from "./type";
import { Property } from "./property";
/**
 * Node in a tree useful to validate property paths in an utterance. See buildPropertyTree for details.
 */
export declare class PropertyNode {
    readonly property: Property;
    readonly propertyType: Type;
    readonly children: Map<string, PropertyNode>;
    /**
     *
     * @param property a Property in a type
     * @param propertyType the corresponding propertyType
     * @param children nodes corresponding to propertyType.Properties
     */
    constructor(property: Property, propertyType: Type, children?: Map<string, PropertyNode>);
    /**
     * Out of a string in Utterances<MealOrderType> like:
     *  'I want a {pizzaOrder.size} {pizzaOrder.pizzaType} pizza and a {drinkOrder.size} {drinkOrder.drinkType} drink'
     * This will build a tree like seen below where each Parenthesis is a Property with the given name and type:
     *
     *                                                    ('', MealOrderType)
     *
     *                 ('pizzaOrder', PizzaOrderType)                                      ('drinkOrder', DrinkOrderType)
     *
     *     ('pizzaType' ,PizzaType)          ('size', PizzaSizeType)             ('drinkType', DrinkType)        ('size', DrinkSizeType)
     *
     * In the process of building the tree 'no such property' errors can be produced.
     * With the tree, at each node, we can verify if the required properties have been specified
     * @param propertyPaths each ask.Name contains dot separate property path like 'pizzaOrder.size' plus its location for error messages.
     * @param type the type where all the first segments in propertyPaths are supposed to belong to.
     * @param context used for type's toString
     * @param getPropertyMap memoized type's getPropertyMap
     * @returns errors and the root of the tree
     */
    static buildPropertyTree(propertyPaths: ask.Name[], type: Type, context: ask.Node | undefined, getPropertyMap: (type: Type) => Map<string, Property>): {
        errors: ParseError[];
        root: PropertyNode;
    };
}
//# sourceMappingURL=property-node.d.ts.map