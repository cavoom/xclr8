import * as antlr from "antlr4ts";
import * as acdl from "./syntax";
import * as ask from "./ast";
import { sourceFile } from "./source-file";
import { Try } from "./try";
import { getNamespace, readFile, readFileSync, readJsonFile, readJsonFileSync, sanitize, trimScheme } from "./util";
import { ActionTypeName, AlexaConversations, AlexaSchema, DialogTypeName, FunctionTypeName } from "./ast";
import { ValidationErrorFactory } from "./error-factory";
export class Counter {
    constructor(counter = 0) {
        Object.defineProperty(this, "counter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: counter
        });
    }
    nextId() {
        this.counter += 1;
        return this.counter;
    }
}
export class ParseContext {
    constructor(uri, namespace, nameCounter, errors, scope, imports) {
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uri
        });
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: namespace
        });
        Object.defineProperty(this, "nameCounter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: nameCounter
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
        Object.defineProperty(this, "scope", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: scope
        });
        Object.defineProperty(this, "imports", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: imports
        });
    }
    hasOptionalImported() {
        return (this.imports.find((i) => (i.kind === "ImportName" && i.name === AlexaSchema.Optional) ||
            (i.kind === "ImportNamespace" && i.name === getNamespace(AlexaSchema.Optional))) !== undefined);
    }
    withScope(scope) {
        return new ParseContext(this.uri, this.namespace, this.nameCounter, this.errors, scope, this.imports);
    }
    addError(err) {
        this.errors.push(err);
    }
    newName() {
        return `var${this.nameCounter.nextId()}`;
    }
}
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
export function loadModuleFileSync(baseDir, uri) {
    const json = readJsonFileSync(trimScheme(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return sourceFile(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
export async function loadModuleFile(baseDir, uri) {
    const json = await readJsonFile(trimScheme(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return sourceFile(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
export function loadACDLFileSync(dir, uri, content) {
    return sourceFile(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : readFileSync(uri)));
}
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
export async function loadACDLFile(dir, uri, content) {
    return sourceFile(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : (await readFile(uri))));
}
/**
 * Parse an ACDL file.
 *
 * @param content ACDL file content
 */
export function parseACDLFile(uri, content) {
    const lexer = new acdl.ACDLLexer(antlr.CharStreams.fromString(content));
    const tokenStream = new antlr.CommonTokenStream(lexer);
    const parser = new acdl.ACDLParser(tokenStream);
    const errors = [];
    parser.removeErrorListeners();
    parser.addErrorListener({
        syntaxError: (recognizer, offendingSymbol, line, charPositionInLine, msg) => {
            errors.push(ValidationErrorFactory.SyntaxError({
                expr: {
                    uri,
                    loc: {
                        begin: { line, character: charPositionInLine },
                        end: { line, character: charPositionInLine },
                    },
                },
                overrideMessage: msg,
            }));
        },
    });
    let module;
    try {
        const unit = parser.module();
        const nameCounter = new Counter();
        const imports = [];
        const namespaceNode = Try(() => unit.namespaceDeclaration())
            .flatMap((ns) => Try(() => ns === null || ns === void 0 ? void 0 : ns.qualifiedName()))
            .getOrDefault(undefined);
        const context = new ParseContext(uri, namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, nameCounter, errors, [], imports);
        const namespace = new ask.Name(namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, namespaceNode ? parseLocation(namespaceNode) : undefined);
        unit.moduleExpression().forEach((expr) => {
            if (expr.importDeclaration()) {
                imports.push(new ask.Import(expr.importDeclaration().ASTERISK() ? "ImportNamespace" : "ImportName", expr.importDeclaration().qualifiedName().text, parseLocation(expr)));
            }
        });
        const expressions = unit
            .moduleExpression()
            .map((expr) => {
            if (expr.actionDeclaration()) {
                return parseActionDeclaration(expr.actionDeclaration(), context);
            }
            if (expr.dialogDeclaration()) {
                return parseDialogDeclaration(expr.dialogDeclaration(), context);
            }
            if (expr.interactionDeclaration()) {
                return parseInteractionDeclaration(expr.interactionDeclaration(), context);
            }
            if (expr.qualifiedNameDeclaration()) {
                return parseNameDeclaration(expr.qualifiedNameDeclaration(), context);
            }
            if (expr.typeDeclaration()) {
                return parseTypeDeclaration(expr.typeDeclaration(), context);
            }
            if (expr.enumDeclaration()) {
                return parseEnumDeclaration(expr.enumDeclaration(), context);
            }
            if (expr.expression()) {
                return parseExpression(expr.expression(), context);
            }
            return undefined;
        })
            .filter((e) => e !== undefined);
        const exports = expressions.map((e) => { var _a; return e.kind !== "InteractionDeclaration" && ((_a = e === null || e === void 0 ? void 0 : e.name) === null || _a === void 0 ? void 0 : _a.name); }).filter((n) => n !== undefined);
        module = new ask.Module(uri, ask.ModuleSchema, namespace, imports, exports, expressions);
    }
    catch (err) {
        module = undefined;
    }
    return [module, errors || undefined];
}
/**
 * Parse the qualified name component of a module-level declaration.
 *
 * That include:
 * - ActionDeclaration
 * - DialogDeclaration
 * - QualifiedNameDeclaration
 * - TypeDeclaration
 */
export function parseModuleLevelNameDeclaration(node, context) {
    let name = parseQualifiedName(node);
    if (name.name) {
        if (name.name.includes(".")) {
            name = new ask.Name(name.name, name.loc);
        }
        else if (context.namespace) {
            name = new ask.Name(`${context.namespace}.${name.name}`, name.loc);
        }
        else {
            name = new ask.Name(name.name, name.loc);
        }
    }
    return name;
}
export function parseEnumDeclaration(type, context) {
    return new ask.EnumDeclaration(parseModuleLevelNameDeclaration(type.qualifiedName(), context), type.enumItem().map((id) => parseEnumItem(id, context)), parseAnnotationList(type.annotationList(), context), parseJsDoc(type.jsdoc()), parseLocation(type));
}
export function parseEnumItem(item, context) {
    return new ask.EnumItem(parseIdentifier(item.identifier()), parseAnnotationList(item.annotationList(), context), parseJsDoc(item.jsdoc()), parseLocation(item));
}
export function parseAnnotationList(annotationList, context) {
    var _a;
    const list = ((_a = annotationList === null || annotationList === void 0 ? void 0 : annotationList.annotation()) === null || _a === void 0 ? void 0 : _a.map((annotation) => new ask.Annotation(parseCall(annotation.call(), context)), undefined)) || undefined;
    if (list === undefined || list.length === 0) {
        return undefined;
    }
    return list;
}
export function parseTypeDeclaration(type, context) {
    var _a;
    const name = parseModuleLevelNameDeclaration(type.qualifiedName(), context);
    return new ask.TypeDeclaration(name, sanitize(Try(() => type.typeProperties())
        .flatMap((typeBody) => Try(() => typeBody === null || typeBody === void 0 ? void 0 : typeBody.typeProperty()).map((typeProperties) => typeProperties === null || typeProperties === void 0 ? void 0 : typeProperties.map((typeProperty) => parseTypeProperty(typeProperty, context))))
        .resolve(context)), sanitize(parseTypeArgumentDeclarations(type.typeArgumentDeclarations(), context)), sanitize((_a = type.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((e) => parseTypeReference(e.typeReference(), context))), parseAnnotationList(type.annotationList(), context), parseJsDoc(type.jsdoc()), parseLocation(type));
}
export function parseTypeArgumentDeclarations(args, context) {
    return args === null || args === void 0 ? void 0 : args.typeArgumentDeclaration().map((arg) => parseTypeArgumentDeclaration(arg, context));
}
export function parseTypeArgumentDeclaration(arg, context) {
    var _a;
    return new ask.TypeParameter(parseIdentifier(arg.identifier()), sanitize((_a = arg.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((constraint) => parseTypeReference(constraint.typeReference(), context))), parseLocation(arg));
}
export function parseTypeReference(reference, context) {
    var _a, _b;
    let loc;
    if (reference.typeArguments() === undefined) {
        loc = parseIdentifierLocation(reference.qualifiedName());
    }
    else {
        loc = parseLocation(reference);
    }
    return new ask.TypeReference(Try(() => reference.qualifiedName())
        .map((name) => parseQualifiedName(name))
        .resolve(context), sanitize((_b = (_a = reference
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context))), parseAnnotationList(reference.annotationList(), context), undefined, loc);
}
export function parseTypeProperty(property, context) {
    return new ask.TypeProperty(property.identifier() ? parseIdentifier(property.identifier()) : undefined, Try(() => property.typeReference())
        .map((t) => parseTypeReference(t, context))
        .resolve(context), Try(() => property.OPTIONAL())
        .map((o) => !!o)
        .resolve(context), parseAnnotationList(property.annotationList(), context), parseJsDoc(property.jsdoc()), parseLocation(property));
}
export function parseNamespaceDeclaration(namespace, context) {
    return new ask.Name(Try(() => namespace.qualifiedName())
        .map((name) => name.text)
        .resolve(context), parseLocation(namespace));
}
export function parseDialogDeclaration(dialog, context) {
    const functionDecl = parseFunctionSignature(dialog.functionSignature(), context);
    return new ask.DialogDeclaration(functionDecl.name, functionDecl.args, Try(() => dialog.dialogScope())
        .flatMap((body) => Try(() => body === null || body === void 0 ? void 0 : body.sampleDeclaration()).map((samples) => (samples === null || samples === void 0 ? void 0 : samples.map((s) => parseSampleDeclaration(s, context))) || []))
        .resolve(context), functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(dialog.annotationList(), context), parseJsDoc(dialog.jsdoc()), parseLocation(dialog));
}
export function parseSampleDeclaration(sample, context) {
    return new ask.Sample(Try(() => sample.block())
        .map((_) => parseScope(_, context, ask.Block))
        .resolve(context), parseAnnotationList(sample.annotationList(), context), parseLocation(sample));
}
export function parseScope(body, context, ctor) {
    return Try(() => body.blockExpression())
        .map((expressions) => {
        const scopeExpressions = [];
        const scopeContext = context;
        for (const expr of expressions) {
            const parsedExpr = parseScopeExpression(expr, scopeContext);
            if (parsedExpr !== undefined) {
                scopeExpressions.push(parsedExpr); // TODO: assert
            }
        }
        return new ctor(scopeExpressions, parseLocation(body));
    })
        .resolve(context);
}
export function parseScopeExpression(expr, context) {
    if (expr.nameDeclaration()) {
        return parseNameDeclaration(expr.nameDeclaration(), context);
    }
    if (expr.expression()) {
        return parseExpression(expr.expression(), context);
    }
    return undefined;
}
export function parseInteractionDeclaration(expr, context) {
    return new ask.InteractionDeclaration(Try(() => expr.block())
        .map((_) => parseScope(_, context, ask.InteractionScope))
        .resolve(context), parseAnnotationList(expr.annotationList(), context), parseLocation(expr));
}
export function parseExpression(expr, context) {
    if (expr instanceof acdl.ParenthesizedExprContext) {
        return Try(() => expr.expression())
            .map((expr) => parseExpression(expr, context))
            .resolve(context);
    }
    if (expr instanceof acdl.LiteralExprContext || expr instanceof acdl.LiteralContext) {
        return parseLiteral(expr, context).resolve(context);
    }
    if (expr instanceof acdl.ObjectContext) {
        return Try(() => parseObject(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.PropertyReferenceContext) {
        return parsePropertyReference(expr, context);
    }
    if (expr instanceof acdl.ListIndexContext) {
        return Try(() => parseListIndex(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.CallExprContext) {
        return Try(() => parseCall(expr.call(), context)).resolve(context);
    }
    if (expr instanceof acdl.BinaryExprContext) {
        return parseBinaryExpression(expr, context).resolve(context);
    }
    if (expr instanceof acdl.NameDeclarationContext || expr instanceof acdl.QualifiedNameDeclarationContext) {
        return Try(() => parseNameDeclaration(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.ConditionExprContext) {
        return Try(() => parseCondition(expr.condition(), context)).resolve(context);
    }
    if (expr instanceof acdl.CorrectionExprContext) {
        return Try(() => parseCorrection(expr.correction(), context)).resolve(context);
    }
    if (expr instanceof acdl.IdentifierExprContext) {
        return parseNameReference(expr, context);
    }
    if (expr instanceof acdl.IsExprContext) {
        return parseIsOperator(expr, context);
    }
    if (expr instanceof acdl.InExprContext) {
        return parseInOperator(expr, context);
    }
    const errorFactory = expr.text
        ? ValidationErrorFactory.UnexpectedOperatorWithText
        : ValidationErrorFactory.UnexpectedOperator;
    const error = errorFactory({
        expr: {
            uri: context.uri,
            loc: parseLocation(expr),
        },
        attributes: {
            expressionText: expr.text,
            constructorName: expr.constructor.name,
        },
    });
    context.addError(error);
    return undefined;
}
export function parseNameReference(expr, context) {
    return new ask.NameReference(parseIdentifier(expr.identifier()), undefined, parseIdentifierLocation(expr.identifier()));
}
export function parsePropertyReference(expr, context) {
    var _a, _b;
    const child = parseExpression(expr.expression(), context); // TODO: type check
    if (child === undefined) {
        return undefined;
    }
    const id = parseIdentifier(expr.identifier());
    const loc = parseLocation(expr);
    if (loc) {
        loc.end = (_b = (_a = id === null || id === void 0 ? void 0 : id.loc) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : loc.end;
    }
    const prop = new ask.PropertyReference(id, child, undefined, loc);
    return prop;
}
export function parseCondition(expr, context) {
    var _a, _b, _c, _d;
    const loc = parseLocation(expr);
    let elseScope;
    if (((_a = expr.otherwise()) === null || _a === void 0 ? void 0 : _a.condition()) !== undefined) {
        const elseIfCondition = parseCondition((_b = expr.otherwise()) === null || _b === void 0 ? void 0 : _b.condition(), context);
        elseScope = new ask.ElseScope(elseIfCondition ? [elseIfCondition] : undefined);
    }
    else if (((_c = expr.otherwise()) === null || _c === void 0 ? void 0 : _c.block()) !== undefined) {
        elseScope = parseScope((_d = expr.otherwise()) === null || _d === void 0 ? void 0 : _d.block(), context, ask.ElseScope);
    }
    return new ask.Condition(new ask.When(Try(() => expr.expression())
        .map((when) => parseExpression(when, context))
        .resolve(context)), // TODO: check,
    Try(() => expr.block())
        .map((body) => (body ? parseScope(body, context, ask.ThenScope) : undefined))
        .resolve(context), elseScope, undefined, loc);
}
export function parseCorrection(expr, context) {
    return new ask.Correction(Try(() => expr.block(0))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), Try(() => expr.block(1))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), parseLocation(expr));
}
export function parseBinaryExpression(expr, context) {
    const loc = parseLocation(expr);
    return Try(() => {
        if (expr._left) {
            return new ask.Call(new ask.Name(parseBooleanOperator(expr, context)), [asArgumentValue(expr._left, "left"), asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        if (expr.NOT()) {
            return new ask.Call(new ask.Name(AlexaConversations.Not), [asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        throw [
            ValidationErrorFactory.UnexpectedBooleanExpression({
                expr: {
                    loc,
                },
                attributes: {
                    expressionText: expr.text,
                },
            }),
        ];
    });
    function asArgumentValue(expr, name) {
        return new ask.Argument(new ask.Name(name), undefined, parseExpression(expr, context), parseLocation(expr));
    }
}
export function parseBooleanOperator(expr, context) {
    var _a, _b, _c, _d, _e, _f;
    const loc = parseLocation(expr);
    if (expr.AND()) {
        return AlexaConversations.And;
    }
    if (expr.OR()) {
        return AlexaConversations.Or;
    }
    if ((_a = expr.relational()) === null || _a === void 0 ? void 0 : _a.GE()) {
        return AlexaConversations.Gte;
    }
    if ((_b = expr.relational()) === null || _b === void 0 ? void 0 : _b.GT()) {
        return AlexaConversations.Gt;
    }
    if ((_c = expr.relational()) === null || _c === void 0 ? void 0 : _c.LE()) {
        return AlexaConversations.Lte;
    }
    if ((_d = expr.relational()) === null || _d === void 0 ? void 0 : _d.LT()) {
        return AlexaConversations.Lt;
    }
    if ((_e = expr.equality()) === null || _e === void 0 ? void 0 : _e.EQUAL()) {
        return AlexaConversations.Eq;
    }
    if ((_f = expr.equality()) === null || _f === void 0 ? void 0 : _f.NOTEQUAL()) {
        return AlexaConversations.Neq;
    }
    context.addError(ValidationErrorFactory.UnexpectedBooleanOperator({
        expr: {
            loc,
        },
        attributes: {
            expressionText: expr.text,
        },
    }));
    return undefined;
}
export function parseCall(expr, context) {
    var _a, _b;
    const name = Try(() => expr.qualifiedName())
        .map((fqn) => parseQualifiedName(fqn))
        .resolve(context);
    const args = Try(() => expr.callArguments())
        .flatMap((list) => Try(() => list === null || list === void 0 ? void 0 : list.callArgument()).map((argumentList) => argumentList === null || argumentList === void 0 ? void 0 : argumentList.map((a, i) => parseArgumentValue(a, context, i))))
        .resolve(context);
    const genericArguments = sanitize((_b = (_a = expr
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context)));
    return new ask.Call(name, args, genericArguments, undefined, parseLocation(expr));
}
export function parseArgumentValue(argument, context, index) {
    const name = Try(() => argument.identifier())
        .map((i) => (i ? parseIdentifier(i) : undefined))
        .resolve(context);
    const value = Try(() => argument.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context); // TODO: type-check
    const loc = name && name.loc && (value === null || value === void 0 ? void 0 : value.loc) ? ask.appendLocation(name.loc, value.loc) : value === null || value === void 0 ? void 0 : value.loc;
    return new ask.Argument(name, index, value, loc);
}
export function parseLiteral(literal, context) {
    const literalValue = literal.text;
    const litLoc = parseLocation(literal);
    const loc = {
        begin: litLoc.begin,
        end: {
            line: litLoc.begin.line,
            character: litLoc.begin.character + literal.text.length,
        },
    };
    return Try(() => {
        var _a;
        if (literal.null()) {
            return createLiteral(AlexaSchema.Void, null, loc);
        }
        if (literal.nothing()) {
            return createLiteral(AlexaSchema.Nothing, null, loc);
        }
        if (literal.string()) {
            const vars = parseSlotValues(literal);
            const text = literalValue.slice(1, literalValue.length - 1);
            let value = text;
            if (vars && vars.length > 0) {
                value = new ask.Utterance(text, vars.map((v) => parseUtteranceQualifiedName(v, literal.string())), parseLocation(literal));
            }
            return createLiteral(AlexaSchema.String, value, loc);
        }
        if (literal.number()) {
            const num = !literalValue.includes(".") ? parseInt(literalValue, 10) : parseFloat(literalValue);
            return createLiteral(AlexaSchema.Number, num, loc);
        }
        if (literal.bool()) {
            return createLiteral(AlexaSchema.Boolean, ((_a = literal.bool()) === null || _a === void 0 ? void 0 : _a.text.toLocaleLowerCase()) === "true", loc);
        }
        if (literal.object()) {
            return parseObject(literal.object(), context);
        }
        if (literal.list()) {
            return parseList(literal.list(), context);
        }
        console.error(literal);
        throw new Error("unexpected node type");
    });
}
export function parseSlotValues(string) {
    if (!string) {
        return undefined;
    }
    // capture '{slotValue}' from the string - slotValue can contain alphabets,numbers and special characters, or can be empty '{}'.
    // all specials characters except '_' and '.' are valid in some MFT cases. for ex. "What's the weather {date|tomorrow's} in {cityName|San Jose, CA} in North America"
    let regex = /{([- a-zA-Z 0-9 _.|,' \s ]+)*}/g;
    let match = string.text.match(regex);
    // remove braces from the match and ignore all values following the pipe '|'
    return match ? match.map((value) => value.replace(/{|}/g, "").split("|")[0]) : undefined;
}
export function parseUtteranceQualifiedName(fullName, context, prefix = "") {
    const lastDot = fullName.indexOf(".");
    const identifier = lastDot === -1 ? fullName : fullName.substring(lastDot + 1);
    const qualifier = lastDot === -1 ? undefined : fullName.substring(0, lastDot);
    return new ask.Name(qualifier === undefined ? `${prefix}${identifier}` : `${qualifier}.${identifier}`, getSlotLocation(context, identifier));
}
export function getSlotLocation(context, id) {
    const string = context.text;
    const stringLoc = parseLocation(context);
    const index = string.indexOf(`{${id}}`) + 1;
    let slotLocation = {
        begin: {
            line: stringLoc.begin.line,
            character: index,
        },
        end: {
            line: stringLoc.end.line,
            character: index + string.length,
        },
    };
    return slotLocation;
}
export function createLiteral(type, value, loc) {
    return new ask.Call(new ask.Name(type), value, undefined, undefined, loc);
}
export function parseIsOperator(expr, context) {
    return new ask.Call(new ask.Name(AlexaConversations.is /* TODO: map the IS token to a source location */), [new ask.Argument(new ask.Name("thing"), 0, parseExpression(expr.expression(), context))], [parseTypeReference(expr.typeReference(), context)]);
}
export function parseInOperator(expr, context) {
    return new ask.Call(new ask.Name(AlexaConversations.in), [
        new ask.Argument(new ask.Name("entity"), 0, parseExpression(expr.expression(0), context)),
        new ask.Argument(new ask.Name("entities"), 0, parseExpression(expr.expression(1), context)),
    ]);
}
export function parseObject(obj, context) {
    const objectType = Try(() => obj.typeReference())
        .map((type) => (type ? parseTypeReference(type, context) : undefined))
        .resolve(context);
    return new ask.Call(objectType === null || objectType === void 0 ? void 0 : objectType.name, Try(() => obj.objectKeyValue())
        .map((pairs) => pairs.map((pair) => parseObjectProperty(pair, context)))
        .resolve(context), objectType === null || objectType === void 0 ? void 0 : objectType.arguments, undefined, parseLocation(obj));
}
export function parseObjectProperty(member, context) {
    const name = parseIdentifier(member.identifier());
    const expr = member.expression();
    const value = (expr === undefined
        ? // if no value is explicitly provided, default to a name reference
            // name = "hello"
            // person Person { name }
            // equiv. { name = name }
            new ask.NameReference(name, undefined, name.loc)
        : parseExpression(expr, context));
    return new ask.Argument(name, undefined, value, parseLocation(member));
}
/**
 * Parse a List literal to a call
 *
 * ```
 * list = ["a", "b"]
 * // or
 * list = List<String> ["a", "b"]
 *
 * // translates to an internal representations
 * alexa.lang.expression<List<String>>(items = ["a", "b"])
 * ```
 *
 * @param expr
 * @param parent
 * @param errors
 */
export function parseList(expr, context) {
    const loc = parseLocation(expr);
    const list = new ask.ListLiteral(expr
        .expression()
        .map((expr, index) => new ask.ListItem(parseExpression(expr, context), index, parseLocation(expr))), loc);
    return new ask.Call(undefined, list, undefined, undefined, parseLocation(expr));
}
/**
 * Parse syntactic sugar for accessing a list.
 *
 * ```
 * List<String> list = ...
 *
 * // access a list by index 0
 * list[0]
 *
 * // is syntactic sugar for the `inList` action:
 * com.amazon.alexa.ask.conversations.inList(list = list, index = 0)
 * com.amazon.alexa.ask.conversations.inList(list, 0)
 * ```
 *
 * TODO: support accessing properties in a List.
 * ```
 * // how should we translate this?
 * c = list[0].a.b.c
 *
 * // perhaps generate a variable for the result of accessing the list
 * var1 = inList(list, 0)
 * // and then a name expression?
 * c = var1.a.b.c
 * ```
 *
 * @param expr syntax for the list
 * @param parent
 * @param errors
 */
export function parseListIndex(expr, context) {
    const list = parseExpression(expr.expression(), context); // TODO: type-check
    const listArg = new ask.Argument(new ask.Name("list"), 0, list, parseLocation(expr));
    const indexNumber = Try(() => parseInt(expr.number().text, 10)).resolve(context);
    const indexLiteral = createLiteral(AlexaSchema.Number, indexNumber, parseLocation(expr.number()));
    const indexArg = new ask.Argument(new ask.Name("index"), 1, indexLiteral);
    return new ask.Call(new ask.Name(AlexaConversations.getListItem), [listArg, indexArg], undefined, undefined, parseLocation(expr));
}
export function parseActionDeclaration(action, context) {
    const functionDecl = parseFunctionSignature(action.functionSignature(), context);
    return new ask.ActionDeclaration(functionDecl.name, functionDecl.args, functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(action.annotationList(), context), parseJsDoc(action.jsdoc()), parseLocation(action));
}
export function parseFunctionSignature(action, context, isTopLevel = true) {
    var _a, _b;
    let returnType;
    const _void = action.void();
    if (_void !== undefined || action.typeReference() === undefined) {
        returnType = new ask.TypeReference(new ask.Name(AlexaSchema.Void), undefined, parseAnnotationList(_void === null || _void === void 0 ? void 0 : _void.annotationList(), context), undefined, _void ? parseLocation(_void) : undefined);
    }
    else {
        returnType = parseTypeReference(action.typeReference(), context);
    }
    const functionDecl = {
        name: isTopLevel
            ? parseModuleLevelNameDeclaration((_a = action.qualifiedName()) !== null && _a !== void 0 ? _a : action.identifier(), context)
            : parseQualifiedName((_b = action.qualifiedName()) !== null && _b !== void 0 ? _b : action.identifier()),
        // TODO: what to do with this?
        args: Try(() => action.argumentDeclarations())
            .map((p) => (p ? parseArgumentDeclarations(p, context) : undefined))
            .resolve(context),
        returnType,
        genericArguments: parseTypeArgumentDeclarations(action.typeArgumentDeclarations(), context),
    };
    return functionDecl;
}
export function parseArgumentDeclarations(argumentDecls, context) {
    return argumentDecls.argumentDeclaration().map((p) => parseArgumentDeclaration(p, context));
}
export function parseArgumentDeclaration(argument, context) {
    var _a, _b;
    const defaultExpression = ((_a = argument.argumentDefault()) === null || _a === void 0 ? void 0 : _a.expression())
        ? parseExpression(argument.argumentDefault().expression(), context)
        : undefined;
    const isOptional = argument.OPTIONAL() !== undefined || ((defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.kind) === "Call" && ((_b = defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaSchema.Nothing);
    if (argument.functionArgumentDeclaration()) {
        return parseFunctionArgumentDeclaration(argument.functionArgumentDeclaration());
    }
    if (argument.standardArgumentDeclaration()) {
        return parseStandardArgumentDeclaration(argument.standardArgumentDeclaration());
    }
    // fatal error, only these two options should be possible.
    throw new Error(`could not parse argument declaration: ${argument.text}`);
    function parseStandardArgumentDeclaration(argDecl) {
        var _a, _b;
        let type;
        if (isOptional) {
            if ((argDecl === null || argDecl === void 0 ? void 0 : argDecl.typeReference()) !== undefined) {
                const innerType = parseTypeReference(argDecl.typeReference(), context);
                if (((_a = innerType.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Optional || (((_b = innerType.name) === null || _b === void 0 ? void 0 : _b.name) === "Optional" && context.hasOptionalImported())) {
                    // type is already Optional, flatten.
                    // innerType.parent = self;
                    type = innerType;
                }
                else {
                    type = new ask.TypeReference(new ask.Name(AlexaSchema.Optional), [innerType], undefined, // innerType.annotations?.map((a) => a.clone()),
                    undefined);
                }
            }
            else {
                type = new ask.TypeReference(new ask.Name(AlexaSchema.Optional), [new ask.TypeReference(new ask.Name(AlexaSchema.Nothing), undefined, undefined, undefined)], undefined, undefined);
            }
        }
        else if (argDecl.typeReference() !== undefined) {
            type = parseTypeReference(argDecl.typeReference(), context);
        }
        else {
            type = new ask.TypeReference(new ask.Name(AlexaSchema.Nothing), undefined, undefined);
        }
        return new ask.ArgumentDeclaration(argDecl.identifier() ? parseIdentifier(argDecl.identifier()) : undefined, type, defaultExpression, parseAnnotationList(argument.annotationList(), context), parseJsDoc(argument.jsdoc()), parseLocation(argument));
    }
    function parseFunctionArgumentDeclaration(fun) {
        var _a, _b, _c, _d, _e, _f, _g;
        const functionSignature = parseFunctionSignature(fun.functionSignature(), context, false);
        const functionArgumentNames = (_c = (_b = (_a = fun
            .functionSignature()
            .argumentDeclarations()) === null || _a === void 0 ? void 0 : _a.argumentDeclaration()) === null || _b === void 0 ? void 0 : _b.map((a, i) => {
            var _a, _b, _c, _d;
            // TODO: this is probably risky??? ACDL will give syntax error though ...
            const defaultArgName = `arg${i}`;
            if (a.standardArgumentDeclaration()) {
                return (_b = (_a = a.standardArgumentDeclaration().identifier()) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : defaultArgName;
            }
            if (a.functionArgumentDeclaration()) {
                return (_d = (_c = a.functionArgumentDeclaration().functionSignature().identifier()) === null || _c === void 0 ? void 0 : _c.text) !== null && _d !== void 0 ? _d : defaultArgName;
            }
            return defaultArgName;
        })) !== null && _c !== void 0 ? _c : [];
        const functionArity = functionArgumentNames.length;
        const typeRefLoc = ((_d = functionSignature.name) === null || _d === void 0 ? void 0 : _d.loc)
            ? ask.betweenLocations(parseLocation(fun), (_e = functionSignature.name) === null || _e === void 0 ? void 0 : _e.loc)
            : parseLocation(fun);
        const typeRefName = fun.ACTION()
            ? ActionTypeName(functionArity)
            : fun.DIALOG()
                ? DialogTypeName(functionArity)
                : FunctionTypeName(functionArity);
        const type = new ask.TypeReference(new ask.Name(typeRefName, typeRefLoc), [...((_g = (_f = functionSignature.args) === null || _f === void 0 ? void 0 : _f.map((arg) => arg.type /* use an object to represent undefined */)) !== null && _g !== void 0 ? _g : []), functionSignature.returnType], undefined, functionArgumentNames, typeRefLoc);
        return new ask.ArgumentDeclaration(functionSignature.name, isOptional ? new ask.TypeReference(new ask.Name(AlexaSchema.Optional, type.loc), [type]) : type, defaultExpression, parseAnnotationList(argument.annotationList(), context));
    }
}
/**
 * Parse a name initialization expression.
 *
 * ```acdl
 * a = <expr>
 * ```
 *
 * @param nameDecl name parse tree
 * @param parent parent expression
 */
export function parseNameDeclaration(nameDecl, context) {
    const name = nameDecl instanceof acdl.QualifiedNameDeclarationContext
        ? parseModuleLevelNameDeclaration(nameDecl.qualifiedName(), context)
        : parseIdentifier(nameDecl.identifier());
    const type = nameDecl.typeReference() ? parseTypeReference(nameDecl.typeReference(), context) : undefined;
    const expr = Try(() => nameDecl.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context);
    return new ask.NameDeclaration(name, type, expr, nameDecl instanceof acdl.QualifiedNameDeclarationContext ? parseAnnotationList(nameDecl.annotationList(), context) : undefined, parseJsDoc(nameDecl.jsdoc()), parseLocation(nameDecl));
}
/**
 * Parse an identifier.
 *
 * @param id identifier parse tree
 * @param context parse context
 */
export function parseIdentifier(id) {
    return new ask.Name(id.text === "<missing IDENTIFIER>" ? undefined : id.text, parseIdentifierLocation(id));
}
export function parseIdentifierLocation(id) {
    const location = parseLocation(id);
    const loc = {
        begin: {
            line: location.begin.line,
            character: location.begin.character,
        },
        end: {
            line: location.begin.line,
            character: location.begin.character + id.text.length,
        },
    };
    return loc;
}
/**
 * Parse a qualified name.
 *
 * @param name identifier or qualified name.
 * @param parent parent expression
 */
export function parseQualifiedName(name, prefix = "") {
    const fullName = name.text;
    const lastDot = fullName.indexOf(".");
    const identifier = lastDot === -1 ? fullName : fullName.substring(lastDot + 1);
    const qualifier = lastDot === -1 ? undefined : fullName.substring(0, lastDot);
    // TODO: match name with regex and report errors.
    return new ask.Name(qualifier === undefined ? `${prefix}${identifier}` : `${qualifier}.${identifier}`, parseIdentifierLocation(name));
}
/**
 * Parse the location from a node in the parse tree.
 *
 * @param node parse tree node.
 */
export function parseLocation(node) {
    var _a, _b;
    const begin = {
        line: node.start.line,
        character: node.start.charPositionInLine,
    };
    // Antlr only gives us the "start of token" position.
    // To get "end of token" position we need to add the token length,
    // plus we need to adjust the line and column if there are newlines in the token's text
    const stopTokenText = (_a = node.stop) === null || _a === void 0 ? void 0 : _a.text;
    const stopTokenLines = (stopTokenText === null || stopTokenText === void 0 ? void 0 : stopTokenText.split("\\n")) || [];
    // Stop token has no text - no adjustment is needed
    if ((Array.isArray(stopTokenLines) && stopTokenLines.length > 0) || ((_b = node.stop) === null || _b === void 0 ? void 0 : _b.type) === antlr.Token.EOF) {
        return {
            begin,
            end: {
                line: node.stop.line,
                character: node.stop.charPositionInLine + 1,
            },
        };
    }
    const lastLineLength = stopTokenLines[stopTokenLines.length - 1].length;
    const tokenEnd = stopTokenLines.length === 1 ? node.stop.charPositionInLine + stopTokenText.length : lastLineLength;
    return {
        begin,
        end: {
            line: node.stop.line + stopTokenLines.length - 1,
            character: tokenEnd + 1,
        },
    };
}
export function parseJsDoc(context) {
    return context === null || context === void 0 ? void 0 : context.text;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEtBQUssTUFBTSxVQUFVLENBQUM7QUFDbEMsT0FBTyxLQUFLLElBQUksTUFBTSxVQUFVLENBQUM7QUFDakMsT0FBTyxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUM7QUFFN0IsT0FBTyxFQUFDLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUVyRCxPQUFPLEVBQUMsR0FBRyxFQUFXLE1BQU0sT0FBTyxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxZQUFZLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUNsSCxPQUFPLEVBQUMsY0FBYyxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxPQUFPLENBQUM7QUFDeEcsT0FBTyxFQUFDLHNCQUFzQixFQUE4QixNQUFNLGlCQUFpQixDQUFDO0FBRXBGLE1BQU0sT0FBTyxPQUFPO0lBQ2xCLFlBQW9CLFVBQWtCLENBQUM7Ozs7O21CQUFuQjs7SUFBc0IsQ0FBQztJQUVwQyxNQUFNO1FBQ1gsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7Q0FDRjtBQUVELE1BQU0sT0FBTyxZQUFZO0lBQ3ZCLFlBQ2tCLEdBQVcsRUFDWCxTQUE2QixFQUM3QixXQUFvQixFQUNwQixNQUFvQixFQUNwQixLQUF1QixFQUN2QixPQUFxQjs7Ozs7bUJBTHJCOzs7Ozs7bUJBQ0E7Ozs7OzttQkFDQTs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7Ozs7OzttQkFDQTs7SUFDZixDQUFDO0lBRUcsbUJBQW1CO1FBQ3hCLE9BQU8sQ0FDTCxJQUFJLENBQUMsT0FB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