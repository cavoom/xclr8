import immutable from "immutable";
import * as ask from "./ast";
import { AlexaConversations, AlexaSchema, AlexaConversationsNamespace, isAnnotationTarget, AlexaSchemaNamespace, BuiltinsNamespace, } from "./ast";
import { Constants } from "./constants";
import { Type } from "./type";
import { ResponsePurpose } from "./responseInfo";
import { getName } from "./util";
/**
 * An Apply represents a Call to an Action, Dialog or Type.
 *
 * This class provides a lazily-evaluated API for querying this call's AST
 * for type checking and type inference.
 */
export class Apply {
    constructor(checker, call, decl, prev, returnType, argumentIndex, genericEnvironment, genericArguments) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "call", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: call
        });
        Object.defineProperty(this, "decl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: decl
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Apply"
        });
        Object.defineProperty(this, "argumentDeclarations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "argumentDeclIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "requiredArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "returnType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "arguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "genericEnvironment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (prev) {
            this.argumentDeclarations = prev.argumentDeclarations;
            this.argumentDeclIndex = prev.argumentDeclIndex;
            this.requiredArguments = prev.requiredArguments;
            this.returnType = returnType;
            this.arguments = argumentIndex;
            this.genericEnvironment = genericEnvironment;
            this.genericArguments = genericArguments;
        }
        else {
            if (decl.kind === "Type") {
                if (decl.isFunction()) {
                    this.argumentDeclarations = decl.getFunctionArgumentDeclarations();
                }
                else {
                    this.argumentDeclarations = decl.properties;
                }
            }
            else if (decl.kind === "TypeDeclaration") {
                this.argumentDeclarations = (_b = (_a = this.checker.instantiateTypeDeclaration(decl)) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.map((prop) => {
                    var _a, _b, _c;
                    const arg = new ask.ArgumentDeclaration(new ask.Name(prop.name), (_a = prop.type) === null || _a === void 0 ? void 0 : _a.toTypeReference(), undefined, (_c = (_b = prop.declaration) === null || _b === void 0 ? void 0 : _b.annotations) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), undefined);
                    decl.setAsParentOn(arg);
                    return arg;
                });
            }
            else {
                this.argumentDeclarations = decl.arguments;
            }
            if (this.argumentDeclarations) {
                (_c = this.argumentDeclarations) === null || _c === void 0 ? void 0 : _c.map((argDecl, index) => {
                    var _a;
                    const argName = typeof (argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === "string" ? argDecl.name : (_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name;
                    if (argName) {
                        this.argumentDeclIndex[argName] = argDecl;
                        this.argumentDeclIndex[index] = argDecl;
                    }
                });
            }
            const required = [];
            if (this.argumentDeclarations) {
                for (const arg of this.argumentDeclarations) {
                    const argName = typeof arg.name === "string" ? arg.name : (_d = arg.name) === null || _d === void 0 ? void 0 : _d.name;
                    if (argName && arg.type) {
                        if (arg.kind === "Property" &&
                            !arg.type.isOptional() &&
                            !arg.type.isArgs() &&
                            ((_e = arg.declaration) === null || _e === void 0 ? void 0 : _e.kind) === "TypeProperty" &&
                            ((_f = arg.declaration) === null || _f === void 0 ? void 0 : _f.optional) !== true) {
                            required.push(argName);
                        }
                        else if (arg.kind === "ArgumentDeclaration" &&
                            checker.qualifyName(arg, (_g = arg.type.name) === null || _g === void 0 ? void 0 : _g.name) !== AlexaSchema.Optional &&
                            checker.qualifyName(arg, (_h = arg.type.name) === null || _h === void 0 ? void 0 : _h.name) !== AlexaConversations.Args &&
                            arg.defaultExpression === undefined) {
                            required.push(argName);
                        }
                    }
                }
            }
            this.requiredArguments = [...required];
        }
    }
    /**
     * Instantiate this static Apply instance within a local TypeChecker environment.
     *
     * @param localChecker the new environment in which to instantiate the Apply.
     */
    instantiate(localChecker) {
        var _a, _b, _c;
        if (this.isList()) {
            return (_a = resolveType(this.getReturnType())) === null || _a === void 0 ? void 0 : _a.apply(this.call, localChecker);
        }
        const actionLocal = localChecker.getThing(this.checker.lookupCallDeclaration(this.call));
        if (actionLocal === undefined || actionLocal.origin === undefined || actionLocal.origin.kind === "ArgumentDeclaration") {
            // we only support instantiating actions for concrete Action/Dialog Declaration expressions.
            return undefined;
        }
        return new Apply(localChecker, this.call, actionLocal.origin, this, resolveType(this.getReturnType()), this.getArguments(), undefined, // this.getGenericEnvironment(),
        (_c = (_b = this.getGenericArguments()) === null || _b === void 0 ? void 0 : _b.map((t) => resolveType(t))) !== null && _c !== void 0 ? _c : null);
        // resolve type parameters
        function resolveType(type, hasTypeParameters = type === null || type === void 0 ? void 0 : type.hasTypeParameters()) {
            var _a, _b, _c, _d;
            if (type === undefined) {
                return undefined;
            }
            if (hasTypeParameters === false) {
                return type;
            }
            if (((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
                return (_c = (_b = localChecker.types) === null || _b === void 0 ? void 0 : _b.get(type.declaration)) !== null && _c !== void 0 ? _c : type;
            }
            return new Type(type.checker, type.declaration, (_d = type.genericArguments) === null || _d === void 0 ? void 0 : _d.map((t) => resolveType(t, hasTypeParameters)), type.functionArgumentNames);
        }
    }
    isList() {
        return this.decl.kind === "Type" && this.decl.isList();
    }
    getListItems() {
        if (this.isList() && ask.isListLiteral(this.call.arguments)) {
            return this.call.arguments.items.map((item) => item.item);
        }
        return undefined;
    }
    isArgs() {
        return this.decl.kind === "Type" && this.decl.isArgs();
    }
    isType() {
        return (this.decl.kind === "Type" && !this.decl.isFunction()) || this.decl.kind === "TypeDeclaration";
    }
    isIs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.is;
    }
    isIsInCatalog() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.isInCatalog;
    }
    isIn() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.in;
    }
    isWhen() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.when;
    }
    isEq() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Eq;
    }
    isNeq() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Neq;
    }
    isAnd() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.And;
    }
    isOr() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Or;
    }
    isNot() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Not;
    }
    isGt() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Gt;
    }
    isGte() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Gte;
    }
    isLt() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Lt;
    }
    isLte() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Lte;
    }
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.skill` action.
     */
    isSkillAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.skill;
    }
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.Skill` type.
     */
    isSkillType() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Skill;
    }
    /**
     * Checks if this apply is targeting the core `annotation` action.
     */
    isAnnotationAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.annotation;
    }
    /**
     * Checks if the target of this Apply is an action annotated with the `@annotation` meta-annotation?
     */
    isAnnotation() {
        var _a;
        return (this.isAction() &&
            this.decl.kind === "ActionDeclaration" &&
            ((_a = this.decl.annotations) === null || _a === void 0 ? void 0 : _a.find((a) => this.checker.qualifyName(this.decl, a.call.name) === AlexaConversations.annotation)) !== undefined);
    }
    /**
     * Get the `allowMultiple` field from an instance of the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * @returns true/false if this is an instance of `Annotation`, otherwise `undefined.
     */
    getAnnotationAllowMultiple() {
        if (this.isAnnotationAction()) {
            const allowMultiple = this.getArgumentValueAndResolveToCallIfNameRef("allowMultiple");
            if ((allowMultiple === null || allowMultiple === void 0 ? void 0 : allowMultiple.kind) === "Call" && typeof allowMultiple.arguments === "boolean") {
                return allowMultiple.arguments;
            }
            return false;
        }
        return undefined;
    }
    /**
     * Get the `targets` field if this is a call to the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * Ex.
     * ```
     * // returns [AnnotationTarget.Type]
     * @Annotation(targets = [AnnotationTarget.Type])
     * ..
     * ```
     */
    getAnnotationTargets() {
        if (this.isAnnotationAction()) {
            const annotationTargets = this.getArgumentValueAndResolveToCallIfNameRef("targets");
            if ((annotationTargets === null || annotationTargets === void 0 ? void 0 : annotationTargets.kind) === "Call" && ask.isListLiteral(annotationTargets.arguments)) {
                return annotationTargets.arguments.items
                    .map((item) => {
                    var _a, _b, _c, _d;
                    if (((_a = item.item) === null || _a === void 0 ? void 0 : _a.kind) === "PropertyReference") {
                        const name = (_b = item.item.name) === null || _b === void 0 ? void 0 : _b.name;
                        const exprType = this.checker.getType(item.item.expression);
                        // if this is a reference to `enum AnnotationTarget`, then its type should be `Type<AnnotationTarget>`.
                        const isAnnotationTargetEnum = (exprType === null || exprType === void 0 ? void 0 : exprType.isType()) && ((_c = exprType.getTypeType()) === null || _c === void 0 ? void 0 : _c.isAnnotationTarget()); // getTypeType() => AnnotationTarget type
                        if (isAnnotationTargetEnum && isAnnotationTarget(name)) {
                            // ex. AnnotationTarget.Dialog
                            // name => Dialog
                            // exprType => Type<AnnotationTarget>
                            // yields AnnotationTarget.Dialog
                            return name;
                        }
                    }
                    else if (((_d = item.item) === null || _d === void 0 ? void 0 : _d.kind) === "NameReference") {
                    }
                    return undefined;
                })
                    .filter((t) => t !== undefined);
            }
        }
        return undefined;
    }
    isAction() {
        return this.decl.kind === "ActionDeclaration" || (this.decl.kind === "Type" && this.decl.isAction());
    }
    isBuiltin() {
        var _a, _b;
        return ((_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(AlexaConversationsNamespace)) || false;
    }
    isUserDefinedApi() {
        var _a;
        return (this.isAction() || (this.decl.kind === "Type" && ((_a = this.decl.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration")) && !this.isBuiltin();
    }
    isDialog() {
        return this.decl.kind === "DialogDeclaration" || (this.decl.kind === "Type" && this.decl.isDialog());
    }
    isBinaryOperator() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && Constants.BINARY_OPERATOR_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    isOperator() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && Constants.OPERATOR_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    // This method tracks the legal data binding function calls in ACDL syntax. Might need a more precise name for this function..
    isNativeAction() {
        return this.isSize() || this.isLength() || this.isExists() || this.isGetListItem() || this.isIs();
    }
    isFileAccessAction() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && Constants.FILE_ACCESS_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    isGetListItem() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.getListItem;
    }
    isEnsure() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ensure;
    }
    isExpect() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.expect;
    }
    isConfirmAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.confirmAction;
    }
    isConfirmActionAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmAction;
    }
    /**
     * Checks if this is a call to the `confirmArgs` action.
     */
    isConfirmArgs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.confirmArgs;
    }
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArgsAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmArgs;
    }
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmArguments;
    }
    isUtterances() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.utterances;
    }
    isTouch() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.touch;
    }
    isMultiModalEvent() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.multiModalEvent;
    }
    isEventDecl() {
        return this.isUtterances() || this.isTouch() || this.isMultiModalEvent() || this.isIntent();
    }
    isCatalogDecl() {
        return this.isListBasedCatalogAction() || this.isExtendCatalogAction() || this.isBuiltinCatalogAction();
    }
    isUtterance() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Utterance;
    }
    isIntent() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.intent;
    }
    isAlexaLine() {
        return this.isResponse() || this.isConfirmAction();
    }
    isResponse() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.response;
    }
    isDelegateToIntent() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.delegateToIntent;
    }
    isIntentRequest() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.IntentRequest;
    }
    isDelegateRequest() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.delegateRequest;
    }
    isReceived() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.received;
    }
    isRequestArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.RequestArguments;
    }
    isResetAllArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ResetAllArguments;
    }
    isResetArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ResetArguments;
    }
    isEnsureArgOrder() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.EnsureArgOrder;
    }
    isRequestAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Request;
    }
    isLength() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.length;
    }
    isAlexaSchemaNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(AlexaSchemaNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isAlexaConversationsNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(AlexaConversationsNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isAlexaBuiltinsNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(BuiltinsNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isSize() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.size;
    }
    isUserSays() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.userSays;
    }
    isExists() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.exists;
    }
    isEvents() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.events;
    }
    isWelcome() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.welcome;
    }
    isLocaleAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.locale;
    }
    isVarArgs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Args;
    }
    isValidateArg() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.validateArg;
    }
    isVariations() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.variations;
    }
    isAplaAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.apla;
    }
    isAplAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.apl;
    }
    isReferableAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.referable;
    }
    isCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.catalog;
    }
    isCatalogType() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Catalog;
    }
    isListBasedCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.listBasedCatalog;
    }
    isExtendCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.extendCatalog;
    }
    isBuiltinCatalogAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.builtinCatalog;
    }
    isGeneratedAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.generated;
    }
    isGetAllNamesAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.getAllNames;
    }
    getName() {
        var _a;
        return (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name;
    }
    getShortName() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) ? getName(this.decl.name.name) : undefined;
    }
    /**
     * Gets a Thing representing an Argument Value.
     *
     * @param name name of the argument value.
     * @returns a Thing representing the value (if it can be determined) or `undefined`.
     */
    getArgumentValueThing(name) {
        return this.checker.getThing(this.getArgumentValue(name));
    }
    /**
     * Gets a List of Thing representing all the argument values
     * @returns a List of Thing representing all the argument values
     */
    getArgumentValueThingList() {
        return this.getArgumentsList().map((argument) => this.checker.getThing(argument.value));
    }
    /**
     * Get the specific argument value by name
     * @param name name string or ask.Name
     */
    getArgumentValue(name) {
        var _a;
        return (_a = this.getArgument(name)) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Get the specific argument by name
     * @param name name string or ask.Name
     */
    getArgument(name) {
        var _a, _b, _c, _d;
        const args = this.getArguments();
        const nameStr = name === undefined
            ? undefined
            : typeof name === "string"
                ? name
                : name.kind === "Name"
                    ? name.name
                    : ((_b = (_a = name.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction()) && name.argumentName
                        ? (_d = (_c = name.parent.parent.concreteToAbstractArgumentNames) === null || _c === void 0 ? void 0 : _c[name.argumentName]) !== null && _d !== void 0 ? _d : name.argumentName
                        : name.argumentName;
        if (args !== undefined && nameStr !== undefined) {
            // return args[this.argumentNameMappings?.[nameStr] ?? nameStr];
            return args[nameStr];
        }
        return undefined;
    }
    /**
     * Get the specific argument value by name, if it's a nameReference, resolve it
     * @param name name string or ask.Name
     * @returns
     */
    getArgumentValueAndResolveIfNameRef(name) {
        const value = this.getArgumentValue(name);
        if (this.checker.isNameReference(value)) {
            return this.checker.resolveNameReference(value);
        }
        return value;
    }
    /**
     * Get the specific argument value by name, if the value kind is nameReference, resolve it to the call
     *
     * E.G.
     * ```
     * apla = APLA {}
     * temp = apla
     * response(temp, Bye {})
     *
     * if we have the response apply
     * apply.getArgumentValueAndResolveToCallIfNameRef('response') => APLA {}
     * ```
     * @param name name string or ask.Name
     */
    getArgumentValueAndResolveToCallIfNameRef(name) {
        const value = this.getArgumentValue(name);
        if (this.checker.isNameReference(value)) {
            return this.checker.resolveNameReferenceToCall(value);
        }
        return value;
    }
    getArgumentsList() {
        var _a;
        return Object.values((_a = this.getArguments()) !== null && _a !== void 0 ? _a : {});
    }
    getArgumentsThing() {
        var _a;
        return Object.entries((_a = this.getArguments()) !== null && _a !== void 0 ? _a : {})
            .map(([name, arg]) => ({
            [name]: this.checker.getThing(arg),
        }))
            .reduce((a, b) => ({ ...a, ...b }), {});
    }
    /**
     * Get a map or argument name to the ArgumentValue node passed to this call.
     */
    getArguments() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.arguments === undefined) {
            this.arguments = {};
            if (this.call.arguments === undefined || Array.isArray(this.call.arguments)) {
                let isPositionalAllowed = true;
                let i = 0;
                let loc;
                for (const argument of this.call.arguments || []) {
                    if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                        isPositionalAllowed = false;
                        this.arguments[argument.name.name] = argument;
                    }
                    else if (argument.index !== undefined) {
                        if (isPositionalAllowed) {
                            const argDecl = (_b = this.argumentDeclarations) === null || _b === void 0 ? void 0 : _b[i];
                            const isVarArgs = argDecl !== undefined &&
                                ((_c = argDecl.type) === null || _c === void 0 ? void 0 : _c.name) &&
                                this.checker.qualifyName(argDecl.type.name, argDecl.type.name.name) === AlexaConversations.Args;
                            const argName = typeof (argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === "string" ? argDecl.name : (_d = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _d === void 0 ? void 0 : _d.name;
                            // argName = argName ? this.argumentNameMappings?.[argName] ?? argName : argName;
                            if (argName) {
                                if (isVarArgs) {
                                    // if this is a var-args, construct a list literal call
                                    let arg = this.arguments[argName];
                                    let listCall = arg === null || arg === void 0 ? void 0 : arg.value;
                                    let list = listCall === null || listCall === void 0 ? void 0 : listCall.arguments;
                                    if (list === undefined) {
                                        list = new ask.ListLiteral([]);
                                        listCall = new ask.Call(new ask.Name(AlexaConversations.Args), list, undefined);
                                        arg = new ask.Argument(undefined, argument.index, listCall);
                                        this.call.setAsParentOn(arg);
                                        this.arguments[argName] = arg;
                                    }
                                    const item = new ask.ListItem((_e = argument === null || argument === void 0 ? void 0 : argument.value) === null || _e === void 0 ? void 0 : _e.clone(), list.items.length);
                                    list.setAsParentOn(item);
                                    list.items.push(item);
                                    if (loc && ((_f = argument.loc) === null || _f === void 0 ? void 0 : _f.end)) {
                                        loc.end = (_g = argument === null || argument === void 0 ? void 0 : argument.loc) === null || _g === void 0 ? void 0 : _g.end;
                                    }
                                    else {
                                        loc = argument.loc;
                                    }
                                    listCall.loc = loc;
                                }
                                else {
                                    this.arguments[argName] = argument;
                                    i += 1; // increment the declaration index only if we're not var-args
                                }
                            }
                        }
                    }
                }
            }
        }
        return this.arguments || undefined;
    }
    /**
     * Get the return type of this call.
     *
     * Infers generic arguments and computing generic return type if necessary
     *
     * @returns the return type if it is known, otherwise `undefined`.
     */
    getReturnType(seen) {
        var _a, _b;
        if (this.returnType === undefined) {
            this.returnType = (_a = this.resolveReturnType(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.returnType) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveReturnType(seen) {
        if (this.decl.kind === "Type") {
            if (this.decl.isFunctionN()) {
                return this.decl.getFunctionReturnType();
            }
            if (this.decl.isFunction()) {
                return this.checker.thing;
            }
            return this.decl;
        }
        if (this.decl.genericArguments === undefined) {
            if (this.decl.kind === "TypeDeclaration") {
                return this.checker.instantiateTypeDeclaration(this.decl);
            }
            return this.checker.instantiateTypeReference(this.decl.returnType);
        }
        if (this.decl.kind === "TypeDeclaration") {
            const args = this.getGenericArguments(seen);
            if (args !== undefined) {
                return this.checker.instantiateTypeDeclaration(this.decl, args);
            }
        }
        else {
            // ActionDeclaration and DialogDeclaration
            const env = this.getGenericEnvironment(seen);
            if (env !== undefined) {
                return this.checker.instantiateTypeReference(this.decl.returnType, env);
            }
        }
        return undefined;
    }
    /**
     * Get the type of an argument or property
     */
    getType(arg, context) {
        var _a, _b, _c;
        if (arg === undefined) {
            // `undefined` refers to a primitive expression's arguments, e.g. `null`, `string`, `[]`.
            if (this.decl.kind === "Type") {
                return this.decl;
            }
        }
        else if (arg.kind === "Argument") {
            const argDecl = ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) ? this.argumentDeclIndex[arg.name.name] : (_b = this.argumentDeclarations) === null || _b === void 0 ? void 0 : _b[arg.index];
            if (argDecl) {
                return this.getType(argDecl, context);
            }
        }
        else {
            const name = typeof arg.name === "string" ? arg.name : (_c = arg.name) === null || _c === void 0 ? void 0 : _c.name;
            const decl = this.argumentDeclIndex[name];
            if (decl.kind === "ArgumentDeclaration") {
                return this.checker.instantiateTypeReference(decl.type, this.getGenericEnvironment());
            }
            return decl.type;
        }
        return undefined;
    }
    /**
     * Retuns a mapping of generic argument names to their inferred type. For instance consider the action declaration:
     *
     *    action Nothing getWeather<T,K>(T something, K somethingElse)
     *
     * For the call/apply below:
     *    sample {
     *      ...
     *      getWeather('x', 1)
     *      ...
     *    }
     * The return value will be: { "T" : <Type object refering to string>, "K": <Type object refering to number>}
     *
     * For anonymous functions the generic arguments are also types as opposed to something like T or K above.
     * For instance consider the reusable dialog declaration containing an anonymous function receiving Optional<T>
     * and returning Nothing:
     *     dialog Nothing reusableDialog<T>( Action1<Optional<T>, Nothing> anonAction, T value) {
     *        sample {
     *            ...
     *            anonAction(value);
     *            ...
     *        }
     *     }
     * for the call/apply inside the sample the generic arguments are the types Optional<T> and Nothing
     * seen in Action1<Optional<T>, Nothing> anonAction
     * The return value for this call is {"T": <Type object refering to T>, "Nothing": <Type object refering to Nothing>}
     * @param seen used  to prevent infinite recursion in type lookups
     */
    getGenericEnvironment(seen) {
        var _a, _b;
        if (this.genericEnvironment === undefined) {
            this.genericEnvironment = this.genericEnvironment = (_a = this.resolveGetGenericEnvironment(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.genericEnvironment) !== null && _b !== void 0 ? _b : undefined;
    }
    /**
     * Does the actual work in getGenericEnvironment.
     * @param seen used  to prevent infinite recursion in type lookups
     */
    resolveGetGenericEnvironment(seen) {
        var _a;
        const genericArgumentTypes = this.getGenericArguments(seen);
        return (_a = this.decl.genericArguments) === null || _a === void 0 ? void 0 : _a.map((declGenericArgument, i) => {
            var _a;
            if ((declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.kind) === "TypeParameter") {
                const type = genericArgumentTypes === null || genericArgumentTypes === void 0 ? void 0 : genericArgumentTypes[i];
                return type ? { [(_a = declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.name) === null || _a === void 0 ? void 0 : _a.name]: type } : {};
            }
            else if ((declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.kind) === "Type") {
                // The generic argument here might look like Apply<Optional<T>,K>. We need to find nested generic arguments T and K.
                // Because of that, one generic argument like Apply<Optional<T>,K> might turn into many: [T,K]. The map below will
                // add a nested dimension to the array that will be flatened below.
                const nestedGenericArguments = declGenericArgument.getNestedGenericArguments();
                return nestedGenericArguments.map((nestedGenericArgument) => {
                    var _a;
                    return { [(_a = nestedGenericArgument === null || nestedGenericArgument === void 0 ? void 0 : nestedGenericArgument.name) === null || _a === void 0 ? void 0 : _a.name]: nestedGenericArgument };
                });
            }
            else {
                return {};
            }
        }).flat().reduce((a, b) => ({ ...a, ...b }), {});
    }
    getGenericArguments(seen) {
        var _a, _b;
        if (this.genericArguments === undefined) {
            this.genericArguments = (_a = this.resolveGenericArguments(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.genericArguments) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveGenericArguments(seen) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.decl.kind === "Type" && this.decl.genericArguments !== undefined) {
            // TODO: infer
            return this.decl.genericArguments;
        }
        if (this.decl.genericArguments === undefined) {
            return undefined;
        }
        if (((_a = this.call.genericArguments) === null || _a === void 0 ? void 0 : _a.length) === this.decl.genericArguments.length) {
            return this.call.genericArguments.map((a) => { var _a; return (_a = this.checker.instantiateTypeReference(a)) !== null && _a !== void 0 ? _a : this.checker.thing; });
        }
        if (this.call.genericArguments === undefined) {
            // infer the arguments from the values
            if (ask.isListLiteral(this.call.arguments) && this.decl.kind === "TypeDeclaration") {
                // we're instantiating a List declaration
                const listValueType = this.checker.getType(this.call.arguments, false, seen);
                const listDeclType = this.checker.instantiateTypeDeclaration(this.decl, this.decl.genericArguments.map((arg) => this.checker.instantiateTypeParameter(arg)));
                if (listValueType && listDeclType) {
                    // the list could be a complex sub type
                    // e.g. type MyList<A> : List<List<A>>
                    // e.g. type MyList2<A> : MyList<List<A>> : List<List<List<A>>
                    // ... so we first reduce it to the value's type
                    return this.decl.genericArguments.map((genericArg) => { var _a, _b; return (_b = inferTypeParameter((_a = genericArg.name) === null || _a === void 0 ? void 0 : _a.name, listDeclType, listValueType)) !== null && _b !== void 0 ? _b : this.checker.thing; });
                }
            }
            else {
                const declarations = this.decl.kind === "Type" ? this.decl.properties : this.argumentDeclarations;
                const args = this.getArguments();
                // store a mapping of Type Parameter to:
                // 1. `string` - another type parameter in the parameter list
                // 2. Type - a type inferred from the values
                const inferredTypes = {};
                // first pass over the generic arguments, infer what we can from the values
                for (const genericArg of this.decl.genericArguments) {
                    let inferredType;
                    if (args !== undefined && declarations !== undefined) {
                        for (const argDecl of declarations) {
                            const argName = typeof argDecl.name === "string" ? argDecl.name : (_b = argDecl.name) === null || _b === void 0 ? void 0 : _b.name;
                            const arg = args[argName];
                            if (arg === undefined || argDecl.type === undefined) {
                                continue;
                            }
                            const argType = this.checker.getType(arg.value, false, seen);
                            if (argType === undefined) {
                                continue;
                            }
                            const argDeclType = argDecl.kind === "ArgumentDeclaration" ? this.checker.instantiateTypeReference(argDecl.type) : argDecl.type;
                            if (argDeclType) {
                                const inferred = inferTypeParameter((_c = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _c === void 0 ? void 0 : _c.name, argDeclType, argType);
                                inferredType = (_d = inferredType === null || inferredType === void 0 ? void 0 : inferredType.union(inferred)) !== null && _d !== void 0 ? _d : inferred;
                            }
                        }
                    }
                    if (inferredType) {
                        // we found a value in the arguments that informs this generic argument
                        inferredTypes[(_e = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _e === void 0 ? void 0 : _e.name] = inferredType;
                    }
                    else if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) === "TypeParameter") {
                        // we did not find a value for the argument, let's see if there are default types
                        if (genericArg.constraints === undefined || genericArg.constraints.length === 0) {
                            // this parameter has no constraints, default to Thing.
                            inferredTypes[(_f = genericArg.name) === null || _f === void 0 ? void 0 : _f.name] = this.checker.thing;
                        }
                        else if (genericArg.constraints.length > 1) {
                            // this generic arg has multiple constraints, e.g. T : A : B
                            // we don't yet support this case, for now we will default it to Thing.
                            inferredTypes[(_g = genericArg.name) === null || _g === void 0 ? void 0 : _g.name] = this.checker.thing;
                        }
                        else if (genericArg.constraints.length === 1) {
                            // this generic arg has a single constrain, e.g. T : V
                            // default to that type
                            const defaultType = this.checker.getType(genericArg.constraints[0], undefined, seen);
                            if (((_h = defaultType === null || defaultType === void 0 ? void 0 : defaultType.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "TypeParameter") {
                                // if the constraint is another type parameter, e.g. <T : V, V>
                                // then use that name as a place-holder and attempt to resolve it in the final pass.
                                inferredTypes[(_j = genericArg.name) === null || _j === void 0 ? void 0 : _j.name] = (_k = defaultType.declaration.name) === null || _k === void 0 ? void 0 : _k.name;
                            }
                            else if (defaultType !== undefined) {
                                // this is a concrete type
                                inferredTypes[(_l = genericArg.name) === null || _l === void 0 ? void 0 : _l.name] = defaultType;
                            }
                        }
                    }
                }
                // second pass over generic arguments where we resolve the inference results
                return this.decl.genericArguments.map((genericArg) => { var _a, _b; return (_b = resolveInferredArg((_a = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _a === void 0 ? void 0 : _a.name)) !== null && _b !== void 0 ? _b : this.checker.thing; });
                /**
                 * Resolves a named argument from the results of the first pass.
                 */
                function resolveInferredArg(name, seen = immutable.Set()) {
                    if (name === undefined) {
                        return undefined;
                    }
                    const inferred = inferredTypes[name];
                    if (inferred === undefined) {
                        return undefined;
                    }
                    if (typeof inferred === "string") {
                        // the type is a place-holder referring to the inferred type of another generic argument
                        if (seen.has(inferred)) {
                            // encountered a loop, so the type is undefined.
                            return undefined;
                        }
                        // try and resolve the place-holder
                        return resolveInferredArg(inferred, seen.add(inferred));
                    }
                    if (inferred.genericArguments === undefined || inferred.genericArguments.length === 0) {
                        // this is a concrete type, terminate inference
                        return inferred;
                    }
                    // this is a generic type, we need to recursively resolve generic arguments that may be
                    // referencing other inferred generic arguments
                    // e.g foo<T : List<V>, V>(V value)
                    // foo("string")
                    // once we have inferred V => String
                    // we must then resolve T => List<V> => List<String>
                    return (function resolveType(type) {
                        if (type === undefined) {
                            return undefined;
                        }
                        if (type.genericArguments === undefined || type.genericArguments.length === 0) {
                            return type;
                        }
                        return new Type(type.checker, type.declaration, type.genericArguments.map((arg) => {
                            var _a, _b;
                            if (((_a = arg === null || arg === void 0 ? void 0 : arg.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
                                const resolvedType = resolveInferredArg((_b = arg.declaration.name) === null || _b === void 0 ? void 0 : _b.name, seen);
                                if (resolvedType !== undefined) {
                                    return resolvedType;
                                }
                            }
                            return resolveType(arg);
                        }));
                    })(inferred);
                }
            }
        }
        return undefined;
    }
    /**
     * a util function help retrieve payload argumentDeclarations
     * @param apply
     */
    getPayloadValue() {
        if (this.isResponse() || this.isConfirmAction()) {
            let payloadValue = this.getArgumentValue("payload");
            if (payloadValue !== undefined) {
                payloadValue = this.checker.isNameReference(payloadValue)
                    ? this.checker.resolveNameReferenceToCall(payloadValue)
                    : payloadValue;
                return payloadValue;
            }
        }
        return undefined;
    }
    /**
     * get detailed response info for an Alexa response
     *
     * In current acdl, there's four response actions and eight response acts, it's hard to retrieve property in different kind of responses
     * This function try to collect all info an Alexa Response may have and represent them as ResponseInfo interface,
     * this new layer make it easier to get a specific property in an Alexa response
     *
     * E.G.
     * ```
     * ensure(
     *      RequestArguments {arguments = [getPerson.arguments.name], response = greeting_apla},
     *      RequestArguments {arguments = [getPerson.arguments.age], response = bye_apla}
     * )
     *
     * =>
     *
     * [
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.name],
     *     prompt: greeting_apla
     *   },
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.age],
     *     prompt: bye_apla
     *   }
     * ]
     * ```
     *
     * @returns
     */
    getResponseInfo() {
        const responseInfo = [];
        if (this.isConfirmAction()) {
            responseInfo.push({
                purpose: ResponsePurpose.ConfirmAction,
                actionName: this.getArgument("actionName"),
                prompt: this.getArgument("response"),
                payload: this.getArgument("payload"),
            });
        }
        else if (this.isConfirmArgs() || this.isEnsure()) {
            const argsValue = this.isConfirmArgs()
                ? this.getArgumentValueAndResolveToCallIfNameRef("confirmArgs")
                : this.getArgumentValueAndResolveToCallIfNameRef("requestArgs");
            if ((argsValue === null || argsValue === void 0 ? void 0 : argsValue.kind) === "Call" && ask.isListLiteral(argsValue.arguments)) {
                for (const confirmArguments of argsValue.arguments.items) {
                    let itemValue = confirmArguments.item;
                    if (this.checker.isNameReference(itemValue)) {
                        itemValue = this.checker.resolveNameReferenceToCall(itemValue);
                    }
                    // The expected value is ConfirmArguments Object Literal or RequestArguments Object Literal
                    if ((itemValue === null || itemValue === void 0 ? void 0 : itemValue.kind) === "Call") {
                        const argsApply = this.checker.getApply(itemValue, undefined);
                        responseInfo.push({
                            purpose: this.isConfirmArgs() ? ResponsePurpose.ConfirmArgs : ResponsePurpose.Request,
                            arguments: argsApply === null || argsApply === void 0 ? void 0 : argsApply.getArgument("arguments"),
                            prompt: argsApply === null || argsApply === void 0 ? void 0 : argsApply.getArgument("response"),
                        });
                    }
                }
            }
        }
        else if (this.isResponse()) {
            const sourceActValue = this.getArgumentValue("act");
            const actValue = this.checker.isNameReference(sourceActValue)
                ? this.checker.resolveNameReferenceToCall(sourceActValue)
                : sourceActValue;
            const actType = this.checker.getType(actValue);
            if ((actValue === null || actValue === void 0 ? void 0 : actValue.kind) === "Call") {
                const actApply = this.checker.getApply(actValue, undefined);
                responseInfo.push({
                    purpose: (actType === null || actType === void 0 ? void 0 : actType.isRequest())
                        ? ResponsePurpose.Request
                        : (actType === null || actType === void 0 ? void 0 : actType.isConfirmArgs())
                            ? ResponsePurpose.ConfirmArgs
                            : (actType === null || actType === void 0 ? void 0 : actType.isConfirmAction())
                                ? ResponsePurpose.ConfirmAction
                                : (actType === null || actType === void 0 ? void 0 : actType.isNotify())
                                    ? ResponsePurpose.Notify
                                    : (actType === null || actType === void 0 ? void 0 : actType.isOffer())
                                        ? ResponsePurpose.Offer
                                        : (actType === null || actType === void 0 ? void 0 : actType.isReqAlt())
                                            ? ResponsePurpose.ReqAlt
                                            : (actType === null || actType === void 0 ? void 0 : actType.isReqMore())
                                                ? ResponsePurpose.ReqMore
                                                : (actType === null || actType === void 0 ? void 0 : actType.isBye())
                                                    ? ResponsePurpose.Bye
                                                    : undefined,
                    arguments: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("arguments"),
                    actionName: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("actionName"),
                    carryOverArguments: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("carryOverArguments"),
                    success: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("success"),
                    prompt: this.getArgument("response"),
                    payload: this.getArgument("payload"),
                });
            }
        }
        return responseInfo;
    }
}
/**
 * Infer a TypeParameter's type by searching for it within an instantiated type.
 *
 * e.g. inferring T from passed in arguments.
 * ```
 * action T myAction(List<T> list)
 * List<String> list
 *
 * t = myAction(list)
 *
 * // declarationType: List<T>
 * // instantiatedType: List<String>
 * ```
 *
 * The declarationType is `List<T>` and the instantiatedType is List<String>. Searching
 * for `T` will find `String`.
 *
 * `T` is inferred as `String` from the passed in `List<String>`.
 *
 * @param parameter – type parameter to infer
 * @param declarationType – declaration signature of this type, e.g. List<T>
 * @param valueType – type of the value e.g. List<String>
 */
function inferTypeParameter(parameter, declaration, valueType) {
    var _a, _b, _c;
    if (valueType === undefined || declaration === undefined) {
        return undefined;
    }
    if (parameter === ((_a = declaration === null || declaration === void 0 ? void 0 : declaration.name) === null || _a === void 0 ? void 0 : _a.name)) {
        return valueType;
    }
    if (((_b = valueType.name) === null || _b === void 0 ? void 0 : _b.name) === ((_c = declaration.name) === null || _c === void 0 ? void 0 : _c.name)) {
        if (declaration.genericArguments !== undefined && valueType.genericArguments !== undefined) {
            for (let i = 0; i < declaration.genericArguments.length; i++) {
                const argumentDeclaration = declaration.genericArguments[i];
                const instantiated = valueType.genericArguments[i];
                if (instantiated !== undefined) {
                    const found = inferTypeParameter(parameter, argumentDeclaration, instantiated);
                    if (found) {
                        return found;
                    }
                }
            }
        }
    }
    else if (valueType.isOptional()) {
        // we currently have the problem where Optional<T> must be assignable to T
        // for this case, we will reduce an Optional<T> value to T and infer from that.
        return inferTypeParameter(parameter, declaration, valueType.getOptionalType());
    }
    else if (declaration.isOptional()) {
        // Optional<T> is effectively a union type, we want to traverse its type parameters (the items in its set) and not its extensions
        return inferTypeParameter(parameter, declaration.getOptionalType(), valueType);
    }
    else if (valueType.extensions) {
        for (const extension of valueType.extensions) {
            const found = inferTypeParameter(parameter, declaration, extension);
            if (found) {
                return found;
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBwbHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxTQUFTLE1BQU0sV0FBVyxDQUFDO0FBQ2xDLE9BQU8sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDO0FBRTdCLE9BQU8sRUFDTCxrQkFBa0IsRUFDbEIsV0FBVyxFQUNYLDJCQUEyQixFQUUzQixrQkFBa0IsRUFDbEIsb0JBQW9CLEVBQ3BCLGlCQUFpQixHQUVsQixNQUFNLE9BQU8sQ0FBQztBQUNmLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFdEMsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUc1QixPQUFPLEVBQWUsZUFBZSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0QsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFFBQVEsQ0FBQztBQU0vQjs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxLQUFLO0lBOEJoQixZQUNXLE9BQW9CLEVBQ3BCLElBQWMsRUFDZCxJQUFnRixFQUN6RixJQUFZLEVBQ1osVUFBb0MsRUFDcEMsYUFBK0QsRUFDL0Qsa0JBQW1ELEVBQ25ELGdCQUE0Qzs7Ozs7O21CQVBuQzs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7O1FBaENYOzs7O21CQUF5QixPQUFPO1dBQUM7UUFFakM7Ozs7O1dBQWtGO1FBRWxGOzs7O21CQUFpRixFQUFFO1dBQUM7UUFFcEY7Ozs7O1dBQThDO1FBRTlDOzs7OztXQUE0QztRQUU1Qzs7Ozs7V0FBbUU7UUFFbkU7Ozs7O1dBQTJEO1FBRTNEOzs7OztXQUFrRTtRQXlCaEUsSUFBSSxJQUFJLEVBQUU7WUFDUixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQ3RELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFDaEQsSUFBSSxDQUFDLGlCQUFp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QU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsV0FBVyxDQUFDO0lBQ2pFLENBQUM7SUFFTSxJQUFJOztRQUNULE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsRUFBRSxDQUFDO0lBQ3hELENBQUM7SUFFTSxNQUFNOztRQUNYLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsSUFBSSxDQUFDO0lBQzFELENBQUM7SUFFTSxJQUFJOztRQUNULE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsRUFBRSxDQUFDO0lBQ3hELENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsR0FBRyxDQUFDO0lBQ3pELENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsR0FBRyxDQUFDO0lBQ3pELENBQUM7SUFFTSxJQUFJOztRQUNULE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsRUFBRSxDQUFDO0lBQ3hELENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtCLENBQUMsR0FBRyxDQUFDO0lBQ3pELENBQUM7SUFFTSxJQUFJOztRQUNULE9BQU8sQ0FBQSxNQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQ0FBRSxJQUFJLE1BQUssa0JBQWtC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